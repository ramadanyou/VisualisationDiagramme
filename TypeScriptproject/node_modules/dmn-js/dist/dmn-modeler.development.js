/*!
 * dmn-js - dmn-modeler v15.0.0
 *
 * Copyright (c) 2014-present, camunda Services GmbH
 *
 * Released under the bpmn.io license
 * http://bpmn.io/license
 *
 * Source Code: https://github.com/bpmn-io/dmn-js
 *
 * Date: 2023-12-07
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DmnJS = factory());
})(this, (function () { 'use strict';

  function _iterableToArrayLimit$1(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s,
        _e,
        _x,
        _r,
        _arr = [],
        _n = !0,
        _d = !1;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i) return;
          _n = !1;
        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  function ownKeys$d(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$d(Object(source), !0).forEach(function (key) {
        _defineProperty$M(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey$J(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty$M(obj, key, value) {
    key = _toPropertyKey$J(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf$1(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$1(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _objectWithoutPropertiesLoose$7(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties$7(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$7(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
  }
  function _toArray(arr) {
    return _arrayWithHoles$1(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableRest$1();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }
  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }
  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        var F = function () {};
        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
  function _toPrimitive$J(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey$J(arg) {
    var key = _toPrimitive$J(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  /**
   * Flatten array, one level deep.
   *
   * @template T
   *
   * @param {T[][]} arr
   *
   * @return {T[]}
   */
  function flatten$1(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  var nativeToString$4 = Object.prototype.toString;
  var nativeHasOwnProperty$3 = Object.prototype.hasOwnProperty;
  function isUndefined$5(obj) {
    return obj === undefined;
  }
  function isDefined(obj) {
    return obj !== undefined;
  }
  function isNil(obj) {
    return obj == null;
  }
  function isArray$6(obj) {
    return nativeToString$4.call(obj) === '[object Array]';
  }
  function isObject$2(obj) {
    return nativeToString$4.call(obj) === '[object Object]';
  }
  function isNumber$3(obj) {
    return nativeToString$4.call(obj) === '[object Number]';
  }

  /**
   * @param {any} obj
   *
   * @return {boolean}
   */
  function isFunction$2(obj) {
    var tag = nativeToString$4.call(obj);
    return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object AsyncGeneratorFunction]' || tag === '[object Proxy]';
  }
  function isString$4(obj) {
    return nativeToString$4.call(obj) === '[object String]';
  }

  /**
   * Return true, if target owns a property with the given key.
   *
   * @param {Object} target
   * @param {String} key
   *
   * @return {Boolean}
   */
  function has$3(target, key) {
    return nativeHasOwnProperty$3.call(target, key);
  }

  /**
   * @template T
   * @typedef { (
   *   ((e: T) => boolean) |
   *   ((e: T, idx: number) => boolean) |
   *   ((e: T, key: string) => boolean) |
   *   string |
   *   number
   * ) } Matcher
   */

  /**
   * @template T
   * @template U
   *
   * @typedef { (
   *   ((e: T) => U) | string | number
   * ) } Extractor
   */

  /**
   * @template T
   * @typedef { (val: T, key: any) => boolean } MatchFn
   */

  /**
   * @template T
   * @typedef { T[] } ArrayCollection
   */

  /**
   * @template T
   * @typedef { { [key: string]: T } } StringKeyValueCollection
   */

  /**
   * @template T
   * @typedef { { [key: number]: T } } NumberKeyValueCollection
   */

  /**
   * @template T
   * @typedef { StringKeyValueCollection<T> | NumberKeyValueCollection<T> } KeyValueCollection
   */

  /**
   * @template T
   * @typedef { KeyValueCollection<T> | ArrayCollection<T> } Collection
   */

  /**
   * Find element in collection.
   *
   * @template T
   * @param {Collection<T>} collection
   * @param {Matcher<T>} matcher
   *
   * @return {Object}
   */
  function find$2(collection, matcher) {
    var matchFn = toMatcher$1(matcher);
    var match;
    forEach$3(collection, function (val, key) {
      if (matchFn(val, key)) {
        match = val;
        return false;
      }
    });
    return match;
  }

  /**
   * Filter elements in collection.
   *
   * @template T
   * @param {Collection<T>} collection
   * @param {Matcher<T>} matcher
   *
   * @return {T[]} result
   */
  function filter$2(collection, matcher) {
    var matchFn = toMatcher$1(matcher);
    var result = [];
    forEach$3(collection, function (val, key) {
      if (matchFn(val, key)) {
        result.push(val);
      }
    });
    return result;
  }

  /**
   * Iterate over collection; returning something
   * (non-undefined) will stop iteration.
   *
   * @template T
   * @param {Collection<T>} collection
   * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator
   *
   * @return {T} return result that stopped the iteration
   */
  function forEach$3(collection, iterator) {
    var val, result;
    if (isUndefined$5(collection)) {
      return;
    }
    var convertKey = isArray$6(collection) ? toNum$3 : identity$3;
    for (var key in collection) {
      if (has$3(collection, key)) {
        val = collection[key];
        result = iterator(val, convertKey(key));
        if (result === false) {
          return val;
        }
      }
    }
  }

  /**
   * Reduce collection, returning a single result.
   *
   * @template T
   * @template V
   *
   * @param {Collection<T>} collection
   * @param {(result: V, entry: T, index: any) => V} iterator
   * @param {V} result
   *
   * @return {V} result returned from last iterator
   */
  function reduce(collection, iterator, result) {
    forEach$3(collection, function (value, idx) {
      result = iterator(result, value, idx);
    });
    return result;
  }

  /**
   * Return true if every element in the collection
   * matches the criteria.
   *
   * @param  {Object|Array} collection
   * @param  {Function} matcher
   *
   * @return {Boolean}
   */
  function every(collection, matcher) {
    return !!reduce(collection, function (matches, val, key) {
      return matches && matcher(val, key);
    }, true);
  }

  /**
   * Return true if some elements in the collection
   * match the criteria.
   *
   * @param  {Object|Array} collection
   * @param  {Function} matcher
   *
   * @return {Boolean}
   */
  function some(collection, matcher) {
    return !!find$2(collection, matcher);
  }

  /**
   * Transform a collection into another collection
   * by piping each member through the given fn.
   *
   * @param  {Object|Array}   collection
   * @param  {Function} fn
   *
   * @return {Array} transformed collection
   */
  function map$2(collection, fn) {
    var result = [];
    forEach$3(collection, function (val, key) {
      result.push(fn(val, key));
    });
    return result;
  }

  /**
   * Get the collections keys.
   *
   * @param  {Object|Array} collection
   *
   * @return {Array}
   */
  function keys(collection) {
    return collection && Object.keys(collection) || [];
  }

  /**
   * Shorthand for `keys(o).length`.
   *
   * @param  {Object|Array} collection
   *
   * @return {Number}
   */
  function size(collection) {
    return keys(collection).length;
  }

  /**
   * Get the values in the collection.
   *
   * @param  {Object|Array} collection
   *
   * @return {Array}
   */
  function values$1(collection) {
    return map$2(collection, function (val) {
      return val;
    });
  }

  /**
   * Group collection members by attribute.
   *
   * @param {Object|Array} collection
   * @param {Extractor} extractor
   *
   * @return {Object} map with { attrValue => [ a, b, c ] }
   */
  function groupBy(collection, extractor) {
    var grouped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    extractor = toExtractor(extractor);
    forEach$3(collection, function (val) {
      var discriminator = extractor(val) || '_';
      var group = grouped[discriminator];
      if (!group) {
        group = grouped[discriminator] = [];
      }
      group.push(val);
    });
    return grouped;
  }
  function uniqueBy(extractor) {
    extractor = toExtractor(extractor);
    var grouped = {};
    for (var _len = arguments.length, collections = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      collections[_key - 1] = arguments[_key];
    }
    forEach$3(collections, function (c) {
      return groupBy(c, extractor, grouped);
    });
    var result = map$2(grouped, function (val, key) {
      return val[0];
    });
    return result;
  }

  /**
   * Sort collection by criteria.
   *
   * @template T
   *
   * @param {Collection<T>} collection
   * @param {Extractor<T, number | string>} extractor
   *
   * @return {Array}
   */
  function sortBy(collection, extractor) {
    extractor = toExtractor(extractor);
    var sorted = [];
    forEach$3(collection, function (value, key) {
      var disc = extractor(value, key);
      var entry = {
        d: disc,
        v: value
      };
      for (var idx = 0; idx < sorted.length; idx++) {
        var d = sorted[idx].d;
        if (disc < d) {
          sorted.splice(idx, 0, entry);
          return;
        }
      }

      // not inserted, append (!)
      sorted.push(entry);
    });
    return map$2(sorted, function (e) {
      return e.v;
    });
  }

  /**
   * Create an object pattern matcher.
   *
   * @example
   *
   * ```javascript
   * const matcher = matchPattern({ id: 1 });
   *
   * let element = find(elements, matcher);
   * ```
   *
   * @template T
   *
   * @param {T} pattern
   *
   * @return { (el: any) =>  boolean } matcherFn
   */
  function matchPattern(pattern) {
    return function (el) {
      return every(pattern, function (val, key) {
        return el[key] === val;
      });
    };
  }

  /**
   * @param {string | ((e: any) => any) } extractor
   *
   * @return { (e: any) => any }
   */
  function toExtractor(extractor) {
    /**
     * @satisfies { (e: any) => any }
     */
    return isFunction$2(extractor) ? extractor : function (e) {
      // @ts-ignore: just works
      return e[extractor];
    };
  }

  /**
   * @template T
   * @param {Matcher<T>} matcher
   *
   * @return {MatchFn<T>}
   */
  function toMatcher$1(matcher) {
    return isFunction$2(matcher) ? matcher : function (e) {
      return e === matcher;
    };
  }
  function identity$3(arg) {
    return arg;
  }
  function toNum$3(arg) {
    return Number(arg);
  }

  /* global setTimeout clearTimeout */

  /**
   * @typedef { {
   *   (...args: any[]): any;
   *   flush: () => void;
   *   cancel: () => void;
   * } } DebouncedFunction
   */

  /**
   * Debounce fn, calling it only once if the given time
   * elapsed between calls.
   *
   * Lodash-style the function exposes methods to `#clear`
   * and `#flush` to control internal behavior.
   *
   * @param  {Function} fn
   * @param  {Number} timeout
   *
   * @return {DebouncedFunction} debounced function
   */
  function debounce(fn, timeout) {
    var timer;
    var lastArgs;
    var lastThis;
    var lastNow;
    function fire(force) {
      var now = Date.now();
      var scheduledDiff = force ? 0 : lastNow + timeout - now;
      if (scheduledDiff > 0) {
        return schedule(scheduledDiff);
      }
      fn.apply(lastThis, lastArgs);
      clear();
    }
    function schedule(timeout) {
      timer = setTimeout(fire, timeout);
    }
    function clear() {
      if (timer) {
        clearTimeout(timer);
      }
      timer = lastNow = lastArgs = lastThis = undefined;
    }
    function flush() {
      if (timer) {
        fire(true);
      }
      clear();
    }

    /**
     * @type { DebouncedFunction }
     */
    function callback() {
      lastNow = Date.now();
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      lastArgs = args;
      lastThis = this;

      // ensure an execution is scheduled
      if (!timer) {
        schedule(timeout);
      }
    }
    callback.flush = flush;
    callback.cancel = clear;
    return callback;
  }

  /**
   * Throttle fn, calling at most once
   * in the given interval.
   *
   * @param  {Function} fn
   * @param  {Number} interval
   *
   * @return {Function} throttled function
   */
  function throttle(fn, interval) {
    var throttling = false;
    return function () {
      if (throttling) {
        return;
      }
      fn.apply(void 0, arguments);
      throttling = true;
      setTimeout(function () {
        throttling = false;
      }, interval);
    };
  }

  /**
   * Bind function against target <this>.
   *
   * @param  {Function} fn
   * @param  {Object}   target
   *
   * @return {Function} bound function
   */
  function bind$3(fn, target) {
    return fn.bind(target);
  }

  /**
   * Convenience wrapper for `Object.assign`.
   *
   * @param {Object} target
   * @param {...Object} others
   *
   * @return {Object} the target
   */
  function assign$4(target) {
    for (var _len3 = arguments.length, others = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      others[_key3 - 1] = arguments[_key3];
    }
    return Object.assign.apply(Object, [target].concat(others));
  }

  /**
   * Pick properties from the given target.
   *
   * @template T
   * @template {any[]} V
   *
   * @param {T} target
   * @param {V} properties
   *
   * @return Pick<T, V>
   */
  function pick$1(target, properties) {
    var result = {};
    var obj = Object(target);
    forEach$3(properties, function (prop) {
      if (prop in obj) {
        result[prop] = target[prop];
      }
    });
    return result;
  }

  /**
   * Pick all target properties, excluding the given ones.
   *
   * @template T
   * @template {any[]} V
   *
   * @param {T} target
   * @param {V} properties
   *
   * @return {Omit<T, V>} target
   */
  function omit(target, properties) {
    var result = {};
    var obj = Object(target);
    forEach$3(obj, function (prop, key) {
      if (properties.indexOf(key) === -1) {
        result[key] = prop;
      }
    });
    return result;
  }

  var FN_REF = '__fn';
  var DEFAULT_PRIORITY$8 = 1000;
  var slice$1 = Array.prototype.slice;

  /**
   * @typedef { {
   *   stopPropagation(): void;
   *   preventDefault(): void;
   *   cancelBubble: boolean;
   *   defaultPrevented: boolean;
   *   returnValue: any;
   * } } Event
   */

  /**
   * @template E
   *
   * @typedef { (event: E & Event, ...any) => any } EventBusEventCallback
   */

  /**
   * @typedef { {
   *  priority: number;
   *  next: EventBusListener | null;
   *  callback: EventBusEventCallback<any>;
   * } } EventBusListener
   */

  /**
   * A general purpose event bus.
   *
   * This component is used to communicate across a diagram instance.
   * Other parts of a diagram can use it to listen to and broadcast events.
   *
   *
   * ## Registering for Events
   *
   * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
   * methods to register for events. {@link EventBus#off} can be used to
   * remove event registrations. Listeners receive an instance of {@link Event}
   * as the first argument. It allows them to hook into the event execution.
   *
   * ```javascript
   *
   * // listen for event
   * eventBus.on('foo', function(event) {
   *
   *   // access event type
   *   event.type; // 'foo'
   *
   *   // stop propagation to other listeners
   *   event.stopPropagation();
   *
   *   // prevent event default
   *   event.preventDefault();
   * });
   *
   * // listen for event with custom payload
   * eventBus.on('bar', function(event, payload) {
   *   console.log(payload);
   * });
   *
   * // listen for event returning value
   * eventBus.on('foobar', function(event) {
   *
   *   // stop event propagation + prevent default
   *   return false;
   *
   *   // stop event propagation + return custom result
   *   return {
   *     complex: 'listening result'
   *   };
   * });
   *
   *
   * // listen with custom priority (default=1000, higher is better)
   * eventBus.on('priorityfoo', 1500, function(event) {
   *   console.log('invoked first!');
   * });
   *
   *
   * // listen for event and pass the context (`this`)
   * eventBus.on('foobar', function(event) {
   *   this.foo();
   * }, this);
   * ```
   *
   *
   * ## Emitting Events
   *
   * Events can be emitted via the event bus using {@link EventBus#fire}.
   *
   * ```javascript
   *
   * // false indicates that the default action
   * // was prevented by listeners
   * if (eventBus.fire('foo') === false) {
   *   console.log('default has been prevented!');
   * };
   *
   *
   * // custom args + return value listener
   * eventBus.on('sum', function(event, a, b) {
   *   return a + b;
   * });
   *
   * // you can pass custom arguments + retrieve result values.
   * var sum = eventBus.fire('sum', 1, 2);
   * console.log(sum); // 3
   * ```
   */
  function EventBus() {
    /**
     * @type { Record<string, EventBusListener> }
     */
    this._listeners = {};

    // cleanup on destroy on lowest priority to allow
    // message passing until the bitter end
    this.on('diagram.destroy', 1, this._destroy, this);
  }

  /**
   * Register an event listener for events with the given name.
   *
   * The callback will be invoked with `event, ...additionalArguments`
   * that have been passed to {@link EventBus#fire}.
   *
   * Returning false from a listener will prevent the events default action
   * (if any is specified). To stop an event from being processed further in
   * other listeners execute {@link Event#stopPropagation}.
   *
   * Returning anything but `undefined` from a listener will stop the listener propagation.
   *
   * @template T
   *
   * @param {string|string[]} events to subscribe to
   * @param {number} [priority=1000] listen priority
   * @param {EventBusEventCallback<T>} callback
   * @param {any} [that] callback context
   */
  EventBus.prototype.on = function (events, priority, callback, that) {
    events = isArray$6(events) ? events : [events];
    if (isFunction$2(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY$8;
    }
    if (!isNumber$3(priority)) {
      throw new Error('priority must be a number');
    }
    var actualCallback = callback;
    if (that) {
      actualCallback = bind$3(callback, that);

      // make sure we remember and are able to remove
      // bound callbacks via {@link #off} using the original
      // callback
      actualCallback[FN_REF] = callback[FN_REF] || callback;
    }
    var self = this;
    events.forEach(function (e) {
      self._addListener(e, {
        priority: priority,
        callback: actualCallback,
        next: null
      });
    });
  };

  /**
   * Register an event listener that is called only once.
   *
   * @template T
   *
   * @param {string|string[]} events to subscribe to
   * @param {number} [priority=1000] the listen priority
   * @param {EventBusEventCallback<T>} callback
   * @param {any} [that] callback context
   */
  EventBus.prototype.once = function (events, priority, callback, that) {
    var self = this;
    if (isFunction$2(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY$8;
    }
    if (!isNumber$3(priority)) {
      throw new Error('priority must be a number');
    }
    function wrappedCallback() {
      wrappedCallback.__isTomb = true;
      var result = callback.apply(that, arguments);
      self.off(events, wrappedCallback);
      return result;
    }

    // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback
    wrappedCallback[FN_REF] = callback;
    this.on(events, priority, wrappedCallback);
  };

  /**
   * Removes event listeners by event and callback.
   *
   * If no callback is given, all listeners for a given event name are being removed.
   *
   * @param {string|string[]} events
   * @param {EventBusEventCallback} [callback]
   */
  EventBus.prototype.off = function (events, callback) {
    events = isArray$6(events) ? events : [events];
    var self = this;
    events.forEach(function (event) {
      self._removeListener(event, callback);
    });
  };

  /**
   * Create an event recognized be the event bus.
   *
   * @param {Object} data Event data.
   *
   * @return {Event} An event that will be recognized by the event bus.
   */
  EventBus.prototype.createEvent = function (data) {
    var event = new InternalEvent();
    event.init(data);
    return event;
  };

  /**
   * Fires an event.
   *
   * @example
   *
   * ```javascript
   * // fire event by name
   * events.fire('foo');
   *
   * // fire event object with nested type
   * var event = { type: 'foo' };
   * events.fire(event);
   *
   * // fire event with explicit type
   * var event = { x: 10, y: 20 };
   * events.fire('element.moved', event);
   *
   * // pass additional arguments to the event
   * events.on('foo', function(event, bar) {
   *   alert(bar);
   * });
   *
   * events.fire({ type: 'foo' }, 'I am bar!');
   * ```
   *
   * @param {string} [type] event type
   * @param {Object} [data] event or event data
   * @param {...any} [args] additional arguments the callback will be called with.
   *
   * @return {any} The return value. Will be set to `false` if the default was prevented.
   */
  EventBus.prototype.fire = function (type, data) {
    var event, firstListener, returnValue, args;
    args = slice$1.call(arguments);
    if (_typeof(type) === 'object') {
      data = type;
      type = data.type;
    }
    if (!type) {
      throw new Error('no event type specified');
    }
    firstListener = this._listeners[type];
    if (!firstListener) {
      return;
    }

    // we make sure we fire instances of our home made
    // events here. We wrap them only once, though
    if (data instanceof InternalEvent) {
      // we are fine, we alread have an event
      event = data;
    } else {
      event = this.createEvent(data);
    }

    // ensure we pass the event as the first parameter
    args[0] = event;

    // original event type (in case we delegate)
    var originalType = event.type;

    // update event type before delegation
    if (type !== originalType) {
      event.type = type;
    }
    try {
      returnValue = this._invokeListeners(event, args, firstListener);
    } finally {
      // reset event type after delegation
      if (type !== originalType) {
        event.type = originalType;
      }
    }

    // set the return value to false if the event default
    // got prevented and no other return value exists
    if (returnValue === undefined && event.defaultPrevented) {
      returnValue = false;
    }
    return returnValue;
  };

  /**
   * Handle an error by firing an event.
   *
   * @param {Error} error The error to be handled.
   *
   * @return {boolean} Whether the error was handled.
   */
  EventBus.prototype.handleError = function (error) {
    return this.fire('error', {
      error: error
    }) === false;
  };
  EventBus.prototype._destroy = function () {
    this._listeners = {};
  };

  /**
   * @param {Event} event
   * @param {any[]} args
   * @param {EventBusListener} listener
   *
   * @return {any}
   */
  EventBus.prototype._invokeListeners = function (event, args, listener) {
    var returnValue;
    while (listener) {
      // handle stopped propagation
      if (event.cancelBubble) {
        break;
      }
      returnValue = this._invokeListener(event, args, listener);
      listener = listener.next;
    }
    return returnValue;
  };

  /**
   * @param {Event} event
   * @param {any[]} args
   * @param {EventBusListener} listener
   *
   * @return {any}
   */
  EventBus.prototype._invokeListener = function (event, args, listener) {
    var returnValue;
    if (listener.callback.__isTomb) {
      return returnValue;
    }
    try {
      // returning false prevents the default action
      returnValue = invokeFunction(listener.callback, args);

      // stop propagation on return value
      if (returnValue !== undefined) {
        event.returnValue = returnValue;
        event.stopPropagation();
      }

      // prevent default on return false
      if (returnValue === false) {
        event.preventDefault();
      }
    } catch (error) {
      if (!this.handleError(error)) {
        console.error('unhandled error in event listener', error);
        throw error;
      }
    }
    return returnValue;
  };

  /**
   * Add new listener with a certain priority to the list
   * of listeners (for the given event).
   *
   * The semantics of listener registration / listener execution are
   * first register, first serve: New listeners will always be inserted
   * after existing listeners with the same priority.
   *
   * Example: Inserting two listeners with priority 1000 and 1300
   *
   *    * before: [ 1500, 1500, 1000, 1000 ]
   *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
   *
   * @param {string} event
   * @param {EventBusListener} newListener
   */
  EventBus.prototype._addListener = function (event, newListener) {
    var listener = this._getListeners(event),
      previousListener;

    // no prior listeners
    if (!listener) {
      this._setListeners(event, newListener);
      return;
    }

    // ensure we order listeners by priority from
    // 0 (high) to n > 0 (low)
    while (listener) {
      if (listener.priority < newListener.priority) {
        newListener.next = listener;
        if (previousListener) {
          previousListener.next = newListener;
        } else {
          this._setListeners(event, newListener);
        }
        return;
      }
      previousListener = listener;
      listener = listener.next;
    }

    // add new listener to back
    previousListener.next = newListener;
  };

  /**
   * @param {string} name
   *
   * @return {EventBusListener}
   */
  EventBus.prototype._getListeners = function (name) {
    return this._listeners[name];
  };

  /**
   * @param {string} name
   * @param {EventBusListener} listener
   */
  EventBus.prototype._setListeners = function (name, listener) {
    this._listeners[name] = listener;
  };
  EventBus.prototype._removeListener = function (event, callback) {
    var listener = this._getListeners(event),
      nextListener,
      previousListener,
      listenerCallback;
    if (!callback) {
      // clear listeners
      this._setListeners(event, null);
      return;
    }
    while (listener) {
      nextListener = listener.next;
      listenerCallback = listener.callback;
      if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
        if (previousListener) {
          previousListener.next = nextListener;
        } else {
          // new first listener
          this._setListeners(event, nextListener);
        }
      }
      previousListener = listener;
      listener = nextListener;
    }
  };

  /**
   * A event that is emitted via the event bus.
   */
  function InternalEvent() {}
  InternalEvent.prototype.stopPropagation = function () {
    this.cancelBubble = true;
  };
  InternalEvent.prototype.preventDefault = function () {
    this.defaultPrevented = true;
  };
  InternalEvent.prototype.init = function (data) {
    assign$4(this, data || {});
  };

  /**
   * Invoke function. Be fast...
   *
   * @param {Function} fn
   * @param {any[]} args
   *
   * @return {any}
   */
  function invokeFunction(fn, args) {
    return fn.apply(null, args);
  }

  /**
   * Flatten array, one level deep.
   *
   * @param {Array<?>} arr
   *
   * @return {Array<?>}
   */
  var nativeToString$3 = Object.prototype.toString;
  function isString$3(obj) {
    return nativeToString$3.call(obj) === '[object String]';
  }
  function _extends$2() {
    _extends$2 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }

  /**
   * Convenience wrapper for `Object.assign`.
   *
   * @param {Object} target
   * @param {...Object} others
   *
   * @return {Object} the target
   */

  function assign$3(target) {
    for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      others[_key - 1] = arguments[_key];
    }
    return _extends$2.apply(void 0, [target].concat(others));
  }

  /**
   * Flatten array, one level deep.
   *
   * @param {Array<?>} arr
   *
   * @return {Array<?>}
   */
  var nativeToString$2 = Object.prototype.toString;
  var nativeHasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function isUndefined$4(obj) {
    return obj === undefined;
  }
  function isArray$5(obj) {
    return nativeToString$2.call(obj) === '[object Array]';
  }
  function isObject$1(obj) {
    return nativeToString$2.call(obj) === '[object Object]';
  }
  function isString$2(obj) {
    return nativeToString$2.call(obj) === '[object String]';
  }
  /**
   * Return true, if target owns a property with the given key.
   *
   * @param {Object} target
   * @param {String} key
   *
   * @return {Boolean}
   */

  function has$2(target, key) {
    return nativeHasOwnProperty$2.call(target, key);
  }
  /**
   * Iterate over collection; returning something
   * (non-undefined) will stop iteration.
   *
   * @param  {Array|Object} collection
   * @param  {Function} iterator
   *
   * @return {Object} return result that stopped the iteration
   */

  function forEach$2(collection, iterator) {
    var val, result;
    if (isUndefined$4(collection)) {
      return;
    }
    var convertKey = isArray$5(collection) ? toNum$2 : identity$2;
    for (var key in collection) {
      if (has$2(collection, key)) {
        val = collection[key];
        result = iterator(val, convertKey(key));
        if (result === false) {
          return val;
        }
      }
    }
  }
  function identity$2(arg) {
    return arg;
  }
  function toNum$2(arg) {
    return Number(arg);
  }
  /**
   * Bind function against target <this>.
   *
   * @param  {Function} fn
   * @param  {Object}   target
   *
   * @return {Function} bound function
   */

  function bind$2(fn, target) {
    return fn.bind(target);
  }
  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }

  /**
   * Convenience wrapper for `Object.assign`.
   *
   * @param {Object} target
   * @param {...Object} others
   *
   * @return {Object} the target
   */

  function assign$2(target) {
    for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      others[_key - 1] = arguments[_key];
    }
    return _extends$1.apply(void 0, [target].concat(others));
  }
  /**
   * Pick given properties from the target object.
   *
   * @param {Object} target
   * @param {Array} properties
   *
   * @return {Object} target
   */

  function pick(target, properties) {
    var result = {};
    var obj = Object(target);
    forEach$2(properties, function (prop) {
      if (prop in obj) {
        result[prop] = target[prop];
      }
    });
    return result;
  }

  /**
   * Moddle base element.
   */
  function Base$1() {}
  Base$1.prototype.get = function (name) {
    return this.$model.properties.get(this, name);
  };
  Base$1.prototype.set = function (name, value) {
    this.$model.properties.set(this, name, value);
  };

  /**
   * A model element factory.
   *
   * @param {Moddle} model
   * @param {Properties} properties
   */
  function Factory(model, properties) {
    this.model = model;
    this.properties = properties;
  }
  Factory.prototype.createType = function (descriptor) {
    var model = this.model;
    var props = this.properties,
      prototype = Object.create(Base$1.prototype);

    // initialize default values
    forEach$2(descriptor.properties, function (p) {
      if (!p.isMany && p["default"] !== undefined) {
        prototype[p.name] = p["default"];
      }
    });
    props.defineModel(prototype, model);
    props.defineDescriptor(prototype, descriptor);
    var name = descriptor.ns.name;

    /**
     * The new type constructor
     */
    function ModdleElement(attrs) {
      props.define(this, '$type', {
        value: name,
        enumerable: true
      });
      props.define(this, '$attrs', {
        value: {}
      });
      props.define(this, '$parent', {
        writable: true
      });
      forEach$2(attrs, bind$2(function (val, key) {
        this.set(key, val);
      }, this));
    }
    ModdleElement.prototype = prototype;
    ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

    // static links
    props.defineModel(ModdleElement, model);
    props.defineDescriptor(ModdleElement, descriptor);
    return ModdleElement;
  };

  /**
   * Built-in moddle types
   */
  var BUILTINS = {
    String: true,
    Boolean: true,
    Integer: true,
    Real: true,
    Element: true
  };

  /**
   * Converters for built in types from string representations
   */
  var TYPE_CONVERTERS = {
    String: function String(s) {
      return s;
    },
    Boolean: function Boolean(s) {
      return s === 'true';
    },
    Integer: function Integer(s) {
      return parseInt(s, 10);
    },
    Real: function Real(s) {
      return parseFloat(s);
    }
  };

  /**
   * Convert a type to its real representation
   */
  function coerceType(type, value) {
    var converter = TYPE_CONVERTERS[type];
    if (converter) {
      return converter(value);
    } else {
      return value;
    }
  }

  /**
   * Return whether the given type is built-in
   */
  function isBuiltIn(type) {
    return !!BUILTINS[type];
  }

  /**
   * Return whether the given type is simple
   */
  function isSimple(type) {
    return !!TYPE_CONVERTERS[type];
  }

  /**
   * Parses a namespaced attribute name of the form (ns:)localName to an object,
   * given a default prefix to assume in case no explicit namespace is given.
   *
   * @param {String} name
   * @param {String} [defaultPrefix] the default prefix to take, if none is present.
   *
   * @return {Object} the parsed name
   */
  function parseName$1(name, defaultPrefix) {
    var parts = name.split(/:/),
      localName,
      prefix;

    // no prefix (i.e. only local name)
    if (parts.length === 1) {
      localName = name;
      prefix = defaultPrefix;
    } else
      // prefix + local name
      if (parts.length === 2) {
        localName = parts[1];
        prefix = parts[0];
      } else {
        throw new Error('expected <prefix:localName> or <localName>, got ' + name);
      }
    name = (prefix ? prefix + ':' : '') + localName;
    return {
      name: name,
      prefix: prefix,
      localName: localName
    };
  }

  /**
   * A utility to build element descriptors.
   */
  function DescriptorBuilder(nameNs) {
    this.ns = nameNs;
    this.name = nameNs.name;
    this.allTypes = [];
    this.allTypesByName = {};
    this.properties = [];
    this.propertiesByName = {};
  }
  DescriptorBuilder.prototype.build = function () {
    return pick(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty']);
  };

  /**
   * Add property at given index.
   *
   * @param {Object} p
   * @param {Number} [idx]
   * @param {Boolean} [validate=true]
   */
  DescriptorBuilder.prototype.addProperty = function (p, idx, validate) {
    if (typeof idx === 'boolean') {
      validate = idx;
      idx = undefined;
    }
    this.addNamedProperty(p, validate !== false);
    var properties = this.properties;
    if (idx !== undefined) {
      properties.splice(idx, 0, p);
    } else {
      properties.push(p);
    }
  };
  DescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {
    var oldNameNs = oldProperty.ns;
    var props = this.properties,
      propertiesByName = this.propertiesByName,
      rename = oldProperty.name !== newProperty.name;
    if (oldProperty.isId) {
      if (!newProperty.isId) {
        throw new Error('property <' + newProperty.ns.name + '> must be id property ' + 'to refine <' + oldProperty.ns.name + '>');
      }
      this.setIdProperty(newProperty, false);
    }
    if (oldProperty.isBody) {
      if (!newProperty.isBody) {
        throw new Error('property <' + newProperty.ns.name + '> must be body property ' + 'to refine <' + oldProperty.ns.name + '>');
      }

      // TODO: Check compatibility
      this.setBodyProperty(newProperty, false);
    }

    // validate existence and get location of old property
    var idx = props.indexOf(oldProperty);
    if (idx === -1) {
      throw new Error('property <' + oldNameNs.name + '> not found in property list');
    }

    // remove old property
    props.splice(idx, 1);

    // replacing the named property is intentional
    //
    //  * validate only if this is a "rename" operation
    //  * add at specific index unless we "replace"
    //
    this.addProperty(newProperty, replace ? undefined : idx, rename);

    // make new property available under old name
    propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
  };
  DescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {
    var nsPrefix = p.ns.prefix;
    var parts = targetPropertyName.split('#');
    var name = parseName$1(parts[0], nsPrefix);
    var attrName = parseName$1(parts[1], name.prefix).name;
    var redefinedProperty = this.propertiesByName[attrName];
    if (!redefinedProperty) {
      throw new Error('refined property <' + attrName + '> not found');
    } else {
      this.replaceProperty(redefinedProperty, p, replace);
    }
    delete p.redefines;
  };
  DescriptorBuilder.prototype.addNamedProperty = function (p, validate) {
    var ns = p.ns,
      propsByName = this.propertiesByName;
    if (validate) {
      this.assertNotDefined(p, ns.name);
      this.assertNotDefined(p, ns.localName);
    }
    propsByName[ns.name] = propsByName[ns.localName] = p;
  };
  DescriptorBuilder.prototype.removeNamedProperty = function (p) {
    var ns = p.ns,
      propsByName = this.propertiesByName;
    delete propsByName[ns.name];
    delete propsByName[ns.localName];
  };
  DescriptorBuilder.prototype.setBodyProperty = function (p, validate) {
    if (validate && this.bodyProperty) {
      throw new Error('body property defined multiple times ' + '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
    }
    this.bodyProperty = p;
  };
  DescriptorBuilder.prototype.setIdProperty = function (p, validate) {
    if (validate && this.idProperty) {
      throw new Error('id property defined multiple times ' + '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');
    }
    this.idProperty = p;
  };
  DescriptorBuilder.prototype.assertNotDefined = function (p, name) {
    var propertyName = p.name,
      definedProperty = this.propertiesByName[propertyName];
    if (definedProperty) {
      throw new Error('property <' + propertyName + '> already defined; ' + 'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' + '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
    }
  };
  DescriptorBuilder.prototype.hasProperty = function (name) {
    return this.propertiesByName[name];
  };
  DescriptorBuilder.prototype.addTrait = function (t, inherited) {
    var typesByName = this.allTypesByName,
      types = this.allTypes;
    var typeName = t.name;
    if (typeName in typesByName) {
      return;
    }
    forEach$2(t.properties, bind$2(function (p) {
      // clone property to allow extensions
      p = assign$2({}, p, {
        name: p.ns.localName,
        inherited: inherited
      });
      Object.defineProperty(p, 'definedBy', {
        value: t
      });
      var replaces = p.replaces,
        redefines = p.redefines;

      // add replace/redefine support
      if (replaces || redefines) {
        this.redefineProperty(p, replaces || redefines, replaces);
      } else {
        if (p.isBody) {
          this.setBodyProperty(p);
        }
        if (p.isId) {
          this.setIdProperty(p);
        }
        this.addProperty(p);
      }
    }, this));
    types.push(t);
    typesByName[typeName] = t;
  };

  /**
   * A registry of Moddle packages.
   *
   * @param {Array<Package>} packages
   * @param {Properties} properties
   */
  function Registry(packages, properties) {
    this.packageMap = {};
    this.typeMap = {};
    this.packages = [];
    this.properties = properties;
    forEach$2(packages, bind$2(this.registerPackage, this));
  }
  Registry.prototype.getPackage = function (uriOrPrefix) {
    return this.packageMap[uriOrPrefix];
  };
  Registry.prototype.getPackages = function () {
    return this.packages;
  };
  Registry.prototype.registerPackage = function (pkg) {
    // copy package
    pkg = assign$2({}, pkg);
    var pkgMap = this.packageMap;
    ensureAvailable(pkgMap, pkg, 'prefix');
    ensureAvailable(pkgMap, pkg, 'uri');

    // register types
    forEach$2(pkg.types, bind$2(function (descriptor) {
      this.registerType(descriptor, pkg);
    }, this));
    pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
    this.packages.push(pkg);
  };

  /**
   * Register a type from a specific package with us
   */
  Registry.prototype.registerType = function (type, pkg) {
    type = assign$2({}, type, {
      superClass: (type.superClass || []).slice(),
      "extends": (type["extends"] || []).slice(),
      properties: (type.properties || []).slice(),
      meta: assign$2(type.meta || {})
    });
    var ns = parseName$1(type.name, pkg.prefix),
      name = ns.name,
      propertiesByName = {};

    // parse properties
    forEach$2(type.properties, bind$2(function (p) {
      // namespace property names
      var propertyNs = parseName$1(p.name, ns.prefix),
        propertyName = propertyNs.name;

      // namespace property types
      if (!isBuiltIn(p.type)) {
        p.type = parseName$1(p.type, propertyNs.prefix).name;
      }
      assign$2(p, {
        ns: propertyNs,
        name: propertyName
      });
      propertiesByName[propertyName] = p;
    }, this));

    // update ns + name
    assign$2(type, {
      ns: ns,
      name: name,
      propertiesByName: propertiesByName
    });
    forEach$2(type["extends"], bind$2(function (extendsName) {
      var extended = this.typeMap[extendsName];
      extended.traits = extended.traits || [];
      extended.traits.push(name);
    }, this));

    // link to package
    this.definePackage(type, pkg);

    // register
    this.typeMap[name] = type;
  };

  /**
   * Traverse the type hierarchy from bottom to top,
   * calling iterator with (type, inherited) for all elements in
   * the inheritance chain.
   *
   * @param {Object} nsName
   * @param {Function} iterator
   * @param {Boolean} [trait=false]
   */
  Registry.prototype.mapTypes = function (nsName, iterator, trait) {
    var type = isBuiltIn(nsName.name) ? {
      name: nsName.name
    } : this.typeMap[nsName.name];
    var self = this;

    /**
     * Traverse the selected trait.
     *
     * @param {String} cls
     */
    function traverseTrait(cls) {
      return traverseSuper(cls, true);
    }

    /**
     * Traverse the selected super type or trait
     *
     * @param {String} cls
     * @param {Boolean} [trait=false]
     */
    function traverseSuper(cls, trait) {
      var parentNs = parseName$1(cls, isBuiltIn(cls) ? '' : nsName.prefix);
      self.mapTypes(parentNs, iterator, trait);
    }
    if (!type) {
      throw new Error('unknown type <' + nsName.name + '>');
    }
    forEach$2(type.superClass, trait ? traverseTrait : traverseSuper);

    // call iterator with (type, inherited=!trait)
    iterator(type, !trait);
    forEach$2(type.traits, traverseTrait);
  };

  /**
   * Returns the effective descriptor for a type.
   *
   * @param  {String} type the namespaced name (ns:localName) of the type
   *
   * @return {Descriptor} the resulting effective descriptor
   */
  Registry.prototype.getEffectiveDescriptor = function (name) {
    var nsName = parseName$1(name);
    var builder = new DescriptorBuilder(nsName);
    this.mapTypes(nsName, function (type, inherited) {
      builder.addTrait(type, inherited);
    });
    var descriptor = builder.build();

    // define package link
    this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);
    return descriptor;
  };
  Registry.prototype.definePackage = function (target, pkg) {
    this.properties.define(target, '$pkg', {
      value: pkg
    });
  };

  ///////// helpers ////////////////////////////

  function ensureAvailable(packageMap, pkg, identifierKey) {
    var value = pkg[identifierKey];
    if (value in packageMap) {
      throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');
    }
  }

  /**
   * A utility that gets and sets properties of model elements.
   *
   * @param {Model} model
   */
  function Properties(model) {
    this.model = model;
  }

  /**
   * Sets a named property on the target element.
   * If the value is undefined, the property gets deleted.
   *
   * @param {Object} target
   * @param {String} name
   * @param {Object} value
   */
  Properties.prototype.set = function (target, name, value) {
    if (!isString$2(name) || !name.length) {
      throw new TypeError('property name must be a non-empty string');
    }
    var property = this.model.getPropertyDescriptor(target, name);
    var propertyName = property && property.name;
    if (isUndefined$3(value)) {
      // unset the property, if the specified value is undefined;
      // delete from $attrs (for extensions) or the target itself
      if (property) {
        delete target[propertyName];
      } else {
        delete target.$attrs[name];
      }
    } else {
      // set the property, defining well defined properties on the fly
      // or simply updating them in target.$attrs (for extensions)
      if (property) {
        if (propertyName in target) {
          target[propertyName] = value;
        } else {
          defineProperty$2(target, property, value);
        }
      } else {
        target.$attrs[name] = value;
      }
    }
  };

  /**
   * Returns the named property of the given element
   *
   * @param  {Object} target
   * @param  {String} name
   *
   * @return {Object}
   */
  Properties.prototype.get = function (target, name) {
    var property = this.model.getPropertyDescriptor(target, name);
    if (!property) {
      return target.$attrs[name];
    }
    var propertyName = property.name;

    // check if access to collection property and lazily initialize it
    if (!target[propertyName] && property.isMany) {
      defineProperty$2(target, property, []);
    }
    return target[propertyName];
  };

  /**
   * Define a property on the target element
   *
   * @param  {Object} target
   * @param  {String} name
   * @param  {Object} options
   */
  Properties.prototype.define = function (target, name, options) {
    if (!options.writable) {
      var value = options.value;

      // use getters for read-only variables to support ES6 proxies
      // cf. https://github.com/bpmn-io/internal-docs/issues/386
      options = assign$2({}, options, {
        get: function get() {
          return value;
        }
      });
      delete options.value;
    }
    Object.defineProperty(target, name, options);
  };

  /**
   * Define the descriptor for an element
   */
  Properties.prototype.defineDescriptor = function (target, descriptor) {
    this.define(target, '$descriptor', {
      value: descriptor
    });
  };

  /**
   * Define the model for an element
   */
  Properties.prototype.defineModel = function (target, model) {
    this.define(target, '$model', {
      value: model
    });
  };
  function isUndefined$3(val) {
    return typeof val === 'undefined';
  }
  function defineProperty$2(target, property, value) {
    Object.defineProperty(target, property.name, {
      enumerable: !property.isReference,
      writable: true,
      value: value,
      configurable: true
    });
  }

  //// Moddle implementation /////////////////////////////////////////////////

  /**
   * @class Moddle
   *
   * A model that can be used to create elements of a specific type.
   *
   * @example
   *
   * var Moddle = require('moddle');
   *
   * var pkg = {
   *   name: 'mypackage',
   *   prefix: 'my',
   *   types: [
   *     { name: 'Root' }
   *   ]
   * };
   *
   * var moddle = new Moddle([pkg]);
   *
   * @param {Array<Package>} packages the packages to contain
   */
  function Moddle(packages) {
    this.properties = new Properties(this);
    this.factory = new Factory(this, this.properties);
    this.registry = new Registry(packages, this.properties);
    this.typeCache = {};
  }

  /**
   * Create an instance of the specified type.
   *
   * @method Moddle#create
   *
   * @example
   *
   * var foo = moddle.create('my:Foo');
   * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
   *
   * @param  {String|Object} descriptor the type descriptor or name know to the model
   * @param  {Object} attrs   a number of attributes to initialize the model instance with
   * @return {Object}         model instance
   */
  Moddle.prototype.create = function (descriptor, attrs) {
    var Type = this.getType(descriptor);
    if (!Type) {
      throw new Error('unknown type <' + descriptor + '>');
    }
    return new Type(attrs);
  };

  /**
   * Returns the type representing a given descriptor
   *
   * @method Moddle#getType
   *
   * @example
   *
   * var Foo = moddle.getType('my:Foo');
   * var foo = new Foo({ 'id' : 'FOO_1' });
   *
   * @param  {String|Object} descriptor the type descriptor or name know to the model
   * @return {Object}         the type representing the descriptor
   */
  Moddle.prototype.getType = function (descriptor) {
    var cache = this.typeCache;
    var name = isString$2(descriptor) ? descriptor : descriptor.ns.name;
    var type = cache[name];
    if (!type) {
      descriptor = this.registry.getEffectiveDescriptor(name);
      type = cache[name] = this.factory.createType(descriptor);
    }
    return type;
  };

  /**
   * Creates an any-element type to be used within model instances.
   *
   * This can be used to create custom elements that lie outside the meta-model.
   * The created element contains all the meta-data required to serialize it
   * as part of meta-model elements.
   *
   * @method Moddle#createAny
   *
   * @example
   *
   * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
   *   value: 'bar'
   * });
   *
   * var container = moddle.create('my:Container', 'http://my', {
   *   any: [ foo ]
   * });
   *
   * // go ahead and serialize the stuff
   *
   *
   * @param  {String} name  the name of the element
   * @param  {String} nsUri the namespace uri of the element
   * @param  {Object} [properties] a map of properties to initialize the instance with
   * @return {Object} the any type instance
   */
  Moddle.prototype.createAny = function (name, nsUri, properties) {
    var nameNs = parseName$1(name);
    var element = {
      $type: name,
      $instanceOf: function $instanceOf(type) {
        return type === this.$type;
      }
    };
    var descriptor = {
      name: name,
      isGeneric: true,
      ns: {
        prefix: nameNs.prefix,
        localName: nameNs.localName,
        uri: nsUri
      }
    };
    this.properties.defineDescriptor(element, descriptor);
    this.properties.defineModel(element, this);
    this.properties.define(element, '$parent', {
      enumerable: false,
      writable: true
    });
    this.properties.define(element, '$instanceOf', {
      enumerable: false,
      writable: true
    });
    forEach$2(properties, function (a, key) {
      if (isObject$1(a) && a.value !== undefined) {
        element[a.name] = a.value;
      } else {
        element[key] = a;
      }
    });
    return element;
  };

  /**
   * Returns a registered package by uri or prefix
   *
   * @return {Object} the package
   */
  Moddle.prototype.getPackage = function (uriOrPrefix) {
    return this.registry.getPackage(uriOrPrefix);
  };

  /**
   * Returns a snapshot of all known packages
   *
   * @return {Object} the package
   */
  Moddle.prototype.getPackages = function () {
    return this.registry.getPackages();
  };

  /**
   * Returns the descriptor for an element
   */
  Moddle.prototype.getElementDescriptor = function (element) {
    return element.$descriptor;
  };

  /**
   * Returns true if the given descriptor or instance
   * represents the given type.
   *
   * May be applied to this, if element is omitted.
   */
  Moddle.prototype.hasType = function (element, type) {
    if (type === undefined) {
      type = element;
      element = this;
    }
    var descriptor = element.$model.getElementDescriptor(element);
    return type in descriptor.allTypesByName;
  };

  /**
   * Returns the descriptor of an elements named property
   */
  Moddle.prototype.getPropertyDescriptor = function (element, property) {
    return this.getElementDescriptor(element).propertiesByName[property];
  };

  /**
   * Returns a mapped type's descriptor
   */
  Moddle.prototype.getTypeDescriptor = function (type) {
    return this.registry.typeMap[type];
  };

  /**
   * Flatten array, one level deep.
   *
   * @param {Array<?>} arr
   *
   * @return {Array<?>}
   */
  var nativeToString$1 = Object.prototype.toString;
  var nativeHasOwnProperty$1 = Object.prototype.hasOwnProperty;
  function isUndefined$2(obj) {
    return obj === undefined;
  }
  function isArray$4(obj) {
    return nativeToString$1.call(obj) === '[object Array]';
  }
  function isFunction$1(obj) {
    var tag = nativeToString$1.call(obj);
    return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object AsyncGeneratorFunction]' || tag === '[object Proxy]';
  }
  function isString$1(obj) {
    return nativeToString$1.call(obj) === '[object String]';
  }
  /**
   * Return true, if target owns a property with the given key.
   *
   * @param {Object} target
   * @param {String} key
   *
   * @return {Boolean}
   */

  function has$1(target, key) {
    return nativeHasOwnProperty$1.call(target, key);
  }

  /**
   * Find element in collection.
   *
   * @param  {Array|Object} collection
   * @param  {Function|Object} matcher
   *
   * @return {Object}
   */

  function find$1(collection, matcher) {
    matcher = toMatcher(matcher);
    var match;
    forEach$1(collection, function (val, key) {
      if (matcher(val, key)) {
        match = val;
        return false;
      }
    });
    return match;
  }
  /**
   * Find element index in collection.
   *
   * @param  {Array|Object} collection
   * @param  {Function} matcher
   *
   * @return {Object}
   */

  function findIndex(collection, matcher) {
    matcher = toMatcher(matcher);
    var idx = isArray$4(collection) ? -1 : undefined;
    forEach$1(collection, function (val, key) {
      if (matcher(val, key)) {
        idx = key;
        return false;
      }
    });
    return idx;
  }
  /**
   * Find element in collection.
   *
   * @param  {Array|Object} collection
   * @param  {Function} matcher
   *
   * @return {Array} result
   */

  function filter$1(collection, matcher) {
    var result = [];
    forEach$1(collection, function (val, key) {
      if (matcher(val, key)) {
        result.push(val);
      }
    });
    return result;
  }
  /**
   * Iterate over collection; returning something
   * (non-undefined) will stop iteration.
   *
   * @param  {Array|Object} collection
   * @param  {Function} iterator
   *
   * @return {Object} return result that stopped the iteration
   */

  function forEach$1(collection, iterator) {
    var val, result;
    if (isUndefined$2(collection)) {
      return;
    }
    var convertKey = isArray$4(collection) ? toNum$1 : identity$1;
    for (var key in collection) {
      if (has$1(collection, key)) {
        val = collection[key];
        result = iterator(val, convertKey(key));
        if (result === false) {
          return val;
        }
      }
    }
  }
  function toMatcher(matcher) {
    return isFunction$1(matcher) ? matcher : function (e) {
      return e === matcher;
    };
  }
  function identity$1(arg) {
    return arg;
  }
  function toNum$1(arg) {
    return Number(arg);
  }
  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  /**
   * Convenience wrapper for `Object.assign`.
   *
   * @param {Object} target
   * @param {...Object} others
   *
   * @return {Object} the target
   */

  function assign$1(target) {
    for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      others[_key - 1] = arguments[_key];
    }
    return _extends.apply(void 0, [target].concat(others));
  }

  var fromCharCode = String.fromCharCode;
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;
  var ENTITY_MAPPING = {
    'amp': '&',
    'apos': '\'',
    'gt': '>',
    'lt': '<',
    'quot': '"'
  };

  // map UPPERCASE variants of supported special chars
  Object.keys(ENTITY_MAPPING).forEach(function (k) {
    ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
  });
  function replaceEntities(_, d, x, z) {
    // reserved names, i.e. &nbsp;
    if (z) {
      if (hasOwnProperty$1.call(ENTITY_MAPPING, z)) {
        return ENTITY_MAPPING[z];
      } else {
        // fall back to original value
        return '&' + z + ';';
      }
    }

    // decimal encoded char
    if (d) {
      return fromCharCode(d);
    }

    // hex encoded char
    return fromCharCode(parseInt(x, 16));
  }

  /**
   * A basic entity decoder that can decode a minimal
   * sub-set of reserved names (&amp;) as well as
   * hex (&#xaaf;) and decimal (&#1231;) encoded characters.
   *
   * @param {string} str
   *
   * @return {string} decoded string
   */
  function decodeEntities(s) {
    if (s.length > 3 && s.indexOf('&') !== -1) {
      return s.replace(ENTITY_PATTERN, replaceEntities);
    }
    return s;
  }
  var XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';
  var XSI_PREFIX = 'xsi';
  var XSI_TYPE$1 = 'xsi:type';
  var NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';
  function error$4(msg) {
    return new Error(msg);
  }
  function missingNamespaceForPrefix(prefix) {
    return 'missing namespace for prefix <' + prefix + '>';
  }
  function getter(getFn) {
    return {
      'get': getFn,
      'enumerable': true
    };
  }
  function cloneNsMatrix(nsMatrix) {
    var clone = {},
      key;
    for (key in nsMatrix) {
      clone[key] = nsMatrix[key];
    }
    return clone;
  }
  function uriPrefix(prefix) {
    return prefix + '$uri';
  }
  function buildNsMatrix(nsUriToPrefix) {
    var nsMatrix = {},
      uri,
      prefix;
    for (uri in nsUriToPrefix) {
      prefix = nsUriToPrefix[uri];
      nsMatrix[prefix] = prefix;
      nsMatrix[uriPrefix(prefix)] = uri;
    }
    return nsMatrix;
  }
  function noopGetContext() {
    return {
      'line': 0,
      'column': 0
    };
  }
  function throwFunc(err) {
    throw err;
  }

  /**
   * Creates a new parser with the given options.
   *
   * @constructor
   *
   * @param  {!Object<string, ?>=} options
   */
  function Parser$1(options) {
    if (!this) {
      return new Parser$1(options);
    }
    var proxy = options && options['proxy'];
    var onText,
      onOpenTag,
      onCloseTag,
      onCDATA,
      onError = throwFunc,
      onWarning,
      onComment,
      onQuestion,
      onAttention;
    var getContext = noopGetContext;

    /**
     * Do we need to parse the current elements attributes for namespaces?
     *
     * @type {boolean}
     */
    var maybeNS = false;

    /**
     * Do we process namespaces at all?
     *
     * @type {boolean}
     */
    var isNamespace = false;

    /**
     * The caught error returned on parse end
     *
     * @type {Error}
     */
    var returnError = null;

    /**
     * Should we stop parsing?
     *
     * @type {boolean}
     */
    var parseStop = false;

    /**
     * A map of { uri: prefix } used by the parser.
     *
     * This map will ensure we can normalize prefixes during processing;
     * for each uri, only one prefix will be exposed to the handlers.
     *
     * @type {!Object<string, string>}}
     */
    var nsUriToPrefix;

    /**
     * Handle parse error.
     *
     * @param  {string|Error} err
     */
    function handleError(err) {
      if (!(err instanceof Error)) {
        err = error$4(err);
      }
      returnError = err;
      onError(err, getContext);
    }

    /**
     * Handle parse error.
     *
     * @param  {string|Error} err
     */
    function handleWarning(err) {
      if (!onWarning) {
        return;
      }
      if (!(err instanceof Error)) {
        err = error$4(err);
      }
      onWarning(err, getContext);
    }

    /**
     * Register parse listener.
     *
     * @param  {string}   name
     * @param  {Function} cb
     *
     * @return {Parser}
     */
    this['on'] = function (name, cb) {
      if (typeof cb !== 'function') {
        throw error$4('required args <name, cb>');
      }
      switch (name) {
        case 'openTag':
          onOpenTag = cb;
          break;
        case 'text':
          onText = cb;
          break;
        case 'closeTag':
          onCloseTag = cb;
          break;
        case 'error':
          onError = cb;
          break;
        case 'warn':
          onWarning = cb;
          break;
        case 'cdata':
          onCDATA = cb;
          break;
        case 'attention':
          onAttention = cb;
          break;
        // <!XXXXX zzzz="eeee">
        case 'question':
          onQuestion = cb;
          break;
        // <? ....  ?>
        case 'comment':
          onComment = cb;
          break;
        default:
          throw error$4('unsupported event: ' + name);
      }
      return this;
    };

    /**
     * Set the namespace to prefix mapping.
     *
     * @example
     *
     * parser.ns({
     *   'http://foo': 'foo',
     *   'http://bar': 'bar'
     * });
     *
     * @param  {!Object<string, string>} nsMap
     *
     * @return {Parser}
     */
    this['ns'] = function (nsMap) {
      if (typeof nsMap === 'undefined') {
        nsMap = {};
      }
      if (_typeof(nsMap) !== 'object') {
        throw error$4('required args <nsMap={}>');
      }
      var _nsUriToPrefix = {},
        k;
      for (k in nsMap) {
        _nsUriToPrefix[k] = nsMap[k];
      }

      // FORCE default mapping for schema instance
      _nsUriToPrefix[XSI_URI] = XSI_PREFIX;
      isNamespace = true;
      nsUriToPrefix = _nsUriToPrefix;
      return this;
    };

    /**
     * Parse xml string.
     *
     * @param  {string} xml
     *
     * @return {Error} returnError, if not thrown
     */
    this['parse'] = function (xml) {
      if (typeof xml !== 'string') {
        throw error$4('required args <xml=string>');
      }
      returnError = null;
      parse(xml);
      getContext = noopGetContext;
      parseStop = false;
      return returnError;
    };

    /**
     * Stop parsing.
     */
    this['stop'] = function () {
      parseStop = true;
    };

    /**
     * Parse string, invoking configured listeners on element.
     *
     * @param  {string} xml
     */
    function parse(xml) {
      var nsMatrixStack = isNamespace ? [] : null,
        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,
        _nsMatrix,
        nodeStack = [],
        anonymousNsCount = 0,
        tagStart = false,
        tagEnd = false,
        i = 0,
        j = 0,
        x,
        y,
        q,
        w,
        v,
        xmlns,
        elementName,
        _elementName,
        elementProxy;
      var attrsString = '',
        attrsStart = 0,
        cachedAttrs // false = parsed with errors, null = needs parsing
      ;

      /**
       * Parse attributes on demand and returns the parsed attributes.
       *
       * Return semantics: (1) `false` on attribute parse error,
       * (2) object hash on extracted attrs.
       *
       * @return {boolean|Object}
       */
      function getAttrs() {
        if (cachedAttrs !== null) {
          return cachedAttrs;
        }
        var nsUri,
          nsUriPrefix,
          nsName,
          defaultAlias = isNamespace && nsMatrix['xmlns'],
          attrList = isNamespace && maybeNS ? [] : null,
          i = attrsStart,
          s = attrsString,
          l = s.length,
          hasNewMatrix,
          newalias,
          value,
          alias,
          name,
          attrs = {},
          seenAttrs = {},
          skipAttr,
          w,
          j;
        parseAttr: for (; i < l; i++) {
          skipAttr = false;
          w = s.charCodeAt(i);
          if (w === 32 || w < 14 && w > 8) {
            // WHITESPACE={ \f\n\r\t\v}
            continue;
          }

          // wait for non whitespace character
          if (w < 65 || w > 122 || w > 90 && w < 97) {
            if (w !== 95 && w !== 58) {
              // char 95"_" 58":"
              handleWarning('illegal first char attribute name');
              skipAttr = true;
            }
          }

          // parse attribute name
          for (j = i + 1; j < l; j++) {
            w = s.charCodeAt(j);
            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 ||
            // '.'
            w === 45 ||
            // '-'
            w === 95 // '_'
            ) {
              continue;
            }

            // unexpected whitespace
            if (w === 32 || w < 14 && w > 8) {
              // WHITESPACE
              handleWarning('missing attribute value');
              i = j;
              continue parseAttr;
            }

            // expected "="
            if (w === 61) {
              // "=" == 61
              break;
            }
            handleWarning('illegal attribute name char');
            skipAttr = true;
          }
          name = s.substring(i, j);
          if (name === 'xmlns:xmlns') {
            handleWarning('illegal declaration of xmlns');
            skipAttr = true;
          }
          w = s.charCodeAt(j + 1);
          if (w === 34) {
            // '"'
            j = s.indexOf('"', i = j + 2);
            if (j === -1) {
              j = s.indexOf('\'', i);
              if (j !== -1) {
                handleWarning('attribute value quote missmatch');
                skipAttr = true;
              }
            }
          } else if (w === 39) {
            // "'"
            j = s.indexOf('\'', i = j + 2);
            if (j === -1) {
              j = s.indexOf('"', i);
              if (j !== -1) {
                handleWarning('attribute value quote missmatch');
                skipAttr = true;
              }
            }
          } else {
            handleWarning('missing attribute value quotes');
            skipAttr = true;

            // skip to next space
            for (j = j + 1; j < l; j++) {
              w = s.charCodeAt(j + 1);
              if (w === 32 || w < 14 && w > 8) {
                // WHITESPACE
                break;
              }
            }
          }
          if (j === -1) {
            handleWarning('missing closing quotes');
            j = l;
            skipAttr = true;
          }
          if (!skipAttr) {
            value = s.substring(i, j);
          }
          i = j;

          // ensure SPACE follows attribute
          // skip illegal content otherwise
          // example a="b"c
          for (; j + 1 < l; j++) {
            w = s.charCodeAt(j + 1);
            if (w === 32 || w < 14 && w > 8) {
              // WHITESPACE
              break;
            }

            // FIRST ILLEGAL CHAR
            if (i === j) {
              handleWarning('illegal character after attribute end');
              skipAttr = true;
            }
          }

          // advance cursor to next attribute
          i = j + 1;
          if (skipAttr) {
            continue parseAttr;
          }

          // check attribute re-declaration
          if (name in seenAttrs) {
            handleWarning('attribute <' + name + '> already defined');
            continue;
          }
          seenAttrs[name] = true;
          if (!isNamespace) {
            attrs[name] = value;
            continue;
          }

          // try to extract namespace information
          if (maybeNS) {
            newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null;

            // handle xmlns(:alias) assignment
            if (newalias !== null) {
              nsUri = decodeEntities(value);
              nsUriPrefix = uriPrefix(newalias);
              alias = nsUriToPrefix[nsUri];
              if (!alias) {
                // no prefix defined or prefix collision
                if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                  // alocate free ns prefix
                  do {
                    alias = 'ns' + anonymousNsCount++;
                  } while (typeof nsMatrix[alias] !== 'undefined');
                } else {
                  alias = newalias;
                }
                nsUriToPrefix[nsUri] = alias;
              }
              if (nsMatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  nsMatrix = cloneNsMatrix(nsMatrix);
                  hasNewMatrix = true;
                }
                nsMatrix[newalias] = alias;
                if (newalias === 'xmlns') {
                  nsMatrix[uriPrefix(alias)] = nsUri;
                  defaultAlias = alias;
                }
                nsMatrix[nsUriPrefix] = nsUri;
              }

              // expose xmlns(:asd)="..." in attributes
              attrs[name] = value;
              continue;
            }

            // collect attributes until all namespace
            // declarations are processed
            attrList.push(name, value);
            continue;
          } /** end if (maybeNs) */

          // handle attributes on element without
          // namespace declarations
          w = name.indexOf(':');
          if (w === -1) {
            attrs[name] = value;
            continue;
          }

          // normalize ns attribute name
          if (!(nsName = nsMatrix[name.substring(0, w)])) {
            handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
            continue;
          }
          name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);

          // end: normalize ns attribute name

          // normalize xsi:type ns attribute value
          if (name === XSI_TYPE$1) {
            w = value.indexOf(':');
            if (w !== -1) {
              nsName = value.substring(0, w);

              // handle default prefixes, i.e. xs:String gracefully
              nsName = nsMatrix[nsName] || nsName;
              value = nsName + value.substring(w);
            } else {
              value = defaultAlias + ':' + value;
            }
          }

          // end: normalize xsi:type ns attribute value

          attrs[name] = value;
        }

        // handle deferred, possibly namespaced attributes
        if (maybeNS) {
          // normalize captured attributes
          for (i = 0, l = attrList.length; i < l; i++) {
            name = attrList[i++];
            value = attrList[i];
            w = name.indexOf(':');
            if (w !== -1) {
              // normalize ns attribute name
              if (!(nsName = nsMatrix[name.substring(0, w)])) {
                handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
                continue;
              }
              name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);

              // end: normalize ns attribute name

              // normalize xsi:type ns attribute value
              if (name === XSI_TYPE$1) {
                w = value.indexOf(':');
                if (w !== -1) {
                  nsName = value.substring(0, w);

                  // handle default prefixes, i.e. xs:String gracefully
                  nsName = nsMatrix[nsName] || nsName;
                  value = nsName + value.substring(w);
                } else {
                  value = defaultAlias + ':' + value;
                }
              }

              // end: normalize xsi:type ns attribute value
            }

            attrs[name] = value;
          }

          // end: normalize captured attributes
        }

        return cachedAttrs = attrs;
      }

      /**
       * Extract the parse context { line, column, part }
       * from the current parser position.
       *
       * @return {Object} parse context
       */
      function getParseContext() {
        var splitsRe = /(\r\n|\r|\n)/g;
        var line = 0;
        var column = 0;
        var startOfLine = 0;
        var endOfLine = j;
        var match;
        var data;
        while (i >= startOfLine) {
          match = splitsRe.exec(xml);
          if (!match) {
            break;
          }

          // end of line = (break idx + break chars)
          endOfLine = match[0].length + match.index;
          if (endOfLine > i) {
            break;
          }

          // advance to next line
          line += 1;
          startOfLine = endOfLine;
        }

        // EOF errors
        if (i == -1) {
          column = endOfLine;
          data = xml.substring(j);
        } else
          // start errors
          if (j === 0) {
            data = xml.substring(j, i);
          }

          // other errors
          else {
            column = i - startOfLine;
            data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);
          }
        return {
          'data': data,
          'line': line,
          'column': column
        };
      }
      getContext = getParseContext;
      if (proxy) {
        elementProxy = Object.create({}, {
          'name': getter(function () {
            return elementName;
          }),
          'originalName': getter(function () {
            return _elementName;
          }),
          'attrs': getter(getAttrs),
          'ns': getter(function () {
            return nsMatrix;
          })
        });
      }

      // actual parse logic
      while (j !== -1) {
        if (xml.charCodeAt(j) === 60) {
          // "<"
          i = j;
        } else {
          i = xml.indexOf('<', j);
        }

        // parse end
        if (i === -1) {
          if (nodeStack.length) {
            return handleError('unexpected end of file');
          }
          if (j === 0) {
            return handleError('missing start tag');
          }
          if (j < xml.length) {
            if (xml.substring(j).trim()) {
              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
            }
          }
          return;
        }

        // parse text
        if (j !== i) {
          if (nodeStack.length) {
            if (onText) {
              onText(xml.substring(j, i), decodeEntities, getContext);
              if (parseStop) {
                return;
              }
            }
          } else {
            if (xml.substring(j, i).trim()) {
              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
              if (parseStop) {
                return;
              }
            }
          }
        }
        w = xml.charCodeAt(i + 1);

        // parse comments + CDATA
        if (w === 33) {
          // "!"
          q = xml.charCodeAt(i + 2);

          // CDATA section
          if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') {
            // 91 == "["
            j = xml.indexOf(']]>', i);
            if (j === -1) {
              return handleError('unclosed cdata');
            }
            if (onCDATA) {
              onCDATA(xml.substring(i + 9, j), getContext);
              if (parseStop) {
                return;
              }
            }
            j += 3;
            continue;
          }

          // comment
          if (q === 45 && xml.charCodeAt(i + 3) === 45) {
            // 45 == "-"
            j = xml.indexOf('-->', i);
            if (j === -1) {
              return handleError('unclosed comment');
            }
            if (onComment) {
              onComment(xml.substring(i + 4, j), decodeEntities, getContext);
              if (parseStop) {
                return;
              }
            }
            j += 3;
            continue;
          }
        }

        // parse question <? ... ?>
        if (w === 63) {
          // "?"
          j = xml.indexOf('?>', i);
          if (j === -1) {
            return handleError('unclosed question');
          }
          if (onQuestion) {
            onQuestion(xml.substring(i, j + 2), getContext);
            if (parseStop) {
              return;
            }
          }
          j += 2;
          continue;
        }

        // find matching closing tag for attention or standard tags
        // for that we must skip through attribute values
        // (enclosed in single or double quotes)
        for (x = i + 1;; x++) {
          v = xml.charCodeAt(x);
          if (isNaN(v)) {
            j = -1;
            return handleError('unclosed tag');
          }

          // [10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"
          // skips the quoted string
          // (double quotes) does not appear in a literal enclosed by (double quotes)
          // (single quote) does not appear in a literal enclosed by (single quote)
          if (v === 34) {
            //  '"'
            q = xml.indexOf('"', x + 1);
            x = q !== -1 ? q : x;
          } else if (v === 39) {
            // "'"
            q = xml.indexOf("'", x + 1);
            x = q !== -1 ? q : x;
          } else if (v === 62) {
            // '>'
            j = x;
            break;
          }
        }

        // parse attention <! ...>
        // previously comment and CDATA have already been parsed
        if (w === 33) {
          // "!"

          if (onAttention) {
            onAttention(xml.substring(i, j + 1), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
          j += 1;
          continue;
        }

        // don't process attributes;
        // there are none
        cachedAttrs = {};

        // if (xml.charCodeAt(i+1) === 47) { // </...
        if (w === 47) {
          // </...
          tagStart = false;
          tagEnd = true;
          if (!nodeStack.length) {
            return handleError('missing open tag');
          }

          // verify open <-> close tag match
          x = elementName = nodeStack.pop();
          q = i + 2 + x.length;
          if (xml.substring(i + 2, q) !== x) {
            return handleError('closing tag mismatch');
          }

          // verify chars in close tag
          for (; q < j; q++) {
            w = xml.charCodeAt(q);
            if (w === 32 || w > 8 && w < 14) {
              // \f\n\r\t\v space
              continue;
            }
            return handleError('close tag');
          }
        } else {
          if (xml.charCodeAt(j - 1) === 47) {
            // .../>
            x = elementName = xml.substring(i + 1, j - 1);
            tagStart = true;
            tagEnd = true;
          } else {
            x = elementName = xml.substring(i + 1, j);
            tagStart = true;
            tagEnd = false;
          }
          if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {
            // char 95"_" 58":"
            return handleError('illegal first char nodeName');
          }
          for (q = 1, y = x.length; q < y; q++) {
            w = x.charCodeAt(q);
            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {
              continue;
            }
            if (w === 32 || w < 14 && w > 8) {
              // \f\n\r\t\v space
              elementName = x.substring(0, q);

              // maybe there are attributes
              cachedAttrs = null;
              break;
            }
            return handleError('invalid nodeName');
          }
          if (!tagEnd) {
            nodeStack.push(elementName);
          }
        }
        if (isNamespace) {
          _nsMatrix = nsMatrix;
          if (tagStart) {
            // remember old namespace
            // unless we're self-closing
            if (!tagEnd) {
              nsMatrixStack.push(_nsMatrix);
            }
            if (cachedAttrs === null) {
              // quick check, whether there may be namespace
              // declarations on the node; if that is the case
              // we need to eagerly parse the node attributes
              if (maybeNS = x.indexOf('xmlns', q) !== -1) {
                attrsStart = q;
                attrsString = x;
                getAttrs();
                maybeNS = false;
              }
            }
          }
          _elementName = elementName;
          w = elementName.indexOf(':');
          if (w !== -1) {
            xmlns = nsMatrix[elementName.substring(0, w)];

            // prefix given; namespace must exist
            if (!xmlns) {
              return handleError('missing namespace on <' + _elementName + '>');
            }
            elementName = elementName.substr(w + 1);
          } else {
            xmlns = nsMatrix['xmlns'];

            // if no default namespace is defined,
            // we'll import the element as anonymous.
            //
            // it is up to users to correct that to the document defined
            // targetNamespace, or whatever their undersanding of the
            // XML spec mandates.
          }

          // adjust namespace prefixs as configured
          if (xmlns) {
            elementName = xmlns + ':' + elementName;
          }
        }
        if (tagStart) {
          attrsStart = q;
          attrsString = x;
          if (onOpenTag) {
            if (proxy) {
              onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
            } else {
              onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
            }
            if (parseStop) {
              return;
            }
          }
        }
        if (tagEnd) {
          if (onCloseTag) {
            onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);
            if (parseStop) {
              return;
            }
          }

          // restore old namespace
          if (isNamespace) {
            if (!tagStart) {
              nsMatrix = nsMatrixStack.pop();
            } else {
              nsMatrix = _nsMatrix;
            }
          }
        }
        j += 1;
      }
    } /** end parse */
  }

  function hasLowerCaseAlias(pkg) {
    return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
  }
  var DEFAULT_NS_MAP = {
    'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
    'xml': 'http://www.w3.org/XML/1998/namespace'
  };
  var XSI_TYPE = 'xsi:type';
  function serializeFormat(element) {
    return element.xml && element.xml.serialize;
  }
  function serializeAsType(element) {
    return serializeFormat(element) === XSI_TYPE;
  }
  function serializeAsProperty(element) {
    return serializeFormat(element) === 'property';
  }
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function aliasToName(aliasNs, pkg) {
    if (!hasLowerCaseAlias(pkg)) {
      return aliasNs.name;
    }
    return aliasNs.prefix + ':' + capitalize(aliasNs.localName);
  }
  function prefixedToName(nameNs, pkg) {
    var name = nameNs.name,
      localName = nameNs.localName;
    var typePrefix = pkg.xml && pkg.xml.typePrefix;
    if (typePrefix && localName.indexOf(typePrefix) === 0) {
      return nameNs.prefix + ':' + localName.slice(typePrefix.length);
    } else {
      return name;
    }
  }
  function normalizeXsiTypeName(name, model) {
    var nameNs = parseName$1(name);
    var pkg = model.getPackage(nameNs.prefix);
    return prefixedToName(nameNs, pkg);
  }
  function error$3(message) {
    return new Error(message);
  }

  /**
   * Get the moddle descriptor for a given instance or type.
   *
   * @param  {ModdleElement|Function} element
   *
   * @return {Object} the moddle descriptor
   */
  function getModdleDescriptor(element) {
    return element.$descriptor;
  }

  /**
   * A parse context.
   *
   * @class
   *
   * @param {Object} options
   * @param {ElementHandler} options.rootHandler the root handler for parsing a document
   * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
   */
  function Context$1(options) {
    /**
     * @property {ElementHandler} rootHandler
     */

    /**
     * @property {Boolean} lax
     */

    assign$1(this, options);
    this.elementsById = {};
    this.references = [];
    this.warnings = [];

    /**
     * Add an unresolved reference.
     *
     * @param {Object} reference
     */
    this.addReference = function (reference) {
      this.references.push(reference);
    };

    /**
     * Add a processed element.
     *
     * @param {ModdleElement} element
     */
    this.addElement = function (element) {
      if (!element) {
        throw error$3('expected element');
      }
      var elementsById = this.elementsById;
      var descriptor = getModdleDescriptor(element);
      var idProperty = descriptor.idProperty,
        id;
      if (idProperty) {
        id = element.get(idProperty.name);
        if (id) {
          // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
          if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
            throw new Error('illegal ID <' + id + '>');
          }
          if (elementsById[id]) {
            throw error$3('duplicate ID <' + id + '>');
          }
          elementsById[id] = element;
        }
      }
    };

    /**
     * Add an import warning.
     *
     * @param {Object} warning
     * @param {String} warning.message
     * @param {Error} [warning.error]
     */
    this.addWarning = function (warning) {
      this.warnings.push(warning);
    };
  }
  function BaseHandler() {}
  BaseHandler.prototype.handleEnd = function () {};
  BaseHandler.prototype.handleText = function () {};
  BaseHandler.prototype.handleNode = function () {};

  /**
   * A simple pass through handler that does nothing except for
   * ignoring all input it receives.
   *
   * This is used to ignore unknown elements and
   * attributes.
   */
  function NoopHandler() {}
  NoopHandler.prototype = Object.create(BaseHandler.prototype);
  NoopHandler.prototype.handleNode = function () {
    return this;
  };
  function BodyHandler() {}
  BodyHandler.prototype = Object.create(BaseHandler.prototype);
  BodyHandler.prototype.handleText = function (text) {
    this.body = (this.body || '') + text;
  };
  function ReferenceHandler(property, context) {
    this.property = property;
    this.context = context;
  }
  ReferenceHandler.prototype = Object.create(BodyHandler.prototype);
  ReferenceHandler.prototype.handleNode = function (node) {
    if (this.element) {
      throw error$3('expected no sub nodes');
    } else {
      this.element = this.createReference(node);
    }
    return this;
  };
  ReferenceHandler.prototype.handleEnd = function () {
    this.element.id = this.body;
  };
  ReferenceHandler.prototype.createReference = function (node) {
    return {
      property: this.property.ns.name,
      id: ''
    };
  };
  function ValueHandler(propertyDesc, element) {
    this.element = element;
    this.propertyDesc = propertyDesc;
  }
  ValueHandler.prototype = Object.create(BodyHandler.prototype);
  ValueHandler.prototype.handleEnd = function () {
    var value = this.body || '',
      element = this.element,
      propertyDesc = this.propertyDesc;
    value = coerceType(propertyDesc.type, value);
    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(value);
    } else {
      element.set(propertyDesc.name, value);
    }
  };
  function BaseElementHandler() {}
  BaseElementHandler.prototype = Object.create(BodyHandler.prototype);
  BaseElementHandler.prototype.handleNode = function (node) {
    var parser = this,
      element = this.element;
    if (!element) {
      element = this.element = this.createElement(node);
      this.context.addElement(element);
    } else {
      parser = this.handleChild(node);
    }
    return parser;
  };

  /**
   * @class Reader.ElementHandler
   *
   */
  function ElementHandler(model, typeName, context) {
    this.model = model;
    this.type = model.getType(typeName);
    this.context = context;
  }
  ElementHandler.prototype = Object.create(BaseElementHandler.prototype);
  ElementHandler.prototype.addReference = function (reference) {
    this.context.addReference(reference);
  };
  ElementHandler.prototype.handleText = function (text) {
    var element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;
    if (!bodyProperty) {
      throw error$3('unexpected body text <' + text + '>');
    }
    BodyHandler.prototype.handleText.call(this, text);
  };
  ElementHandler.prototype.handleEnd = function () {
    var value = this.body,
      element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;
    if (bodyProperty && value !== undefined) {
      value = coerceType(bodyProperty.type, value);
      element.set(bodyProperty.name, value);
    }
  };

  /**
   * Create an instance of the model from the given node.
   *
   * @param  {Element} node the xml node
   */
  ElementHandler.prototype.createElement = function (node) {
    var attributes = node.attributes,
      Type = this.type,
      descriptor = getModdleDescriptor(Type),
      context = this.context,
      instance = new Type({}),
      model = this.model,
      propNameNs;
    forEach$1(attributes, function (value, name) {
      var prop = descriptor.propertiesByName[name],
        values;
      if (prop && prop.isReference) {
        if (!prop.isMany) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: value
          });
        } else {
          // IDREFS: parse references as whitespace-separated list
          values = value.split(' ');
          forEach$1(values, function (v) {
            context.addReference({
              element: instance,
              property: prop.ns.name,
              id: v
            });
          });
        }
      } else {
        if (prop) {
          value = coerceType(prop.type, value);
        } else if (name !== 'xmlns') {
          propNameNs = parseName$1(name, descriptor.ns.prefix);

          // check whether attribute is defined in a well-known namespace
          // if that is the case we emit a warning to indicate potential misuse
          if (model.getPackage(propNameNs.prefix)) {
            context.addWarning({
              message: 'unknown attribute <' + name + '>',
              element: instance,
              property: name,
              value: value
            });
          }
        }
        instance.set(name, value);
      }
    });
    return instance;
  };
  ElementHandler.prototype.getPropertyForNode = function (node) {
    var name = node.name;
    var nameNs = parseName$1(name);
    var type = this.type,
      model = this.model,
      descriptor = getModdleDescriptor(type);
    var propertyName = nameNs.name,
      property = descriptor.propertiesByName[propertyName],
      elementTypeName,
      elementType;

    // search for properties by name first

    if (property && !property.isAttr) {
      if (serializeAsType(property)) {
        elementTypeName = node.attributes[XSI_TYPE];

        // xsi type is optional, if it does not exists the
        // default type is assumed
        if (elementTypeName) {
          // take possible type prefixes from XML
          // into account, i.e.: xsi:type="t{ActualType}"
          elementTypeName = normalizeXsiTypeName(elementTypeName, model);
          elementType = model.getType(elementTypeName);
          return assign$1({}, property, {
            effectiveType: getModdleDescriptor(elementType).name
          });
        }
      }

      // search for properties by name first
      return property;
    }
    var pkg = model.getPackage(nameNs.prefix);
    if (pkg) {
      elementTypeName = aliasToName(nameNs, pkg);
      elementType = model.getType(elementTypeName);

      // search for collection members later
      property = find$1(descriptor.properties, function (p) {
        return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
      });
      if (property) {
        return assign$1({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    } else {
      // parse unknown element (maybe extension)
      property = find$1(descriptor.properties, function (p) {
        return !p.isReference && !p.isAttribute && p.type === 'Element';
      });
      if (property) {
        return property;
      }
    }
    throw error$3('unrecognized element <' + nameNs.name + '>');
  };
  ElementHandler.prototype.toString = function () {
    return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
  };
  ElementHandler.prototype.valueHandler = function (propertyDesc, element) {
    return new ValueHandler(propertyDesc, element);
  };
  ElementHandler.prototype.referenceHandler = function (propertyDesc) {
    return new ReferenceHandler(propertyDesc, this.context);
  };
  ElementHandler.prototype.handler = function (type) {
    if (type === 'Element') {
      return new GenericElementHandler(this.model, type, this.context);
    } else {
      return new ElementHandler(this.model, type, this.context);
    }
  };

  /**
   * Handle the child element parsing
   *
   * @param  {Element} node the xml node
   */
  ElementHandler.prototype.handleChild = function (node) {
    var propertyDesc, type, element, childHandler;
    propertyDesc = this.getPropertyForNode(node);
    element = this.element;
    type = propertyDesc.effectiveType || propertyDesc.type;
    if (isSimple(type)) {
      return this.valueHandler(propertyDesc, element);
    }
    if (propertyDesc.isReference) {
      childHandler = this.referenceHandler(propertyDesc).handleNode(node);
    } else {
      childHandler = this.handler(type).handleNode(node);
    }
    var newElement = childHandler.element;

    // child handles may decide to skip elements
    // by not returning anything
    if (newElement !== undefined) {
      if (propertyDesc.isMany) {
        element.get(propertyDesc.name).push(newElement);
      } else {
        element.set(propertyDesc.name, newElement);
      }
      if (propertyDesc.isReference) {
        assign$1(newElement, {
          element: element
        });
        this.context.addReference(newElement);
      } else {
        // establish child -> parent relationship
        newElement.$parent = element;
      }
    }
    return childHandler;
  };

  /**
   * An element handler that performs special validation
   * to ensure the node it gets initialized with matches
   * the handlers type (namespace wise).
   *
   * @param {Moddle} model
   * @param {String} typeName
   * @param {Context} context
   */
  function RootElementHandler(model, typeName, context) {
    ElementHandler.call(this, model, typeName, context);
  }
  RootElementHandler.prototype = Object.create(ElementHandler.prototype);
  RootElementHandler.prototype.createElement = function (node) {
    var name = node.name,
      nameNs = parseName$1(name),
      model = this.model,
      type = this.type,
      pkg = model.getPackage(nameNs.prefix),
      typeName = pkg && aliasToName(nameNs, pkg) || name;

    // verify the correct namespace if we parse
    // the first element in the handler tree
    //
    // this ensures we don't mistakenly import wrong namespace elements
    if (!type.hasType(typeName)) {
      throw error$3('unexpected element <' + node.originalName + '>');
    }
    return ElementHandler.prototype.createElement.call(this, node);
  };
  function GenericElementHandler(model, typeName, context) {
    this.model = model;
    this.context = context;
  }
  GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);
  GenericElementHandler.prototype.createElement = function (node) {
    var name = node.name,
      ns = parseName$1(name),
      prefix = ns.prefix,
      uri = node.ns[prefix + '$uri'],
      attributes = node.attributes;
    return this.model.createAny(name, uri, attributes);
  };
  GenericElementHandler.prototype.handleChild = function (node) {
    var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
      element = this.element;
    var newElement = handler.element,
      children;
    if (newElement !== undefined) {
      children = element.$children = element.$children || [];
      children.push(newElement);

      // establish child -> parent relationship
      newElement.$parent = element;
    }
    return handler;
  };
  GenericElementHandler.prototype.handleEnd = function () {
    if (this.body) {
      this.element.$body = this.body;
    }
  };

  /**
   * A reader for a meta-model
   *
   * @param {Object} options
   * @param {Model} options.model used to read xml files
   * @param {Boolean} options.lax whether to make parse errors warnings
   */
  function Reader(options) {
    if (options instanceof Moddle) {
      options = {
        model: options
      };
    }
    assign$1(this, {
      lax: false
    }, options);
  }

  /**
   * The fromXML result.
   *
   * @typedef {Object} ParseResult
   *
   * @property {ModdleElement} rootElement
   * @property {Array<Object>} references
   * @property {Array<Error>} warnings
   * @property {Object} elementsById - a mapping containing each ID -> ModdleElement
   */

  /**
   * The fromXML result.
   *
   * @typedef {Error} ParseError
   *
   * @property {Array<Error>} warnings
   */

  /**
   * Parse the given XML into a moddle document tree.
   *
   * @param {String} xml
   * @param {ElementHandler|Object} options or rootHandler
   *
   * @returns {Promise<ParseResult, ParseError>}
   */
  Reader.prototype.fromXML = function (xml, options, done) {
    var rootHandler = options.rootHandler;
    if (options instanceof ElementHandler) {
      // root handler passed via (xml, { rootHandler: ElementHandler }, ...)
      rootHandler = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        // rootHandler passed via (xml, 'someString', ...)
        rootHandler = this.handler(options);
        options = {};
      } else if (typeof rootHandler === 'string') {
        // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)
        rootHandler = this.handler(rootHandler);
      }
    }
    var model = this.model,
      lax = this.lax;
    var context = new Context$1(assign$1({}, options, {
        rootHandler: rootHandler
      })),
      parser = new Parser$1({
        proxy: true
      }),
      stack = createStack();
    rootHandler.context = context;

    // push root handler
    stack.push(rootHandler);

    /**
     * Handle error.
     *
     * @param  {Error} err
     * @param  {Function} getContext
     * @param  {boolean} lax
     *
     * @return {boolean} true if handled
     */
    function handleError(err, getContext, lax) {
      var ctx = getContext();
      var line = ctx.line,
        column = ctx.column,
        data = ctx.data;

      // we receive the full context data here,
      // for elements trim down the information
      // to the tag name, only
      if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {
        data = data.slice(0, data.indexOf(' ')) + '>';
      }
      var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\n\t' + 'line: ' + line + '\n\t' + 'column: ' + column + '\n\t' + 'nested error: ' + err.message;
      if (lax) {
        context.addWarning({
          message: message,
          error: err
        });
        return true;
      } else {
        throw error$3(message);
      }
    }
    function handleWarning(err, getContext) {
      // just like handling errors in <lax=true> mode
      return handleError(err, getContext, true);
    }

    /**
     * Resolve collected references on parse end.
     */
    function resolveReferences() {
      var elementsById = context.elementsById;
      var references = context.references;
      var i, r;
      for (i = 0; r = references[i]; i++) {
        var element = r.element;
        var reference = elementsById[r.id];
        var property = getModdleDescriptor(element).propertiesByName[r.property];
        if (!reference) {
          context.addWarning({
            message: 'unresolved reference <' + r.id + '>',
            element: r.element,
            property: r.property,
            value: r.id
          });
        }
        if (property.isMany) {
          var collection = element.get(property.name),
            idx = collection.indexOf(r);

          // we replace an existing place holder (idx != -1) or
          // append to the collection instead
          if (idx === -1) {
            idx = collection.length;
          }
          if (!reference) {
            // remove unresolvable reference
            collection.splice(idx, 1);
          } else {
            // add or update reference in collection
            collection[idx] = reference;
          }
        } else {
          element.set(property.name, reference);
        }
      }
    }
    function handleClose() {
      stack.pop().handleEnd();
    }
    var PREAMBLE_START_PATTERN = /^<\?xml /i;
    var ENCODING_PATTERN = / encoding="([^"]+)"/i;
    var UTF_8_PATTERN = /^utf-8$/i;
    function handleQuestion(question) {
      if (!PREAMBLE_START_PATTERN.test(question)) {
        return;
      }
      var match = ENCODING_PATTERN.exec(question);
      var encoding = match && match[1];
      if (!encoding || UTF_8_PATTERN.test(encoding)) {
        return;
      }
      context.addWarning({
        message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'
      });
    }
    function handleOpen(node, getContext) {
      var handler = stack.peek();
      try {
        stack.push(handler.handleNode(node));
      } catch (err) {
        if (handleError(err, getContext, lax)) {
          stack.push(new NoopHandler());
        }
      }
    }
    function handleCData(text, getContext) {
      try {
        stack.peek().handleText(text);
      } catch (err) {
        handleWarning(err, getContext);
      }
    }
    function handleText(text, getContext) {
      // strip whitespace only nodes, i.e. before
      // <!CDATA[ ... ]> sections and in between tags

      if (!text.trim()) {
        return;
      }
      handleCData(text, getContext);
    }
    var uriMap = model.getPackages().reduce(function (uriMap, p) {
      uriMap[p.uri] = p.prefix;
      return uriMap;
    }, {
      'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns
    });

    parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {
      // gracefully handle unparsable attributes (attrs=false)
      var attrs = obj.attrs || {};
      var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {
        var value = decodeStr(attrs[key]);
        d[key] = value;
        return d;
      }, {});
      var node = {
        name: obj.name,
        originalName: obj.originalName,
        attributes: decodedAttrs,
        ns: obj.ns
      };
      handleOpen(node, getContext);
    }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities, getContext) {
      handleText(decodeEntities(text), getContext);
    }).on('error', handleError).on('warn', handleWarning);

    // async XML parsing to make sure the execution environment
    // (node or brower) is kept responsive and that certain optimization
    // strategies can kick in.
    return new Promise(function (resolve, reject) {
      var err;
      try {
        parser.parse(xml);
        resolveReferences();
      } catch (e) {
        err = e;
      }
      var rootElement = rootHandler.element;
      if (!err && !rootElement) {
        err = error$3('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');
      }
      var warnings = context.warnings;
      var references = context.references;
      var elementsById = context.elementsById;
      if (err) {
        err.warnings = warnings;
        return reject(err);
      } else {
        return resolve({
          rootElement: rootElement,
          elementsById: elementsById,
          references: references,
          warnings: warnings
        });
      }
    });
  };
  Reader.prototype.handler = function (name) {
    return new RootElementHandler(this.model, name);
  };

  // helpers //////////////////////////

  function createStack() {
    var stack = [];
    Object.defineProperty(stack, 'peek', {
      value: function value() {
        return this[this.length - 1];
      }
    });
    return stack;
  }
  var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';
  var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
  var ESCAPE_CHARS = /<|>|&/g;
  function Namespaces(parent) {
    var prefixMap = {};
    var uriMap = {};
    var used = {};
    var wellknown = [];
    var custom = [];

    // API

    this.byUri = function (uri) {
      return uriMap[uri] || parent && parent.byUri(uri);
    };
    this.add = function (ns, isWellknown) {
      uriMap[ns.uri] = ns;
      if (isWellknown) {
        wellknown.push(ns);
      } else {
        custom.push(ns);
      }
      this.mapPrefix(ns.prefix, ns.uri);
    };
    this.uriByPrefix = function (prefix) {
      return prefixMap[prefix || 'xmlns'];
    };
    this.mapPrefix = function (prefix, uri) {
      prefixMap[prefix || 'xmlns'] = uri;
    };
    this.getNSKey = function (ns) {
      return ns.prefix !== undefined ? ns.uri + '|' + ns.prefix : ns.uri;
    };
    this.logUsed = function (ns) {
      var uri = ns.uri;
      var nsKey = this.getNSKey(ns);
      used[nsKey] = this.byUri(uri);

      // Inform parent recursively about the usage of this NS
      if (parent) {
        parent.logUsed(ns);
      }
    };
    this.getUsed = function (ns) {
      function isUsed(ns) {
        var nsKey = self.getNSKey(ns);
        return used[nsKey];
      }
      var self = this;
      var allNs = [].concat(wellknown, custom);
      return allNs.filter(isUsed);
    };
  }
  function lower(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  }
  function nameToAlias(name, pkg) {
    if (hasLowerCaseAlias(pkg)) {
      return lower(name);
    } else {
      return name;
    }
  }
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }
  function nsName(ns) {
    if (isString$1(ns)) {
      return ns;
    } else {
      return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
    }
  }
  function getNsAttrs(namespaces) {
    return namespaces.getUsed().filter(function (ns) {
      // do not serialize built in <xml> namespace
      return ns.prefix !== 'xml';
    }).map(function (ns) {
      var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
      return {
        name: name,
        value: ns.uri
      };
    });
  }
  function getElementNs(ns, descriptor) {
    if (descriptor.isGeneric) {
      return assign$1({
        localName: descriptor.ns.localName
      }, ns);
    } else {
      return assign$1({
        localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)
      }, ns);
    }
  }
  function getPropertyNs(ns, descriptor) {
    return assign$1({
      localName: descriptor.ns.localName
    }, ns);
  }
  function getSerializableProperties(element) {
    var descriptor = element.$descriptor;
    return filter$1(descriptor.properties, function (p) {
      var name = p.name;
      if (p.isVirtual) {
        return false;
      }

      // do not serialize defaults
      if (!has$1(element, name)) {
        return false;
      }
      var value = element[name];

      // do not serialize default equals
      if (value === p["default"]) {
        return false;
      }

      // do not serialize null properties
      if (value === null) {
        return false;
      }
      return p.isMany ? value.length : true;
    });
  }
  var ESCAPE_ATTR_MAP = {
    '\n': '#10',
    '\n\r': '#10',
    '"': '#34',
    '\'': '#39',
    '<': '#60',
    '>': '#62',
    '&': '#38'
  };
  var ESCAPE_MAP = {
    '<': 'lt',
    '>': 'gt',
    '&': 'amp'
  };
  function escape$1(str, charPattern, replaceMap) {
    // ensure we are handling strings here
    str = isString$1(str) ? str : '' + str;
    return str.replace(charPattern, function (s) {
      return '&' + replaceMap[s] + ';';
    });
  }

  /**
   * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
   *
   * @param {String} str the string to escape
   * @return {String} the escaped string
   */
  function escapeAttr(str) {
    return escape$1(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
  }
  function escapeBody(str) {
    return escape$1(str, ESCAPE_CHARS, ESCAPE_MAP);
  }
  function filterAttributes(props) {
    return filter$1(props, function (p) {
      return p.isAttr;
    });
  }
  function filterContained(props) {
    return filter$1(props, function (p) {
      return !p.isAttr;
    });
  }
  function ReferenceSerializer(tagName) {
    this.tagName = tagName;
  }
  ReferenceSerializer.prototype.build = function (element) {
    this.element = element;
    return this;
  };
  ReferenceSerializer.prototype.serializeTo = function (writer) {
    writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();
  };
  function BodySerializer() {}
  BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {
    writer.append(this.escape ? escapeBody(this.value) : this.value);
  };
  BodySerializer.prototype.build = function (prop, value) {
    this.value = value;
    if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
      this.escape = true;
    }
    return this;
  };
  function ValueSerializer(tagName) {
    this.tagName = tagName;
  }
  inherits(ValueSerializer, BodySerializer);
  ValueSerializer.prototype.serializeTo = function (writer) {
    writer.appendIndent().append('<' + this.tagName + '>');
    this.serializeValue(writer);
    writer.append('</' + this.tagName + '>').appendNewLine();
  };
  function ElementSerializer(parent, propertyDescriptor) {
    this.body = [];
    this.attrs = [];
    this.parent = parent;
    this.propertyDescriptor = propertyDescriptor;
  }
  ElementSerializer.prototype.build = function (element) {
    this.element = element;
    var elementDescriptor = element.$descriptor,
      propertyDescriptor = this.propertyDescriptor;
    var otherAttrs, properties;
    var isGeneric = elementDescriptor.isGeneric;
    if (isGeneric) {
      otherAttrs = this.parseGeneric(element);
    } else {
      otherAttrs = this.parseNsAttributes(element);
    }
    if (propertyDescriptor) {
      this.ns = this.nsPropertyTagName(propertyDescriptor);
    } else {
      this.ns = this.nsTagName(elementDescriptor);
    }

    // compute tag name
    this.tagName = this.addTagName(this.ns);
    if (!isGeneric) {
      properties = getSerializableProperties(element);
      this.parseAttributes(filterAttributes(properties));
      this.parseContainments(filterContained(properties));
    }
    this.parseGenericAttributes(element, otherAttrs);
    return this;
  };
  ElementSerializer.prototype.nsTagName = function (descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getElementNs(effectiveNs, descriptor);
  };
  ElementSerializer.prototype.nsPropertyTagName = function (descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getPropertyNs(effectiveNs, descriptor);
  };
  ElementSerializer.prototype.isLocalNs = function (ns) {
    return ns.uri === this.ns.uri;
  };

  /**
   * Get the actual ns attribute name for the given element.
   *
   * @param {Object} element
   * @param {Boolean} [element.inherited=false]
   *
   * @return {Object} nsName
   */
  ElementSerializer.prototype.nsAttributeName = function (element) {
    var ns;
    if (isString$1(element)) {
      ns = parseName$1(element);
    } else {
      ns = element.ns;
    }

    // return just local name for inherited attributes
    if (element.inherited) {
      return {
        localName: ns.localName
      };
    }

    // parse + log effective ns
    var effectiveNs = this.logNamespaceUsed(ns);

    // LOG ACTUAL namespace use
    this.getNamespaces().logUsed(effectiveNs);

    // strip prefix if same namespace like parent
    if (this.isLocalNs(effectiveNs)) {
      return {
        localName: ns.localName
      };
    } else {
      return assign$1({
        localName: ns.localName
      }, effectiveNs);
    }
  };
  ElementSerializer.prototype.parseGeneric = function (element) {
    var self = this,
      body = this.body;
    var attributes = [];
    forEach$1(element, function (val, key) {
      var nonNsAttr;
      if (key === '$body') {
        body.push(new BodySerializer().build({
          type: 'String'
        }, val));
      } else if (key === '$children') {
        forEach$1(val, function (child) {
          body.push(new ElementSerializer(self).build(child));
        });
      } else if (key.indexOf('$') !== 0) {
        nonNsAttr = self.parseNsAttribute(element, key, val);
        if (nonNsAttr) {
          attributes.push({
            name: key,
            value: val
          });
        }
      }
    });
    return attributes;
  };
  ElementSerializer.prototype.parseNsAttribute = function (element, name, value) {
    var model = element.$model;
    var nameNs = parseName$1(name);
    var ns;

    // parse xmlns:foo="http://foo.bar"
    if (nameNs.prefix === 'xmlns') {
      ns = {
        prefix: nameNs.localName,
        uri: value
      };
    }

    // parse xmlns="http://foo.bar"
    if (!nameNs.prefix && nameNs.localName === 'xmlns') {
      ns = {
        uri: value
      };
    }
    if (!ns) {
      return {
        name: name,
        value: value
      };
    }
    if (model && model.getPackage(value)) {
      // register well known namespace
      this.logNamespace(ns, true, true);
    } else {
      // log custom namespace directly as used
      var actualNs = this.logNamespaceUsed(ns, true);
      this.getNamespaces().logUsed(actualNs);
    }
  };

  /**
   * Parse namespaces and return a list of left over generic attributes
   *
   * @param  {Object} element
   * @return {Array<Object>}
   */
  ElementSerializer.prototype.parseNsAttributes = function (element, attrs) {
    var self = this;
    var genericAttrs = element.$attrs;
    var attributes = [];

    // parse namespace attributes first
    // and log them. push non namespace attributes to a list
    // and process them later
    forEach$1(genericAttrs, function (value, name) {
      var nonNsAttr = self.parseNsAttribute(element, name, value);
      if (nonNsAttr) {
        attributes.push(nonNsAttr);
      }
    });
    return attributes;
  };
  ElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {
    var self = this;
    forEach$1(attributes, function (attr) {
      // do not serialize xsi:type attribute
      // it is set manually based on the actual implementation type
      if (attr.name === XSI_TYPE) {
        return;
      }
      try {
        self.addAttribute(self.nsAttributeName(attr.name), attr.value);
      } catch (e) {
        console.warn('missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);
      }
    });
  };
  ElementSerializer.prototype.parseContainments = function (properties) {
    var self = this,
      body = this.body,
      element = this.element;
    forEach$1(properties, function (p) {
      var value = element.get(p.name),
        isReference = p.isReference,
        isMany = p.isMany;
      if (!isMany) {
        value = [value];
      }
      if (p.isBody) {
        body.push(new BodySerializer().build(p, value[0]));
      } else if (isSimple(p.type)) {
        forEach$1(value, function (v) {
          body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));
        });
      } else if (isReference) {
        forEach$1(value, function (v) {
          body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));
        });
      } else {
        // allow serialization via type
        // rather than element name
        var asType = serializeAsType(p),
          asProperty = serializeAsProperty(p);
        forEach$1(value, function (v) {
          var serializer;
          if (asType) {
            serializer = new TypeSerializer(self, p);
          } else if (asProperty) {
            serializer = new ElementSerializer(self, p);
          } else {
            serializer = new ElementSerializer(self);
          }
          body.push(serializer.build(v));
        });
      }
    });
  };
  ElementSerializer.prototype.getNamespaces = function (local) {
    var namespaces = this.namespaces,
      parent = this.parent,
      parentNamespaces;
    if (!namespaces) {
      parentNamespaces = parent && parent.getNamespaces();
      if (local || !parentNamespaces) {
        this.namespaces = namespaces = new Namespaces(parentNamespaces);
      } else {
        namespaces = parentNamespaces;
      }
    }
    return namespaces;
  };
  ElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {
    var namespaces = this.getNamespaces(local);
    var nsUri = ns.uri,
      nsPrefix = ns.prefix;
    var existing = namespaces.byUri(nsUri);
    if (!existing || local) {
      namespaces.add(ns, wellknown);
    }
    namespaces.mapPrefix(nsPrefix, nsUri);
    return ns;
  };
  ElementSerializer.prototype.logNamespaceUsed = function (ns, local) {
    var element = this.element,
      model = element.$model,
      namespaces = this.getNamespaces(local);

    // ns may be
    //
    //   * prefix only
    //   * prefix:uri
    //   * localName only

    var prefix = ns.prefix,
      uri = ns.uri,
      newPrefix,
      idx,
      wellknownUri;

    // handle anonymous namespaces (elementForm=unqualified), cf. #23
    if (!prefix && !uri) {
      return {
        localName: ns.localName
      };
    }
    wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;
    uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);
    if (!uri) {
      throw new Error('no namespace uri given for prefix <' + prefix + '>');
    }
    ns = namespaces.byUri(uri);
    if (!ns) {
      newPrefix = prefix;
      idx = 1;

      // find a prefix that is not mapped yet
      while (namespaces.uriByPrefix(newPrefix)) {
        newPrefix = prefix + '_' + idx++;
      }
      ns = this.logNamespace({
        prefix: newPrefix,
        uri: uri
      }, wellknownUri === uri);
    }
    if (prefix) {
      namespaces.mapPrefix(prefix, uri);
    }
    return ns;
  };
  ElementSerializer.prototype.parseAttributes = function (properties) {
    var self = this,
      element = this.element;
    forEach$1(properties, function (p) {
      var value = element.get(p.name);
      if (p.isReference) {
        if (!p.isMany) {
          value = value.id;
        } else {
          var values = [];
          forEach$1(value, function (v) {
            values.push(v.id);
          });

          // IDREFS is a whitespace-separated list of references.
          value = values.join(' ');
        }
      }
      self.addAttribute(self.nsAttributeName(p), value);
    });
  };
  ElementSerializer.prototype.addTagName = function (nsTagName) {
    var actualNs = this.logNamespaceUsed(nsTagName);
    this.getNamespaces().logUsed(actualNs);
    return nsName(nsTagName);
  };
  ElementSerializer.prototype.addAttribute = function (name, value) {
    var attrs = this.attrs;
    if (isString$1(value)) {
      value = escapeAttr(value);
    }

    // de-duplicate attributes
    // https://github.com/bpmn-io/moddle-xml/issues/66
    var idx = findIndex(attrs, function (element) {
      return element.name.localName === name.localName && element.name.uri === name.uri && element.name.prefix === name.prefix;
    });
    var attr = {
      name: name,
      value: value
    };
    if (idx !== -1) {
      attrs.splice(idx, 1, attr);
    } else {
      attrs.push(attr);
    }
  };
  ElementSerializer.prototype.serializeAttributes = function (writer) {
    var attrs = this.attrs,
      namespaces = this.namespaces;
    if (namespaces) {
      attrs = getNsAttrs(namespaces).concat(attrs);
    }
    forEach$1(attrs, function (a) {
      writer.append(' ').append(nsName(a.name)).append('="').append(a.value).append('"');
    });
  };
  ElementSerializer.prototype.serializeTo = function (writer) {
    var firstBody = this.body[0],
      indent = firstBody && firstBody.constructor !== BodySerializer;
    writer.appendIndent().append('<' + this.tagName);
    this.serializeAttributes(writer);
    writer.append(firstBody ? '>' : ' />');
    if (firstBody) {
      if (indent) {
        writer.appendNewLine().indent();
      }
      forEach$1(this.body, function (b) {
        b.serializeTo(writer);
      });
      if (indent) {
        writer.unindent().appendIndent();
      }
      writer.append('</' + this.tagName + '>');
    }
    writer.appendNewLine();
  };

  /**
   * A serializer for types that handles serialization of data types
   */
  function TypeSerializer(parent, propertyDescriptor) {
    ElementSerializer.call(this, parent, propertyDescriptor);
  }
  inherits(TypeSerializer, ElementSerializer);
  TypeSerializer.prototype.parseNsAttributes = function (element) {
    // extracted attributes
    var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);
    var descriptor = element.$descriptor;

    // only serialize xsi:type if necessary
    if (descriptor.name === this.propertyDescriptor.type) {
      return attributes;
    }
    var typeNs = this.typeNs = this.nsTagName(descriptor);
    this.getNamespaces().logUsed(this.typeNs);

    // add xsi:type attribute to represent the elements
    // actual type

    var pkg = element.$model.getPackage(typeNs.uri),
      typePrefix = pkg.xml && pkg.xml.typePrefix || '';
    this.addAttribute(this.nsAttributeName(XSI_TYPE), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);
    return attributes;
  };
  TypeSerializer.prototype.isLocalNs = function (ns) {
    return ns.uri === (this.typeNs || this.ns).uri;
  };
  function SavingWriter() {
    this.value = '';
    this.write = function (str) {
      this.value += str;
    };
  }
  function FormatingWriter(out, format) {
    var indent = [''];
    this.append = function (str) {
      out.write(str);
      return this;
    };
    this.appendNewLine = function () {
      if (format) {
        out.write('\n');
      }
      return this;
    };
    this.appendIndent = function () {
      if (format) {
        out.write(indent.join('  '));
      }
      return this;
    };
    this.indent = function () {
      indent.push('');
      return this;
    };
    this.unindent = function () {
      indent.pop();
      return this;
    };
  }

  /**
   * A writer for meta-model backed document trees
   *
   * @param {Object} options output options to pass into the writer
   */
  function Writer(options) {
    options = assign$1({
      format: false,
      preamble: true
    }, options || {});
    function toXML(tree, writer) {
      var internalWriter = writer || new SavingWriter();
      var formatingWriter = new FormatingWriter(internalWriter, options.format);
      if (options.preamble) {
        formatingWriter.append(XML_PREAMBLE);
      }
      new ElementSerializer().build(tree).serializeTo(formatingWriter);
      if (!writer) {
        return internalWriter.value;
      }
    }
    return {
      toXML: toXML
    };
  }

  /**
   * A sub class of {@link Moddle} with support for import and export of DMN xml files.
   *
   * @class DmnModdle
   * @extends Moddle
   *
   * @param {Object|Array} packages to use for instantiating the model
   * @param {Object} [options] additional options to pass over
   */
  function DmnModdle(packages, options) {
    Moddle.call(this, packages, options);
  }
  DmnModdle.prototype = Object.create(Moddle.prototype);

  /**
   * The fromXML result.
   *
   * @typedef {Object} ParseResult
   *
   * @property {ModdleElement} rootElement
   * @property {Array<Object>} references
   * @property {Array<Error>} warnings
   * @property {Object} elementsById - a mapping containing each ID -> ModdleElement
   */

  /**
   * The fromXML error.
   *
   * @typedef {Error} ParseError
   *
   * @property {Array<Error>} warnings
   */

  /**
   * Instantiates a DMN model tree from a given xml string.
   *
   * @param {String}   xmlStr
   * @param {String}   [typeName='dmn:Definitions'] name of the root element
   * @param {Object}   [options]  options to pass to the underlying reader
   *
   * @returns {Promise<ParseResult, ParseError>}
   */
  DmnModdle.prototype.fromXML = function (xmlStr, typeName, options) {
    if (!isString$3(typeName)) {
      options = typeName;
      typeName = 'dmn:Definitions';
    }
    var reader = new Reader(assign$3({
      model: this,
      lax: true
    }, options));
    var rootHandler = reader.handler(typeName);
    return reader.fromXML(xmlStr, rootHandler);
  };

  /**
   * The toXML result.
   *
   * @typedef {Object} SerializationResult
   *
   * @property {String} xml
   */

  /**
   * Serializes a DMN object tree to XML.
   *
   * @param {String}   element    the root element, typically an instance of `Definitions`
   * @param {Object}   [options]  to pass to the underlying writer
   *
   * @returns {Promise<SerializationResult, Error>}
   */
  DmnModdle.prototype.toXML = function (element, options) {
    var writer = new Writer(options);
    return new Promise(function (resolve, reject) {
      try {
        var result = writer.toXML(element);
        return resolve({
          xml: result
        });
      } catch (err) {
        return reject(err);
      }
    });
  };
  var name$4 = "DC";
  var prefix$4 = "dc";
  var uri$4 = "http://www.omg.org/spec/DMN/20180521/DC/";
  var types$4 = [{
    name: "Dimension",
    properties: [{
      name: "width",
      isAttr: true,
      type: "Real"
    }, {
      name: "height",
      isAttr: true,
      type: "Real"
    }]
  }, {
    name: "Bounds",
    properties: [{
      name: "height",
      isAttr: true,
      type: "Real"
    }, {
      name: "width",
      isAttr: true,
      type: "Real"
    }, {
      name: "x",
      isAttr: true,
      type: "Real"
    }, {
      name: "y",
      isAttr: true,
      type: "Real"
    }]
  }, {
    name: "Point",
    properties: [{
      name: "x",
      isAttr: true,
      type: "Real"
    }, {
      name: "y",
      isAttr: true,
      type: "Real"
    }]
  }, {
    name: "Color",
    properties: [{
      name: "red",
      type: "UML_Standard_Profile.mdzip:eee_1045467100323_917313_65"
    }, {
      name: "green",
      type: "UML_Standard_Profile.mdzip:eee_1045467100323_917313_65"
    }, {
      name: "blue",
      type: "UML_Standard_Profile.mdzip:eee_1045467100323_917313_65"
    }]
  }];
  var associations$3 = [];
  var enumerations$3 = [{
    name: "AlignmentKind",
    literalValues: [{
      name: "start"
    }, {
      name: "center"
    }, {
      name: "end"
    }]
  }];
  var DcPackage = {
    name: name$4,
    prefix: prefix$4,
    uri: uri$4,
    types: types$4,
    associations: associations$3,
    enumerations: enumerations$3
  };
  var name$3 = "DI";
  var prefix$3 = "di";
  var uri$3 = "http://www.omg.org/spec/DMN/20180521/DI/";
  var types$3 = [{
    name: "DiagramElement",
    isAbstract: true,
    properties: [{
      name: "extension",
      type: "Extension"
    }, {
      name: "id",
      isAttr: true,
      isId: true,
      type: "String"
    }, {
      name: "style",
      isReference: true,
      type: "Style",
      xml: {
        serialize: "property"
      }
    }, {
      name: "sharedStyle",
      isReference: true,
      isVirtual: true,
      type: "Style"
    }]
  }, {
    name: "Diagram",
    superClass: ["DiagramElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "documentation",
      isAttr: true,
      type: "String"
    }, {
      name: "resolution",
      isAttr: true,
      type: "Real"
    }]
  }, {
    name: "Shape",
    isAbstract: true,
    properties: [{
      name: "bounds",
      type: "dc:Bounds"
    }],
    superClass: ["DiagramElement"]
  }, {
    name: "Edge",
    isAbstract: true,
    properties: [{
      name: "waypoint",
      type: "dc:Point",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }],
    superClass: ["DiagramElement"]
  }, {
    name: "Style",
    isAbstract: true,
    properties: [{
      name: "id",
      isAttr: true,
      isId: true,
      type: "String"
    }]
  }, {
    name: "Extension",
    properties: [{
      name: "values",
      isMany: true,
      type: "Element"
    }]
  }];
  var associations$2 = [];
  var enumerations$2 = [];
  var xml$2 = {
    tagAlias: "lowerCase"
  };
  var DiPackage = {
    name: name$3,
    prefix: prefix$3,
    uri: uri$3,
    types: types$3,
    associations: associations$2,
    enumerations: enumerations$2,
    xml: xml$2
  };
  var name$2 = "DMN";
  var prefix$2 = "dmn";
  var uri$2 = "https://www.omg.org/spec/DMN/20191111/MODEL/";
  var types$2 = [{
    name: "AuthorityRequirement",
    superClass: ["DMNElement"],
    properties: [{
      name: "requiredAuthority",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "requiredDecision",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "requiredInput",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "ItemDefinition",
    superClass: ["NamedElement"],
    properties: [{
      name: "typeRef",
      type: "String"
    }, {
      name: "allowedValues",
      type: "UnaryTests",
      xml: {
        serialize: "property"
      }
    }, {
      name: "typeLanguage",
      type: "String",
      isAttr: true
    }, {
      name: "itemComponent",
      type: "ItemDefinition",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "functionItem",
      type: "FunctionItem"
    }, {
      name: "isCollection",
      isAttr: true,
      type: "Boolean"
    }]
  }, {
    name: "Definitions",
    superClass: ["NamedElement"],
    properties: [{
      name: "import",
      type: "Import",
      isMany: true
    }, {
      name: "itemDefinition",
      type: "ItemDefinition",
      isMany: true
    }, {
      name: "drgElement",
      type: "DRGElement",
      isMany: true
    }, {
      name: "artifact",
      type: "Artifact",
      isMany: true
    }, {
      name: "elementCollection",
      type: "ElementCollection",
      isMany: true
    }, {
      name: "businessContextElement",
      type: "BusinessContextElement",
      isMany: true
    }, {
      name: "namespace",
      type: "String",
      isAttr: true
    }, {
      name: "expressionLanguage",
      type: "String",
      isAttr: true
    }, {
      name: "typeLanguage",
      type: "String",
      isAttr: true
    }, {
      name: "exporter",
      isAttr: true,
      type: "String"
    }, {
      name: "exporterVersion",
      isAttr: true,
      type: "String"
    }, {
      name: "dmnDI",
      type: "dmndi:DMNDI"
    }]
  }, {
    name: "KnowledgeSource",
    superClass: ["DRGElement"],
    properties: [{
      name: "authorityRequirement",
      type: "AuthorityRequirement",
      isMany: true
    }, {
      name: "type",
      type: "String"
    }, {
      name: "owner",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "locationURI",
      type: "String",
      isAttr: true
    }]
  }, {
    name: "DecisionRule",
    superClass: ["DMNElement"],
    properties: [{
      name: "inputEntry",
      type: "UnaryTests",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "outputEntry",
      type: "LiteralExpression",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "annotationEntry",
      type: "RuleAnnotation",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "Expression",
    isAbstract: true,
    superClass: ["DMNElement"],
    properties: [{
      name: "typeRef",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "InformationItem",
    superClass: ["NamedElement"],
    properties: [{
      name: "typeRef",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Decision",
    superClass: ["DRGElement"],
    properties: [{
      name: "question",
      type: "String",
      xml: {
        serialize: "property"
      }
    }, {
      name: "allowedAnswers",
      type: "String",
      xml: {
        serialize: "property"
      }
    }, {
      name: "variable",
      type: "InformationItem",
      xml: {
        serialize: "property"
      }
    }, {
      name: "informationRequirement",
      type: "InformationRequirement",
      isMany: true
    }, {
      name: "knowledgeRequirement",
      type: "KnowledgeRequirement",
      isMany: true
    }, {
      name: "authorityRequirement",
      type: "AuthorityRequirement",
      isMany: true
    }, {
      name: "supportedObjective",
      isMany: true,
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "impactedPerformanceIndicator",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "decisionMaker",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "decisionOwner",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "usingProcess",
      isMany: true,
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "usingTask",
      isMany: true,
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "decisionLogic",
      type: "Expression"
    }]
  }, {
    name: "Invocation",
    superClass: ["Expression"],
    properties: [{
      name: "calledFunction",
      type: "Expression"
    }, {
      name: "binding",
      type: "Binding",
      isMany: true
    }]
  }, {
    name: "OrganisationalUnit",
    superClass: ["BusinessContextElement"],
    properties: [{
      name: "decisionMade",
      type: "Decision",
      isReference: true,
      isMany: true
    }, {
      name: "decisionOwned",
      type: "Decision",
      isReference: true,
      isMany: true
    }]
  }, {
    name: "Import",
    superClass: ["NamedElement"],
    properties: [{
      name: "importType",
      type: "String",
      isAttr: true
    }, {
      name: "locationURI",
      type: "String",
      isAttr: true
    }, {
      name: "namespace",
      type: "String",
      isAttr: true
    }]
  }, {
    name: "InformationRequirement",
    superClass: ["DMNElement"],
    properties: [{
      name: "requiredDecision",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "requiredInput",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "ElementCollection",
    superClass: ["NamedElement"],
    properties: [{
      name: "drgElement",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "DRGElement",
    isAbstract: true,
    superClass: ["NamedElement"],
    properties: []
  }, {
    name: "InputData",
    superClass: ["DRGElement"],
    properties: [{
      name: "variable",
      type: "InformationItem",
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "DMNElement",
    isAbstract: true,
    properties: [{
      name: "description",
      type: "String"
    }, {
      name: "extensionElements",
      type: "ExtensionElements"
    }, {
      name: "id",
      type: "String",
      isAttr: true,
      isId: true
    }, {
      name: "extensionAttribute",
      type: "ExtensionAttribute",
      isMany: true
    }, {
      name: "label",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "InputClause",
    superClass: ["DMNElement"],
    properties: [{
      name: "inputExpression",
      type: "LiteralExpression",
      xml: {
        serialize: "property"
      }
    }, {
      name: "inputValues",
      type: "UnaryTests",
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "DecisionTable",
    superClass: ["Expression"],
    properties: [{
      name: "input",
      type: "InputClause",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "output",
      type: "OutputClause",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "annotation",
      type: "RuleAnnotationClause",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "rule",
      type: "DecisionRule",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "hitPolicy",
      type: "HitPolicy",
      isAttr: true,
      "default": "UNIQUE"
    }, {
      name: "aggregation",
      type: "BuiltinAggregator",
      isAttr: true
    }, {
      name: "preferredOrientation",
      type: "DecisionTableOrientation",
      isAttr: true
    }, {
      name: "outputLabel",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "LiteralExpression",
    superClass: ["Expression"],
    properties: [{
      name: "expressionLanguage",
      type: "String",
      isAttr: true
    }, {
      name: "text",
      type: "String"
    }, {
      name: "importedValues",
      type: "ImportedValues"
    }]
  }, {
    name: "Binding",
    properties: [{
      name: "parameter",
      type: "InformationItem",
      xml: {
        serialize: "property"
      }
    }, {
      name: "bindingFormula",
      type: "Expression"
    }]
  }, {
    name: "KnowledgeRequirement",
    superClass: ["DMNElement"],
    properties: [{
      name: "requiredKnowledge",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "BusinessKnowledgeModel",
    superClass: ["Invocable"],
    properties: [{
      name: "encapsulatedLogic",
      type: "FunctionDefinition",
      xml: {
        serialize: "property"
      }
    }, {
      name: "knowledgeRequirement",
      type: "KnowledgeRequirement",
      isMany: true
    }, {
      name: "authorityRequirement",
      type: "AuthorityRequirement",
      isMany: true
    }]
  }, {
    name: "BusinessContextElement",
    isAbstract: true,
    superClass: ["NamedElement"],
    properties: [{
      name: "URI",
      type: "String",
      isAttr: true
    }]
  }, {
    name: "PerformanceIndicator",
    superClass: ["BusinessContextElement"],
    properties: [{
      name: "impactingDecision",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "FunctionDefinition",
    superClass: ["Expression"],
    properties: [{
      name: "formalParameter",
      type: "InformationItem",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "body",
      type: "Expression"
    }, {
      name: "kind",
      type: "FunctionKind",
      isAttr: true
    }]
  }, {
    name: "Context",
    superClass: ["Expression"],
    properties: [{
      name: "contextEntry",
      type: "ContextEntry",
      isMany: true
    }]
  }, {
    name: "ContextEntry",
    superClass: ["DMNElement"],
    properties: [{
      name: "variable",
      type: "InformationItem",
      xml: {
        serialize: "property"
      }
    }, {
      name: "value",
      type: "Expression"
    }]
  }, {
    name: "List",
    superClass: ["Expression"],
    properties: [{
      name: "elements",
      isMany: true,
      type: "Expression"
    }]
  }, {
    name: "Relation",
    superClass: ["Expression"],
    properties: [{
      name: "column",
      type: "InformationItem",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "row",
      type: "List",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "OutputClause",
    superClass: ["DMNElement"],
    properties: [{
      name: "outputValues",
      type: "UnaryTests",
      xml: {
        serialize: "property"
      }
    }, {
      name: "defaultOutputEntry",
      type: "LiteralExpression",
      xml: {
        serialize: "property"
      }
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "typeRef",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "UnaryTests",
    superClass: ["Expression"],
    properties: [{
      name: "text",
      type: "String"
    }, {
      name: "expressionLanguage",
      type: "String",
      isAttr: true
    }]
  }, {
    name: "NamedElement",
    isAbstract: true,
    superClass: ["DMNElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ImportedValues",
    superClass: ["Import"],
    properties: [{
      name: "importedElement",
      type: "String"
    }, {
      name: "expressionLanguage",
      type: "String",
      isAttr: true
    }]
  }, {
    name: "DecisionService",
    superClass: ["Invocable"],
    properties: [{
      name: "outputDecision",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "encapsulatedDecision",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "inputDecision",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }, {
      name: "inputData",
      type: "DMNElementReference",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "ExtensionElements",
    properties: [{
      name: "values",
      type: "Element",
      isMany: true
    }]
  }, {
    name: "ExtensionAttribute",
    properties: [{
      name: "value",
      type: "Element"
    }, {
      name: "valueRef",
      type: "Element",
      isAttr: true,
      isReference: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Element",
    isAbstract: true,
    properties: [{
      name: "extensionAttribute",
      type: "ExtensionAttribute",
      isAttr: true,
      isReference: true
    }, {
      name: "elements",
      type: "ExtensionElements",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Artifact",
    isAbstract: true,
    superClass: ["DMNElement"],
    properties: []
  }, {
    name: "Association",
    superClass: ["Artifact"],
    properties: [{
      name: "sourceRef",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "targetRef",
      type: "DMNElementReference",
      xml: {
        serialize: "property"
      }
    }, {
      name: "associationDirection",
      type: "AssociationDirection",
      isAttr: true
    }]
  }, {
    name: "TextAnnotation",
    superClass: ["Artifact"],
    properties: [{
      name: "text",
      type: "String"
    }, {
      name: "textFormat",
      isAttr: true,
      type: "String",
      "default": "text/plain"
    }]
  }, {
    name: "RuleAnnotationClause",
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "RuleAnnotation",
    properties: [{
      name: "text",
      type: "String"
    }]
  }, {
    name: "Invocable",
    isAbstract: true,
    superClass: ["DRGElement"],
    properties: [{
      name: "variable",
      type: "InformationItem",
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "Group",
    superClass: ["Artifact"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "FunctionItem",
    superClass: ["DMNElement"],
    properties: [{
      name: "parameters",
      isMany: true,
      type: "InformationItem",
      xml: {
        serialize: "property"
      }
    }, {
      name: "outputTypeRef",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "DMNElementReference",
    properties: [{
      isAttr: true,
      name: "href",
      type: "String"
    }]
  }];
  var enumerations$1 = [{
    name: "HitPolicy",
    literalValues: [{
      name: "UNIQUE"
    }, {
      name: "FIRST"
    }, {
      name: "PRIORITY"
    }, {
      name: "ANY"
    }, {
      name: "COLLECT"
    }, {
      name: "RULE ORDER"
    }, {
      name: "OUTPUT ORDER"
    }]
  }, {
    name: "BuiltinAggregator",
    literalValues: [{
      name: "SUM"
    }, {
      name: "COUNT"
    }, {
      name: "MIN"
    }, {
      name: "MAX"
    }]
  }, {
    name: "DecisionTableOrientation",
    literalValues: [{
      name: "Rule-as-Row"
    }, {
      name: "Rule-as-Column"
    }, {
      name: "CrossTable"
    }]
  }, {
    name: "AssociationDirection",
    literalValues: [{
      name: "None"
    }, {
      name: "One"
    }, {
      name: "Both"
    }]
  }, {
    name: "FunctionKind",
    literalValues: [{
      name: "FEEL"
    }, {
      name: "Java"
    }, {
      name: "PMML"
    }]
  }];
  var associations$1 = [];
  var xml$1 = {
    tagAlias: "lowerCase"
  };
  var DmnPackage = {
    name: name$2,
    prefix: prefix$2,
    uri: uri$2,
    types: types$2,
    enumerations: enumerations$1,
    associations: associations$1,
    xml: xml$1
  };
  var name$1$1 = "DMNDI";
  var prefix$1 = "dmndi";
  var uri$1 = "https://www.omg.org/spec/DMN/20191111/DMNDI/";
  var types$1$1 = [{
    name: "DMNDI",
    properties: [{
      name: "diagrams",
      type: "DMNDiagram",
      isMany: true
    }, {
      name: "styles",
      type: "DMNStyle",
      isMany: true
    }]
  }, {
    name: "DMNStyle",
    superClass: ["di:Style"],
    properties: [{
      name: "fillColor",
      type: "dc:Color",
      isAttr: true
    }, {
      name: "strokeColor",
      type: "dc:Color",
      isAttr: true
    }, {
      name: "fontColor",
      type: "dc:Color",
      isAttr: true
    }, {
      name: "fontSize",
      isAttr: true,
      type: "Real"
    }, {
      name: "fontFamily",
      isAttr: true,
      type: "String"
    }, {
      name: "fontItalic",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "fontBold",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "fontUnderline",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "fontStrikeThrough",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "labelHorizontalAlignment",
      type: "dc:AlignmentKind",
      isAttr: true
    }, {
      name: "labelVerticalAlignment",
      type: "dc:AlignmentKind",
      isAttr: true
    }]
  }, {
    name: "DMNDiagram",
    superClass: ["di:Diagram"],
    properties: [{
      name: "dmnElementRef",
      type: "dmn:DMNElement",
      isAttr: true,
      isReference: true
    }, {
      name: "size",
      type: "Size"
    }, {
      name: "localStyle",
      type: "DMNStyle",
      isVirtual: true
    }, {
      name: "sharedStyle",
      type: "DMNStyle",
      isVirtual: true,
      isReference: true,
      redefines: "di:DiagramElement#sharedStyle"
    }, {
      name: "diagramElements",
      type: "DMNDiagramElement",
      isMany: true
    }]
  }, {
    name: "DMNDiagramElement",
    isAbstract: true,
    superClass: ["di:DiagramElement"],
    properties: [{
      name: "dmnElementRef",
      type: "dmn:DMNElement",
      isAttr: true,
      isReference: true
    }, {
      name: "sharedStyle",
      type: "DMNStyle",
      isVirtual: true,
      isReference: true,
      redefines: "di:DiagramElement#sharedStyle"
    }, {
      name: "localStyle",
      type: "DMNStyle",
      isVirtual: true
    }, {
      name: "label",
      type: "DMNLabel"
    }]
  }, {
    name: "DMNLabel",
    superClass: ["di:Shape"],
    properties: [{
      name: "text",
      type: "Text"
    }]
  }, {
    name: "DMNShape",
    superClass: ["di:Shape", "DMNDiagramElement"],
    properties: [{
      name: "isListedInputData",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "decisionServiceDividerLine",
      type: "DMNDecisionServiceDividerLine"
    }, {
      name: "isCollapsed",
      isAttr: true,
      type: "Boolean"
    }]
  }, {
    name: "DMNEdge",
    superClass: ["di:Edge", "DMNDiagramElement"],
    properties: [{
      name: "sourceElement",
      type: "DMNDiagramElement",
      isAttr: true,
      isReference: true
    }, {
      name: "targetElement",
      type: "DMNDiagramElement",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "DMNDecisionServiceDividerLine",
    superClass: ["di:Edge"]
  }, {
    name: "Text",
    properties: [{
      name: "text",
      isBody: true,
      type: "String"
    }]
  }, {
    name: "Size",
    superClass: ["dc:Dimension"]
  }];
  var associations = [];
  var enumerations = [];
  var DmnDiPackage = {
    name: name$1$1,
    prefix: prefix$1,
    uri: uri$1,
    types: types$1$1,
    associations: associations,
    enumerations: enumerations
  };
  var name$5 = "bpmn.io DI for DMN";
  var uri = "http://bpmn.io/schema/dmn/biodi/2.0";
  var prefix$5 = "biodi";
  var xml = {
    tagAlias: "lowerCase"
  };
  var types$5 = [{
    name: "DecisionTable",
    isAbstract: true,
    "extends": ["dmn:DecisionTable"],
    properties: [{
      name: "annotationsWidth",
      isAttr: true,
      type: "Integer"
    }]
  }, {
    name: "OutputClause",
    isAbstract: true,
    "extends": ["dmn:OutputClause"],
    properties: [{
      name: "width",
      isAttr: true,
      type: "Integer"
    }]
  }, {
    name: "InputClause",
    isAbstract: true,
    "extends": ["dmn:InputClause"],
    properties: [{
      name: "width",
      isAttr: true,
      type: "Integer"
    }]
  }];
  var BioDiPackage = {
    name: name$5,
    uri: uri,
    prefix: prefix$5,
    xml: xml,
    types: types$5
  };
  var packages = {
    dc: DcPackage,
    di: DiPackage,
    dmn: DmnPackage,
    dmndi: DmnDiPackage,
    biodi: BioDiPackage
  };
  function simple(additionalPackages, options) {
    var pks = assign$3({}, packages, additionalPackages);
    return new DmnModdle(pks, options);
  }

  function _mergeNamespaces$1(n, m) {
    m.forEach(function (e) {
      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
        if (k !== 'default' && !(k in n)) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function get() {
              return e[k];
            }
          });
        }
      });
    });
    return Object.freeze(n);
  }

  /**
   * Flatten array, one level deep.
   *
   * @param {Array<?>} arr
   *
   * @return {Array<?>}
   */

  var nativeToString = Object.prototype.toString;
  var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
  function isUndefined$1(obj) {
    return obj === undefined;
  }
  function isArray$3(obj) {
    return nativeToString.call(obj) === '[object Array]';
  }

  /**
   * Return true, if target owns a property with the given key.
   *
   * @param {Object} target
   * @param {String} key
   *
   * @return {Boolean}
   */
  function has(target, key) {
    return nativeHasOwnProperty.call(target, key);
  }

  /**
   * Iterate over collection; returning something
   * (non-undefined) will stop iteration.
   *
   * @param  {Array|Object} collection
   * @param  {Function} iterator
   *
   * @return {Object} return result that stopped the iteration
   */
  function forEach(collection, iterator) {
    var val, result;
    if (isUndefined$1(collection)) {
      return;
    }
    var convertKey = isArray$3(collection) ? toNum : identity;
    for (var key in collection) {
      if (has(collection, key)) {
        val = collection[key];
        result = iterator(val, convertKey(key));
        if (result === false) {
          return val;
        }
      }
    }
  }
  function identity(arg) {
    return arg;
  }
  function toNum(arg) {
    return Number(arg);
  }

  /**
   * Assigns style attributes in a style-src compliant way.
   *
   * @param {Element} element
   * @param {...Object} styleSources
   *
   * @return {Element} the element
   */
  function assign(element) {
    var target = element.style;
    for (var _len = arguments.length, styleSources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      styleSources[_key - 1] = arguments[_key];
    }
    forEach(styleSources, function (style) {
      if (!style) {
        return;
      }
      forEach(style, function (value, key) {
        target[key] = value;
      });
    });
    return element;
  }

  /**
   * Set attribute `name` to `val`, or get attr `name`.
   *
   * @param {Element} el
   * @param {String} name
   * @param {String} [val]
   * @api public
   */
  function attr$1(el, name, val) {
    // get
    if (arguments.length == 2) {
      return el.getAttribute(name);
    }

    // remove
    if (val === null) {
      return el.removeAttribute(name);
    }

    // set
    el.setAttribute(name, val);
    return el;
  }

  /**
   * Taken from https://github.com/component/classes
   *
   * Without the component bits.
   */

  /**
   * toString reference.
   */

  var toString$1 = Object.prototype.toString;

  /**
   * Wrap `el` in a `ClassList`.
   *
   * @param {Element} el
   * @return {ClassList}
   * @api public
   */

  function classes$1(el) {
    return new ClassList$1(el);
  }

  /**
   * Initialize a new ClassList for `el`.
   *
   * @param {Element} el
   * @api private
   */

  function ClassList$1(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }

  /**
   * Add class `name` if not already present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.add = function (name) {
    this.list.add(name);
    return this;
  };

  /**
   * Remove class `name` when present, or
   * pass a regular expression to remove
   * any which match.
   *
   * @param {String|RegExp} name
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.remove = function (name) {
    if ('[object RegExp]' == toString$1.call(name)) {
      return this.removeMatching(name);
    }
    this.list.remove(name);
    return this;
  };

  /**
   * Remove all classes matching `re`.
   *
   * @param {RegExp} re
   * @return {ClassList}
   * @api private
   */

  ClassList$1.prototype.removeMatching = function (re) {
    var arr = this.array();
    for (var i = 0; i < arr.length; i++) {
      if (re.test(arr[i])) {
        this.remove(arr[i]);
      }
    }
    return this;
  };

  /**
   * Toggle class `name`, can force state via `force`.
   *
   * For browsers that support classList, but do not support `force` yet,
   * the mistake will be detected and corrected.
   *
   * @param {String} name
   * @param {Boolean} force
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.toggle = function (name, force) {
    if ('undefined' !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  };

  /**
   * Return an array of classes.
   *
   * @return {Array}
   * @api public
   */

  ClassList$1.prototype.array = function () {
    return Array.from(this.list);
  };

  /**
   * Check if class `name` is present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.has = ClassList$1.prototype.contains = function (name) {
    return this.list.contains(name);
  };

  /**
   * Remove all children from the given element.
   */
  function clear$1(el) {
    var c;
    while (el.childNodes.length) {
      c = el.childNodes[0];
      el.removeChild(c);
    }
    return el;
  }

  /**
   * @param { HTMLElement } element
   * @param { String } selector
   *
   * @return { boolean }
   */
  function matches(element, selector) {
    return element && typeof element.matches === 'function' && element.matches(selector);
  }

  /**
   * Closest
   *
   * @param {Element} el
   * @param {String} selector
   * @param {Boolean} checkYourSelf (optional)
   */
  function closest(element, selector, checkYourSelf) {
    var currentElem = checkYourSelf ? element : element.parentNode;
    while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {
      if (matches(currentElem, selector)) {
        return currentElem;
      }
      currentElem = currentElem.parentNode;
    }
    return matches(currentElem, selector) ? currentElem : null;
  }
  var componentEvent = {};
  var bind$1, unbind$1, prefix;
  function detect() {
    bind$1 = window.addEventListener ? 'addEventListener' : 'attachEvent';
    unbind$1 = window.removeEventListener ? 'removeEventListener' : 'detachEvent';
    prefix = bind$1 !== 'addEventListener' ? 'on' : '';
  }

  /**
   * Bind `el` event `type` to `fn`.
   *
   * @param {Element} el
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @return {Function}
   * @api public
   */

  var bind_1 = componentEvent.bind = function (el, type, fn, capture) {
    if (!bind$1) detect();
    el[bind$1](prefix + type, fn, capture || false);
    return fn;
  };

  /**
   * Unbind `el` event `type`'s callback `fn`.
   *
   * @param {Element} el
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @return {Function}
   * @api public
   */

  var unbind_1 = componentEvent.unbind = function (el, type, fn, capture) {
    if (!unbind$1) detect();
    el[unbind$1](prefix + type, fn, capture || false);
    return fn;
  };
  var event = /*#__PURE__*/_mergeNamespaces$1({
    __proto__: null,
    bind: bind_1,
    unbind: unbind_1,
    'default': componentEvent
  }, [componentEvent]);

  /**
   * Module dependencies.
   */

  /**
   * Delegate event `type` to `selector`
   * and invoke `fn(e)`. A callback function
   * is returned which may be passed to `.unbind()`.
   *
   * @param {Element} el
   * @param {String} selector
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @return {Function}
   * @api public
   */

  // Some events don't bubble, so we want to bind to the capture phase instead
  // when delegating.
  var forceCaptureEvents = ['focus', 'blur'];
  function bind(el, selector, type, fn, capture) {
    if (forceCaptureEvents.indexOf(type) !== -1) {
      capture = true;
    }
    return event.bind(el, type, function (e) {
      var target = e.target || e.srcElement;
      e.delegateTarget = closest(target, selector, true);
      if (e.delegateTarget) {
        fn.call(el, e);
      }
    }, capture);
  }

  /**
   * Unbind event `type`'s callback `fn`.
   *
   * @param {Element} el
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @api public
   */
  function unbind(el, type, fn, capture) {
    if (forceCaptureEvents.indexOf(type) !== -1) {
      capture = true;
    }
    return event.unbind(el, type, fn, capture);
  }
  var delegate = {
    bind: bind,
    unbind: unbind
  };

  /**
   * Expose `parse`.
   */

  var domify = parse$1;

  /**
   * Tests for browser support.
   */

  var innerHTMLBug = false;
  var bugTestDiv;
  if (typeof document !== 'undefined') {
    bugTestDiv = document.createElement('div');
    // Setup
    bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
    bugTestDiv = undefined;
  }

  /**
   * Wrap map from jquery.
   */

  var map$1 = {
    legend: [1, '<fieldset>', '</fieldset>'],
    tr: [2, '<table><tbody>', '</tbody></table>'],
    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
    // for script/link/style tags to work in IE6-8, you have to wrap
    // in a div with a non-whitespace character in front, ha!
    _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
  };
  map$1.td = map$1.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
  map$1.option = map$1.optgroup = [1, '<select multiple="multiple">', '</select>'];
  map$1.thead = map$1.tbody = map$1.colgroup = map$1.caption = map$1.tfoot = [1, '<table>', '</table>'];
  map$1.polyline = map$1.ellipse = map$1.polygon = map$1.circle = map$1.text = map$1.line = map$1.path = map$1.rect = map$1.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'];

  /**
   * Parse `html` and return a DOM Node instance, which could be a TextNode,
   * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
   * instance, depending on the contents of the `html` string.
   *
   * @param {String} html - HTML string to "domify"
   * @param {Document} doc - The `document` instance to create the Node for
   * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
   * @api private
   */

  function parse$1(html, doc) {
    if ('string' != typeof html) throw new TypeError('String expected');

    // default to the global `document` object
    if (!doc) doc = document;

    // tag name
    var m = /<([\w:]+)/.exec(html);
    if (!m) return doc.createTextNode(html);
    html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

    var tag = m[1];

    // body support
    if (tag == 'body') {
      var el = doc.createElement('html');
      el.innerHTML = html;
      return el.removeChild(el.lastChild);
    }

    // wrap map
    var wrap = Object.prototype.hasOwnProperty.call(map$1, tag) ? map$1[tag] : map$1._default;
    var depth = wrap[0];
    var prefix = wrap[1];
    var suffix = wrap[2];
    var el = doc.createElement('div');
    el.innerHTML = prefix + html + suffix;
    while (depth--) el = el.lastChild;

    // one element
    if (el.firstChild == el.lastChild) {
      return el.removeChild(el.firstChild);
    }

    // several elements
    var fragment = doc.createDocumentFragment();
    while (el.firstChild) {
      fragment.appendChild(el.removeChild(el.firstChild));
    }
    return fragment;
  }
  var domify$1 = domify;
  function query(selector, el) {
    el = el || document;
    return el.querySelector(selector);
  }
  function all(selector, el) {
    el = el || document;
    return el.querySelectorAll(selector);
  }
  function remove$4(el) {
    el.parentNode && el.parentNode.removeChild(el);
  }

  // TODO: remove with future dmn-js version

  /**
   * Wraps APIs to check:
   *
   * 1) If a callback is passed -> Warn users about callback deprecation.
   * 2) If Promise class is implemented in current environment.
   *
   * @private
   */
  function wrapForCompatibility(api) {
    return function () {
      if (!window.Promise) {
        throw new Error('Promises is not supported in this environment.' + ' Please polyfill Promise.');
      }
      var argLen = arguments.length;
      if (argLen >= 1 && isFunction$2(arguments[argLen - 1])) {
        var callback = arguments[argLen - 1];
        console.warn(new Error('Passing callbacks to ' + replaceBoundPrefix(api.name) + ' is deprecated and will be removed in a future major release. ' + 'Please switch to promises: https://bpmn.io/l/moving-to-promises.html'));
        var argsWithoutCallback = Array.prototype.slice.call(arguments, 0, -1);
        api.apply(this, argsWithoutCallback).then(function (result) {
          var firstKey = Object.keys(result)[0];

          // The APIs we are wrapping all resolve a single item depending on the API.
          // For instance, importXML resolves { warnings } and saveXML returns { xml }.
          // That's why we can call the callback with the first item of result.
          return callback(null, result[firstKey]);

          // Passing a second paramter instead of catch because we don't want to
          // catch errors thrown by callback().
        }, function (err) {
          return callback(err, err.warnings);
        });
      } else {
        return api.apply(this, arguments);
      }
    };
  }

  // helper ////////

  /**
   * replaceBoundPrefix - replace the <bound > prefix from a string. Can be used
   * when logging the name of an API, not being sure whether is was bound or not.
   *
   * @param  {string} string
   * @return {string} the string without the <bound > prefix. If no <bound > prefix
   * was present, the same string will be returned.
   */
  function replaceBoundPrefix(string) {
    return string.replace('bound ', '');
  }

  function ownKeys$c(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$c(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$c(Object(source), !0).forEach(function (key) {
        _defineProperty$L(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$L(obj, key, value) {
    key = _toPropertyKey$I(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$I(arg) {
    var key = _toPrimitive$I(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$I(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * @typedef {import('./View').OpenResult} OpenResult
   */

  /**
   * @typedef {import('./View').OpenError} OpenError
   */

  var DEFAULT_CONTAINER_OPTIONS = {
    width: '100%',
    height: '100%',
    position: 'relative'
  };

  /**
   * The base class for DMN viewers and editors.
   *
   * @abstract
   */
  var Manager = /*#__PURE__*/function () {
    /**
     * Create a new instance with the given options.
     *
     * @param  {Object} options
     *
     * @return {Manager}
     */
    function Manager() {
      var _this = this;
      _classCallCheck(this, Manager);
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _defineProperty$L(this, "_viewsChanged", function () {
        _this._emit('views.changed', {
          views: _this._views,
          activeView: _this._activeView
        });
      });
      this._eventBus = new EventBus();
      this._viewsChanged = debounce(this._viewsChanged, 0);
      this._views = [];
      this._viewers = {};

      // keep support for callbacks
      this.open = wrapForCompatibility(this.open.bind(this));
      this.importXML = wrapForCompatibility(this.importXML.bind(this));
      this.saveXML = wrapForCompatibility(this.saveXML.bind(this));
      this._init(options);
    }

    /**
    * The importXML result.
    *
    * @typedef {Object} ImportXMLResult
    *
    * @property {Array<string>} warnings
    */

    /**
    * The importXML error.
    *
    * @typedef {Error} ImportXMLError
    *
    * @property {Array<string>} warnings
    */

    /**
     * Parse and render a DMN diagram.
     *
     * Once finished the viewer reports back the result to the
     * provided callback function with (err, warnings).
     *
     * ## Life-Cycle Events
     *
     * During import the viewer will fire life-cycle events:
     *
     *   * import.parse.start (about to read model from xml)
     *   * import.parse.complete (model read; may have worked or not)
     *   * import.render.start (graphical import start)
     *   * import.render.complete (graphical import finished)
     *   * import.done (everything done)
     *
     * You can use these events to hook into the life-cycle.
     *
     * @param {string} xml the DMN xml
     * @param {Object} [options]
     * @param {boolean} [options.open=true]
     *
     * @return {Promise<ImportXMLResult, ImportXMLError>}
     */
    _createClass(Manager, [{
      key: "importXML",
      value: function importXML(xml, options) {
        var self = this;
        options = options || {
          open: true
        };
        return new Promise(function (resolve, reject) {
          var previousActiveView = self._activeView;

          // clean up previously rendered diagram before new import
          self._clear().then(function () {
            // hook in pre-parse listeners +
            // allow xml manipulation
            xml = self._emit('import.parse.start', {
              xml: xml
            }) || xml;
            var parseWarnings;
            self._moddle.fromXML(xml, 'dmn:Definitions').then(function (parseResult) {
              var definitions = parseResult.rootElement;
              var references = parseResult.references;
              var elementsById = parseResult.elementsById;
              parseWarnings = parseResult.warnings;

              // hook in post parse listeners +
              // allow definitions manipulation
              definitions = self._emit('import.parse.complete', ParseCompleteEvent({
                error: null,
                definitions: definitions,
                elementsById: elementsById,
                references: references,
                warnings: parseWarnings
              })) || definitions;
              self._setDefinitions(definitions);
              if (!options.open) {
                self._emit('import.done', {
                  error: null,
                  warnings: parseWarnings
                });
                resolve({
                  warnings: parseWarnings
                });
                return;
              }

              // open either previously active view or view of the same type if available
              var view = self._getInitialView(self._views, previousActiveView);
              if (!view) {
                var noDisplayableContentsErr = new Error('no displayable contents');
                self._emit('import.done', {
                  error: noDisplayableContentsErr,
                  warnings: parseWarnings
                });
                noDisplayableContentsErr.warnings = parseWarnings;
                return reject(noDisplayableContentsErr);
              }
              self.open(view).then(function (result) {
                return {
                  warnings: result.warnings
                };
              })["catch"](function (error) {
                return {
                  error: error,
                  warnings: error.warnings
                };
              }).then(function (result) {
                var allWarnings = [].concat(parseWarnings, result.warnings);
                self._emit('import.done', {
                  error: result.error,
                  warnings: allWarnings
                });
                if (result.error) {
                  result.error.warnings = allWarnings;
                  reject(result.error);
                } else {
                  resolve({
                    warnings: allWarnings
                  });
                }
              });
            })["catch"](function (parseError) {
              parseWarnings = parseError.warnings;
              parseError = checkDMNCompatibilityError(parseError, xml) || checkValidationError(parseError) || parseError;
              self._emit('import.parse.complete', ParseCompleteEvent({
                error: parseError,
                warnings: parseWarnings
              }));
              self._emit('import.done', {
                error: parseError,
                warnings: parseWarnings
              });
              parseError.warnings = parseWarnings;
              return reject(parseError);
            });
          })["catch"](function (clearError) {
            self._emit('import.done', {
              error: clearError,
              warnings: []
            });
            clearError.warnings = [];
            return reject(clearError);
          });
        });

        // TODO: remove with future dmn-js version
        function ParseCompleteEvent(data) {
          var event = self._eventBus.createEvent(data);
          Object.defineProperty(event, 'context', {
            enumerable: true,
            get: function get() {
              console.warn(new Error('import.parse.complete <context> is deprecated ' + 'and will be removed in future library versions'));
              return {
                warnings: data.warnings,
                references: data.references,
                elementsById: data.elementsById
              };
            }
          });
          return event;
        }
      }
    }, {
      key: "getDefinitions",
      value: function getDefinitions() {
        return this._definitions;
      }

      /**
       * Return active view.
       *
       * @return {View}
       */
    }, {
      key: "getActiveView",
      value: function getActiveView() {
        return this._activeView;
      }

      /**
       * Get the currently active viewer instance.
       *
       * @return {View}
       */
    }, {
      key: "getActiveViewer",
      value: function getActiveViewer() {
        var activeView = this.getActiveView();
        return activeView && this._getViewer(activeView);
      }
    }, {
      key: "getView",
      value: function getView(element) {
        return this._views.filter(function (v) {
          return v.element === element;
        })[0];
      }
    }, {
      key: "getViews",
      value: function getViews() {
        return this._views;
      }

      /**
       * The saveXML result.
       *
       * @typedef {Object} SaveXMLResult
       *
       * @property {string} xml
       */

      /**
       * Export the currently displayed DMN diagram as
       * a DMN XML document.
       *
       * ## Life-Cycle Events
       *
       * During XML saving the viewer will fire life-cycle events:
       *
       *   * saveXML.start (before serialization)
       *   * saveXML.serialized (after xml generation)
       *   * saveXML.done (everything done)
       *
       * You can use these events to hook into the life-cycle.
       *
       * @param {Object} [options] export options
       * @param {boolean} [options.format=false] output formated XML
       * @param {boolean} [options.preamble=true] output preamble
       *
       * @return {Promise<SaveXMLResult, Error>}
       */
    }, {
      key: "saveXML",
      value: function saveXML(options) {
        var self = this;
        options = options || {};
        var definitions = this._definitions;
        return new Promise(function (resolve, reject) {
          if (!definitions) {
            reject(new Error('no definitions loaded'));
            return;
          }

          // allow to fiddle around with definitions
          definitions = self._emit('saveXML.start', {
            definitions: definitions
          }) || definitions;
          self._moddle.toXML(definitions, options).then(function (result) {
            var xml = result.xml;
            xml = self._emit('saveXML.serialized', {
              xml: xml
            }) || xml;
            return {
              xml: xml
            };
          })["catch"](function (error) {
            return {
              error: error
            };
          }).then(function (result) {
            self._emit('saveXML.done', result);
            if (result.error) {
              reject(result.error);
            } else {
              resolve({
                xml: result.xml
              });
            }
          });
        });
      }

      /**
       * Register an event listener
       *
       * Remove a previously added listener via {@link #off(event, callback)}.
       *
       * @param {string} event
       * @param {number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */
    }, {
      key: "on",
      value: function on() {
        var _this$_eventBus;
        (_this$_eventBus = this._eventBus).on.apply(_this$_eventBus, arguments);
      }

      /**
       * De-register an event listener
       *
       * @param {string} event
       * @param {Function} callback
       */
    }, {
      key: "off",
      value: function off() {
        var _this$_eventBus2;
        (_this$_eventBus2 = this._eventBus).off.apply(_this$_eventBus2, arguments);
      }

      /**
       * Register a listener to be invoked once only.
       *
       * @param {string} event
       * @param {number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */
    }, {
      key: "once",
      value: function once() {
        var _this$_eventBus3;
        (_this$_eventBus3 = this._eventBus).once.apply(_this$_eventBus3, arguments);
      }
    }, {
      key: "attachTo",
      value: function attachTo(parentNode) {
        // unwrap jQuery if provided
        if (parentNode.get && parentNode.constructor.prototype.jquery) {
          parentNode = parentNode.get(0);
        }
        if (typeof parentNode === 'string') {
          parentNode = query(parentNode);
        }
        parentNode.appendChild(this._container);
        this._emit('attach', {});
      }
    }, {
      key: "detach",
      value: function detach() {
        this._emit('detach', {});
        remove$4(this._container);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this2 = this;
        Object.keys(this._viewers).forEach(function (viewerId) {
          var viewer = _this2._viewers[viewerId];
          safeExecute(viewer, 'destroy');
        });
        remove$4(this._container);
      }
    }, {
      key: "_init",
      value: function _init(options) {
        this._options = options;
        this._moddle = this._createModdle(options);
        this._viewers = {};
        this._views = [];
        var container = domify$1('<div class="dmn-js-parent"></div>');
        var containerOptions = assign$4({}, DEFAULT_CONTAINER_OPTIONS, options);
        assign$4(container.style, {
          width: ensureUnit(containerOptions.width),
          height: ensureUnit(containerOptions.height),
          position: containerOptions.position
        });
        this._container = container;
        if (options.container) {
          this.attachTo(options.container);
        }
      }
    }, {
      key: "_clear",
      value: function _clear() {
        return this._switchView(null);
      }

      /**
       * Open diagram view.
       *
       * @param  {View} view
       * @returns {Promise} Resolves with {OpenResult} when successful
       * or rejects with {OpenError}
       */
    }, {
      key: "open",
      value: function open(view) {
        return this._switchView(view);
      }
    }, {
      key: "_setDefinitions",
      value: function _setDefinitions(definitions) {
        this._definitions = definitions;
        this._updateViews();
      }
      /**
       * Recompute changed views after elements in
       * the DMN diagram have changed.
       */
    }, {
      key: "_updateViews",
      value: function _updateViews() {
        var definitions = this._definitions;
        if (!definitions) {
          this._views = [];
          this._switchView(null);
          return;
        }
        var viewProviders = this._getViewProviders();
        var displayableElements = [definitions].concat(_toConsumableArray(definitions.drgElement || []));

        // compute list of available views
        var views = this._views,
          newViews = [];
        for (var _i = 0, _displayableElements = displayableElements; _i < _displayableElements.length; _i++) {
          var element = _displayableElements[_i];
          var provider = find$2(viewProviders, function (provider) {
            if (typeof provider.opens === 'string') {
              return provider.opens === element.$type;
            } else {
              return provider.opens(element);
            }
          });
          if (!provider) {
            continue;
          }
          var view = {
            element: element,
            id: element.id,
            name: element.name,
            type: provider.id
          };
          newViews.push(view);
        }
        var activeView = this._activeView,
          newActiveView;
        if (activeView) {
          // check the new active view
          newActiveView = find$2(newViews, function (view) {
            return viewsEqual(activeView, view);
          }) || this._getInitialView(newViews);
          if (!newActiveView) {
            this._switchView(null);
            return;
          }
        }

        // Views have changed if
        // active view has changed OR
        // number of views has changed OR
        // not all views equal
        var activeViewChanged = !viewsEqual(activeView, newActiveView) || viewNameChanged(activeView, newActiveView);
        var viewsChanged = views.length !== newViews.length || !every(newViews, function (newView) {
          return find$2(views, function (view) {
            return viewsEqual(view, newView) && !viewNameChanged(view, newView);
          });
        });
        this._activeView = newActiveView;
        this._views = newViews;
        if (activeViewChanged || viewsChanged) {
          this._viewsChanged();
        }
      }
    }, {
      key: "_getInitialView",
      value: function _getInitialView(views, preferredView) {
        var initialView;
        if (preferredView) {
          initialView = find$2(views, function (view) {
            return viewsEqual(view, preferredView);
          }) || find$2(views, function (view) {
            return view.type === preferredView;
          });
        }
        return initialView || views[0];
      }

      /**
       * Switch to another view.
       *
       * @param  {View} newView
       * @returns {Promise} Resolves with {OpenResult} when successful
       * or rejects with {OpenError}
       */
    }, {
      key: "_switchView",
      value: function _switchView(newView) {
        var self = this;
        return new Promise(function (resolve, reject) {
          var complete = function complete(openError, openResult) {
            self._viewsChanged();
            if (openError) {
              reject(openError);
            } else {
              resolve(openResult);
            }
          };
          var activeView = self.getActiveView(),
            activeViewer;
          var newViewer = newView && self._getViewer(newView),
            element = newView && newView.element;
          if (activeView) {
            activeViewer = self._getViewer(activeView);
            if (activeViewer !== newViewer) {
              safeExecute(activeViewer, 'clear');
              activeViewer.detach();
            }
          }
          self._activeView = newView;
          if (newViewer) {
            if (activeViewer !== newViewer) {
              newViewer.attachTo(self._container);
            }
            self._emit('import.render.start', {
              view: newView,
              element: element
            });
            newViewer.open(element).then(function (result) {
              self._emit('import.render.complete', {
                view: newView,
                error: null,
                warnings: result.warnings
              });
              complete(null, result);
            })["catch"](function (error) {
              self._emit('import.render.complete', {
                view: newView,
                error: error,
                warnings: error.warnings
              });
              complete(error, null);
            });
            return;
          }

          // no active view
          complete();
        });
      }
    }, {
      key: "_getViewer",
      value: function _getViewer(view) {
        var type = view.type;
        var viewer = this._viewers[type];
        if (!viewer) {
          viewer = this._viewers[type] = this._createViewer(view.type);
          this._emit('viewer.created', {
            type: type,
            viewer: viewer
          });
        }
        return viewer;
      }
    }, {
      key: "_createViewer",
      value: function _createViewer(id) {
        var provider = find$2(this._getViewProviders(), function (provider) {
          return provider.id === id;
        });
        if (!provider) {
          throw new Error('no provider for view type <' + id + '>');
        }
        var Viewer = provider.constructor;
        var providerOptions = this._options[id] || {};
        var commonOptions = this._options.common || {};
        return new Viewer(_objectSpread$c(_objectSpread$c(_objectSpread$c({}, commonOptions), providerOptions), {}, {
          additionalModules: [].concat(_toConsumableArray(providerOptions.additionalModules || []), [{
            _parent: ['value', this],
            moddle: ['value', this._moddle]
          }])
        }));
      }

      /**
       * Emit an event.
       */
    }, {
      key: "_emit",
      value: function _emit() {
        var _this$_eventBus4;
        return (_this$_eventBus4 = this._eventBus).fire.apply(_this$_eventBus4, arguments);
      }
    }, {
      key: "_createModdle",
      value: function _createModdle(options) {
        return new simple(options.moddleExtensions);
      }

      /**
       * Return the list of available view providers.
       *
       * @abstract
       *
       * @return {Array<ViewProvider>}
       */
    }, {
      key: "_getViewProviders",
      value: function _getViewProviders() {
        return [];
      }
    }]);
    return Manager;
  }(); // helpers //////////////////////
  function ensureUnit(val) {
    return val + (isNumber$3(val) ? 'px' : '');
  }
  function checkDMNCompatibilityError(err, xml) {
    // check if we can indicate opening of old DMN 1.1 or DMN 1.2 diagrams

    if (err.message !== 'failed to parse document as <dmn:Definitions>') {
      return null;
    }
    var olderDMNVersion = xml.indexOf('"http://www.omg.org/spec/DMN/20151101/dmn.xsd"') !== -1 && '1.1' || xml.indexOf('"http://www.omg.org/spec/DMN/20180521/MODEL/"') !== -1 && '1.2';
    if (!olderDMNVersion) {
      return null;
    }
    err = new Error('unsupported DMN ' + olderDMNVersion + ' file detected; ' + 'only DMN 1.3 files can be opened');
    console.error('Cannot open what looks like a DMN ' + olderDMNVersion + ' diagram. ' + 'Please refer to https://bpmn.io/l/dmn-compatibility.html ' + 'to learn how to make the toolkit compatible with older DMN files', err);
    return err;
  }
  function checkValidationError(err) {
    // check if we can help the user by indicating wrong DMN 1.3 xml
    // (in case he or the exporting tool did not get that right)

    var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/,
      match = pattern.exec(err.message);
    if (!match) {
      return null;
    }
    err.message = 'unparsable content <' + match[1] + '> detected; ' + 'this may indicate an invalid DMN 1.3 diagram file' + match[2];
    return err;
  }
  function viewsEqual(a, b) {
    if (!isDefined(a)) {
      if (!isDefined(b)) {
        return true;
      } else {
        return false;
      }
    }
    if (!isDefined(b)) {
      return false;
    }

    // compare by element OR element ID equality
    return a.element === b.element || a.id === b.id;
  }
  function viewNameChanged(a, b) {
    return !a || !b || a.name !== b.name;
  }
  function safeExecute(viewer, method) {
    if (isFunction$2(viewer[method])) {
      viewer[method]();
    }
  }

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }
  var hat_1 = createCommonjsModule(function (module) {
    var hat = module.exports = function (bits, base) {
      if (!base) base = 16;
      if (bits === undefined) bits = 128;
      if (bits <= 0) return '0';
      var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
      for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
      }
      var rem = digits - Math.floor(digits);
      var res = '';
      for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
      }
      if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
      }
      var parsed = parseInt(res, base);
      if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base);
      } else return res;
    };
    hat.rack = function (bits, base, expandBy) {
      var fn = function fn(data) {
        var iters = 0;
        do {
          if (iters++ > 10) {
            if (expandBy) bits += expandBy;else throw new Error('too many ID collisions, use more bits');
          }
          var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        hats[id] = data;
        return id;
      };
      var hats = fn.hats = {};
      fn.get = function (id) {
        return fn.hats[id];
      };
      fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
      };
      fn.bits = bits || 128;
      fn.base = base || 16;
      return fn;
    };
  });

  /**
   * Create a new id generator / cache instance.
   *
   * You may optionally provide a seed that is used internally.
   *
   * @param {Seed} seed
   */

  function Ids(seed) {
    if (!(this instanceof Ids)) {
      return new Ids(seed);
    }
    seed = seed || [128, 36, 1];
    this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
  }
  /**
   * Generate a next id.
   *
   * @param {Object} [element] element to bind the id to
   *
   * @return {String} id
   */

  Ids.prototype.next = function (element) {
    return this._seed(element || true);
  };
  /**
   * Generate a next id with a given prefix.
   *
   * @param {Object} [element] element to bind the id to
   *
   * @return {String} id
   */

  Ids.prototype.nextPrefixed = function (prefix, element) {
    var id;
    do {
      id = prefix + this.next(true);
    } while (this.assigned(id)); // claim {prefix}{random}

    this.claim(id, element); // return

    return id;
  };
  /**
   * Manually claim an existing id.
   *
   * @param {String} id
   * @param {String} [element] element the id is claimed by
   */

  Ids.prototype.claim = function (id, element) {
    this._seed.set(id, element || true);
  };
  /**
   * Returns true if the given id has already been assigned.
   *
   * @param  {String} id
   * @return {Boolean}
   */

  Ids.prototype.assigned = function (id) {
    return this._seed.get(id) || false;
  };
  /**
   * Unclaim an id.
   *
   * @param  {String} id the id to unclaim
   */

  Ids.prototype.unclaim = function (id) {
    delete this._seed.hats[id];
  };
  /**
   * Clear all claimed ids.
   */

  Ids.prototype.clear = function () {
    var hats = this._seed.hats,
      id;
    for (id in hats) {
      this.unclaim(id);
    }
  };

  /**
   * Is an element of the given DMN type?
   *
   * @param  {tjs.model.Base|ModdleElement} element
   * @param  {string} type
   *
   * @return {boolean}
   */
  function is$1(element, type) {
    var bo = getBusinessObject(element);
    return bo && typeof bo.$instanceOf === 'function' && bo.$instanceOf(type);
  }
  function isInput$1(element) {
    return is$1(element, 'dmn:InputClause');
  }
  function isOutput(element) {
    return is$1(element, 'dmn:OutputClause');
  }

  /**
   * Return the business object for a given element.
   *
   * @param  {tjs.model.Base|ModdleElement} element
   *
   * @return {ModdleElement}
   */
  function getBusinessObject(element) {
    return element && element.businessObject || element;
  }
  function getName(element) {
    return getBusinessObject(element).name;
  }

  /**
   * Return true if element has any of the given types.
   *
   * @param {djs.model.Base} element
   * @param {Array<string>} types
   *
   * @return {boolean}
   */
  function isAny(element, types) {
    return some(types, function (t) {
      return is$1(element, t);
    });
  }

  var EditingManager = /*#__PURE__*/function (_Manager) {
    _inherits$1(EditingManager, _Manager);
    var _super = _createSuper(EditingManager);
    function EditingManager() {
      _classCallCheck(this, EditingManager);
      return _super.apply(this, arguments);
    }
    _createClass(EditingManager, [{
      key: "_init",
      value: function _init(options) {
        var _this = this;
        _get(_getPrototypeOf(EditingManager.prototype), "_init", this).call(this, options);

        // hook ID collection into the modeler
        this.on('import.parse.complete', function (event) {
          if (!event.error) {
            _this._collectIds(event.definitions, event.elementsById);
          }
        });
        this.on('destroy', function () {
          _this._moddle.ids.clear();
        });
        this.on('viewer.created', function (_ref) {
          var viewer = _ref.viewer;
          viewer.on('elements.changed', function (_ref2) {
            var elements = _ref2.elements;
            var viewsChanged = elements.some(function (e) {
              return isAny(e, ['dmn:Decision', 'dmn:Definitions']);
            });
            if (viewsChanged) {
              _this._updateViews();
            }
          });
        });
      }

      /**
       * Collect ids processed during parsing of the
       * definitions object.
       *
       * @param {ModdleElement} definitions
       * @param {Array<ModdleElement>} elementsById
       */
    }, {
      key: "_collectIds",
      value: function _collectIds(definitions, elementsById) {
        var moddle = definitions.$model,
          ids = moddle.ids,
          id;

        // remove references from previous import
        ids.clear();
        for (id in elementsById) {
          ids.claim(id, elementsById[id]);
        }
      }
    }, {
      key: "_createModdle",
      value: function _createModdle(options) {
        var moddle = _get(_getPrototypeOf(EditingManager.prototype), "_createModdle", this).call(this, options);

        // attach ids to moddle to be able to track
        // and validated ids in the DMN XML document
        // tree
        moddle.ids = new Ids([32, 36, 1]);
        return moddle;
      }
    }]);
    return EditingManager;
  }(Manager);

  function e$2(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  }

  var CLASS_PATTERN = /^class[ {]/;

  /**
   * @param {function} fn
   *
   * @return {boolean}
   */
  function isClass(fn) {
    return CLASS_PATTERN.test(fn.toString());
  }

  /**
   * @param {any} obj
   *
   * @return {boolean}
   */
  function isArray$2(obj) {
    return Array.isArray(obj);
  }

  /**
   * @param {any} obj
   * @param {string} prop
   *
   * @return {boolean}
   */
  function hasOwnProp(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  /**
   * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated
   */

  /**
   * @template T
   *
   * @params {[...string[], T] | ...string[], T} args
   *
   * @return {T & InjectAnnotated}
   */
  function annotate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && isArray$2(args[0])) {
      args = args[0];
    }
    args = _toConsumableArray(args);
    var fn = args.pop();
    fn.$inject = args;
    return fn;
  }

  // Current limitations:
  // - can't put into "function arg" comments
  // function /* (no parenthesis like this) */ (){}
  // function abc( /* xx (no parenthesis like this) */ a, b) {}
  //
  // Just put the comment before function or inside:
  // /* (((this is fine))) */ function(a, b) {}
  // function abc(a) { /* (((this is fine))) */}
  //
  // - can't reliably auto-annotate constructor; we'll match the
  // first constructor(...) pattern found which may be the one
  // of a nested class, too.

  var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
  var FN_ARGS = /^(?:async\s+)?(?:function\s*[^(]*)?(?:\(\s*([^)]*)\)|(\w+))/m;
  var FN_ARG = /\/\*([^*]*)\*\//m;

  /**
   * @param {unknown} fn
   *
   * @return {string[]}
   */
  function parseAnnotations(fn) {
    if (typeof fn !== 'function') {
      throw new Error("Cannot annotate \"".concat(fn, "\". Expected a function!"));
    }
    var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);

    // may parse class without constructor
    if (!match) {
      return [];
    }
    var args = match[1] || match[2];
    return args && args.split(',').map(function (arg) {
      var argMatch = arg.match(FN_ARG);
      return (argMatch && argMatch[1] || arg).trim();
    }) || [];
  }

  /**
   * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration
   * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition
   * @typedef { import('./index.js').InjectorContext } InjectorContext
   */

  /**
   * Create a new injector with the given modules.
   *
   * @param {ModuleDefinition[]} modules
   * @param {InjectorContext} [parent]
   */
  function Injector(modules, parent) {
    parent = parent || {
      get: function get(name, strict) {
        currentlyResolving.push(name);
        if (strict === false) {
          return null;
        } else {
          throw error("No provider for \"".concat(name, "\"!"));
        }
      }
    };
    var currentlyResolving = [];
    var providers = this._providers = Object.create(parent._providers || null);
    var instances = this._instances = Object.create(null);
    var self = instances.injector = this;
    var error = function error(msg) {
      var stack = currentlyResolving.join(' -> ');
      currentlyResolving.length = 0;
      return new Error(stack ? "".concat(msg, " (Resolving: ").concat(stack, ")") : msg);
    };

    /**
     * Return a named service.
     *
     * @param {string} name
     * @param {boolean} [strict=true] if false, resolve missing services to null
     *
     * @return {any}
     */
    function get(name, strict) {
      if (!providers[name] && name.indexOf('.') !== -1) {
        var parts = name.split('.');
        var pivot = get(parts.shift());
        while (parts.length) {
          pivot = pivot[parts.shift()];
        }
        return pivot;
      }
      if (hasOwnProp(instances, name)) {
        return instances[name];
      }
      if (hasOwnProp(providers, name)) {
        if (currentlyResolving.indexOf(name) !== -1) {
          currentlyResolving.push(name);
          throw error('Cannot resolve circular dependency!');
        }
        currentlyResolving.push(name);
        instances[name] = providers[name][0](providers[name][1]);
        currentlyResolving.pop();
        return instances[name];
      }
      return parent.get(name, strict);
    }
    function fnDef(fn, locals) {
      if (typeof locals === 'undefined') {
        locals = {};
      }
      if (typeof fn !== 'function') {
        if (isArray$2(fn)) {
          fn = annotate(fn.slice());
        } else {
          throw error("Cannot invoke \"".concat(fn, "\". Expected a function!"));
        }
      }
      var inject = fn.$inject || parseAnnotations(fn);
      var dependencies = inject.map(function (dep) {
        if (hasOwnProp(locals, dep)) {
          return locals[dep];
        } else {
          return get(dep);
        }
      });
      return {
        fn: fn,
        dependencies: dependencies
      };
    }

    /**
     * Instantiate the given type, injecting dependencies.
     *
     * @template T
     *
     * @param { Function | [...string[], Function ]} type
     *
     * @return T
     */
    function instantiate(type) {
      var _fnDef = fnDef(type),
        fn = _fnDef.fn,
        dependencies = _fnDef.dependencies;

      // instantiate var args constructor
      var Constructor = Function.prototype.bind.apply(fn, [null].concat(dependencies));
      return new Constructor();
    }

    /**
     * Invoke the given function, injecting dependencies. Return the result.
     *
     * @template T
     *
     * @param { Function | [...string[], Function ]} func
     * @param { Object } [context]
     * @param { Object } [locals]
     *
     * @return {T} invocation result
     */
    function invoke(func, context, locals) {
      var _fnDef2 = fnDef(func, locals),
        fn = _fnDef2.fn,
        dependencies = _fnDef2.dependencies;
      return fn.apply(context, dependencies);
    }

    /**
     * @param {Injector} childInjector
     *
     * @return {Function}
     */
    function createPrivateInjectorFactory(childInjector) {
      return annotate(function (key) {
        return childInjector.get(key);
      });
    }

    /**
     * @param {ModuleDefinition[]} modules
     * @param {string[]} [forceNewInstances]
     *
     * @return {Injector}
     */
    function createChild(modules, forceNewInstances) {
      if (forceNewInstances && forceNewInstances.length) {
        var fromParentModule = Object.create(null);
        var matchedScopes = Object.create(null);
        var privateInjectorsCache = [];
        var privateChildInjectors = [];
        var privateChildFactories = [];
        var provider;
        var cacheIdx;
        var privateChildInjector;
        var privateChildInjectorFactory;
        var _loop = function _loop(name) {
          provider = providers[name];
          if (forceNewInstances.indexOf(name) !== -1) {
            if (provider[2] === 'private') {
              cacheIdx = privateInjectorsCache.indexOf(provider[3]);
              if (cacheIdx === -1) {
                privateChildInjector = provider[3].createChild([], forceNewInstances);
                privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
                privateInjectorsCache.push(provider[3]);
                privateChildInjectors.push(privateChildInjector);
                privateChildFactories.push(privateChildInjectorFactory);
                fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];
              } else {
                fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];
              }
            } else {
              fromParentModule[name] = [provider[2], provider[1]];
            }
            matchedScopes[name] = true;
          }
          if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
            /* jshint -W083 */
            forceNewInstances.forEach(function (scope) {
              if (provider[1].$scope.indexOf(scope) !== -1) {
                fromParentModule[name] = [provider[2], provider[1]];
                matchedScopes[scope] = true;
              }
            });
          }
        };
        for (var name in providers) {
          _loop(name);
        }
        forceNewInstances.forEach(function (scope) {
          if (!matchedScopes[scope]) {
            throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
          }
        });
        modules.unshift(fromParentModule);
      }
      return new Injector(modules, self);
    }
    var factoryMap = {
      factory: invoke,
      type: instantiate,
      value: function value(_value) {
        return _value;
      }
    };

    /**
     * @param {ModuleDefinition} moduleDefinition
     * @param {Injector} injector
     */
    function createInitializer(moduleDefinition, injector) {
      var initializers = moduleDefinition.__init__ || [];
      return function () {
        initializers.forEach(function (initializer) {
          // eagerly resolve component (fn or string)
          if (typeof initializer === 'string') {
            injector.get(initializer);
          } else {
            injector.invoke(initializer);
          }
        });
      };
    }

    /**
     * @param {ModuleDefinition} moduleDefinition
     */
    function loadModule(moduleDefinition) {
      var moduleExports = moduleDefinition.__exports__;

      // private module
      if (moduleExports) {
        var nestedModules = moduleDefinition.__modules__;
        var clonedModule = Object.keys(moduleDefinition).reduce(function (clonedModule, key) {
          if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {
            clonedModule[key] = moduleDefinition[key];
          }
          return clonedModule;
        }, Object.create(null));
        var childModules = (nestedModules || []).concat(clonedModule);
        var privateInjector = createChild(childModules);
        var getFromPrivateInjector = annotate(function (key) {
          return privateInjector.get(key);
        });
        moduleExports.forEach(function (key) {
          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
        });

        // ensure child injector initializes
        var initializers = (moduleDefinition.__init__ || []).slice();
        initializers.unshift(function () {
          privateInjector.init();
        });
        moduleDefinition = Object.assign({}, moduleDefinition, {
          __init__: initializers
        });
        return createInitializer(moduleDefinition, privateInjector);
      }

      // normal module
      Object.keys(moduleDefinition).forEach(function (key) {
        if (key === '__init__' || key === '__depends__') {
          return;
        }
        if (moduleDefinition[key][2] === 'private') {
          providers[key] = moduleDefinition[key];
          return;
        }
        var type = moduleDefinition[key][0];
        var value = moduleDefinition[key][1];
        providers[key] = [factoryMap[type], arrayUnwrap(type, value), type];
      });
      return createInitializer(moduleDefinition, self);
    }

    /**
     * @param {ModuleDefinition[]} moduleDefinitions
     * @param {ModuleDefinition} moduleDefinition
     *
     * @return {ModuleDefinition[]}
     */
    function resolveDependencies(moduleDefinitions, moduleDefinition) {
      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
        return moduleDefinitions;
      }
      moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);
      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
        return moduleDefinitions;
      }
      return moduleDefinitions.concat(moduleDefinition);
    }

    /**
     * @param {ModuleDefinition[]} moduleDefinitions
     *
     * @return { () => void } initializerFn
     */
    function bootstrap(moduleDefinitions) {
      var initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);
      var initialized = false;
      return function () {
        if (initialized) {
          return;
        }
        initialized = true;
        initializers.forEach(function (initializer) {
          return initializer();
        });
      };
    }

    // public API
    this.get = get;
    this.invoke = invoke;
    this.instantiate = instantiate;
    this.createChild = createChild;

    // setup
    this.init = bootstrap(modules);
  }

  // helpers ///////////////

  function arrayUnwrap(type, value) {
    if (type !== 'value' && isArray$2(value)) {
      value = annotate(value.slice());
    }
    return value;
  }

  var DEFAULT_RENDER_PRIORITY$1 = 1000;

  /**
   * @typedef {import('../core/Types').ElementLike} Element
   * @typedef {import('../core/Types').ConnectionLike} Connection
   * @typedef {import('../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../core/EventBus').default} EventBus
   */

  /**
   * The base implementation of shape and connection renderers.
   *
   * @param {EventBus} eventBus
   * @param {number} [renderPriority=1000]
   */
  function BaseRenderer(eventBus, renderPriority) {
    var self = this;
    renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY$1;
    eventBus.on(['render.shape', 'render.connection'], renderPriority, function (evt, context) {
      var type = evt.type,
        element = context.element,
        visuals = context.gfx,
        attrs = context.attrs;
      if (self.canRender(element)) {
        if (type === 'render.shape') {
          return self.drawShape(visuals, element, attrs);
        } else {
          return self.drawConnection(visuals, element, attrs);
        }
      }
    });
    eventBus.on(['render.getShapePath', 'render.getConnectionPath'], renderPriority, function (evt, element) {
      if (self.canRender(element)) {
        if (evt.type === 'render.getShapePath') {
          return self.getShapePath(element);
        } else {
          return self.getConnectionPath(element);
        }
      }
    });
  }

  /**
   * Checks whether an element can be rendered.
   *
   * @param {Element} element The element to be rendered.
   *
   * @return {boolean} Whether the element can be rendered.
   */
  BaseRenderer.prototype.canRender = function (element) {};

  /**
   * Draws a shape.
   *
   * @param {SVGElement} visuals The SVG element to draw the shape into.
   * @param {Shape} shape The shape to be drawn.
   *
   * @return {SVGElement} The SVG element of the shape drawn.
   */
  BaseRenderer.prototype.drawShape = function (visuals, shape) {};

  /**
   * Draws a connection.
   *
   * @param {SVGElement} visuals The SVG element to draw the connection into.
   * @param {Connection} connection The connection to be drawn.
   *
   * @return {SVGElement} The SVG element of the connection drawn.
   */
  BaseRenderer.prototype.drawConnection = function (visuals, connection) {};

  /**
   * Gets the SVG path of the graphical representation of a shape.
   *
   * @param {Shape} shape The shape.
   *
   * @return {string} The SVG path of the shape.
   */
  BaseRenderer.prototype.getShapePath = function (shape) {};

  /**
   * Gets the SVG path of the graphical representation of a connection.
   *
   * @param {Connection} connection The connection.
   *
   * @return {string} The SVG path of the connection.
   */
  BaseRenderer.prototype.getConnectionPath = function (connection) {};

  function ensureImported(element, target) {
    if (element.ownerDocument !== target.ownerDocument) {
      try {
        // may fail on webkit
        return target.ownerDocument.importNode(element, true);
      } catch (e) {

        // ignore
      }
    }
    return element;
  }

  /**
   * appendTo utility
   */

  /**
   * Append a node to a target element and return the appended node.
   *
   * @param  {SVGElement} element
   * @param  {SVGElement} target
   *
   * @return {SVGElement} the appended node
   */
  function appendTo(element, target) {
    return target.appendChild(ensureImported(element, target));
  }

  /**
   * append utility
   */

  /**
   * Append a node to an element
   *
   * @param  {SVGElement} element
   * @param  {SVGElement} node
   *
   * @return {SVGElement} the element
   */
  function append(target, node) {
    appendTo(node, target);
    return target;
  }

  /**
   * attribute accessor utility
   */

  var LENGTH_ATTR = 2;
  var CSS_PROPERTIES = {
    'alignment-baseline': 1,
    'baseline-shift': 1,
    'clip': 1,
    'clip-path': 1,
    'clip-rule': 1,
    'color': 1,
    'color-interpolation': 1,
    'color-interpolation-filters': 1,
    'color-profile': 1,
    'color-rendering': 1,
    'cursor': 1,
    'direction': 1,
    'display': 1,
    'dominant-baseline': 1,
    'enable-background': 1,
    'fill': 1,
    'fill-opacity': 1,
    'fill-rule': 1,
    'filter': 1,
    'flood-color': 1,
    'flood-opacity': 1,
    'font': 1,
    'font-family': 1,
    'font-size': LENGTH_ATTR,
    'font-size-adjust': 1,
    'font-stretch': 1,
    'font-style': 1,
    'font-variant': 1,
    'font-weight': 1,
    'glyph-orientation-horizontal': 1,
    'glyph-orientation-vertical': 1,
    'image-rendering': 1,
    'kerning': 1,
    'letter-spacing': 1,
    'lighting-color': 1,
    'marker': 1,
    'marker-end': 1,
    'marker-mid': 1,
    'marker-start': 1,
    'mask': 1,
    'opacity': 1,
    'overflow': 1,
    'pointer-events': 1,
    'shape-rendering': 1,
    'stop-color': 1,
    'stop-opacity': 1,
    'stroke': 1,
    'stroke-dasharray': 1,
    'stroke-dashoffset': 1,
    'stroke-linecap': 1,
    'stroke-linejoin': 1,
    'stroke-miterlimit': 1,
    'stroke-opacity': 1,
    'stroke-width': LENGTH_ATTR,
    'text-anchor': 1,
    'text-decoration': 1,
    'text-rendering': 1,
    'unicode-bidi': 1,
    'visibility': 1,
    'word-spacing': 1,
    'writing-mode': 1
  };
  function getAttribute(node, name) {
    if (CSS_PROPERTIES[name]) {
      return node.style[name];
    } else {
      return node.getAttributeNS(null, name);
    }
  }
  function setAttribute(node, name, value) {
    var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var type = CSS_PROPERTIES[hyphenated];
    if (type) {
      // append pixel unit, unless present
      if (type === LENGTH_ATTR && typeof value === 'number') {
        value = String(value) + 'px';
      }
      node.style[hyphenated] = value;
    } else {
      node.setAttributeNS(null, name, value);
    }
  }
  function setAttributes(node, attrs) {
    var names = Object.keys(attrs),
      i,
      name;
    for (i = 0, name; name = names[i]; i++) {
      setAttribute(node, name, attrs[name]);
    }
  }

  /**
   * Gets or sets raw attributes on a node.
   *
   * @param  {SVGElement} node
   * @param  {Object} [attrs]
   * @param  {String} [name]
   * @param  {String} [value]
   *
   * @return {String}
   */
  function attr(node, name, value) {
    if (typeof name === 'string') {
      if (value !== undefined) {
        setAttribute(node, name, value);
      } else {
        return getAttribute(node, name);
      }
    } else {
      setAttributes(node, name);
    }
    return node;
  }

  /**
   * Taken from https://github.com/component/classes
   *
   * Without the component bits.
   */

  /**
   * toString reference.
   */

  var toString = Object.prototype.toString;

  /**
    * Wrap `el` in a `ClassList`.
    *
    * @param {Element} el
    * @return {ClassList}
    * @api public
    */

  function classes(el) {
    return new ClassList(el);
  }
  function ClassList(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }

  /**
    * Add class `name` if not already present.
    *
    * @param {String} name
    * @return {ClassList}
    * @api public
    */

  ClassList.prototype.add = function (name) {
    this.list.add(name);
    return this;
  };

  /**
    * Remove class `name` when present, or
    * pass a regular expression to remove
    * any which match.
    *
    * @param {String|RegExp} name
    * @return {ClassList}
    * @api public
    */

  ClassList.prototype.remove = function (name) {
    if ('[object RegExp]' == toString.call(name)) {
      return this.removeMatching(name);
    }
    this.list.remove(name);
    return this;
  };

  /**
    * Remove all classes matching `re`.
    *
    * @param {RegExp} re
    * @return {ClassList}
    * @api private
    */

  ClassList.prototype.removeMatching = function (re) {
    var arr = this.array();
    for (var i = 0; i < arr.length; i++) {
      if (re.test(arr[i])) {
        this.remove(arr[i]);
      }
    }
    return this;
  };

  /**
    * Toggle class `name`, can force state via `force`.
    *
    * For browsers that support classList, but do not support `force` yet,
    * the mistake will be detected and corrected.
    *
    * @param {String} name
    * @param {Boolean} force
    * @return {ClassList}
    * @api public
    */

  ClassList.prototype.toggle = function (name, force) {
    if ('undefined' !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  };

  /**
    * Return an array of classes.
    *
    * @return {Array}
    * @api public
    */

  ClassList.prototype.array = function () {
    return Array.from(this.list);
  };

  /**
    * Check if class `name` is present.
    *
    * @param {String} name
    * @return {ClassList}
    * @api public
    */

  ClassList.prototype.has = ClassList.prototype.contains = function (name) {
    return this.list.contains(name);
  };
  function remove$3(element) {
    var parent = element.parentNode;
    if (parent) {
      parent.removeChild(element);
    }
    return element;
  }

  /**
   * Clear utility
   */

  /**
   * Removes all children from the given element
   *
   * @param  {DOMElement} element
   * @return {DOMElement} the element (for chaining)
   */
  function clear(element) {
    var child;
    while (child = element.firstChild) {
      remove$3(child);
    }
    return element;
  }
  function clone$1(element) {
    return element.cloneNode(true);
  }
  var ns = {
    svg: 'http://www.w3.org/2000/svg'
  };

  /**
   * DOM parsing utility
   */

  var SVG_START = '<svg xmlns="' + ns.svg + '"';
  function parse(svg) {
    var unwrap = false;

    // ensure we import a valid svg document
    if (svg.substring(0, 4) === '<svg') {
      if (svg.indexOf(ns.svg) === -1) {
        svg = SVG_START + svg.substring(4);
      }
    } else {
      // namespace svg
      svg = SVG_START + '>' + svg + '</svg>';
      unwrap = true;
    }
    var parsed = parseDocument(svg);
    if (!unwrap) {
      return parsed;
    }
    var fragment = document.createDocumentFragment();
    var parent = parsed.firstChild;
    while (parent.firstChild) {
      fragment.appendChild(parent.firstChild);
    }
    return fragment;
  }
  function parseDocument(svg) {
    var parser;

    // parse
    parser = new DOMParser();
    parser.async = false;
    return parser.parseFromString(svg, 'text/xml');
  }

  /**
   * Create utility for SVG elements
   */

  /**
   * Create a specific type from name or SVG markup.
   *
   * @param {String} name the name or markup of the element
   * @param {Object} [attrs] attributes to set on the element
   *
   * @returns {SVGElement}
   */
  function create$2(name, attrs) {
    var element;
    if (name.charAt(0) === '<') {
      element = parse(name).firstChild;
      element = document.importNode(element, true);
    } else {
      element = document.createElementNS(ns.svg, name);
    }
    if (attrs) {
      attr(element, attrs);
    }
    return element;
  }

  /**
   * Geometry helpers
   */

  // fake node used to instantiate svg geometry elements
  var node = null;
  function getNode() {
    if (node === null) {
      node = create$2('svg');
    }
    return node;
  }
  function extend$2(object, props) {
    var i,
      k,
      keys = Object.keys(props);
    for (i = 0; k = keys[i]; i++) {
      object[k] = props[k];
    }
    return object;
  }

  /**
   * Create matrix via args.
   *
   * @example
   *
   * createMatrix({ a: 1, b: 1 });
   * createMatrix();
   * createMatrix(1, 2, 0, 0, 30, 20);
   *
   * @return {SVGMatrix}
   */
  function createMatrix(a, b, c, d, e, f) {
    var matrix = getNode().createSVGMatrix();
    switch (arguments.length) {
      case 0:
        return matrix;
      case 1:
        return extend$2(matrix, a);
      case 6:
        return extend$2(matrix, {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f
        });
    }
  }
  function createTransform(matrix) {
    if (matrix) {
      return getNode().createSVGTransformFromMatrix(matrix);
    } else {
      return getNode().createSVGTransform();
    }
  }

  /**
   * Serialization util
   */

  var TEXT_ENTITIES = /([&<>]{1})/g;
  var ATTR_ENTITIES = /([\n\r"]{1})/g;
  var ENTITY_REPLACEMENT = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '\''
  };
  function escape(str, pattern) {
    function replaceFn(match, entity) {
      return ENTITY_REPLACEMENT[entity] || entity;
    }
    return str.replace(pattern, replaceFn);
  }
  function serialize(node, output) {
    var i, len, attrMap, attrNode, childNodes;
    switch (node.nodeType) {
      // TEXT
      case 3:
        // replace special XML characters
        output.push(escape(node.textContent, TEXT_ENTITIES));
        break;

      // ELEMENT
      case 1:
        output.push('<', node.tagName);
        if (node.hasAttributes()) {
          attrMap = node.attributes;
          for (i = 0, len = attrMap.length; i < len; ++i) {
            attrNode = attrMap.item(i);
            output.push(' ', attrNode.name, '="', escape(attrNode.value, ATTR_ENTITIES), '"');
          }
        }
        if (node.hasChildNodes()) {
          output.push('>');
          childNodes = node.childNodes;
          for (i = 0, len = childNodes.length; i < len; ++i) {
            serialize(childNodes.item(i), output);
          }
          output.push('</', node.tagName, '>');
        } else {
          output.push('/>');
        }
        break;

      // COMMENT
      case 8:
        output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');
        break;

      // CDATA
      case 4:
        output.push('<![CDATA[', node.nodeValue, ']]>');
        break;
      default:
        throw new Error('unable to handle node ' + node.nodeType);
    }
    return output;
  }

  /**
   * innerHTML like functionality for SVG elements.
   * based on innerSVG (https://code.google.com/p/innersvg)
   */

  function set$1(element, svg) {
    var parsed = parse(svg);

    // clear element contents
    clear(element);
    if (!svg) {
      return;
    }
    if (!isFragment(parsed)) {
      // extract <svg> from parsed document
      parsed = parsed.documentElement;
    }
    var nodes = slice(parsed.childNodes);

    // import + append each node
    for (var i = 0; i < nodes.length; i++) {
      appendTo(nodes[i], element);
    }
  }
  function get$1(element) {
    var child = element.firstChild,
      output = [];
    while (child) {
      serialize(child, output);
      child = child.nextSibling;
    }
    return output.join('');
  }
  function isFragment(node) {
    return node.nodeName === '#document-fragment';
  }
  function innerSVG(element, svg) {
    if (svg !== undefined) {
      try {
        set$1(element, svg);
      } catch (e) {
        throw new Error('error parsing SVG: ' + e.message);
      }
      return element;
    } else {
      return get$1(element);
    }
  }
  function slice(arr) {
    return Array.prototype.slice.call(arr);
  }

  /**
   * transform accessor utility
   */

  function wrapMatrix(transformList, transform) {
    if (transform instanceof SVGMatrix) {
      return transformList.createSVGTransformFromMatrix(transform);
    }
    return transform;
  }
  function setTransforms(transformList, transforms) {
    var i, t;
    transformList.clear();
    for (i = 0; t = transforms[i]; i++) {
      transformList.appendItem(wrapMatrix(transformList, t));
    }
  }

  /**
   * Get or set the transforms on the given node.
   *
   * @param {SVGElement} node
   * @param  {SVGTransform|SVGMatrix|Array<SVGTransform|SVGMatrix>} [transforms]
   *
   * @return {SVGTransform} the consolidated transform
   */
  function transform$1(node, transforms) {
    var transformList = node.transform.baseVal;
    if (transforms) {
      if (!Array.isArray(transforms)) {
        transforms = [transforms];
      }
      setTransforms(transformList, transforms);
    }
    return transformList.consolidate();
  }

  /**
   * @typedef {(string|number)[]} Component
   *
   * @typedef {import('../util/Types').Point} Point
   */

  /**
   * @param {Component[] | Component[][]} elements
   *
   * @return {string}
   */
  function componentsToPath(elements) {
    return elements.flat().join(',').replace(/,?([A-z]),?/g, '$1');
  }

  /**
   * @param {Point} point
   *
   * @return {Component[]}
   */
  function move(point) {
    return ['M', point.x, point.y];
  }

  /**
   * @param {Point} point
   *
   * @return {Component[]}
   */
  function lineTo(point) {
    return ['L', point.x, point.y];
  }

  /**
   * @param {Point} p1
   * @param {Point} p2
   * @param {Point} p3
   *
   * @return {Component[]}
   */
  function curveTo(p1, p2, p3) {
    return ['C', p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
  }

  /**
   * @param {Point[]} waypoints
   * @param {number} [cornerRadius]
   * @return {Component[][]}
   */
  function drawPath(waypoints, cornerRadius) {
    var pointCount = waypoints.length;
    var path = [move(waypoints[0])];
    for (var i = 1; i < pointCount; i++) {
      var pointBefore = waypoints[i - 1];
      var point = waypoints[i];
      var pointAfter = waypoints[i + 1];
      if (!pointAfter || !cornerRadius) {
        path.push(lineTo(point));
        continue;
      }
      var effectiveRadius = Math.min(cornerRadius, vectorLength$1(point.x - pointBefore.x, point.y - pointBefore.y), vectorLength$1(pointAfter.x - point.x, pointAfter.y - point.y));
      if (!effectiveRadius) {
        path.push(lineTo(point));
        continue;
      }
      var beforePoint = getPointAtLength(point, pointBefore, effectiveRadius);
      var beforePoint2 = getPointAtLength(point, pointBefore, effectiveRadius * .5);
      var afterPoint = getPointAtLength(point, pointAfter, effectiveRadius);
      var afterPoint2 = getPointAtLength(point, pointAfter, effectiveRadius * .5);
      path.push(lineTo(beforePoint));
      path.push(curveTo(beforePoint2, afterPoint2, afterPoint));
    }
    return path;
  }
  function getPointAtLength(start, end, length) {
    var deltaX = end.x - start.x;
    var deltaY = end.y - start.y;
    var totalLength = vectorLength$1(deltaX, deltaY);
    var percent = length / totalLength;
    return {
      x: start.x + deltaX * percent,
      y: start.y + deltaY * percent
    };
  }
  function vectorLength$1(x, y) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  }

  /**
   * @param {Point[]} points
   * @param {number|Object} [attrs]
   * @param {number} [radius]
   *
   * @return {SVGElement}
   */
  function createLine(points, attrs, radius) {
    if (isNumber$3(attrs)) {
      radius = attrs;
      attrs = null;
    }
    if (!attrs) {
      attrs = {};
    }
    var line = create$2('path', attrs);
    if (isNumber$3(radius)) {
      line.dataset.cornerRadius = String(radius);
    }
    return updateLine(line, points);
  }

  /**
   * @param {SVGElement} gfx
   * @param {Point[]} points
   *
   * @return {SVGElement}
   */
  function updateLine(gfx, points) {
    var cornerRadius = parseInt(gfx.dataset.cornerRadius, 10) || 0;
    attr(gfx, {
      d: componentsToPath(drawPath(points, cornerRadius))
    });
    return gfx;
  }

  /**
   * @typedef {import('../model/Types').Connection} Connection
   * @typedef {import('../model/Types').Element} Element
   * @typedef {import('../model/Types').Shape} Shape
   *
   * @typedef {import('../../type/Types').Rect} Rect
   *
   * @typedef { {
   *   allShapes: Record<string, Shape>,
   *   allConnections: Record<string, Connection>,
   *   topLevel: Record<string, Element>,
   *   enclosedConnections: Record<string, Connection>,
   *   enclosedElements: Record<string, Element>
   * } } Closure
   */

  /**
   * Get parent elements.
   *
   * @param {Element[]} elements
   *
   * @return {Element[]}
   */
  function getParents(elements) {
    // find elements that are not children of any other elements
    return filter$2(elements, function (element) {
      return !find$2(elements, function (e) {
        return e !== element && getParent(element, e);
      });
    });
  }
  function getParent(element, parent) {
    if (!parent) {
      return;
    }
    if (element === parent) {
      return parent;
    }
    if (!element.parent) {
      return;
    }
    return getParent(element.parent, parent);
  }

  /**
   * Adds an element to a collection and returns true if the
   * element was added.
   *
   * @param {Object[]} elements
   * @param {Object} element
   * @param {boolean} [unique]
   */
  function add$3(elements, element, unique) {
    var canAdd = !unique || elements.indexOf(element) === -1;
    if (canAdd) {
      elements.push(element);
    }
    return canAdd;
  }

  /**
   * Iterate over each element in a collection, calling the iterator function `fn`
   * with (element, index, recursionDepth).
   *
   * Recurse into all elements that are returned by `fn`.
   *
   * @param {Element|Element[]} elements
   * @param {(element: Element, index: number, depth: number) => Element[] | boolean | undefined} fn
   * @param {number} [depth] maximum recursion depth
   */
  function eachElement(elements, fn, depth) {
    depth = depth || 0;
    if (!isArray$6(elements)) {
      elements = [elements];
    }
    forEach$3(elements, function (s, i) {
      var filter = fn(s, i, depth);
      if (isArray$6(filter) && filter.length) {
        eachElement(filter, fn, depth + 1);
      }
    });
  }

  /**
   * Collects self + child elements up to a given depth from a list of elements.
   *
   * @param {Element|Element[]} elements the elements to select the children from
   * @param {boolean} unique whether to return a unique result set (no duplicates)
   * @param {number} maxDepth the depth to search through or -1 for infinite
   *
   * @return {Element[]} found elements
   */
  function selfAndChildren(elements, unique, maxDepth) {
    var result = [],
      processedChildren = [];
    eachElement(elements, function (element, i, depth) {
      add$3(result, element, unique);
      var children = element.children;

      // max traversal depth not reached yet
      if (maxDepth === -1 || depth < maxDepth) {
        // children exist && children not yet processed
        if (children && add$3(processedChildren, children, unique)) {
          return children;
        }
      }
    });
    return result;
  }

  /**
   * Return self + ALL children for a number of elements
   *
   * @param {Element[]} elements to query
   * @param {boolean} [allowDuplicates] to allow duplicates in the result set
   *
   * @return {Element[]} the collected elements
   */
  function selfAndAllChildren(elements, allowDuplicates) {
    return selfAndChildren(elements, !allowDuplicates, -1);
  }

  /**
   * Gets the the closure for all selected elements,
   * their enclosed children and connections.
   *
   * @param {Element[]} elements
   * @param {boolean} [isTopLevel=true]
   * @param {Closure} [closure]
   *
   * @return {Closure} newClosure
   */
  function getClosure(elements, isTopLevel, closure) {
    if (isUndefined$5(isTopLevel)) {
      isTopLevel = true;
    }
    if (isObject$2(isTopLevel)) {
      closure = isTopLevel;
      isTopLevel = true;
    }
    closure = closure || {};
    var allShapes = copyObject(closure.allShapes),
      allConnections = copyObject(closure.allConnections),
      enclosedElements = copyObject(closure.enclosedElements),
      enclosedConnections = copyObject(closure.enclosedConnections);
    var topLevel = copyObject(closure.topLevel, isTopLevel && groupBy(elements, function (e) {
      return e.id;
    }));
    function handleConnection(c) {
      if (topLevel[c.source.id] && topLevel[c.target.id]) {
        topLevel[c.id] = [c];
      }

      // not enclosed as a child, but maybe logically
      // (connecting two moved elements?)
      if (allShapes[c.source.id] && allShapes[c.target.id]) {
        enclosedConnections[c.id] = enclosedElements[c.id] = c;
      }
      allConnections[c.id] = c;
    }
    function handleElement(element) {
      enclosedElements[element.id] = element;
      if (element.waypoints) {
        // remember connection
        enclosedConnections[element.id] = allConnections[element.id] = element;
      } else {
        // remember shape
        allShapes[element.id] = element;

        // remember all connections
        forEach$3(element.incoming, handleConnection);
        forEach$3(element.outgoing, handleConnection);

        // recurse into children
        return element.children;
      }
    }
    eachElement(elements, handleElement);
    return {
      allShapes: allShapes,
      allConnections: allConnections,
      topLevel: topLevel,
      enclosedConnections: enclosedConnections,
      enclosedElements: enclosedElements
    };
  }

  /**
   * Returns the surrounding bbox for all elements in
   * the array or the element primitive.
   *
   * @param {Element|Element[]} elements
   * @param {boolean} [stopRecursion=false]
   *
   * @return {Rect}
   */
  function getBBox(elements, stopRecursion) {
    stopRecursion = !!stopRecursion;
    if (!isArray$6(elements)) {
      elements = [elements];
    }
    var minX, minY, maxX, maxY;
    forEach$3(elements, function (element) {
      // If element is a connection the bbox must be computed first
      var bbox = element;
      if (element.waypoints && !stopRecursion) {
        bbox = getBBox(element.waypoints, true);
      }
      var x = bbox.x,
        y = bbox.y,
        height = bbox.height || 0,
        width = bbox.width || 0;
      if (x < minX || minX === undefined) {
        minX = x;
      }
      if (y < minY || minY === undefined) {
        minY = y;
      }
      if (x + width > maxX || maxX === undefined) {
        maxX = x + width;
      }
      if (y + height > maxY || maxY === undefined) {
        maxY = y + height;
      }
    });
    return {
      x: minX,
      y: minY,
      height: maxY - minY,
      width: maxX - minX
    };
  }

  /**
   * Returns all elements that are enclosed from the bounding box.
   *
   *   * If bbox.(width|height) is not specified the method returns
   *     all elements with element.x/y > bbox.x/y
   *   * If only bbox.x or bbox.y is specified, method return all elements with
   *     e.x > bbox.x or e.y > bbox.y
   *
   * @param {Element[]} elements List of Elements to search through
   * @param {Rect} bbox the enclosing bbox.
   *
   * @return {Element[]} enclosed elements
   */
  function getEnclosedElements(elements, bbox) {
    var filteredElements = {};
    forEach$3(elements, function (element) {
      var e = element;
      if (e.waypoints) {
        e = getBBox(e);
      }
      if (!isNumber$3(bbox.y) && e.x > bbox.x) {
        filteredElements[element.id] = element;
      }
      if (!isNumber$3(bbox.x) && e.y > bbox.y) {
        filteredElements[element.id] = element;
      }
      if (e.x > bbox.x && e.y > bbox.y) {
        if (isNumber$3(bbox.width) && isNumber$3(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {
          filteredElements[element.id] = element;
        } else if (!isNumber$3(bbox.width) || !isNumber$3(bbox.height)) {
          filteredElements[element.id] = element;
        }
      }
    });
    return filteredElements;
  }

  /**
   * Get the element's type
   *
   * @param {Element} element
   *
   * @return {'connection' | 'shape' | 'root'}
   */
  function getType$1(element) {
    if ('waypoints' in element) {
      return 'connection';
    }
    if ('x' in element) {
      return 'shape';
    }
    return 'root';
  }

  /**
   * @param {Element} element
   *
   * @return {boolean}
   */
  function isFrameElement(element) {
    return !!(element && element.isFrame);
  }

  // helpers ///////////////////////////////

  function copyObject(src1, src2) {
    return assign$4({}, src1 || {}, src2 || {});
  }

  /**
   * @typedef {import('../core/EventBus').default} EventBus
   * @typedef {import('./Styles').default} Styles
   */

  // apply default renderer with lowest possible priority
  // so that it only kicks in if noone else could render
  var DEFAULT_RENDER_PRIORITY = 1;

  /**
   * The default renderer used for shapes and connections.
   *
   * @param {EventBus} eventBus
   * @param {Styles} styles
   */
  function DefaultRenderer(eventBus, styles) {
    BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);
    this.CONNECTION_STYLE = styles.style(['no-fill'], {
      strokeWidth: 5,
      stroke: 'fuchsia'
    });
    this.SHAPE_STYLE = styles.style({
      fill: 'white',
      stroke: 'fuchsia',
      strokeWidth: 2
    });
    this.FRAME_STYLE = styles.style(['no-fill'], {
      stroke: 'fuchsia',
      strokeDasharray: 4,
      strokeWidth: 2
    });
  }
  e$2(DefaultRenderer, BaseRenderer);

  /**
   * @private
   */
  DefaultRenderer.prototype.canRender = function () {
    return true;
  };

  /**
   * @private
   */
  DefaultRenderer.prototype.drawShape = function drawShape(visuals, element, attrs) {
    var rect = create$2('rect');
    attr(rect, {
      x: 0,
      y: 0,
      width: element.width || 0,
      height: element.height || 0
    });
    if (isFrameElement(element)) {
      attr(rect, assign$4({}, this.FRAME_STYLE, attrs || {}));
    } else {
      attr(rect, assign$4({}, this.SHAPE_STYLE, attrs || {}));
    }
    append(visuals, rect);
    return rect;
  };

  /**
   * @private
   */
  DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection, attrs) {
    var line = createLine(connection.waypoints, assign$4({}, this.CONNECTION_STYLE, attrs || {}));
    append(visuals, line);
    return line;
  };

  /**
   * @private
   */
  DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {
    var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;
    var shapePath = [['M', x, y], ['l', width, 0], ['l', 0, height], ['l', -width, 0], ['z']];
    return componentsToPath(shapePath);
  };

  /**
   * @private
   */
  DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
    var waypoints = connection.waypoints;
    var idx,
      point,
      connectionPath = [];
    for (idx = 0; point = waypoints[idx]; idx++) {
      // take invisible docking into account
      // when creating the path
      point = point.original || point;
      connectionPath.push([idx === 0 ? 'M' : 'L', point.x, point.y]);
    }
    return componentsToPath(connectionPath);
  };
  DefaultRenderer.$inject = ['eventBus', 'styles'];

  /**
   * A component that manages shape styles
   */
  function Styles() {
    var defaultTraits = {
      'no-fill': {
        fill: 'none'
      },
      'no-border': {
        strokeOpacity: 0.0
      },
      'no-events': {
        pointerEvents: 'none'
      }
    };
    var self = this;

    /**
     * Builds a style definition from a className, a list of traits and an object
     * of additional attributes.
     *
     * @param {string} className
     * @param {string[]} [traits]
     * @param {Object} [additionalAttrs]
     *
     * @return {Object} the style definition
     */
    this.cls = function (className, traits, additionalAttrs) {
      var attrs = this.style(traits, additionalAttrs);
      return assign$4(attrs, {
        'class': className
      });
    };

    /**
     * Builds a style definition from a list of traits and an object of additional
     * attributes.
     *
     * @param {string[]} [traits]
     * @param {Object} additionalAttrs
     *
     * @return {Object} the style definition
     */
    this.style = function (traits, additionalAttrs) {
      if (!isArray$6(traits) && !additionalAttrs) {
        additionalAttrs = traits;
        traits = [];
      }
      var attrs = reduce(traits, function (attrs, t) {
        return assign$4(attrs, defaultTraits[t] || {});
      }, {});
      return additionalAttrs ? assign$4(attrs, additionalAttrs) : attrs;
    };

    /**
     * Computes a style definition from a list of traits and an object of
     * additional attributes, with custom style definition object.
     *
     * @param {Object} custom
     * @param {string[]} [traits]
     * @param {Object} defaultStyles
     *
     * @return {Object} the style definition
     */
    this.computeStyle = function (custom, traits, defaultStyles) {
      if (!isArray$6(traits)) {
        defaultStyles = traits;
        traits = [];
      }
      return self.style(traits || [], assign$4({}, defaultStyles, custom || {}));
    };
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DrawModule$1 = {
    __init__: ['defaultRenderer'],
    defaultRenderer: ['type', DefaultRenderer],
    styles: ['type', Styles]
  };

  /**
   * Failsafe remove an element from a collection
   *
   * @param {Array<Object>} [collection]
   * @param {Object} [element]
   *
   * @return {number} the previous index of the element
   */
  function remove$2(collection, element) {
    if (!collection || !element) {
      return -1;
    }
    var idx = collection.indexOf(element);
    if (idx !== -1) {
      collection.splice(idx, 1);
    }
    return idx;
  }

  /**
   * Fail save add an element to the given connection, ensuring
   * it does not yet exist.
   *
   * @param {Array<Object>} collection
   * @param {Object} element
   * @param {number} [idx]
   */
  function add$2(collection, element, idx) {
    if (!collection || !element) {
      return;
    }
    if (typeof idx !== 'number') {
      idx = -1;
    }
    var currentIdx = collection.indexOf(element);
    if (currentIdx !== -1) {
      if (currentIdx === idx) {
        // nothing to do, position has not changed
        return;
      } else {
        if (idx !== -1) {
          // remove from current position
          collection.splice(currentIdx, 1);
        } else {
          // already exists in collection
          return;
        }
      }
    }
    if (idx !== -1) {
      // insert at specified position
      collection.splice(idx, 0, element);
    } else {
      // push to end
      collection.push(element);
    }
  }

  /**
   * Fail save get the index of an element in a collection.
   *
   * @param {Array<Object>} collection
   * @param {Object} element
   *
   * @return {number} the index or -1 if collection or element do
   *                  not exist or the element is not contained.
   */
  function indexOf(collection, element) {
    if (!collection || !element) {
      return -1;
    }
    return collection.indexOf(element);
  }

  /**
   * @typedef {import('../util/Types').Axis} Axis
   * @typedef {import('../util/Types').Point} Point
   * @typedef {import('../util/Types').Rect} Rect
   */

  /**
   * Computes the distance between two points.
   *
   * @param {Point} a
   * @param {Point} b
   *
   * @return {number} The distance between the two points.
   */
  function pointDistance(a, b) {
    if (!a || !b) {
      return -1;
    }
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  }

  /**
   * Returns true if the point r is on the line between p and q.
   *
   * @param {Point} p
   * @param {Point} q
   * @param {Point} r
   * @param {number} [accuracy=5] The accuracy with which to check (lower is better).
   *
   * @return {boolean}
   */
  function pointsOnLine(p, q, r, accuracy) {
    if (typeof accuracy === 'undefined') {
      accuracy = 5;
    }
    if (!p || !q || !r) {
      return false;
    }
    var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
      dist = pointDistance(p, q);

    // @see http://stackoverflow.com/a/907491/412190
    return Math.abs(val / dist) <= accuracy;
  }
  var ALIGNED_THRESHOLD = 2;

  /**
   * Check whether two points are horizontally or vertically aligned.
   *
   * @param {Point[]|Point} a
   * @param {Point} [b]
   *
   * @return {string|boolean} If and how the two points are aligned ('h', 'v' or `false`).
   */
  function pointsAligned(a, b) {
    var points = Array.from(arguments).flat();
    var axisMap = {
      'x': 'v',
      'y': 'h'
    };
    for (var _i = 0, _Object$entries = Object.entries(axisMap); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2),
        axis = _Object$entries$_i[0],
        orientation = _Object$entries$_i[1];
      if (pointsAlignedOnAxis(axis, points)) {
        return orientation;
      }
    }
    return false;
  }

  /**
   * @param {Axis} axis
   * @param {Point[]} points
   *
   * @return {boolean}
   */
  function pointsAlignedOnAxis(axis, points) {
    var referencePoint = points[0];
    return every(points, function (point) {
      return Math.abs(referencePoint[axis] - point[axis]) <= ALIGNED_THRESHOLD;
    });
  }

  /**
   * Returns a point in the middle of points p and q
   *
   * @param {Point} p
   * @param {Point} q
   *
   * @return {Point} The mid point between the two points.
   */
  function getMidPoint(p, q) {
    return {
      x: Math.round(p.x + (q.x - p.x) / 2.0),
      y: Math.round(p.y + (q.y - p.y) / 2.0)
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  /**
   * This file contains source code adapted from Snap.svg (licensed Apache-2.0).
   *
   * @see https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js
   */

  /* eslint no-fallthrough: "off" */

  var p2s = /,?([a-z]),?/gi,
    toFloat = parseFloat,
    math = Math,
    PI = math.PI,
    mmin = math.min,
    mmax = math.max,
    pow = math.pow,
    abs$2 = math.abs,
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;
  var isArray$1 = Array.isArray || function (o) {
    return o instanceof Array;
  };
  function hasProperty(obj, property) {
    return Object.prototype.hasOwnProperty.call(obj, property);
  }
  function clone(obj) {
    if (typeof obj == 'function' || Object(obj) !== obj) {
      return obj;
    }
    var res = new obj.constructor();
    for (var key in obj) {
      if (hasProperty(obj, key)) {
        res[key] = clone(obj[key]);
      }
    }
    return res;
  }
  function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
      return array.push(array.splice(i, 1)[0]);
    }
  }
  function cacher(f) {
    function newf() {
      var arg = Array.prototype.slice.call(arguments, 0),
        args = arg.join("\u2400"),
        cache = newf.cache = newf.cache || {},
        count = newf.count = newf.count || [];
      if (hasProperty(cache, args)) {
        repush(count, args);
        return cache[args];
      }
      count.length >= 1e3 && delete cache[count.shift()];
      count.push(args);
      cache[args] = f.apply(0, arg);
      return cache[args];
    }
    return newf;
  }
  function parsePathString(pathString) {
    if (!pathString) {
      return null;
    }
    var pth = paths(pathString);
    if (pth.arr) {
      return clone(pth.arr);
    }
    var paramCounts = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
      },
      data = [];
    if (isArray$1(pathString) && isArray$1(pathString[0])) {
      // rough assumption
      data = clone(pathString);
    }
    if (!data.length) {
      String(pathString).replace(pathCommand, function (a, b, c) {
        var params = [],
          name = b.toLowerCase();
        c.replace(pathValues, function (a, b) {
          b && params.push(+b);
        });
        if (name == 'm' && params.length > 2) {
          data.push([b].concat(params.splice(0, 2)));
          name = 'l';
          b = b == 'm' ? 'l' : 'L';
        }
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      });
    }
    data.toString = paths.toString;
    pth.arr = clone(data);
    return data;
  }
  function paths(ps) {
    var p = paths.ps = paths.ps || {};
    if (p[ps]) {
      p[ps].sleep = 100;
    } else {
      p[ps] = {
        sleep: 100
      };
    }
    setTimeout(function () {
      for (var key in p) {
        if (hasProperty(p, key) && key != ps) {
          p[key].sleep--;
          !p[key].sleep && delete p[key];
        }
      }
    });
    return p[ps];
  }
  function rectBBox(x, y, width, height) {
    if (arguments.length === 1) {
      y = x.y;
      width = x.width;
      height = x.height;
      x = x.x;
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height,
      x2: x + width,
      y2: y + height
    };
  }
  function pathToString() {
    return this.join(',').replace(p2s, '$1');
  }
  function pathClone(pathArray) {
    var res = clone(pathArray);
    res.toString = pathToString;
    return res;
  }
  function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t,
      t13 = pow(t1, 3),
      t12 = pow(t1, 2),
      t2 = t * t,
      t3 = t2 * t,
      x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
      y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
    return {
      x: fixError(x),
      y: fixError(y)
    };
  }
  function bezierBBox(points) {
    var bbox = curveBBox.apply(null, points);
    return rectBBox(bbox.x0, bbox.y0, bbox.x1 - bbox.x0, bbox.y1 - bbox.y0);
  }
  function isPointInsideBBox(bbox, x, y) {
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
  }
  function isBBoxIntersect(bbox1, bbox2) {
    bbox1 = rectBBox(bbox1);
    bbox2 = rectBBox(bbox2);
    return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
  }
  function base3(t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
  }
  function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z == null) {
      z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2,
      n = 12,
      Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],
      Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
      sum = 0;
    for (var i = 0; i < n; i++) {
      var ct = z2 * Tvalues[i] + z2,
        xbase = base3(ct, x1, x2, x3, x4),
        ybase = base3(ct, y1, y2, y3, y4),
        comb = xbase * xbase + ybase * ybase;
      sum += Cvalues[i] * math.sqrt(comb);
    }
    return z2 * sum;
  }
  function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {
    if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
      return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
      return;
    }
    var px = fixError(nx / denominator),
      py = fixError(ny / denominator),
      px2 = +px.toFixed(2),
      py2 = +py.toFixed(2);
    if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
      return;
    }
    return {
      x: px,
      y: py
    };
  }
  function fixError(number) {
    return Math.round(number * 100000000000) / 100000000000;
  }
  function findBezierIntersections(bez1, bez2, justCount) {
    var bbox1 = bezierBBox(bez1),
      bbox2 = bezierBBox(bez2);
    if (!isBBoxIntersect(bbox1, bbox2)) {
      return justCount ? 0 : [];
    }

    // As an optimization, lines will have only 1 segment

    var l1 = bezlen.apply(0, bez1),
      l2 = bezlen.apply(0, bez2),
      n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1,
      n2 = isLine(bez2) ? 1 : ~~(l2 / 5) || 1,
      dots1 = [],
      dots2 = [],
      xy = {},
      res = justCount ? 0 : [];
    for (var i = 0; i < n1 + 1; i++) {
      var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
      dots1.push({
        x: p.x,
        y: p.y,
        t: i / n1
      });
    }
    for (i = 0; i < n2 + 1; i++) {
      p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
      dots2.push({
        x: p.x,
        y: p.y,
        t: i / n2
      });
    }
    for (i = 0; i < n1; i++) {
      for (var j = 0; j < n2; j++) {
        var di = dots1[i],
          di1 = dots1[i + 1],
          dj = dots2[j],
          dj1 = dots2[j + 1],
          ci = abs$2(di1.x - di.x) < .01 ? 'y' : 'x',
          cj = abs$2(dj1.x - dj.x) < .01 ? 'y' : 'x',
          is = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y),
          key;
        if (is) {
          key = is.x.toFixed(9) + '#' + is.y.toFixed(9);
          if (xy[key]) {
            continue;
          }
          xy[key] = true;
          var t1 = di.t + abs$2((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
            t2 = dj.t + abs$2((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
          if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
            if (justCount) {
              res++;
            } else {
              res.push({
                x: is.x,
                y: is.y,
                t1: t1,
                t2: t2
              });
            }
          }
        }
      }
    }
    return res;
  }

  /**
   * Find or counts the intersections between two SVG paths.
   *
   * Returns a number in counting mode and a list of intersections otherwise.
   *
   * A single intersection entry contains the intersection coordinates (x, y)
   * as well as additional information regarding the intersecting segments
   * on each path (segment1, segment2) and the relative location of the
   * intersection on these segments (t1, t2).
   *
   * The path may be an SVG path string or a list of path components
   * such as `[ [ 'M', 0, 10 ], [ 'L', 20, 0 ] ]`.
   *
   * @example
   *
   * var intersections = findPathIntersections(
   *   'M0,0L100,100',
   *   [ [ 'M', 0, 100 ], [ 'L', 100, 0 ] ]
   * );
   *
   * // intersections = [
   * //   { x: 50, y: 50, segment1: 1, segment2: 1, t1: 0.5, t2: 0.5 }
   * // ]
   *
   * @param {String|Array<PathDef>} path1
   * @param {String|Array<PathDef>} path2
   * @param {Boolean} [justCount=false]
   *
   * @return {Array<Intersection>|Number}
   */
  function findPathIntersections(path1, path2, justCount) {
    path1 = pathToCurve(path1);
    path2 = pathToCurve(path2);
    var x1,
      y1,
      x2,
      y2,
      x1m,
      y1m,
      x2m,
      y2m,
      bez1,
      bez2,
      res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
      var pi = path1[i];
      if (pi[0] == 'M') {
        x1 = x1m = pi[1];
        y1 = y1m = pi[2];
      } else {
        if (pi[0] == 'C') {
          bez1 = [x1, y1].concat(pi.slice(1));
          x1 = bez1[6];
          y1 = bez1[7];
        } else {
          bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
          x1 = x1m;
          y1 = y1m;
        }
        for (var j = 0, jj = path2.length; j < jj; j++) {
          var pj = path2[j];
          if (pj[0] == 'M') {
            x2 = x2m = pj[1];
            y2 = y2m = pj[2];
          } else {
            if (pj[0] == 'C') {
              bez2 = [x2, y2].concat(pj.slice(1));
              x2 = bez2[6];
              y2 = bez2[7];
            } else {
              bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
              x2 = x2m;
              y2 = y2m;
            }
            var intr = findBezierIntersections(bez1, bez2, justCount);
            if (justCount) {
              res += intr;
            } else {
              for (var k = 0, kk = intr.length; k < kk; k++) {
                intr[k].segment1 = i;
                intr[k].segment2 = j;
                intr[k].bez1 = bez1;
                intr[k].bez2 = bez2;
              }
              res = res.concat(intr);
            }
          }
        }
      }
    }
    return res;
  }
  function pathToAbsolute(pathArray) {
    var pth = paths(pathArray);
    if (pth.abs) {
      return pathClone(pth.abs);
    }
    if (!isArray$1(pathArray) || !isArray$1(pathArray && pathArray[0])) {
      // rough assumption
      pathArray = parsePathString(pathArray);
    }
    if (!pathArray || !pathArray.length) {
      return [['M', 0, 0]];
    }
    var res = [],
      x = 0,
      y = 0,
      mx = 0,
      my = 0,
      start = 0,
      pa0;
    if (pathArray[0][0] == 'M') {
      x = +pathArray[0][1];
      y = +pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[0] = ['M', x, y];
    }
    for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
      res.push(r = []);
      pa = pathArray[i];
      pa0 = pa[0];
      if (pa0 != pa0.toUpperCase()) {
        r[0] = pa0.toUpperCase();
        switch (r[0]) {
          case 'A':
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +pa[6] + x;
            r[7] = +pa[7] + y;
            break;
          case 'V':
            r[1] = +pa[1] + y;
            break;
          case 'H':
            r[1] = +pa[1] + x;
            break;
          case 'M':
            mx = +pa[1] + x;
            my = +pa[2] + y;
          default:
            for (var j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
        }
      } else {
        for (var k = 0, kk = pa.length; k < kk; k++) {
          r[k] = pa[k];
        }
      }
      pa0 = pa0.toUpperCase();
      switch (r[0]) {
        case 'Z':
          x = +mx;
          y = +my;
          break;
        case 'H':
          x = r[1];
          break;
        case 'V':
          y = r[1];
          break;
        case 'M':
          mx = r[r.length - 2];
          my = r[r.length - 1];
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
    res.toString = pathToString;
    pth.abs = pathClone(res);
    return res;
  }
  function isLine(bez) {
    return bez[0] === bez[2] && bez[1] === bez[3] && bez[4] === bez[6] && bez[5] === bez[7];
  }
  function lineToCurve(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
  }
  function qubicToCurve(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3,
      _23 = 2 / 3;
    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
  }
  function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    var _120 = PI * 120 / 180,
      rad = PI / 180 * (+angle || 0),
      res = [],
      xy,
      rotate = cacher(function (x, y, rad) {
        var X = x * math.cos(rad) - y * math.sin(rad),
          Y = x * math.sin(rad) + y * math.cos(rad);
        return {
          x: X,
          y: Y
        };
      });
    if (!recursive) {
      xy = rotate(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      xy = rotate(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;
      var x = (x1 - x2) / 2,
        y = (y1 - y2) / 2;
      var h = x * x / (rx * rx) + y * y / (ry * ry);
      if (h > 1) {
        h = math.sqrt(h);
        rx = h * rx;
        ry = h * ry;
      }
      var rx2 = rx * rx,
        ry2 = ry * ry,
        k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs$2((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
        cx = k * rx * y / ry + (x1 + x2) / 2,
        cy = k * -ry * x / rx + (y1 + y2) / 2,
        f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
        f2 = math.asin(((y2 - cy) / ry).toFixed(9));
      f1 = x1 < cx ? PI - f1 : f1;
      f2 = x2 < cx ? PI - f2 : f2;
      f1 < 0 && (f1 = PI * 2 + f1);
      f2 < 0 && (f2 = PI * 2 + f2);
      if (sweep_flag && f1 > f2) {
        f1 = f1 - PI * 2;
      }
      if (!sweep_flag && f2 > f1) {
        f2 = f2 - PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }
    var df = f2 - f1;
    if (abs$2(df) > _120) {
      var f2old = f2,
        x2old = x2,
        y2old = y2;
      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * math.cos(f2);
      y2 = cy + ry * math.sin(f2);
      res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = math.cos(f1),
      s1 = math.sin(f1),
      c2 = math.cos(f2),
      s2 = math.sin(f2),
      t = math.tan(df / 4),
      hx = 4 / 3 * rx * t,
      hy = 4 / 3 * ry * t,
      m1 = [x1, y1],
      m2 = [x1 + hx * s1, y1 - hy * c1],
      m3 = [x2 + hx * s2, y2 - hy * c2],
      m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
      return [m2, m3, m4].concat(res);
    } else {
      res = [m2, m3, m4].concat(res).join().split(',');
      var newres = [];
      for (var i = 0, ii = res.length; i < ii; i++) {
        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
      }
      return newres;
    }
  }

  // Returns bounding box of cubic bezier curve.
  // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  // Original version: NISHIO Hirokazu
  // Modifications: https://github.com/timo22345
  function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [],
      bounds = [[], []],
      a,
      b,
      c,
      t,
      t1,
      t2,
      b2ac,
      sqrtb2ac;
    for (var i = 0; i < 2; ++i) {
      if (i == 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (abs$2(a) < 1e-12) {
        if (abs$2(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      sqrtb2ac = math.sqrt(b2ac);
      if (b2ac < 0) {
        continue;
      }
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }
    var j = tvalues.length,
      jlen = j,
      mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return {
      x0: mmin.apply(0, bounds[0]),
      y0: mmin.apply(0, bounds[1]),
      x1: mmax.apply(0, bounds[0]),
      y1: mmax.apply(0, bounds[1])
    };
  }
  function pathToCurve(path) {
    var pth = paths(path);

    // return cached curve, if existing
    if (pth.curve) {
      return pathClone(pth.curve);
    }
    var curvedPath = pathToAbsolute(path),
      attrs = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
      },
      processPath = function processPath(path, d, pathCommand) {
        var nx, ny;
        if (!path) {
          return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }
        !(path[0] in {
          T: 1,
          Q: 1
        }) && (d.qx = d.qy = null);
        switch (path[0]) {
          case 'M':
            d.X = path[1];
            d.Y = path[2];
            break;
          case 'A':
            path = ['C'].concat(arcToCurve.apply(0, [d.x, d.y].concat(path.slice(1))));
            break;
          case 'S':
            if (pathCommand == 'C' || pathCommand == 'S') {
              // In 'S' case we have to take into account, if the previous command is C/S.
              nx = d.x * 2 - d.bx;

              // And reflect the previous
              ny = d.y * 2 - d.by;

              // command's control point relative to the current point.
            } else {
              // or some else or nothing
              nx = d.x;
              ny = d.y;
            }
            path = ['C', nx, ny].concat(path.slice(1));
            break;
          case 'T':
            if (pathCommand == 'Q' || pathCommand == 'T') {
              // In 'T' case we have to take into account, if the previous command is Q/T.
              d.qx = d.x * 2 - d.qx;

              // And make a reflection similar
              d.qy = d.y * 2 - d.qy;

              // to case 'S'.
            } else {
              // or something else or nothing
              d.qx = d.x;
              d.qy = d.y;
            }
            path = ['C'].concat(qubicToCurve(d.x, d.y, d.qx, d.qy, path[1], path[2]));
            break;
          case 'Q':
            d.qx = path[1];
            d.qy = path[2];
            path = ['C'].concat(qubicToCurve(d.x, d.y, path[1], path[2], path[3], path[4]));
            break;
          case 'L':
            path = ['C'].concat(lineToCurve(d.x, d.y, path[1], path[2]));
            break;
          case 'H':
            path = ['C'].concat(lineToCurve(d.x, d.y, path[1], d.y));
            break;
          case 'V':
            path = ['C'].concat(lineToCurve(d.x, d.y, d.x, path[1]));
            break;
          case 'Z':
            path = ['C'].concat(lineToCurve(d.x, d.y, d.X, d.Y));
            break;
        }
        return path;
      },
      fixArc = function fixArc(pp, i) {
        if (pp[i].length > 7) {
          pp[i].shift();
          var pi = pp[i];
          while (pi.length) {
            pathCommands[i] = 'A'; // if created multiple C:s, their original seg is saved
            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
          }
          pp.splice(i, 1);
          ii = curvedPath.length;
        }
      },
      pathCommands = [],
      // path commands of original path p
      pfirst = '',
      // temporary holder for original path command
      pathCommand = ''; // holder for previous path command of original path

    for (var i = 0, ii = curvedPath.length; i < ii; i++) {
      curvedPath[i] && (pfirst = curvedPath[i][0]); // save current path command

      if (pfirst != 'C')
        // C is not saved yet, because it may be result of conversion
        {
          pathCommands[i] = pfirst; // Save current path command
          i && (pathCommand = pathCommands[i - 1]); // Get previous path command pathCommand
        }

      curvedPath[i] = processPath(curvedPath[i], attrs, pathCommand); // Previous path command is inputted to processPath

      if (pathCommands[i] != 'A' && pfirst == 'C') pathCommands[i] = 'C'; // A is the only command
      // which may produce multiple C:s
      // so we have to make sure that C is also C in original path

      fixArc(curvedPath, i); // fixArc adds also the right amount of A:s to pathCommands

      var seg = curvedPath[i],
        seglen = seg.length;
      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
    }

    // cache curve
    pth.curve = pathClone(curvedPath);
    return curvedPath;
  }
  var intersect = findPathIntersections;
  var intersectPaths = /*@__PURE__*/getDefaultExportFromCjs(intersect);

  /**
   * Checks whether a value is an instance of Connection.
   *
   * @param {any} value
   *
   * @return {boolean}
   */
  function isConnection(value) {
    return isObject$2(value) && has$3(value, 'waypoints');
  }

  /**
   * Checks whether a value is an instance of Label.
   *
   * @param {any} value
   *
   * @return {boolean}
   */
  function isLabel$1(value) {
    return isObject$2(value) && has$3(value, 'labelTarget');
  }

  /**
   * @typedef {import('../core/Types').ElementLike} Element
   * @typedef {import('../core/Types').ConnectionLike} Connection
   *
   * @typedef {import('../util/Types').DirectionTRBL} DirectionTRBL
   * @typedef {import('../util/Types').Point} Point
   * @typedef {import('../util/Types').Rect} Rect
   * @typedef {import('../util/Types').RectTRBL} RectTRBL
   */

  /**
   * @param {Rect} bounds
   *
   * @returns {Rect}
   */
  function roundBounds(bounds) {
    return {
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height)
    };
  }

  /**
   * @param {Point} point
   *
   * @returns {Point}
   */
  function roundPoint(point) {
    return {
      x: Math.round(point.x),
      y: Math.round(point.y)
    };
  }

  /**
   * Convert the given bounds to a { top, left, bottom, right } descriptor.
   *
   * @param {Point|Rect} bounds
   *
   * @return {RectTRBL}
   */
  function asTRBL(bounds) {
    return {
      top: bounds.y,
      right: bounds.x + (bounds.width || 0),
      bottom: bounds.y + (bounds.height || 0),
      left: bounds.x
    };
  }

  /**
   * Convert a { top, left, bottom, right } to an objects bounds.
   *
   * @param {RectTRBL} trbl
   *
   * @return {Rect}
   */
  function asBounds(trbl) {
    return {
      x: trbl.left,
      y: trbl.top,
      width: trbl.right - trbl.left,
      height: trbl.bottom - trbl.top
    };
  }

  /**
   * Get the mid of the given bounds or point.
   *
   * @param {Point|Rect} bounds
   *
   * @return {Point}
   */
  function getBoundsMid(bounds) {
    return roundPoint({
      x: bounds.x + (bounds.width || 0) / 2,
      y: bounds.y + (bounds.height || 0) / 2
    });
  }

  /**
   * Get the mid of the given Connection.
   *
   * @param {Connection} connection
   *
   * @return {Point}
   */
  function getConnectionMid(connection) {
    var waypoints = connection.waypoints;

    // calculate total length and length of each segment
    var parts = waypoints.reduce(function (parts, point, index) {
      var lastPoint = waypoints[index - 1];
      if (lastPoint) {
        var lastPart = parts[parts.length - 1];
        var startLength = lastPart && lastPart.endLength || 0;
        var length = distance(lastPoint, point);
        parts.push({
          start: lastPoint,
          end: point,
          startLength: startLength,
          endLength: startLength + length,
          length: length
        });
      }
      return parts;
    }, []);
    var totalLength = parts.reduce(function (length, part) {
      return length + part.length;
    }, 0);

    // find which segement contains middle point
    var midLength = totalLength / 2;
    var i = 0;
    var midSegment = parts[i];
    while (midSegment.endLength < midLength) {
      midSegment = parts[++i];
    }

    // calculate relative position on mid segment
    var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;
    var midPoint = {
      x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,
      y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress
    };
    return midPoint;
  }

  /**
   * Get the mid of the given Element.
   *
   * @param {Element} element
   *
   * @return {Point}
   */
  function getMid(element) {
    if (isConnection(element)) {
      return getConnectionMid(element);
    }
    return getBoundsMid(element);
  }

  // orientation utils //////////////////////

  /**
   * Get orientation of the given rectangle with respect to
   * the reference rectangle.
   *
   * A padding (positive or negative) may be passed to influence
   * horizontal / vertical orientation and intersection.
   *
   * @param {Rect} rect
   * @param {Rect} reference
   * @param {Point|number} padding
   *
   * @return {DirectionTRBL} the orientation; one of top, top-left, left, ..., bottom, right or intersect.
   */
  function getOrientation(rect, reference, padding) {
    padding = padding || 0;

    // make sure we can use an object, too
    // for individual { x, y } padding
    if (!isObject$2(padding)) {
      padding = {
        x: padding,
        y: padding
      };
    }
    var rectOrientation = asTRBL(rect),
      referenceOrientation = asTRBL(reference);
    var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,
      right = rectOrientation.left - padding.x >= referenceOrientation.right,
      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,
      left = rectOrientation.right + padding.x <= referenceOrientation.left;
    var vertical = top ? 'top' : bottom ? 'bottom' : null,
      horizontal = left ? 'left' : right ? 'right' : null;
    if (horizontal && vertical) {
      return vertical + '-' + horizontal;
    } else {
      return horizontal || vertical || 'intersect';
    }
  }

  // intersection utils //////////////////////

  /**
   * Get intersection between an element and a line path.
   *
   * @param {string} elementPath
   * @param {string} linePath
   * @param {boolean} cropStart Whether to crop start or end.
   *
   * @return {Point}
   */
  function getElementLineIntersection(elementPath, linePath, cropStart) {
    var intersections = getIntersections(elementPath, linePath);

    // recognize intersections
    // only one -> choose
    // two close together -> choose first
    // two or more distinct -> pull out appropriate one
    // none -> ok (fallback to point itself)
    if (intersections.length === 1) {
      return roundPoint(intersections[0]);
    } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
      return roundPoint(intersections[0]);
    } else if (intersections.length > 1) {
      // sort by intersections based on connection segment +
      // distance from start
      intersections = sortBy(intersections, function (i) {
        var distance = Math.floor(i.t2 * 100) || 1;
        distance = 100 - distance;
        distance = (distance < 10 ? '0' : '') + distance;

        // create a sort string that makes sure we sort
        // line segment ASC + line segment position DESC (for cropStart)
        // line segment ASC + line segment position ASC (for cropEnd)
        return i.segment2 + '#' + distance;
      });
      return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
    }
    return null;
  }
  function getIntersections(a, b) {
    return intersectPaths(a, b);
  }
  function filterRedundantWaypoints(waypoints) {
    // alter copy of waypoints, not original
    waypoints = waypoints.slice();
    var idx = 0,
      point,
      previousPoint,
      nextPoint;
    while (waypoints[idx]) {
      point = waypoints[idx];
      previousPoint = waypoints[idx - 1];
      nextPoint = waypoints[idx + 1];
      if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {
        // remove point, if overlapping with {nextPoint}
        // or on line with {previousPoint} -> {point} -> {nextPoint}
        waypoints.splice(idx, 1);
      } else {
        idx++;
      }
    }
    return waypoints;
  }

  // helpers //////////////////////

  function distance(a, b) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  }

  /**
   * @typedef {import('./Types').ConnectionLike} ConnectionLike
   * @typedef {import('./Types').RootLike} RootLike
   * @typedef {import('./Types').ParentLike } ParentLike
   * @typedef {import('./Types').ShapeLike} ShapeLike
   *
   * @typedef { {
   *   container?: HTMLElement;
   *   deferUpdate?: boolean;
   *   width?: number;
   *   height?: number;
   * } } CanvasConfig
   * @typedef { {
   *   group: SVGElement;
   *   index: number;
   *   visible: boolean;
   * } } CanvasLayer
   * @typedef { {
   *   [key: string]: CanvasLayer;
   * } } CanvasLayers
   * @typedef { {
   *   rootElement: ShapeLike;
   *   layer: CanvasLayer;
   * } } CanvasPlane
   * @typedef { {
   *   scale: number;
   *   inner: Rect;
   *   outer: Dimensions;
   * } & Rect } CanvasViewbox
   *
   * @typedef {import('./ElementRegistry').default} ElementRegistry
   * @typedef {import('./EventBus').default} EventBus
   * @typedef {import('./GraphicsFactory').default} GraphicsFactory
   *
   * @typedef {import('../util/Types').Dimensions} Dimensions
   * @typedef {import('../util/Types').Point} Point
   * @typedef {import('../util/Types').Rect} Rect
   * @typedef {import('../util/Types').RectTRBL} RectTRBL
   */

  function round$9(number, resolution) {
    return Math.round(number * resolution) / resolution;
  }
  function ensurePx(number) {
    return isNumber$3(number) ? number + 'px' : number;
  }
  function findRoot(element) {
    while (element.parent) {
      element = element.parent;
    }
    return element;
  }

  /**
   * Creates a HTML container element for a SVG element with
   * the given configuration
   *
   * @param {CanvasConfig} options
   *
   * @return {HTMLElement} the container element
   */
  function createContainer(options) {
    options = assign$4({}, {
      width: '100%',
      height: '100%'
    }, options);
    var container = options.container || document.body;

    // create a <div> around the svg element with the respective size
    // this way we can always get the correct container size
    // (this is impossible for <svg> elements at the moment)
    var parent = document.createElement('div');
    parent.setAttribute('class', 'djs-container djs-parent');
    assign(parent, {
      position: 'relative',
      overflow: 'hidden',
      width: ensurePx(options.width),
      height: ensurePx(options.height)
    });
    container.appendChild(parent);
    return parent;
  }
  function createGroup(parent, cls, childIndex) {
    var group = create$2('g');
    classes(group).add(cls);
    var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;

    // must ensure second argument is node or _null_
    // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore
    parent.insertBefore(group, parent.childNodes[index] || null);
    return group;
  }
  var BASE_LAYER = 'base';

  // render plane contents behind utility layers
  var PLANE_LAYER_INDEX = 0;
  var UTILITY_LAYER_INDEX = 1;
  var REQUIRED_MODEL_ATTRS = {
    shape: ['x', 'y', 'width', 'height'],
    connection: ['waypoints']
  };

  /**
   * The main drawing canvas.
   *
   * @class
   * @constructor
   *
   * @emits Canvas#canvas.init
   *
   * @param {CanvasConfig|null} config
   * @param {EventBus} eventBus
   * @param {GraphicsFactory} graphicsFactory
   * @param {ElementRegistry} elementRegistry
   */
  function Canvas(config, eventBus, graphicsFactory, elementRegistry) {
    this._eventBus = eventBus;
    this._elementRegistry = elementRegistry;
    this._graphicsFactory = graphicsFactory;

    /**
     * @type {number}
     */
    this._rootsIdx = 0;

    /**
     * @type {CanvasLayers}
     */
    this._layers = {};

    /**
     * @type {CanvasPlane[]}
     */
    this._planes = [];

    /**
     * @type {RootLike|null}
     */
    this._rootElement = null;
    this._init(config || {});
  }
  Canvas.$inject = ['config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry'];

  /**
   * Creates a <svg> element that is wrapped into a <div>.
   * This way we are always able to correctly figure out the size of the svg element
   * by querying the parent node.

   * (It is not possible to get the size of a svg element cross browser @ 2014-04-01)

   * <div class="djs-container" style="width: {desired-width}, height: {desired-height}">
   *   <svg width="100%" height="100%">
   *    ...
   *   </svg>
   * </div>
   *
   * @param {CanvasConfig} config
   */
  Canvas.prototype._init = function (config) {
    var _this = this;
    var eventBus = this._eventBus;

    // html container
    var container = this._container = createContainer(config);
    var svg = this._svg = create$2('svg');
    attr(svg, {
      width: '100%',
      height: '100%'
    });
    append(container, svg);
    var viewport = this._viewport = createGroup(svg, 'viewport');

    // debounce canvas.viewbox.changed events when deferUpdate is set
    // to help with potential performance issues
    if (config.deferUpdate) {
      this._viewboxChanged = debounce(bind$3(this._viewboxChanged, this), 300);
    }
    eventBus.on('diagram.init', function () {
      /**
       * An event indicating that the canvas is ready to be drawn on.
       *
       * @memberOf Canvas
       *
       * @event canvas.init
       *
       * @type {Object}
       * @property {SVGElement} svg the created svg element
       * @property {SVGElement} viewport the direct parent of diagram elements and shapes
       */
      eventBus.fire('canvas.init', {
        svg: svg,
        viewport: viewport
      });
    });

    // reset viewbox on shape changes to
    // recompute the viewbox
    eventBus.on(['shape.added', 'connection.added', 'shape.removed', 'connection.removed', 'elements.changed', 'root.set'], function () {
      delete _this._cachedViewbox;
    });
    eventBus.on('diagram.destroy', 500, this._destroy, this);
    eventBus.on('diagram.clear', 500, this._clear, this);
  };
  Canvas.prototype._destroy = function () {
    this._eventBus.fire('canvas.destroy', {
      svg: this._svg,
      viewport: this._viewport
    });
    var parent = this._container.parentNode;
    if (parent) {
      parent.removeChild(this._container);
    }
    delete this._svg;
    delete this._container;
    delete this._layers;
    delete this._planes;
    delete this._rootElement;
    delete this._viewport;
  };
  Canvas.prototype._clear = function () {
    var _this2 = this;
    var allElements = this._elementRegistry.getAll();

    // remove all elements
    allElements.forEach(function (element) {
      var type = getType$1(element);
      if (type === 'root') {
        _this2.removeRootElement(element);
      } else {
        _this2._removeElement(element, type);
      }
    });

    // remove all planes
    this._planes = [];
    this._rootElement = null;

    // force recomputation of view box
    delete this._cachedViewbox;
  };

  /**
   * Returns the default layer on which
   * all elements are drawn.
   *
   * @return {SVGElement}  The SVG element of the layer.
   */
  Canvas.prototype.getDefaultLayer = function () {
    return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);
  };

  /**
   * Returns a layer that is used to draw elements
   * or annotations on it.
   *
   * Non-existing layers retrieved through this method
   * will be created. During creation, the optional index
   * may be used to create layers below or above existing layers.
   * A layer with a certain index is always created above all
   * existing layers with the same index.
   *
   * @param {string} name The name of the layer.
   * @param {number} [index] The index of the layer.
   *
   * @return {SVGElement} The SVG element of the layer.
   */
  Canvas.prototype.getLayer = function (name, index) {
    if (!name) {
      throw new Error('must specify a name');
    }
    var layer = this._layers[name];
    if (!layer) {
      layer = this._layers[name] = this._createLayer(name, index);
    }

    // throw an error if layer creation / retrival is
    // requested on different index
    if (typeof index !== 'undefined' && layer.index !== index) {
      throw new Error('layer <' + name + '> already created at index <' + index + '>');
    }
    return layer.group;
  };

  /**
   * For a given index, return the number of layers that have a higher index and
   * are visible.
   *
   * This is used to determine the node a layer should be inserted at.
   *
   * @param {number} index
   *
   * @return {number}
   */
  Canvas.prototype._getChildIndex = function (index) {
    return reduce(this._layers, function (childIndex, layer) {
      if (layer.visible && index >= layer.index) {
        childIndex++;
      }
      return childIndex;
    }, 0);
  };

  /**
   * Creates a given layer and returns it.
   *
   * @param {string} name
   * @param {number} [index=0]
   *
   * @return {CanvasLayer}
   */
  Canvas.prototype._createLayer = function (name, index) {
    if (typeof index === 'undefined') {
      index = UTILITY_LAYER_INDEX;
    }
    var childIndex = this._getChildIndex(index);
    return {
      group: createGroup(this._viewport, 'layer-' + name, childIndex),
      index: index,
      visible: true
    };
  };

  /**
   * Shows a given layer.
   *
   * @param {string} name The name of the layer.
   *
   * @return {SVGElement} The SVG element of the layer.
   */
  Canvas.prototype.showLayer = function (name) {
    if (!name) {
      throw new Error('must specify a name');
    }
    var layer = this._layers[name];
    if (!layer) {
      throw new Error('layer <' + name + '> does not exist');
    }
    var viewport = this._viewport;
    var group = layer.group;
    var index = layer.index;
    if (layer.visible) {
      return group;
    }
    var childIndex = this._getChildIndex(index);
    viewport.insertBefore(group, viewport.childNodes[childIndex] || null);
    layer.visible = true;
    return group;
  };

  /**
   * Hides a given layer.
   *
   * @param {string} name The name of the layer.
   *
   * @return {SVGElement} The SVG element of the layer.
   */
  Canvas.prototype.hideLayer = function (name) {
    if (!name) {
      throw new Error('must specify a name');
    }
    var layer = this._layers[name];
    if (!layer) {
      throw new Error('layer <' + name + '> does not exist');
    }
    var group = layer.group;
    if (!layer.visible) {
      return group;
    }
    remove$3(group);
    layer.visible = false;
    return group;
  };
  Canvas.prototype._removeLayer = function (name) {
    var layer = this._layers[name];
    if (layer) {
      delete this._layers[name];
      remove$3(layer.group);
    }
  };

  /**
   * Returns the currently active layer. Can be null.
   *
   * @return {CanvasLayer|null} The active layer of `null`.
   */
  Canvas.prototype.getActiveLayer = function () {
    var plane = this._findPlaneForRoot(this.getRootElement());
    if (!plane) {
      return null;
    }
    return plane.layer;
  };

  /**
   * Returns the plane which contains the given element.
   *
   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.
   *
   * @return {RootLike|undefined} The root of the element.
   */
  Canvas.prototype.findRoot = function (element) {
    if (typeof element === 'string') {
      element = this._elementRegistry.get(element);
    }
    if (!element) {
      return;
    }
    var plane = this._findPlaneForRoot(findRoot(element)) || {};
    return plane.rootElement;
  };

  /**
   * Return a list of all root elements on the diagram.
   *
   * @return {(RootLike)[]} The list of root elements.
   */
  Canvas.prototype.getRootElements = function () {
    return this._planes.map(function (plane) {
      return plane.rootElement;
    });
  };
  Canvas.prototype._findPlaneForRoot = function (rootElement) {
    return find$2(this._planes, function (plane) {
      return plane.rootElement === rootElement;
    });
  };

  /**
   * Returns the html element that encloses the
   * drawing canvas.
   *
   * @return {HTMLElement} The HTML element of the container.
   */
  Canvas.prototype.getContainer = function () {
    return this._container;
  };

  // markers //////////////////////

  Canvas.prototype._updateMarker = function (element, marker, add) {
    var container;
    if (!element.id) {
      element = this._elementRegistry.get(element);
    }

    // we need to access all
    container = this._elementRegistry._elements[element.id];
    if (!container) {
      return;
    }
    forEach$3([container.gfx, container.secondaryGfx], function (gfx) {
      if (gfx) {
        // invoke either addClass or removeClass based on mode
        if (add) {
          classes(gfx).add(marker);
        } else {
          classes(gfx).remove(marker);
        }
      }
    });

    /**
     * An event indicating that a marker has been updated for an element
     *
     * @event element.marker.update
     * @type {Object}
     * @property {Element} element the shape
     * @property {SVGElement} gfx the graphical representation of the shape
     * @property {string} marker
     * @property {boolean} add true if the marker was added, false if it got removed
     */
    this._eventBus.fire('element.marker.update', {
      element: element,
      gfx: container.gfx,
      marker: marker,
      add: !!add
    });
  };

  /**
   * Adds a marker to an element (basically a css class).
   *
   * Fires the element.marker.update event, making it possible to
   * integrate extension into the marker life-cycle, too.
   *
   * @example
   *
   * ```javascript
   * canvas.addMarker('foo', 'some-marker');
   *
   * const fooGfx = canvas.getGraphics('foo');
   *
   * fooGfx; // <g class="... some-marker"> ... </g>
   * ```
   *
   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.
   * @param {string} marker The marker.
   */
  Canvas.prototype.addMarker = function (element, marker) {
    this._updateMarker(element, marker, true);
  };

  /**
   * Remove a marker from an element.
   *
   * Fires the element.marker.update event, making it possible to
   * integrate extension into the marker life-cycle, too.
   *
   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.
   * @param {string} marker The marker.
   */
  Canvas.prototype.removeMarker = function (element, marker) {
    this._updateMarker(element, marker, false);
  };

  /**
   * Check whether an element has a given marker.
   *
   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.
   * @param {string} marker The marker.
   */
  Canvas.prototype.hasMarker = function (element, marker) {
    if (!element.id) {
      element = this._elementRegistry.get(element);
    }
    var gfx = this.getGraphics(element);
    return classes(gfx).has(marker);
  };

  /**
   * Toggles a marker on an element.
   *
   * Fires the element.marker.update event, making it possible to
   * integrate extension into the marker life-cycle, too.
   *
   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.
   * @param {string} marker The marker.
   */
  Canvas.prototype.toggleMarker = function (element, marker) {
    if (this.hasMarker(element, marker)) {
      this.removeMarker(element, marker);
    } else {
      this.addMarker(element, marker);
    }
  };

  /**
   * Returns the current root element.
   *
   * Supports two different modes for handling root elements:
   *
   * 1. if no root element has been added before, an implicit root will be added
   * and returned. This is used in applications that don't require explicit
   * root elements.
   *
   * 2. when root elements have been added before calling `getRootElement`,
   * root elements can be null. This is used for applications that want to manage
   * root elements themselves.
   *
   * @return {RootLike} The current root element.
   */
  Canvas.prototype.getRootElement = function () {
    var rootElement = this._rootElement;

    // can return null if root elements are present but none was set yet
    if (rootElement || this._planes.length) {
      return rootElement;
    }
    return this.setRootElement(this.addRootElement(null));
  };

  /**
   * Adds a given root element and returns it.
   *
   * @param {RootLike} [rootElement] The root element to be added.
   *
   * @return {RootLike} The added root element or an implicit root element.
   */
  Canvas.prototype.addRootElement = function (rootElement) {
    var idx = this._rootsIdx++;
    if (!rootElement) {
      rootElement = {
        id: '__implicitroot_' + idx,
        children: [],
        isImplicit: true
      };
    }
    var layerName = rootElement.layer = 'root-' + idx;
    this._ensureValid('root', rootElement);
    var layer = this.getLayer(layerName, PLANE_LAYER_INDEX);
    this.hideLayer(layerName);
    this._addRoot(rootElement, layer);
    this._planes.push({
      rootElement: rootElement,
      layer: layer
    });
    return rootElement;
  };

  /**
   * Removes a given root element and returns it.
   *
   * @param {RootLike|string} rootElement element or element ID
   *
   * @return {RootLike|undefined} removed element
   */
  Canvas.prototype.removeRootElement = function (rootElement) {
    if (typeof rootElement === 'string') {
      rootElement = this._elementRegistry.get(rootElement);
    }
    var plane = this._findPlaneForRoot(rootElement);
    if (!plane) {
      return;
    }

    // hook up life-cycle events
    this._removeRoot(rootElement);

    // clean up layer
    this._removeLayer(rootElement.layer);

    // clean up plane
    this._planes = this._planes.filter(function (plane) {
      return plane.rootElement !== rootElement;
    });

    // clean up active root
    if (this._rootElement === rootElement) {
      this._rootElement = null;
    }
    return rootElement;
  };

  /**
   * Sets a given element as the new root element for the canvas
   * and returns the new root element.
   *
   * @param {RootLike} rootElement The root element to be set.
   *
   * @return {RootLike} The set root element.
   */
  Canvas.prototype.setRootElement = function (rootElement) {
    if (rootElement === this._rootElement) {
      return;
    }
    var plane;
    if (!rootElement) {
      throw new Error('rootElement required');
    }
    plane = this._findPlaneForRoot(rootElement);

    // give set add semantics for backwards compatibility
    if (!plane) {
      rootElement = this.addRootElement(rootElement);
    }
    this._setRoot(rootElement);
    return rootElement;
  };
  Canvas.prototype._removeRoot = function (element) {
    var elementRegistry = this._elementRegistry,
      eventBus = this._eventBus;

    // simulate element remove event sequence
    eventBus.fire('root.remove', {
      element: element
    });
    eventBus.fire('root.removed', {
      element: element
    });
    elementRegistry.remove(element);
  };
  Canvas.prototype._addRoot = function (element, gfx) {
    var elementRegistry = this._elementRegistry,
      eventBus = this._eventBus;

    // resemble element add event sequence
    eventBus.fire('root.add', {
      element: element
    });
    elementRegistry.add(element, gfx);
    eventBus.fire('root.added', {
      element: element,
      gfx: gfx
    });
  };
  Canvas.prototype._setRoot = function (rootElement, layer) {
    var currentRoot = this._rootElement;
    if (currentRoot) {
      // un-associate previous root element <svg>
      this._elementRegistry.updateGraphics(currentRoot, null, true);

      // hide previous layer
      this.hideLayer(currentRoot.layer);
    }
    if (rootElement) {
      if (!layer) {
        layer = this._findPlaneForRoot(rootElement).layer;
      }

      // associate element with <svg>
      this._elementRegistry.updateGraphics(rootElement, this._svg, true);

      // show root layer
      this.showLayer(rootElement.layer);
    }
    this._rootElement = rootElement;
    this._eventBus.fire('root.set', {
      element: rootElement
    });
  };
  Canvas.prototype._ensureValid = function (type, element) {
    if (!element.id) {
      throw new Error('element must have an id');
    }
    if (this._elementRegistry.get(element.id)) {
      throw new Error('element <' + element.id + '> already exists');
    }
    var requiredAttrs = REQUIRED_MODEL_ATTRS[type];
    var valid = every(requiredAttrs, function (attr) {
      return typeof element[attr] !== 'undefined';
    });
    if (!valid) {
      throw new Error('must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);
    }
  };
  Canvas.prototype._setParent = function (element, parent, parentIndex) {
    add$2(parent.children, element, parentIndex);
    element.parent = parent;
  };

  /**
   * Adds an element to the canvas.
   *
   * This wires the parent <-> child relationship between the element and
   * a explicitly specified parent or an implicit root element.
   *
   * During add it emits the events
   *
   *  * <{type}.add> (element, parent)
   *  * <{type}.added> (element, gfx)
   *
   * Extensions may hook into these events to perform their magic.
   *
   * @param {string} type
   * @param {ConnectionLike|ShapeLike} element
   * @param {ShapeLike} [parent]
   * @param {number} [parentIndex]
   *
   * @return {ConnectionLike|ShapeLike} The added element.
   */
  Canvas.prototype._addElement = function (type, element, parent, parentIndex) {
    parent = parent || this.getRootElement();
    var eventBus = this._eventBus,
      graphicsFactory = this._graphicsFactory;
    this._ensureValid(type, element);
    eventBus.fire(type + '.add', {
      element: element,
      parent: parent
    });
    this._setParent(element, parent, parentIndex);

    // create graphics
    var gfx = graphicsFactory.create(type, element, parentIndex);
    this._elementRegistry.add(element, gfx);

    // update its visual
    graphicsFactory.update(type, element, gfx);
    eventBus.fire(type + '.added', {
      element: element,
      gfx: gfx
    });
    return element;
  };

  /**
   * Adds a shape to the canvas.
   *
   * @param {ShapeLike} shape The shape to be added
   * @param {ParentLike} [parent] The shape's parent.
   * @param {number} [parentIndex] The index at which to add the shape to the parent's children.
   *
   * @return {ShapeLike} The added shape.
   */
  Canvas.prototype.addShape = function (shape, parent, parentIndex) {
    return this._addElement('shape', shape, parent, parentIndex);
  };

  /**
   * Adds a connection to the canvas.
   *
   * @param {ConnectionLike} connection The connection to be added.
   * @param {ParentLike} [parent] The connection's parent.
   * @param {number} [parentIndex] The index at which to add the connection to the parent's children.
   *
   * @return {ConnectionLike} The added connection.
   */
  Canvas.prototype.addConnection = function (connection, parent, parentIndex) {
    return this._addElement('connection', connection, parent, parentIndex);
  };

  /**
   * Internal remove element
   */
  Canvas.prototype._removeElement = function (element, type) {
    var elementRegistry = this._elementRegistry,
      graphicsFactory = this._graphicsFactory,
      eventBus = this._eventBus;
    element = elementRegistry.get(element.id || element);
    if (!element) {
      // element was removed already
      return;
    }
    eventBus.fire(type + '.remove', {
      element: element
    });
    graphicsFactory.remove(element);

    // unset parent <-> child relationship
    remove$2(element.parent && element.parent.children, element);
    element.parent = null;
    eventBus.fire(type + '.removed', {
      element: element
    });
    elementRegistry.remove(element);
    return element;
  };

  /**
   * Removes a shape from the canvas.
   *
   * @fires ShapeRemoveEvent
   * @fires ShapeRemovedEvent
   *
   * @param {ShapeLike|string} shape The shape or its ID.
   *
   * @return {ShapeLike} The removed shape.
   */
  Canvas.prototype.removeShape = function (shape) {
    /**
     * An event indicating that a shape is about to be removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event ShapeRemoveEvent
     * @type {Object}
     * @property {ShapeLike} element The shape.
     * @property {SVGElement} gfx The graphical element.
     */

    /**
     * An event indicating that a shape has been removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event ShapeRemovedEvent
     * @type {Object}
     * @property {ShapeLike} element The shape.
     * @property {SVGElement} gfx The graphical element.
     */
    return this._removeElement(shape, 'shape');
  };

  /**
   * Removes a connection from the canvas.
   *
   * @fires ConnectionRemoveEvent
   * @fires ConnectionRemovedEvent
   *
   * @param {ConnectionLike|string} connection The connection or its ID.
   *
   * @return {ConnectionLike} The removed connection.
   */
  Canvas.prototype.removeConnection = function (connection) {
    /**
     * An event indicating that a connection is about to be removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event ConnectionRemoveEvent
     * @type {Object}
     * @property {ConnectionLike} element The connection.
     * @property {SVGElement} gfx The graphical element.
     */

    /**
     * An event indicating that a connection has been removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event ConnectionRemovedEvent
     * @type {Object}
     * @property {ConnectionLike} element The connection.
     * @property {SVGElement} gfx The graphical element.
     */
    return this._removeElement(connection, 'connection');
  };

  /**
   * Returns the graphical element of an element.
   *
   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.
   * @param {boolean} [secondary=false] Whether to return the secondary graphical element.
   *
   * @return {SVGElement} The graphical element.
   */
  Canvas.prototype.getGraphics = function (element, secondary) {
    return this._elementRegistry.getGraphics(element, secondary);
  };

  /**
   * Perform a viewbox update via a given change function.
   *
   * @param {Function} changeFn
   */
  Canvas.prototype._changeViewbox = function (changeFn) {
    // notify others of the upcoming viewbox change
    this._eventBus.fire('canvas.viewbox.changing');

    // perform actual change
    changeFn.apply(this);

    // reset the cached viewbox so that
    // a new get operation on viewbox or zoom
    // triggers a viewbox re-computation
    this._cachedViewbox = null;

    // notify others of the change; this step
    // may or may not be debounced
    this._viewboxChanged();
  };
  Canvas.prototype._viewboxChanged = function () {
    this._eventBus.fire('canvas.viewbox.changed', {
      viewbox: this.viewbox()
    });
  };

  /**
   * Gets or sets the view box of the canvas, i.e. the
   * area that is currently displayed.
   *
   * The getter may return a cached viewbox (if it is currently
   * changing). To force a recomputation, pass `false` as the first argument.
   *
   * @example
   *
   * ```javascript
   * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })
   *
   * // sets the visible area of the diagram to (100|100) -> (600|100)
   * // and and scales it according to the diagram width
   *
   * const viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.
   *
   * console.log(viewbox);
   * // {
   * //   inner: Dimensions,
   * //   outer: Dimensions,
   * //   scale,
   * //   x, y,
   * //   width, height
   * // }
   *
   * // if the current diagram is zoomed and scrolled, you may reset it to the
   * // default zoom via this method, too:
   *
   * const zoomedAndScrolledViewbox = canvas.viewbox();
   *
   * canvas.viewbox({
   *   x: 0,
   *   y: 0,
   *   width: zoomedAndScrolledViewbox.outer.width,
   *   height: zoomedAndScrolledViewbox.outer.height
   * });
   * ```
   *
   * @param {Rect} [box] The viewbox to be set.
   *
   * @return {CanvasViewbox} The set viewbox.
   */
  Canvas.prototype.viewbox = function (box) {
    if (box === undefined && this._cachedViewbox) {
      return this._cachedViewbox;
    }
    var viewport = this._viewport,
      outerBox = this.getSize();
    var innerBox, matrix, activeLayer, transform, scale, x, y;
    if (!box) {
      // compute the inner box based on the
      // diagrams active layer. This allows us to exclude
      // external components, such as overlays

      activeLayer = this._rootElement ? this.getActiveLayer() : null;
      innerBox = activeLayer && activeLayer.getBBox() || {};
      transform = transform$1(viewport);
      matrix = transform ? transform.matrix : createMatrix();
      scale = round$9(matrix.a, 1000);
      x = round$9(-matrix.e || 0, 1000);
      y = round$9(-matrix.f || 0, 1000);
      box = this._cachedViewbox = {
        x: x ? x / scale : 0,
        y: y ? y / scale : 0,
        width: outerBox.width / scale,
        height: outerBox.height / scale,
        scale: scale,
        inner: {
          width: innerBox.width || 0,
          height: innerBox.height || 0,
          x: innerBox.x || 0,
          y: innerBox.y || 0
        },
        outer: outerBox
      };
      return box;
    } else {
      this._changeViewbox(function () {
        scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);
        var matrix = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);
        transform$1(viewport, matrix);
      });
    }
    return box;
  };

  /**
   * Gets or sets the scroll of the canvas.
   *
   * @param {Point} [delta] The scroll to be set.
   *
   * @return {Point}
   */
  Canvas.prototype.scroll = function (delta) {
    var node = this._viewport;
    var matrix = node.getCTM();
    if (delta) {
      this._changeViewbox(function () {
        delta = assign$4({
          dx: 0,
          dy: 0
        }, delta || {});
        matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);
        setCTM(node, matrix);
      });
    }
    return {
      x: matrix.e,
      y: matrix.f
    };
  };

  /**
   * Scrolls the viewbox to contain the given element.
   * Optionally specify a padding to be applied to the edges.
   *
   * @param {ShapeLike|ConnectionLike|string} element The element to scroll to or its ID.
   * @param {RectTRBL|number} [padding=100] The padding to be applied. Can also specify top, bottom, left and right.
   */
  Canvas.prototype.scrollToElement = function (element, padding) {
    var defaultPadding = 100;
    if (typeof element === 'string') {
      element = this._elementRegistry.get(element);
    }

    // set to correct rootElement
    var rootElement = this.findRoot(element);
    if (rootElement !== this.getRootElement()) {
      this.setRootElement(rootElement);
    }

    // element is rootElement, do not change viewport
    if (rootElement === element) {
      return;
    }
    if (!padding) {
      padding = {};
    }
    if (typeof padding === 'number') {
      defaultPadding = padding;
    }
    padding = {
      top: padding.top || defaultPadding,
      right: padding.right || defaultPadding,
      bottom: padding.bottom || defaultPadding,
      left: padding.left || defaultPadding
    };
    var elementBounds = getBBox(element),
      elementTrbl = asTRBL(elementBounds),
      viewboxBounds = this.viewbox(),
      zoom = this.zoom();
    var dx, dy;

    // shrink viewboxBounds with padding
    viewboxBounds.y += padding.top / zoom;
    viewboxBounds.x += padding.left / zoom;
    viewboxBounds.width -= (padding.right + padding.left) / zoom;
    viewboxBounds.height -= (padding.bottom + padding.top) / zoom;
    var viewboxTrbl = asTRBL(viewboxBounds);
    var canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;
    if (!canFit) {
      // top-left when element can't fit
      dx = elementBounds.x - viewboxBounds.x;
      dy = elementBounds.y - viewboxBounds.y;
    } else {
      var dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right),
        dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left),
        dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom),
        dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);
      dx = dRight || dLeft;
      dy = dBottom || dTop;
    }
    this.scroll({
      dx: -dx * zoom,
      dy: -dy * zoom
    });
  };

  /**
   * Gets or sets the current zoom of the canvas, optionally zooming to the
   * specified position.
   *
   * The getter may return a cached zoom level. Call it with `false` as the first
   * argument to force recomputation of the current level.
   *
   * @param {number|'fit-viewport'} [newScale] The new zoom level, either a number,
   * i.e. 0.9, or `fit-viewport` to adjust the size to fit the current viewport.
   * @param {Point} [center] The reference point { x: ..., y: ...} to zoom to.
   *
   * @return {number} The set zoom level.
   */
  Canvas.prototype.zoom = function (newScale, center) {
    if (!newScale) {
      return this.viewbox(newScale).scale;
    }
    if (newScale === 'fit-viewport') {
      return this._fitViewport(center);
    }
    var outer, matrix;
    this._changeViewbox(function () {
      if (_typeof(center) !== 'object') {
        outer = this.viewbox().outer;
        center = {
          x: outer.width / 2,
          y: outer.height / 2
        };
      }
      matrix = this._setZoom(newScale, center);
    });
    return round$9(matrix.a, 1000);
  };
  function setCTM(node, m) {
    var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
    node.setAttribute('transform', mstr);
  }
  Canvas.prototype._fitViewport = function (center) {
    var vbox = this.viewbox(),
      outer = vbox.outer,
      inner = vbox.inner;
    var newScale, newViewbox;

    // display the complete diagram without zooming in.
    // instead of relying on internal zoom, we perform a
    // hard reset on the canvas viewbox to realize this
    //
    // if diagram does not need to be zoomed in, we focus it around
    // the diagram origin instead

    if (inner.x >= 0 && inner.y >= 0 && inner.x + inner.width <= outer.width && inner.y + inner.height <= outer.height && !center) {
      newViewbox = {
        x: 0,
        y: 0,
        width: Math.max(inner.width + inner.x, outer.width),
        height: Math.max(inner.height + inner.y, outer.height)
      };
    } else {
      newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
      newViewbox = {
        x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
        y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
        width: outer.width / newScale,
        height: outer.height / newScale
      };
    }
    this.viewbox(newViewbox);
    return this.viewbox(false).scale;
  };
  Canvas.prototype._setZoom = function (scale, center) {
    var svg = this._svg,
      viewport = this._viewport;
    var matrix = svg.createSVGMatrix();
    var point = svg.createSVGPoint();
    var centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;
    currentMatrix = viewport.getCTM();
    var currentScale = currentMatrix.a;
    if (center) {
      centerPoint = assign$4(point, center);

      // revert applied viewport transformations
      originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());

      // create scale matrix
      scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);
      newMatrix = currentMatrix.multiply(scaleMatrix);
    } else {
      newMatrix = matrix.scale(scale);
    }
    setCTM(this._viewport, newMatrix);
    return newMatrix;
  };

  /**
   * Returns the size of the canvas.
   *
   * @return {Dimensions} The size of the canvas.
   */
  Canvas.prototype.getSize = function () {
    return {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
  };

  /**
   * Returns the absolute bounding box of an element.
   *
   * The absolute bounding box may be used to display overlays in the callers
   * (browser) coordinate system rather than the zoomed in/out canvas coordinates.
   *
   * @param {ShapeLike|ConnectionLike} element The element.
   *
   * @return {Rect} The element's absolute bounding box.
   */
  Canvas.prototype.getAbsoluteBBox = function (element) {
    var vbox = this.viewbox();
    var bbox;

    // connection
    // use svg bbox
    if (element.waypoints) {
      var gfx = this.getGraphics(element);
      bbox = gfx.getBBox();
    }

    // shapes
    // use data
    else {
      bbox = element;
    }
    var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
    var y = bbox.y * vbox.scale - vbox.y * vbox.scale;
    var width = bbox.width * vbox.scale;
    var height = bbox.height * vbox.scale;
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };

  /**
   * Fires an event so other modules can react to the canvas resizing.
   */
  Canvas.prototype.resized = function () {
    // force recomputation of view box
    delete this._cachedViewbox;
    this._eventBus.fire('canvas.resized');
  };

  var ELEMENT_ID = 'data-element-id';

  /**
   * @typedef {import('./Types').ElementLike} ElementLike
   *
   * @typedef {import('./EventBus').default} EventBus
   *
   * @typedef { (element: ElementLike, gfx: SVGElement) => boolean|any } ElementRegistryFilterCallback
   * @typedef { (element: ElementLike, gfx: SVGElement) => any } ElementRegistryForEachCallback
   */

  /**
   * A registry that keeps track of all shapes in the diagram.
   *
   * @class
   * @constructor
   *
   * @param {EventBus} eventBus
   */
  function ElementRegistry$2(eventBus) {
    /**
     * @type { {
     *   [id: string]: {
     *     element: ElementLike;
     *     gfx?: SVGElement;
     *     secondaryGfx?: SVGElement;
     *   }
     * } }
     */
    this._elements = {};
    this._eventBus = eventBus;
  }
  ElementRegistry$2.$inject = ['eventBus'];

  /**
   * Add an element and its graphical representation(s) to the registry.
   *
   * @param {ElementLike} element The element to be added.
   * @param {SVGElement} gfx The primary graphical representation.
   * @param {SVGElement} [secondaryGfx] The secondary graphical representation.
   */
  ElementRegistry$2.prototype.add = function (element, gfx, secondaryGfx) {
    var id = element.id;
    this._validateId(id);

    // associate dom node with element
    attr(gfx, ELEMENT_ID, id);
    if (secondaryGfx) {
      attr(secondaryGfx, ELEMENT_ID, id);
    }
    this._elements[id] = {
      element: element,
      gfx: gfx,
      secondaryGfx: secondaryGfx
    };
  };

  /**
   * Remove an element from the registry.
   *
   * @param {ElementLike|string} element
   */
  ElementRegistry$2.prototype.remove = function (element) {
    var elements = this._elements,
      id = element.id || element,
      container = id && elements[id];
    if (container) {
      // unset element id on gfx
      attr(container.gfx, ELEMENT_ID, '');
      if (container.secondaryGfx) {
        attr(container.secondaryGfx, ELEMENT_ID, '');
      }
      delete elements[id];
    }
  };

  /**
   * Update an elements ID.
   *
   * @param {ElementLike|string} element The element or its ID.
   * @param {string} newId The new ID.
   */
  ElementRegistry$2.prototype.updateId = function (element, newId) {
    this._validateId(newId);
    if (typeof element === 'string') {
      element = this.get(element);
    }
    this._eventBus.fire('element.updateId', {
      element: element,
      newId: newId
    });
    var gfx = this.getGraphics(element),
      secondaryGfx = this.getGraphics(element, true);
    this.remove(element);
    element.id = newId;
    this.add(element, gfx, secondaryGfx);
  };

  /**
   * Update the graphical representation of an element.
   *
   * @param {ElementLike|string} filter The element or its ID.
   * @param {SVGElement} gfx The new graphical representation.
   * @param {boolean} [secondary=false] Whether to update the secondary graphical representation.
   */
  ElementRegistry$2.prototype.updateGraphics = function (filter, gfx, secondary) {
    var id = filter.id || filter;
    var container = this._elements[id];
    if (secondary) {
      container.secondaryGfx = gfx;
    } else {
      container.gfx = gfx;
    }
    if (gfx) {
      attr(gfx, ELEMENT_ID, id);
    }
    return gfx;
  };

  /**
   * Get the element with the given ID or graphical representation.
   *
   * @example
   *
   * ```javascript
   * elementRegistry.get('SomeElementId_1');
   *
   * elementRegistry.get(gfx);
   * ```
   *
   * @param {string|SVGElement} filter The elements ID or graphical representation.
   *
   * @return {ElementLike|undefined} The element.
   */
  ElementRegistry$2.prototype.get = function (filter) {
    var id;
    if (typeof filter === 'string') {
      id = filter;
    } else {
      id = filter && attr(filter, ELEMENT_ID);
    }
    var container = this._elements[id];
    return container && container.element;
  };

  /**
   * Return all elements that match a given filter function.
   *
   * @param {ElementRegistryFilterCallback} fn The filter function.
   *
   * @return {ElementLike[]} The matching elements.
   */
  ElementRegistry$2.prototype.filter = function (fn) {
    var filtered = [];
    this.forEach(function (element, gfx) {
      if (fn(element, gfx)) {
        filtered.push(element);
      }
    });
    return filtered;
  };

  /**
   * Return the first element that matches the given filter function.
   *
   * @param {ElementRegistryFilterCallback} fn The filter function.
   *
   * @return {ElementLike|undefined} The matching element.
   */
  ElementRegistry$2.prototype.find = function (fn) {
    var map = this._elements,
      keys = Object.keys(map);
    for (var i = 0; i < keys.length; i++) {
      var id = keys[i],
        container = map[id],
        element = container.element,
        gfx = container.gfx;
      if (fn(element, gfx)) {
        return element;
      }
    }
  };

  /**
   * Get all elements.
   *
   * @return {ElementLike[]} All elements.
   */
  ElementRegistry$2.prototype.getAll = function () {
    return this.filter(function (e) {
      return e;
    });
  };

  /**
   * Execute a given function for each element.
   *
   * @param {ElementRegistryForEachCallback} fn The function to execute.
   */
  ElementRegistry$2.prototype.forEach = function (fn) {
    var map = this._elements;
    Object.keys(map).forEach(function (id) {
      var container = map[id],
        element = container.element,
        gfx = container.gfx;
      return fn(element, gfx);
    });
  };

  /**
   * Return the graphical representation of an element.
   *
   * @example
   *
   * ```javascript
   * elementRegistry.getGraphics('SomeElementId_1');
   *
   * elementRegistry.getGraphics(rootElement); // <g ...>
   *
   * elementRegistry.getGraphics(rootElement, true); // <svg ...>
   * ```
   *
   * @param {ElementLike|string} filter The element or its ID.
   * @param {boolean} [secondary=false] Whether to return the secondary graphical representation.
   *
   * @return {SVGElement} The graphical representation.
   */
  ElementRegistry$2.prototype.getGraphics = function (filter, secondary) {
    var id = filter.id || filter;
    var container = this._elements[id];
    return container && (secondary ? container.secondaryGfx : container.gfx);
  };

  /**
   * Validate an ID and throw an error if invalid.
   *
   * @param {string} id
   *
   * @throws {Error} Error indicating that the ID is invalid or already assigned.
   */
  ElementRegistry$2.prototype._validateId = function (id) {
    if (!id) {
      throw new Error('element must have an id');
    }
    if (this._elements[id]) {
      throw new Error('element with id ' + id + ' already added');
    }
  };

  var objectRefs = {exports: {}};

  var collection = {};

  /**
   * An empty collection stub. Use {@link RefsCollection.extend} to extend a
   * collection with ref semantics.
   *
   * @class RefsCollection
   */

  /**
   * Extends a collection with {@link Refs} aware methods
   *
   * @memberof RefsCollection
   * @static
   *
   * @param  {Array<Object>} collection
   * @param  {Refs} refs instance
   * @param  {Object} property represented by the collection
   * @param  {Object} target object the collection is attached to
   *
   * @return {RefsCollection<Object>} the extended array
   */
  function extend$1(collection, refs, property, target) {
    var inverseProperty = property.inverse;

    /**
     * Removes the given element from the array and returns it.
     *
     * @method RefsCollection#remove
     *
     * @param {Object} element the element to remove
     */
    Object.defineProperty(collection, 'remove', {
      value: function value(element) {
        var idx = this.indexOf(element);
        if (idx !== -1) {
          this.splice(idx, 1);

          // unset inverse
          refs.unset(element, inverseProperty, target);
        }
        return element;
      }
    });

    /**
     * Returns true if the collection contains the given element
     *
     * @method RefsCollection#contains
     *
     * @param {Object} element the element to check for
     */
    Object.defineProperty(collection, 'contains', {
      value: function value(element) {
        return this.indexOf(element) !== -1;
      }
    });

    /**
     * Adds an element to the array, unless it exists already (set semantics).
     *
     * @method RefsCollection#add
     *
     * @param {Object} element the element to add
     * @param {Number} optional index to add element to
     *                 (possibly moving other elements around)
     */
    Object.defineProperty(collection, 'add', {
      value: function value(element, idx) {
        var currentIdx = this.indexOf(element);
        if (typeof idx === 'undefined') {
          if (currentIdx !== -1) {
            // element already in collection (!)
            return;
          }

          // add to end of array, as no idx is specified
          idx = this.length;
        }

        // handle already in collection
        if (currentIdx !== -1) {
          // remove element from currentIdx
          this.splice(currentIdx, 1);
        }

        // add element at idx
        this.splice(idx, 0, element);
        if (currentIdx === -1) {
          // set inverse, unless element was
          // in collection already
          refs.set(element, inverseProperty, target);
        }
      }
    });

    // a simple marker, identifying this element
    // as being a refs collection
    Object.defineProperty(collection, '__refs_collection', {
      value: true
    });
    return collection;
  }
  function isExtended(collection) {
    return collection.__refs_collection === true;
  }
  collection.extend = extend$1;
  collection.isExtended = isExtended;

  var Collection = collection;
  function hasOwnProperty(e, property) {
    return Object.prototype.hasOwnProperty.call(e, property.name || property);
  }
  function defineCollectionProperty(ref, property, target) {
    var collection = Collection.extend(target[property.name] || [], ref, property, target);
    Object.defineProperty(target, property.name, {
      enumerable: property.enumerable,
      value: collection
    });
    if (collection.length) {
      collection.forEach(function (o) {
        ref.set(o, property.inverse, target);
      });
    }
  }
  function defineProperty$1(ref, property, target) {
    var inverseProperty = property.inverse;
    var _value = target[property.name];
    Object.defineProperty(target, property.name, {
      configurable: property.configurable,
      enumerable: property.enumerable,
      get: function get() {
        return _value;
      },
      set: function set(value) {
        // return if we already performed all changes
        if (value === _value) {
          return;
        }
        var old = _value;

        // temporary set null
        _value = null;
        if (old) {
          ref.unset(old, inverseProperty, target);
        }

        // set new value
        _value = value;

        // set inverse value
        ref.set(_value, inverseProperty, target);
      }
    });
  }

  /**
   * Creates a new references object defining two inversly related
   * attribute descriptors a and b.
   *
   * <p>
   *   When bound to an object using {@link Refs#bind} the references
   *   get activated and ensure that add and remove operations are applied
   *   reversely, too.
   * </p>
   *
   * <p>
   *   For attributes represented as collections {@link Refs} provides the
   *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
   *   that must be used to properly hook into the inverse change mechanism.
   * </p>
   *
   * @class Refs
   *
   * @classdesc A bi-directional reference between two attributes.
   *
   * @param {Refs.AttributeDescriptor} a property descriptor
   * @param {Refs.AttributeDescriptor} b property descriptor
   *
   * @example
   *
   * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
   *
   * var car = { name: 'toyota' };
   * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
   *
   * refs.bind(car, 'wheels');
   *
   * car.wheels // []
   * car.wheels.add(wheels[0]);
   * car.wheels.add(wheels[1]);
   *
   * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
   *
   * wheels[0].car // { name: 'toyota' };
   * car.wheels.remove(wheels[0]);
   *
   * wheels[0].car // undefined
   */
  function Refs$1(a, b) {
    if (!(this instanceof Refs$1)) {
      return new Refs$1(a, b);
    }

    // link
    a.inverse = b;
    b.inverse = a;
    this.props = {};
    this.props[a.name] = a;
    this.props[b.name] = b;
  }

  /**
   * Binds one side of a bi-directional reference to a
   * target object.
   *
   * @memberOf Refs
   *
   * @param  {Object} target
   * @param  {String} property
   */
  Refs$1.prototype.bind = function (target, property) {
    if (typeof property === 'string') {
      if (!this.props[property]) {
        throw new Error('no property <' + property + '> in ref');
      }
      property = this.props[property];
    }
    if (property.collection) {
      defineCollectionProperty(this, property, target);
    } else {
      defineProperty$1(this, property, target);
    }
  };
  Refs$1.prototype.ensureRefsCollection = function (target, property) {
    var collection = target[property.name];
    if (!Collection.isExtended(collection)) {
      defineCollectionProperty(this, property, target);
    }
    return collection;
  };
  Refs$1.prototype.ensureBound = function (target, property) {
    if (!hasOwnProperty(target, property)) {
      this.bind(target, property);
    }
  };
  Refs$1.prototype.unset = function (target, property, value) {
    if (target) {
      this.ensureBound(target, property);
      if (property.collection) {
        this.ensureRefsCollection(target, property).remove(value);
      } else {
        target[property.name] = undefined;
      }
    }
  };
  Refs$1.prototype.set = function (target, property, value) {
    if (target) {
      this.ensureBound(target, property);
      if (property.collection) {
        this.ensureRefsCollection(target, property).add(value);
      } else {
        target[property.name] = value;
      }
    }
  };
  var refs = Refs$1;

  objectRefs.exports = refs;
  objectRefs.exports.Collection = collection;
  var objectRefsExports = objectRefs.exports;
  var Refs = /*@__PURE__*/getDefaultExportFromCjs(objectRefsExports);

  var parentRefs = new Refs({
      name: 'children',
      enumerable: true,
      collection: true
    }, {
      name: 'parent'
    }),
    labelRefs = new Refs({
      name: 'labels',
      enumerable: true,
      collection: true
    }, {
      name: 'labelTarget'
    }),
    attacherRefs = new Refs({
      name: 'attachers',
      collection: true
    }, {
      name: 'host'
    }),
    outgoingRefs = new Refs({
      name: 'outgoing',
      collection: true
    }, {
      name: 'source'
    }),
    incomingRefs = new Refs({
      name: 'incoming',
      collection: true
    }, {
      name: 'target'
    });

  /**
   * @typedef {import('./Types').Element} Element
   * @typedef {import('./Types').Shape} Shape
   * @typedef {import('./Types').Root} Root
   * @typedef {import('./Types').Label} Label
   * @typedef {import('./Types').Connection} Connection
   */

  /**
   * The basic graphical representation
   *
   * @class
   * @constructor
   */
  function ElementImpl() {
    /**
     * The object that backs up the shape
     *
     * @name Element#businessObject
     * @type Object
     */
    Object.defineProperty(this, 'businessObject', {
      writable: true
    });

    /**
     * Single label support, will mapped to multi label array
     *
     * @name Element#label
     * @type Object
     */
    Object.defineProperty(this, 'label', {
      get: function get() {
        return this.labels[0];
      },
      set: function set(newLabel) {
        var label = this.label,
          labels = this.labels;
        if (!newLabel && label) {
          labels.remove(label);
        } else {
          labels.add(newLabel, 0);
        }
      }
    });

    /**
     * The parent shape
     *
     * @name Element#parent
     * @type Shape
     */
    parentRefs.bind(this, 'parent');

    /**
     * The list of labels
     *
     * @name Element#labels
     * @type Label
     */
    labelRefs.bind(this, 'labels');

    /**
     * The list of outgoing connections
     *
     * @name Element#outgoing
     * @type Array<Connection>
     */
    outgoingRefs.bind(this, 'outgoing');

    /**
     * The list of incoming connections
     *
     * @name Element#incoming
     * @type Array<Connection>
     */
    incomingRefs.bind(this, 'incoming');
  }

  /**
   * A graphical object
   *
   * @class
   * @constructor
   *
   * @extends ElementImpl
   */
  function ShapeImpl() {
    ElementImpl.call(this);

    /**
     * Indicates frame shapes
     *
     * @name ShapeImpl#isFrame
     * @type boolean
     */

    /**
     * The list of children
     *
     * @name ShapeImpl#children
     * @type Element[]
     */
    parentRefs.bind(this, 'children');

    /**
     * @name ShapeImpl#host
     * @type Shape
     */
    attacherRefs.bind(this, 'host');

    /**
     * @name ShapeImpl#attachers
     * @type Shape
     */
    attacherRefs.bind(this, 'attachers');
  }
  e$2(ShapeImpl, ElementImpl);

  /**
   * A root graphical object
   *
   * @class
   * @constructor
   *
   * @extends ElementImpl
   */
  function RootImpl() {
    ElementImpl.call(this);

    /**
     * The list of children
     *
     * @name RootImpl#children
     * @type Element[]
     */
    parentRefs.bind(this, 'children');
  }
  e$2(RootImpl, ShapeImpl);

  /**
   * A label for an element
   *
   * @class
   * @constructor
   *
   * @extends ShapeImpl
   */
  function LabelImpl() {
    ShapeImpl.call(this);

    /**
     * The labeled element
     *
     * @name LabelImpl#labelTarget
     * @type Element
     */
    labelRefs.bind(this, 'labelTarget');
  }
  e$2(LabelImpl, ShapeImpl);

  /**
   * A connection between two elements
   *
   * @class
   * @constructor
   *
   * @extends ElementImpl
   */
  function ConnectionImpl() {
    ElementImpl.call(this);

    /**
     * The element this connection originates from
     *
     * @name ConnectionImpl#source
     * @type Element
     */
    outgoingRefs.bind(this, 'source');

    /**
     * The element this connection points to
     *
     * @name ConnectionImpl#target
     * @type Element
     */
    incomingRefs.bind(this, 'target');
  }
  e$2(ConnectionImpl, ElementImpl);
  var types$1 = {
    connection: ConnectionImpl,
    shape: ShapeImpl,
    label: LabelImpl,
    root: RootImpl
  };

  /**
   * Creates a root element.
   *
   * @overlord
   *
   * @example
   *
   * ```javascript
   * import * as Model from 'diagram-js/lib/model';
   *
   * const root = Model.create('root', {
   *   x: 100,
   *   y: 100,
   *   width: 100,
   *   height: 100
   * });
   * ```
   *
   * @param {'root'} type
   * @param {any} [attrs]
   *
   * @return {Root}
   */

  /**
   * Creates a connection.
   *
   * @overlord
   *
   * @example
   *
   * ```javascript
   * import * as Model from 'diagram-js/lib/model';
   *
   * const connection = Model.create('connection', {
   *   waypoints: [
   *     { x: 100, y: 100 },
   *     { x: 200, y: 100 }
   *   ]
   * });
   * ```
   *
   * @param {'connection'} type
   * @param {any} [attrs]
   *
   * @return {Connection}
   */

  /**
   * Creates a shape.
   *
   * @overlord
   *
   * @example
   *
   * ```javascript
   * import * as Model from 'diagram-js/lib/model';
   *
   * const shape = Model.create('shape', {
   *   x: 100,
   *   y: 100,
   *   width: 100,
   *   height: 100
   * });
   * ```
   *
   * @param {'shape'} type
   * @param {any} [attrs]
   *
   * @return {Shape}
   */

  /**
   * Creates a label.
   *
   * @example
   *
   * ```javascript
   * import * as Model from 'diagram-js/lib/model';
   *
   * const label = Model.create('label', {
   *   x: 100,
   *   y: 100,
   *   width: 100,
   *   height: 100,
   *   labelTarget: shape
   * });
   * ```
   *
   * @param {'label'} type
   * @param {Object} [attrs]
   *
   * @return {Label}
   */
  function create$1(type, attrs) {
    var Type = types$1[type];
    if (!Type) {
      throw new Error('unknown type: <' + type + '>');
    }
    return assign$4(new Type(), attrs);
  }

  /**
   * Checks whether an object is a model instance.
   *
   * @param {any} obj
   *
   * @return {boolean}
   */
  function isModelElement(obj) {
    return obj instanceof ElementImpl;
  }

  /**
   * @typedef {import('../model/Types').Element} Element
   * @typedef {import('../model/Types').Connection} Connection
   * @typedef {import('../model/Types').Label} Label
   * @typedef {import('../model/Types').Root} Root
   * @typedef {import('../model/Types').Shape} Shape
   */

  /**
   * A factory for model elements.
   *
   * @template {Connection} [T=Connection]
   * @template {Label} [U=Label]
   * @template {Root} [V=Root]
   * @template {Shape} [W=Shape]
   */
  function ElementFactory$3() {
    this._uid = 12;
  }

  /**
   * Create a root element.
   *
   * @param {Partial<Root>} [attrs]
   *
   * @return {V} The created root element.
   */
  ElementFactory$3.prototype.createRoot = function (attrs) {
    return this.create('root', attrs);
  };

  /**
   * Create a label.
   *
   * @param {Partial<Label>} [attrs]
   *
   * @return {U} The created label.
   */
  ElementFactory$3.prototype.createLabel = function (attrs) {
    return this.create('label', attrs);
  };

  /**
   * Create a shape.
   *
   * @param {Partial<Shape>} [attrs]
   *
   * @return {W} The created shape.
   */
  ElementFactory$3.prototype.createShape = function (attrs) {
    return this.create('shape', attrs);
  };

  /**
   * Create a connection.
   *
   * @param {Partial<Connection>} [attrs]
   *
   * @return {T} The created connection.
   */
  ElementFactory$3.prototype.createConnection = function (attrs) {
    return this.create('connection', attrs);
  };

  /**
   * Create a root element.
   *
   * @overlord
   * @param {'root'} type
   * @param {Partial<Root>} [attrs]
   * @return {V}
   */
  /**
   * Create a shape.
   *
   * @overlord
   * @param {'shape'} type
   * @param {Partial<Shape>} [attrs]
   * @return {W}
   */
  /**
   * Create a connection.
   *
   * @overlord
   * @param {'connection'} type
   * @param {Partial<Connection>} [attrs]
   * @return {T}
   */
  /**
   * Create a label.
   *
   * @param {'label'} type
   * @param {Partial<Label>} [attrs]
   * @return {U}
   */
  ElementFactory$3.prototype.create = function (type, attrs) {
    attrs = assign$4({}, attrs || {});
    if (!attrs.id) {
      attrs.id = type + '_' + this._uid++;
    }
    return create$1(type, attrs);
  };

  /**
   * SVGs for elements are generated by the {@link GraphicsFactory}.
   *
   * This utility gives quick access to the important semantic
   * parts of an element.
   */

  /**
   * Returns the visual part of a diagram element.
   *
   * @param {SVGElement} gfx
   *
   * @return {SVGElement}
   */
  function getVisual(gfx) {
    return gfx.childNodes[0];
  }

  /**
   * Returns the children for a given diagram element.
   *
   * @param {SVGElement} gfx
   * @return {SVGElement}
   */
  function getChildren$1(gfx) {
    return gfx.parentNode.childNodes[1];
  }

  /**
   * @param {SVGElement} gfx
   * @param {number} x
   * @param {number} y
   * @param {number} [angle]
   * @param {number} [amount]
   */
  function transform(gfx, x, y, angle, amount) {
    var translate = createTransform();
    translate.setTranslate(x, y);
    var rotate = createTransform();
    rotate.setRotate(angle || 0, 0, 0);
    var scale = createTransform();
    scale.setScale(amount || 1, amount || 1);
    transform$1(gfx, [translate, rotate, scale]);
  }

  /**
   * @param {SVGElement} gfx
   * @param {number} x
   * @param {number} y
   */
  function translate$1(gfx, x, y) {
    var translate = createTransform();
    translate.setTranslate(x, y);
    transform$1(gfx, translate);
  }

  /**
   * @param {SVGElement} gfx
   * @param {number} angle
   */
  function rotate(gfx, angle) {
    var rotate = createTransform();
    rotate.setRotate(angle, 0, 0);
    transform$1(gfx, rotate);
  }

  /**
   * @typedef {import('./Types').ConnectionLike} ConnectionLike
   * @typedef {import('./Types').ElementLike} ElementLike
   * @typedef {import('./Types').ShapeLike} ShapeLike
   *
   * @typedef {import('./ElementRegistry').default} ElementRegistry
   * @typedef {import('./EventBus').default} EventBus
   */

  /**
   * A factory that creates graphical elements.
   *
   * @param {EventBus} eventBus
   * @param {ElementRegistry} elementRegistry
   */
  function GraphicsFactory(eventBus, elementRegistry) {
    this._eventBus = eventBus;
    this._elementRegistry = elementRegistry;
  }
  GraphicsFactory.$inject = ['eventBus', 'elementRegistry'];

  /**
   * @param { { parent?: any } } element
   * @return {SVGElement}
   */
  GraphicsFactory.prototype._getChildrenContainer = function (element) {
    var gfx = this._elementRegistry.getGraphics(element);
    var childrenGfx;

    // root element
    if (!element.parent) {
      childrenGfx = gfx;
    } else {
      childrenGfx = getChildren$1(gfx);
      if (!childrenGfx) {
        childrenGfx = create$2('g');
        classes(childrenGfx).add('djs-children');
        append(gfx.parentNode, childrenGfx);
      }
    }
    return childrenGfx;
  };

  /**
   * Clears the graphical representation of the element and returns the
   * cleared visual (the <g class="djs-visual" /> element).
   */
  GraphicsFactory.prototype._clear = function (gfx) {
    var visual = getVisual(gfx);
    clear$1(visual);
    return visual;
  };

  /**
   * Creates a gfx container for shapes and connections
   *
   * The layout is as follows:
   *
   * <g class="djs-group">
   *
   *   <!-- the gfx -->
   *   <g class="djs-element djs-(shape|connection|frame)">
   *     <g class="djs-visual">
   *       <!-- the renderer draws in here -->
   *     </g>
   *
   *     <!-- extensions (overlays, click box, ...) goes here
   *   </g>
   *
   *   <!-- the gfx child nodes -->
   *   <g class="djs-children"></g>
   * </g>
   *
   * @param {string} type the type of the element, i.e. shape | connection
   * @param {SVGElement} childrenGfx
   * @param {number} [parentIndex] position to create container in parent
   * @param {boolean} [isFrame] is frame element
   *
   * @return {SVGElement}
   */
  GraphicsFactory.prototype._createContainer = function (type, childrenGfx, parentIndex, isFrame) {
    var outerGfx = create$2('g');
    classes(outerGfx).add('djs-group');

    // insert node at position
    if (typeof parentIndex !== 'undefined') {
      prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
    } else {
      append(childrenGfx, outerGfx);
    }
    var gfx = create$2('g');
    classes(gfx).add('djs-element');
    classes(gfx).add('djs-' + type);
    if (isFrame) {
      classes(gfx).add('djs-frame');
    }
    append(outerGfx, gfx);

    // create visual
    var visual = create$2('g');
    classes(visual).add('djs-visual');
    append(gfx, visual);
    return gfx;
  };

  /**
   * Create a graphical element.
   *
   * @param { 'shape' | 'connection' | 'label' | 'root' } type The type of the element.
   * @param {ElementLike} element The element.
   * @param {number} [parentIndex] The index at which to add the graphical element to its parent's children.
   *
   * @return {SVGElement} The graphical element.
   */
  GraphicsFactory.prototype.create = function (type, element, parentIndex) {
    var childrenGfx = this._getChildrenContainer(element.parent);
    return this._createContainer(type, childrenGfx, parentIndex, isFrameElement(element));
  };

  /**
   * Update the containments of the given elements.
   *
   * @param {ElementLike[]} elements The elements.
   */
  GraphicsFactory.prototype.updateContainments = function (elements) {
    var self = this,
      elementRegistry = this._elementRegistry,
      parents;
    parents = reduce(elements, function (map, e) {
      if (e.parent) {
        map[e.parent.id] = e.parent;
      }
      return map;
    }, {});

    // update all parents of changed and reorganized their children
    // in the correct order (as indicated in our model)
    forEach$3(parents, function (parent) {
      var children = parent.children;
      if (!children) {
        return;
      }
      var childrenGfx = self._getChildrenContainer(parent);
      forEach$3(children.slice().reverse(), function (child) {
        var childGfx = elementRegistry.getGraphics(child);
        prependTo(childGfx.parentNode, childrenGfx);
      });
    });
  };

  /**
   * Draw a shape.
   *
   * @param {SVGElement} visual The graphical element.
   * @param {ShapeLike} element The shape.
   * @param {Object} attrs Optional attributes.
   *
   * @return {SVGElement}
   */
  GraphicsFactory.prototype.drawShape = function (visual, element) {
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var eventBus = this._eventBus;
    return eventBus.fire('render.shape', {
      gfx: visual,
      element: element,
      attrs: attrs
    });
  };

  /**
   * Get the path of a shape.
   *
   * @param {ShapeLike} element The shape.
   *
   * @return {string} The path of the shape.
   */
  GraphicsFactory.prototype.getShapePath = function (element) {
    var eventBus = this._eventBus;
    return eventBus.fire('render.getShapePath', element);
  };

  /**
   * Draw a connection.
   *
   * @param {SVGElement} visual The graphical element.
   * @param {ConnectionLike} element The connection.
   * @param {Object} attrs Optional attributes.
   *
   * @return {SVGElement}
   */
  GraphicsFactory.prototype.drawConnection = function (visual, element) {
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var eventBus = this._eventBus;
    return eventBus.fire('render.connection', {
      gfx: visual,
      element: element,
      attrs: attrs
    });
  };

  /**
   * Get the path of a connection.
   *
   * @param {ConnectionLike} connection The connection.
   *
   * @return {string} The path of the connection.
   */
  GraphicsFactory.prototype.getConnectionPath = function (connection) {
    var eventBus = this._eventBus;
    return eventBus.fire('render.getConnectionPath', connection);
  };

  /**
   * Update an elements graphical representation.
   *
   * @param {'shape'|'connection'} type
   * @param {ElementLike} element
   * @param {SVGElement} gfx
   */
  GraphicsFactory.prototype.update = function (type, element, gfx) {
    // do NOT update root element
    if (!element.parent) {
      return;
    }
    var visual = this._clear(gfx);

    // redraw
    if (type === 'shape') {
      this.drawShape(visual, element);

      // update positioning
      translate$1(gfx, element.x, element.y);
    } else if (type === 'connection') {
      this.drawConnection(visual, element);
    } else {
      throw new Error('unknown type: ' + type);
    }
    if (element.hidden) {
      attr(gfx, 'display', 'none');
    } else {
      attr(gfx, 'display', 'block');
    }
  };

  /**
   * Remove a graphical element.
   *
   * @param {ElementLike} element The element.
   */
  GraphicsFactory.prototype.remove = function (element) {
    var gfx = this._elementRegistry.getGraphics(element);

    // remove
    remove$3(gfx.parentNode);
  };

  // helpers //////////

  function prependTo(newNode, parentNode, siblingNode) {
    var node = siblingNode || parentNode.firstChild;

    // do not prepend node to itself to prevent IE from crashing
    // https://github.com/bpmn-io/bpmn-js/issues/746
    if (newNode === node) {
      return;
    }
    parentNode.insertBefore(newNode, node);
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var CoreModule$2 = {
    __depends__: [DrawModule$1],
    __init__: ['canvas'],
    canvas: ['type', Canvas],
    elementRegistry: ['type', ElementRegistry$2],
    elementFactory: ['type', ElementFactory$3],
    eventBus: ['type', EventBus],
    graphicsFactory: ['type', GraphicsFactory]
  };

  /**
   * @typedef {import('didi').InjectionContext} InjectionContext
   * @typedef {import('didi').LocalsMap} LocalsMap
   * @typedef {import('didi').ModuleDeclaration} ModuleDeclaration
   *
   * @typedef { {
   *   modules?: ModuleDeclaration[];
   * } & Record<string, any> } DiagramOptions
   */

  /**
   * Bootstrap an injector from a list of modules, instantiating a number of default components
   *
   * @param {ModuleDeclaration[]} modules
   *
   * @return {Injector} a injector to use to access the components
   */
  function bootstrap(modules) {
    var injector = new Injector(modules);
    injector.init();
    return injector;
  }

  /**
   * Creates an injector from passed options.
   *
   * @param {DiagramOptions} [options]
   *
   * @return {Injector}
   */
  function createInjector$2(options) {
    options = options || {};

    /**
     * @type { ModuleDeclaration }
     */
    var configModule = {
      'config': ['value', options]
    };
    var modules = [configModule, CoreModule$2].concat(options.modules || []);
    return bootstrap(modules);
  }

  /**
   * The main diagram-js entry point that bootstraps the diagram with the given
   * configuration.
   *
   * To register extensions with the diagram, pass them as Array<Module> to the constructor.
   *
   * @class
   * @constructor
   *
   * @example Creating a plug-in that logs whenever a shape is added to the canvas.
   *
   * ```javascript
   * // plug-in implementation
   * function MyLoggingPlugin(eventBus) {
   *   eventBus.on('shape.added', function(event) {
   *     console.log('shape ', event.shape, ' was added to the diagram');
   *   });
   * }
   *
   * // export as module
   * export default {
   *   __init__: [ 'myLoggingPlugin' ],
   *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
   * };
   * ```
   *
   * Use the plug-in in a Diagram instance:
   *
   * ```javascript
   * import MyLoggingModule from 'path-to-my-logging-plugin';
   *
   * var diagram = new Diagram({
   *   modules: [
   *     MyLoggingModule
   *   ]
   * });
   *
   * diagram.invoke([ 'canvas', function(canvas) {
   *   // add shape to drawing canvas
   *   canvas.addShape({ x: 10, y: 10 });
   * });
   *
   * // 'shape ... was added to the diagram' logged to console
   * ```
   *
   * @param {DiagramOptions} [options]
   * @param {Injector} [injector] An (optional) injector to bootstrap the diagram with.
   */
  function Diagram(options, injector) {
    this._injector = injector = injector || createInjector$2(options);

    // API

    /**
     * Resolves a diagram service.
     *
     * @template T
     *
     * @param {string} name The name of the service to get.
     * @param {boolean} [strict=true] If false, resolve missing services to null.
     *
     * @return {T|null}
     */
    this.get = injector.get;

    /**
     * Executes a function with its dependencies injected.
     *
     * @template T
     *
     * @param {Function} func function to be invoked
     * @param {InjectionContext} [context] context of the invocation
     * @param {LocalsMap} [locals] locals provided
     *
     * @return {T|null}
     */
    this.invoke = injector.invoke;

    // init

    // indicate via event

    /**
     * An event indicating that all plug-ins are loaded.
     *
     * Use this event to fire other events to interested plug-ins
     *
     * @memberOf Diagram
     *
     * @event diagram.init
     *
     * @example
     *
     * ```javascript
     * eventBus.on('diagram.init', function() {
     *   eventBus.fire('my-custom-event', { foo: 'BAR' });
     * });
     * ```
     *
     * @type {Object}
     */
    this.get('eventBus').fire('diagram.init');
  }

  /**
   * Destroys the diagram
   */
  Diagram.prototype.destroy = function () {
    this.get('eventBus').fire('diagram.destroy');
  };

  /**
   * Clear the diagram, removing all contents.
   */
  Diagram.prototype.clear = function () {
    this.get('eventBus').fire('diagram.clear');
  };

  var diRefs = new Refs({
    name: 'dmnElementRef',
    enumerable: true
  }, {
    name: 'di',
    configurable: true
  });
  function DRDTreeWalker(handler, options) {
    // list of elements to handle deferred to ensure
    // prerequisites are drawn
    var deferred = [];
    function visit(element) {
      var gfx = element.gfx;

      // avoid multiple rendering of elements
      if (gfx) {
        throw new Error('already rendered ' + element.id);
      }

      // call handler
      return handler.element(element);
    }
    function visitRoot(element) {
      return handler.root(element);
    }
    function visitIfDi(element) {
      try {
        var gfx = element.di && visit(element);
        return gfx;
      } catch (e) {
        logError(e.message, {
          element: element,
          error: e
        });
      }
    }

    // Semantic handling //////////////////////

    /**
     * Handle definitions and return the rendered diagram (if any)
     *
     * @param {ModdleElement} definitions to walk and import
     * @param {ModdleElement} [diagram] specific diagram to import and display
     *
     * @throws {Error} if no diagram to display could be found
     */
    function handleDefinitions(definitions, diagram) {
      // make sure we walk the correct dmnElement
      var dmnDI = definitions.dmnDI;
      if (!dmnDI) {
        throw new Error('no dmndi:DMNDI');
      }
      var diagrams = dmnDI.diagrams || [];
      if (diagram && diagrams.indexOf(diagram) === -1) {
        throw new Error('diagram not part of dmndi:DMNDI');
      }
      if (!diagram && diagrams && diagrams.length) {
        diagram = diagrams[0];
      }

      // no diagram -> nothing to import
      if (!diagram) {
        throw new Error('no diagram to display');
      }

      // assign current diagram to definitions so that it can accessed later
      definitions.di = diagram;

      // load DI from selected diagram only
      handleDiagram(diagram);
      visitRoot(definitions);
      handleDrgElements(definitions.get('drgElement'));
      handleArtifacts(definitions.get('artifact'));
      handleDeferred();
    }
    function handleDrgElements(elements) {
      forEach$3(elements, function (element) {
        visitIfDi(element);
        handleRequirements(element);
      });
    }
    function handleArtifacts(elements) {
      forEach$3(elements, function (element) {
        if (is$1(element, 'dmn:Association')) {
          handleAssociation(element);
        } else {
          visitIfDi(element);
        }
      });
    }

    /**
     * Defer association visit until all shapes are visited.
     *
     * @param {ModdleElement} element
     */
    function handleAssociation(element) {
      defer(function () {
        visitIfDi(element);
      });
    }

    /**
     * Defer requirements visiting until all shapes are visited.
     *
     * @param {ModdleElement} element
     */
    function handleRequirements(element) {
      forEach$3(['informationRequirement', 'knowledgeRequirement', 'authorityRequirement'], function (requirements) {
        forEach$3(element[requirements], function (requirement) {
          defer(function () {
            visitIfDi(requirement);
          });
        });
      });
    }

    // DI handling //////////////////////
    function handleDiagram(diagram) {
      forEach$3(diagram.diagramElements, handleDiagramElement);
    }
    function handleDiagramElement(diagramElement) {
      registerDi(diagramElement);
    }
    function registerDi(di) {
      var dmnElement = di.dmnElementRef;
      if (dmnElement) {
        if (dmnElement.di) {
          logError('multiple DI elements defined for element', {
            element: dmnElement
          });
        } else {
          diRefs.bind(dmnElement, 'di');
          dmnElement.di = di;
        }
      } else {
        logError('no DMN element referenced in element', {
          element: di
        });
      }
    }
    function defer(fn) {
      deferred.push(fn);
    }
    function handleDeferred() {
      forEach$3(deferred, function (d) {
        d();
      });
    }
    function logError(message, context) {
      handler.error(message, context);
    }

    // API //////////////////////

    return {
      handleDefinitions: handleDefinitions
    };
  }

  /**
   * Import the definitions into a diagram.
   *
   * Errors and warnings are reported through the specified callback.
   *
   * @param  {Drd} drd
   * @param  {ModdleElement} definitions
   * @param  {Function} done
   *         the callback, invoked with (err, [ warning ]) once the import is done
   */
  function importDRD(drd, definitions, done) {
    var importer = drd.get('drdImporter'),
      eventBus = drd.get('eventBus');
    var error,
      warnings = [];
    function render(definitions) {
      var visitor = {
        root: function root(element) {
          return importer.root(element);
        },
        element: function element(_element, di) {
          return importer.add(_element, di);
        },
        error: function error(message, context) {
          warnings.push({
            message: message,
            context: context
          });
        }
      };
      var walker = new DRDTreeWalker(visitor);

      // import
      walker.handleDefinitions(definitions);
    }
    eventBus.fire('import.start', {
      definitions: definitions
    });
    try {
      render(definitions);
    } catch (e) {
      error = e;
    }
    eventBus.fire('import.done', {
      error: error,
      warnings: warnings
    });
    done(error, warnings);
  }

  var RENDERER_IDS = new Ids();
  var black = 'hsl(225, 10%, 15%)';

  /**
   * Renderer for the DRD view. The default colors are configurable.
   * When default label color is not provided, it will take the default
   * stroke color.
   *
   * @example
   * ```javascript
   * // for simple DRD viewer
   * const viewer = new DrdViewer({
   *   drdRenderer: {
   *     defaultFillColor: '#ffd700',
   *     defaultStrokeColor: '#0057b8',
   *     defaultLabelColor: '#0057b8'
   *   }
   * });
   *
   * // in dmn-js
   * const modeler = new DmnModeler({
   *   drd: {
   *     drdRenderer: {
   *       defaultFillColor: '#ffd700',
   *       defaultStrokeColor: '#0057b8',
   *       defaultLabelColor: '#0057b8'
   *     }
   *   }
   * });
   * ```
   */
  function DrdRenderer(config, eventBus, pathMap, styles, textRenderer, canvas) {
    BaseRenderer.call(this, eventBus);
    var rendererId = RENDERER_IDS.next();
    var computeStyle = styles.computeStyle;
    var markers = {};
    var defaultFillColor = config && config.defaultFillColor || 'white',
      defaultStrokeColor = config && config.defaultStrokeColor || black,
      defaultLabelColor = config && config.defaultLabelColor;
    function marker(type, fill, stroke) {
      var id = type + '-' + colorEscape(fill) + '-' + colorEscape(stroke) + '-' + rendererId;
      if (!markers[id]) {
        createMarker(id, type, fill, stroke);
      }
      return 'url(#' + id + ')';
    }
    function addMarker(id, options) {
      var attrs = assign$4({
        strokeWidth: 1,
        strokeLinecap: 'round',
        strokeDasharray: 'none'
      }, options.attrs);
      var ref = options.ref || {
        x: 0,
        y: 0
      };
      var scale = options.scale || 1;

      // fix for safari / chrome / firefox bug not correctly
      // resetting stroke dash array
      if (attrs.strokeDasharray === 'none') {
        attrs.strokeDasharray = [10000, 1];
      }
      var marker = create$2('marker');
      attr(options.element, attrs);
      append(marker, options.element);
      attr(marker, {
        id: id,
        viewBox: '0 0 20 20',
        refX: ref.x,
        refY: ref.y,
        markerWidth: 20 * scale,
        markerHeight: 20 * scale,
        orient: 'auto'
      });
      var defs = query('defs', canvas._svg);
      if (!defs) {
        defs = create$2('defs');
        append(canvas._svg, defs);
      }
      append(defs, marker);
      markers[id] = marker;
    }
    function createMarker(id, type, fill, stroke) {
      if (type === 'association-start') {
        var associationStart = create$2('path');
        attr(associationStart, {
          d: 'M 11 5 L 1 10 L 11 15'
        });
        addMarker(id, {
          element: associationStart,
          attrs: {
            fill: 'none',
            stroke: stroke,
            strokeWidth: 1.5
          },
          ref: {
            x: 1,
            y: 10
          },
          scale: 0.5
        });
      } else if (type === 'association-end') {
        var associationEnd = create$2('path');
        attr(associationEnd, {
          d: 'M 1 5 L 11 10 L 1 15'
        });
        addMarker(id, {
          element: associationEnd,
          attrs: {
            fill: 'none',
            stroke: stroke,
            strokeWidth: 1.5
          },
          ref: {
            x: 12,
            y: 10
          },
          scale: 0.5
        });
      } else if (type === 'information-requirement-end') {
        var informationRequirementEnd = create$2('path');
        attr(informationRequirementEnd, {
          d: 'M 1 5 L 11 10 L 1 15 Z'
        });
        addMarker(id, {
          element: informationRequirementEnd,
          attrs: {
            fill: stroke,
            stroke: 'none'
          },
          ref: {
            x: 11,
            y: 10
          },
          scale: 1
        });
      } else if (type === 'knowledge-requirement-end') {
        var knowledgeRequirementEnd = create$2('path');
        attr(knowledgeRequirementEnd, {
          d: 'M 1 3 L 11 10 L 1 17'
        });
        addMarker(id, {
          element: knowledgeRequirementEnd,
          attrs: {
            fill: 'none',
            stroke: stroke,
            strokeWidth: 2
          },
          ref: {
            x: 11,
            y: 10
          },
          scale: 0.8
        });
      } else if (type === 'authority-requirement-end') {
        var authorityRequirementEnd = create$2('circle');
        attr(authorityRequirementEnd, {
          cx: 3,
          cy: 3,
          r: 3
        });
        addMarker(id, {
          element: authorityRequirementEnd,
          attrs: {
            fill: stroke,
            stroke: 'none'
          },
          ref: {
            x: 3,
            y: 3
          },
          scale: 0.9
        });
      }
    }
    function drawRect(p, width, height, r, offset, attrs) {
      if (isObject$2(offset)) {
        attrs = offset;
        offset = 0;
      }
      offset = offset || 0;
      attrs = computeStyle(attrs, {
        stroke: black,
        strokeWidth: 2,
        fill: 'white'
      });
      var rect = create$2('rect');
      attr(rect, {
        x: offset,
        y: offset,
        width: width - offset * 2,
        height: height - offset * 2,
        rx: r,
        ry: r
      });
      attr(rect, attrs);
      append(p, rect);
      return rect;
    }
    function renderLabel(p, label, options) {
      var text = textRenderer.createText(label || '', options);
      attr$1(text, 'class', 'djs-label');
      append(p, text);
      return text;
    }
    function renderEmbeddedLabel(p, element, align, options) {
      var name = getName(element);
      options = assign$4({
        box: element,
        align: align,
        padding: 5,
        style: {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
        }
      }, options);
      return renderLabel(p, name, options);
    }
    function drawPath(p, d, attrs) {
      attrs = computeStyle(attrs, ['no-fill'], {
        strokeWidth: 2,
        stroke: black
      });
      var path = create$2('path');
      attr(path, {
        d: d
      });
      attr(path, attrs);
      append(p, path);
      return path;
    }
    var handlers = {
      'dmn:Decision': function dmnDecision(p, element) {
        var rect = drawRect(p, element.width, element.height, 0, {
          stroke: getStrokeColor(element, defaultStrokeColor),
          fill: getFillColor(element, defaultFillColor)
        });
        renderEmbeddedLabel(p, element, 'center-middle');
        return rect;
      },
      'dmn:KnowledgeSource': function dmnKnowledgeSource(p, element) {
        var pathData = pathMap.getScaledPath('KNOWLEDGE_SOURCE', {
          xScaleFactor: 1.021,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.0,
            my: 0.075
          }
        });
        var knowledgeSource = drawPath(p, pathData, {
          strokeWidth: 2,
          fill: getFillColor(element, defaultFillColor),
          stroke: getStrokeColor(element, defaultStrokeColor)
        });
        renderEmbeddedLabel(p, element, 'center-middle');
        return knowledgeSource;
      },
      'dmn:BusinessKnowledgeModel': function dmnBusinessKnowledgeModel(p, element) {
        var pathData = pathMap.getScaledPath('BUSINESS_KNOWLEDGE_MODEL', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.0,
            my: 0.3
          }
        });
        var businessKnowledge = drawPath(p, pathData, {
          strokeWidth: 2,
          fill: getFillColor(element, defaultFillColor),
          stroke: getStrokeColor(element, defaultStrokeColor)
        });
        renderEmbeddedLabel(p, element, 'center-middle');
        return businessKnowledge;
      },
      'dmn:InputData': function dmnInputData(p, element) {
        var rect = drawRect(p, element.width, element.height, 22, {
          stroke: getStrokeColor(element, defaultStrokeColor),
          fill: getFillColor(element, defaultFillColor)
        });
        renderEmbeddedLabel(p, element, 'center-middle');
        return rect;
      },
      'dmn:TextAnnotation': function dmnTextAnnotation(p, element) {
        var style = {
          'fill': 'none',
          'stroke': 'none'
        };
        var textElement = drawRect(p, element.width, element.height, 0, 0, style);
        var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.0,
            my: 0.0
          }
        });
        drawPath(p, textPathData, {
          stroke: getStrokeColor(element, defaultStrokeColor)
        });
        var text = getSemantic(element).text || '';
        renderLabel(p, text, {
          style: {
            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
          },
          box: element,
          align: 'left-top',
          padding: 5
        });
        return textElement;
      },
      'dmn:Association': function dmnAssociation(p, element) {
        var semantic = getSemantic(element);
        var fill = getFillColor(element, defaultFillColor),
          stroke = getStrokeColor(element, defaultStrokeColor),
          attrs = {
            stroke: stroke,
            strokeDasharray: '0.5, 5',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            fill: 'none'
          };
        if (semantic.associationDirection === 'One' || semantic.associationDirection === 'Both') {
          attrs.markerEnd = marker('association-end', fill, stroke);
        }
        if (semantic.associationDirection === 'Both') {
          attrs.markerStart = marker('association-start', fill, stroke);
        }
        return drawLine(p, element.waypoints, attrs);
      },
      'dmn:InformationRequirement': function dmnInformationRequirement(p, element) {
        var fill = getFillColor(element, defaultFillColor),
          stroke = getStrokeColor(element, defaultStrokeColor),
          attrs = {
            stroke: stroke,
            strokeWidth: 1,
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            markerEnd: marker('information-requirement-end', fill, stroke)
          };
        return drawLine(p, element.waypoints, attrs);
      },
      'dmn:KnowledgeRequirement': function dmnKnowledgeRequirement(p, element) {
        var fill = getFillColor(element, defaultFillColor),
          stroke = getStrokeColor(element, defaultStrokeColor);
        var attrs = {
          stroke: stroke,
          strokeWidth: 1,
          strokeDasharray: 5,
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          markerEnd: marker('knowledge-requirement-end', fill, stroke)
        };
        return drawLine(p, element.waypoints, attrs);
      },
      'dmn:AuthorityRequirement': function dmnAuthorityRequirement(p, element) {
        var fill = getFillColor(element, defaultFillColor),
          stroke = getStrokeColor(element, defaultStrokeColor),
          attrs = {
            stroke: stroke,
            strokeWidth: 1.5,
            strokeDasharray: 5,
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            markerEnd: marker('authority-requirement-end', fill, stroke)
          };
        return drawLine(p, element.waypoints, attrs);
      }
    };

    // draw shape and connection //////////////////

    function drawShape(parent, element) {
      var h = handlers[element.type];
      if (!h) {
        return BaseRenderer.prototype.drawShape.apply(this, [parent, element]);
      } else {
        return h(parent, element);
      }
    }
    function drawConnection(parent, element) {
      var type = element.type;
      var h = handlers[type];
      if (!h) {
        return BaseRenderer.prototype.drawConnection.apply(this, [parent, element]);
      } else {
        return h(parent, element);
      }
    }
    function drawLine(p, waypoints, attrs) {
      attrs = computeStyle(attrs, ['no-fill'], {
        stroke: black,
        strokeWidth: 2,
        fill: 'none'
      });
      var line = createLine(waypoints, attrs);
      append(p, line);
      return line;
    }
    this.canRender = function (element) {
      return is$1(element, 'dmn:DMNElement') || is$1(element, 'dmn:InformationRequirement') || is$1(element, 'dmn:KnowledgeRequirement') || is$1(element, 'dmn:AuthorityRequirement');
    };
    this.drawShape = drawShape;
    this.drawConnection = drawConnection;
  }
  e$2(DrdRenderer, BaseRenderer);
  DrdRenderer.$inject = ['config.drdRenderer', 'eventBus', 'pathMap', 'styles', 'textRenderer', 'canvas'];

  // helper functions //////////////////////

  function getSemantic(element) {
    return element.businessObject;
  }
  function colorEscape(str) {
    // only allow characters and numbers
    return str.replace(/[^0-9a-zA-z]+/g, '_');
  }
  function getStrokeColor(element, defaultColor) {
    return defaultColor;
  }
  function getFillColor(element, defaultColor) {
    return defaultColor;
  }
  function getLabelColor(element, defaultColor, defaultStrokeColor) {
    return defaultColor || getStrokeColor(element, defaultStrokeColor);
  }

  /**
   * @typedef {import('../util/Types').Dimensions} Dimensions
   *
   * @typedef { {
   *   top: number;
   *   left: number;
   *   right: number;
   *   bottom: number;
   * } } Padding
   *
   * @typedef { number | Partial<Padding> } PaddingConfig
   *
   * @typedef { {
   *   horizontal: 'center' | 'left';
   *   vertical: 'top' | 'center';
   * } } Alignment
   *
   *  @typedef { 'center-middle' | 'center-top' } AlignmentConfig
   *
   * @typedef { Partial<{
   *   align: AlignmentConfig;
   *   style: Record<string, number | string>;
   *   padding: PaddingConfig;
   * }> } BaseTextConfig
   *
   * @typedef { BaseTextConfig & Partial<{
   *   size: Dimensions;
   * }> } TextConfig
   *
   * @typedef { BaseTextConfig & Partial<{
   *   box: Dimensions;
   *   fitBox: boolean;
   * }> } TextLayoutConfig
   *
   *  @typedef { Dimensions & {
   *  text: string;
   * } } LineDescriptor
   */

  var DEFAULT_BOX_PADDING = 0;
  var DEFAULT_LABEL_SIZE = {
    width: 150,
    height: 50
  };

  /**
   * @param {AlignmentConfig} align
   * @return {Alignment}
   */
  function parseAlign(align) {
    var parts = align.split('-');
    return {
      horizontal: parts[0] || 'center',
      vertical: parts[1] || 'top'
    };
  }

  /**
   * @param {PaddingConfig} padding
   *
   * @return {Padding}
   */
  function parsePadding(padding) {
    if (isObject$2(padding)) {
      return assign$4({
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }, padding);
    } else {
      return {
        top: padding,
        left: padding,
        right: padding,
        bottom: padding
      };
    }
  }

  /**
   * @param {string} text
   * @param {SVGTextElement} fakeText
   *
   * @return {import('../util/Types').Dimensions}
   */
  function getTextBBox(text, fakeText) {
    fakeText.textContent = text;
    var textBBox;
    try {
      var bbox,
        emptyLine = text === '';

      // add dummy text, when line is empty to
      // determine correct height
      fakeText.textContent = emptyLine ? 'dummy' : text;
      textBBox = fakeText.getBBox();

      // take text rendering related horizontal
      // padding into account
      bbox = {
        width: textBBox.width + textBBox.x * 2,
        height: textBBox.height
      };
      if (emptyLine) {
        // correct width
        bbox.width = 0;
      }
      return bbox;
    } catch (e) {
      return {
        width: 0,
        height: 0
      };
    }
  }

  /**
   * Layout the next line and return the layouted element.
   *
   * Alters the lines passed.
   *
   * @param {string[]} lines
   * @param {number} maxWidth
   * @param {SVGTextElement} fakeText
   *
   * @return {LineDescriptor} the line descriptor
   */
  function layoutNext(lines, maxWidth, fakeText) {
    var originalLine = lines.shift(),
      fitLine = originalLine;
    var textBBox;
    for (;;) {
      textBBox = getTextBBox(fitLine, fakeText);
      textBBox.width = fitLine ? textBBox.width : 0;

      // try to fit
      if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
        return fit(lines, fitLine, originalLine, textBBox);
      }
      fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
    }
  }

  /**
   * @param {string[]} lines
   * @param {string} fitLine
   * @param {string} originalLine
   * @param {Dimensions} textBBox
   *
   * @return {LineDescriptor}
   */
  function fit(lines, fitLine, originalLine, textBBox) {
    if (fitLine.length < originalLine.length) {
      var remainder = originalLine.slice(fitLine.length).trim();
      lines.unshift(remainder);
    }
    return {
      width: textBBox.width,
      height: textBBox.height,
      text: fitLine
    };
  }
  var SOFT_BREAK = "\xAD";

  /**
   * Shortens a line based on spacing and hyphens.
   * Returns the shortened result on success.
   *
   * @param {string} line
   * @param {number} maxLength the maximum characters of the string
   *
   * @return {string} the shortened string
   */
  function semanticShorten(line, maxLength) {
    var parts = line.split(/(\s|-|\u00AD)/g),
      part,
      shortenedParts = [],
      length = 0;

    // try to shorten via break chars
    if (parts.length > 1) {
      while (part = parts.shift()) {
        if (part.length + length < maxLength) {
          shortenedParts.push(part);
          length += part.length;
        } else {
          // remove previous part, too if hyphen does not fit anymore
          if (part === '-' || part === SOFT_BREAK) {
            shortenedParts.pop();
          }
          break;
        }
      }
    }
    var last = shortenedParts[shortenedParts.length - 1];

    // translate trailing soft break to actual hyphen
    if (last && last === SOFT_BREAK) {
      shortenedParts[shortenedParts.length - 1] = '-';
    }
    return shortenedParts.join('');
  }

  /**
   * @param {string} line
   * @param {number} width
   * @param {number} maxWidth
   *
   * @return {string}
   */
  function shortenLine(line, width, maxWidth) {
    var length = Math.max(line.length * (maxWidth / width), 1);

    // try to shorten semantically (i.e. based on spaces and hyphens)
    var shortenedLine = semanticShorten(line, length);
    if (!shortenedLine) {
      // force shorten by cutting the long word
      shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
    }
    return shortenedLine;
  }

  /**
   * @return {SVGSVGElement}
   */
  function getHelperSvg() {
    var helperSvg = document.getElementById('helper-svg');
    if (!helperSvg) {
      helperSvg = create$2('svg');
      attr(helperSvg, {
        id: 'helper-svg'
      });
      assign(helperSvg, {
        visibility: 'hidden',
        position: 'fixed',
        width: 0,
        height: 0
      });
      document.body.appendChild(helperSvg);
    }
    return helperSvg;
  }

  /**
   * Creates a new label utility
   *
   * @param {TextConfig} config
   */
  function Text$1(config) {
    this._config = assign$4({}, {
      size: DEFAULT_LABEL_SIZE,
      padding: DEFAULT_BOX_PADDING,
      style: {},
      align: 'center-top'
    }, config || {});
  }

  /**
   * Returns the layouted text as an SVG element.
   *
   * @param {string} text
   * @param {TextLayoutConfig} options
   *
   * @return {SVGElement}
   */
  Text$1.prototype.createText = function (text, options) {
    return this.layoutText(text, options).element;
  };

  /**
   * Returns a labels layouted dimensions.
   *
   * @param {string} text to layout
   * @param {TextLayoutConfig} options
   *
   * @return {Dimensions}
   */
  Text$1.prototype.getDimensions = function (text, options) {
    return this.layoutText(text, options).dimensions;
  };

  /**
   * Creates and returns a label and its bounding box.
   *
   * @param {string} text the text to render on the label
   * @param {TextLayoutConfig} options
   *
   * @return { {
   *   element: SVGElement,
   *   dimensions: Dimensions
   * } }
   */
  Text$1.prototype.layoutText = function (text, options) {
    var box = assign$4({}, this._config.size, options.box),
      style = assign$4({}, this._config.style, options.style),
      align = parseAlign(options.align || this._config.align),
      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),
      fitBox = options.fitBox || false;
    var lineHeight = getLineHeight(style);

    // we split text by lines and normalize
    // {soft break} + {line break} => { line break }
    var lines = text.split(/\u00AD?\r?\n/),
      layouted = [];
    var maxWidth = box.width - padding.left - padding.right;

    // ensure correct rendering by attaching helper text node to invisible SVG
    var helperText = create$2('text');
    attr(helperText, {
      x: 0,
      y: 0
    });
    attr(helperText, style);
    var helperSvg = getHelperSvg();
    append(helperSvg, helperText);
    while (lines.length) {
      layouted.push(layoutNext(lines, maxWidth, helperText));
    }
    if (align.vertical === 'middle') {
      padding.top = padding.bottom = 0;
    }
    var totalHeight = reduce(layouted, function (sum, line, idx) {
      return sum + (lineHeight || line.height);
    }, 0) + padding.top + padding.bottom;
    var maxLineWidth = reduce(layouted, function (sum, line, idx) {
      return line.width > sum ? line.width : sum;
    }, 0);

    // the y position of the next line
    var y = padding.top;
    if (align.vertical === 'middle') {
      y += (box.height - totalHeight) / 2;
    }

    // magic number initial offset
    y -= (lineHeight || layouted[0].height) / 4;
    var textElement = create$2('text');
    attr(textElement, style);

    // layout each line taking into account that parent
    // shape might resize to fit text size
    forEach$3(layouted, function (line) {
      var x;
      y += lineHeight || line.height;
      switch (align.horizontal) {
        case 'left':
          x = padding.left;
          break;
        case 'right':
          x = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;
          break;
        default:
          // aka center
          x = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);
      }
      var tspan = create$2('tspan');
      attr(tspan, {
        x: x,
        y: y
      });
      tspan.textContent = line.text;
      append(textElement, tspan);
    });
    remove$3(helperText);
    var dimensions = {
      width: maxLineWidth,
      height: totalHeight
    };
    return {
      dimensions: dimensions,
      element: textElement
    };
  };
  function getLineHeight(style) {
    if ('fontSize' in style && 'lineHeight' in style) {
      return style.lineHeight * parseInt(style.fontSize, 10);
    }
  }

  var DEFAULT_FONT_SIZE = 12;
  var LINE_HEIGHT_RATIO = 1.2;
  var MIN_TEXT_ANNOTATION_HEIGHT = 30;
  function TextRenderer(config) {
    var defaultStyle = assign$4({
      fontFamily: 'Arial, sans-serif',
      fontSize: DEFAULT_FONT_SIZE,
      fontWeight: 'normal',
      lineHeight: LINE_HEIGHT_RATIO
    }, config && config.defaultStyle || {});
    var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;
    var externalStyle = assign$4({}, defaultStyle, {
      fontSize: fontSize
    }, config && config.externalStyle || {});
    var textUtil = new Text$1({
      style: defaultStyle
    });

    /**
     * Get the new bounds of an externally rendered,
     * layouted label.
     *
     * @param  {Bounds} bounds
     * @param  {string} text
     *
     * @return {Bounds}
     */
    this.getExternalLabelBounds = function (bounds, text) {
      var layoutedDimensions = textUtil.getDimensions(text, {
        box: {
          width: 90,
          height: 30,
          x: bounds.width / 2 + bounds.x,
          y: bounds.height / 2 + bounds.y
        },
        style: externalStyle
      });

      // resize label shape to fit label text
      return {
        x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
        y: Math.round(bounds.y),
        width: Math.ceil(layoutedDimensions.width),
        height: Math.ceil(layoutedDimensions.height)
      };
    };

    /**
     * Get the new bounds of text annotation.
     *
     * @param  {Bounds} bounds
     * @param  {string} text
     *
     * @return {Bounds}
     */
    this.getTextAnnotationBounds = function (bounds, text) {
      var layoutedDimensions = textUtil.getDimensions(text, {
        box: bounds,
        style: defaultStyle,
        align: 'left-top',
        padding: 5
      });
      return {
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))
      };
    };

    /**
     * Create a layouted text element.
     *
     * @param {string} text
     * @param {Object} [options]
     *
     * @return {SVGElement} rendered text
     */
    this.createText = function (text, options) {
      return textUtil.createText(text, options || {});
    };

    /**
     * Get default text style.
     */
    this.getDefaultStyle = function () {
      return defaultStyle;
    };

    /**
     * Get the external text style.
     */
    this.getExternalStyle = function () {
      return externalStyle;
    };
  }
  TextRenderer.$inject = ['config.textRenderer'];

  /* eslint-disable max-len */

  /**
   * Map containing SVG paths needed by BpmnRenderer.
   */

  function PathMap() {
    /**
     * Contains a map of path elements
     *
     * <h1>Path definition</h1>
     * A parameterized path is defined like this:
     * <pre>
     * 'GATEWAY_PARALLEL': {
     *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
            '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
     *   height: 17.5,
     *   width:  17.5,
     *   heightElements: [2.5, 7.5],
     *   widthElements: [2.5, 7.5]
     * }
     * </pre>
     * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling
     * is based on the ratio between the specified height and width in this object and the
     * height and width that is set as scale target (Note x,y coordinates will be scaled with
     * individual ratios).</p>
     * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.
     * The scaling is based on the computed ratios.
     * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using
     * the computed ratio coefficient.
     * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.
     *   <ul>
     *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>
     *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>
     *   </ul>
     *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.
     * </p>
      m1,1
      l 0,55.3
      c 29.8,19.7 48.4,-4.2 67.2,-6.7
      c 12.2,-2.3 19.8,1.6 30.8,6.2
      l 0,-54.6
      z
      */
    this.pathMap = {
      'KNOWLEDGE_SOURCE': {
        d: 'm {mx},{my} ' + 'l 0,{e.y0} ' + 'c {e.x0},{e.y1} {e.x1},-{e.y2} {e.x2},-{e.y3} ' + 'c {e.x3},-{e.y4} {e.x4},{e.y5} {e.x5},{e.y6} ' + 'l 0,-{e.y7}z',
        width: 100,
        height: 65,
        widthElements: [29.8, 48.4, 67.2, 12.2, 19.8, 30.8],
        heightElements: [55.3, 19.7, 4.2, 6.7, 2.3, 1.6, 6.2, 54.6]
      },
      'BUSINESS_KNOWLEDGE_MODEL': {
        d: 'm {mx},{my} l {e.x0},-{e.y0} l {e.x1},0 l 0,{e.y1} l -{e.x2},{e.y2} l -{e.x3},0z',
        width: 125,
        height: 45,
        widthElements: [13.8, 109.2, 13.8, 109.1],
        heightElements: [13.2, 29.8, 13.2]
      },
      'TEXT_ANNOTATION': {
        d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
        width: 10,
        height: 30,
        widthElements: [10],
        heightElements: [30]
      }
    };
    this.getRawPath = function getRawPath(pathId) {
      return this.pathMap[pathId].d;
    };

    /**
     * Scales the path to the given height and width.
     * <h1>Use case</h1>
     * <p>Use case is to scale the content of elements (event, gateways) based
     * on the element bounding box's size.
     * </p>
     * <h1>Why not transform</h1>
     * <p>Scaling a path with transform() will also scale the stroke and IE does not support
     * the option 'non-scaling-stroke' to prevent this.
     * Also there are use cases where only some parts of a path should be
     * scaled.</p>
     *
     * @param {string} pathId The ID of the path.
     * @param {Object} param <p>
     *   Example param object scales the path to 60% size of the container (data.width, data.height).
     *   <pre>
     *   {
     *     xScaleFactor: 0.6,
     *     yScaleFactor:0.6,
     *     containerWidth: data.width,
     *     containerHeight: data.height,
     *     position: {
     *       mx: 0.46,
     *       my: 0.2,
     *     }
     *   }
     *   </pre>
     *   <ul>
     *    <li>targetpathwidth = xScaleFactor * containerWidth</li>
     *    <li>targetpathheight = yScaleFactor * containerHeight</li>
     *    <li>Position is used to set the starting coordinate of the path. M is computed:
      *    <ul>
      *      <li>position.x * containerWidth</li>
      *      <li>position.y * containerHeight</li>
      *    </ul>
      *    Center of the container <pre> position: {
     *       mx: 0.5,
     *       my: 0.5,
     *     }</pre>
     *     Upper left corner of the container
     *     <pre> position: {
     *       mx: 0.0,
     *       my: 0.0,
     *     }</pre>
     *    </li>
     *   </ul>
     * </p>
     *
     */
    this.getScaledPath = function getScaledPath(pathId, param) {
      var rawPath = this.pathMap[pathId];

      // positioning
      // compute the start point of the path
      var mx, my;
      if (param.abspos) {
        mx = param.abspos.x;
        my = param.abspos.y;
      } else {
        mx = param.containerWidth * param.position.mx;
        my = param.containerHeight * param.position.my;
      }
      var coordinates = {}; // map for the scaled coordinates
      if (param.position) {
        // path
        var heightRatio = param.containerHeight / rawPath.height * param.yScaleFactor;
        var widthRatio = param.containerWidth / rawPath.width * param.xScaleFactor;

        // Apply height ratio
        for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
          coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
        }

        // Apply width ratio
        for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
          coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
        }
      }

      // Apply value to raw path
      var path = format(rawPath.d, {
        mx: mx,
        my: my,
        e: coordinates
      });
      return path;
    };
  }

  // helpers //////////////////////

  // copied and adjusted from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js
  var tokenRegex = /\{([^{}]+)\}/g,
    objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g; // matches .xxxxx or ["xxxxx"] to run over object properties

  function replacer(all, key, obj) {
    var res = obj;
    key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
      name = name || quotedName;
      if (res) {
        if (name in res) {
          res = res[name];
        }
        typeof res == 'function' && isFunc && (res = res());
      }
    });
    res = (res == null || res == obj ? all : res) + '';
    return res;
  }
  function format(str, obj) {
    return String(str).replace(tokenRegex, function (all, key) {
      return replacer(all, key, obj);
    });
  }

  var DrawModule = {
    __init__: ['drdRenderer'],
    drdRenderer: ['type', DrdRenderer],
    textRenderer: ['type', TextRenderer],
    pathMap: ['type', PathMap]
  };

  function DrdImporter(eventBus, canvas, elementFactory, elementRegistry) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._elementRegistry = elementRegistry;
    this._elementFactory = elementFactory;
  }
  DrdImporter.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry'];
  DrdImporter.prototype.root = function (semantic) {
    var element = this._elementFactory.createRoot(elementData$1(semantic));
    this._canvas.setRootElement(element);
    return element;
  };

  /**
   * Add drd element (semantic) to the canvas.
   */
  DrdImporter.prototype.add = function (semantic) {
    var elementFactory = this._elementFactory,
      canvas = this._canvas,
      eventBus = this._eventBus,
      di = semantic.di;
    var element, waypoints, source, target, elementDefinition, bounds;
    if (di.$instanceOf('dmndi:DMNShape')) {
      bounds = di.bounds;
      elementDefinition = elementData$1(semantic, {
        x: Math.round(bounds.x),
        y: Math.round(bounds.y),
        width: Math.round(bounds.width),
        height: Math.round(bounds.height)
      });
      element = elementFactory.createShape(elementDefinition);
      canvas.addShape(element);
      eventBus.fire('drdElement.added', {
        element: element,
        di: di
      });
    } else if (di.$instanceOf('dmndi:DMNEdge')) {
      waypoints = collectWaypoints(di);
      source = this._getSource(semantic);
      target = this._getTarget(semantic);
      if (source && target) {
        elementDefinition = elementData$1(semantic, {
          hidden: false,
          source: source,
          target: target,
          waypoints: waypoints
        });
        element = elementFactory.createConnection(elementDefinition);
        canvas.addConnection(element);
        eventBus.fire('drdElement.added', {
          element: element,
          di: di
        });
      }
    } else {
      throw new Error('unknown di for element ' + semantic.id);
    }
    return element;
  };
  DrdImporter.prototype._getSource = function (semantic) {
    var href, elementReference;
    if (is$1(semantic, 'dmn:Association')) {
      elementReference = semantic.sourceRef;
    } else if (is$1(semantic, 'dmn:InformationRequirement')) {
      elementReference = semantic.requiredDecision || semantic.requiredInput;
    } else if (is$1(semantic, 'dmn:KnowledgeRequirement')) {
      elementReference = semantic.requiredKnowledge;
    } else if (is$1(semantic, 'dmn:AuthorityRequirement')) {
      elementReference = semantic.requiredDecision || semantic.requiredInput || semantic.requiredAuthority;
    }
    if (elementReference) {
      href = elementReference.href;
    }
    if (href) {
      return this._getShape(getIdFromHref(href));
    }
  };
  DrdImporter.prototype._getTarget = function (semantic) {
    if (is$1(semantic, 'dmn:Association')) {
      return semantic.targetRef && this._getShape(getIdFromHref(semantic.targetRef.href));
    }
    return this._getShape(semantic.$parent.id);
  };
  DrdImporter.prototype._getShape = function (id) {
    return this._elementRegistry.get(id);
  };

  // helper /////
  function elementData$1(semantic, attrs) {
    return assign$4({
      id: semantic.id,
      type: semantic.$type,
      businessObject: semantic
    }, attrs);
  }
  function collectWaypoints(edge) {
    var waypoints = edge.waypoint;
    if (waypoints) {
      return map$2(waypoints, function (waypoint) {
        var position = {
          x: waypoint.x,
          y: waypoint.y
        };
        return assign$4({
          original: position
        }, position);
      });
    }
  }
  function getIdFromHref(href) {
    return href.split('#').pop();
  }

  var ImportModule = {
    drdImporter: ['type', DrdImporter]
  };

  var CoreModule$1 = {
    __depends__: [DrawModule, ImportModule]
  };

  /**
   * @typedef { {
   *   [key: string]: string;
   * } } TranslateReplacements
   */

  /**
   * A simple translation stub to be used for multi-language support
   * in diagrams. Can be easily replaced with a more sophisticated
   * solution.
   *
   * @example
   *
   * ```javascript
   * // use it inside any diagram component by injecting `translate`.
   *
   * function MyService(translate) {
   *   alert(translate('HELLO {you}', { you: 'You!' }));
   * }
   * ```
   *
   * @param {string} template to interpolate
   * @param {TranslateReplacements} [replacements] a map with substitutes
   *
   * @return {string} the translated string
   */
  function translate(template, replacements) {
    replacements = replacements || {};
    return template.replace(/{([^}]+)}/g, function (_, key) {
      return replacements[key] || '{' + key + '}';
    });
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var TranslateModule = {
    translate: ['value', translate]
  };

  /**
   * @typedef {import('../util/Types').Point} Point
   */

  function __stopPropagation(event) {
    if (!event || typeof event.stopPropagation !== 'function') {
      return;
    }
    event.stopPropagation();
  }

  /**
   * @param {import('../core/EventBus').Event} event
   *
   * @return {Event}
   */
  function getOriginal$1(event) {
    return event.originalEvent || event.srcEvent;
  }

  /**
   * @param {Event|import('../core/EventBus').Event} event
   */
  function stopPropagation$3(event) {
    __stopPropagation(event);
    __stopPropagation(getOriginal$1(event));
  }

  /**
   * @param {Event} event
   *
   * @return {Point|null}
   */
  function toPoint(event) {
    if (event.pointers && event.pointers.length) {
      event = event.pointers[0];
    }
    if (event.touches && event.touches.length) {
      event = event.touches[0];
    }
    return event ? {
      x: event.clientX,
      y: event.clientY
    } : null;
  }

  function isMac() {
    return /mac/i.test(navigator.platform);
  }

  /**
   * @param {MouseEvent} event
   * @param {string} button
   *
   * @return {boolean}
   */
  function isButton(event, button) {
    return (getOriginal$1(event) || event).button === button;
  }

  /**
   * @param {MouseEvent} event
   *
   * @return {boolean}
   */
  function isPrimaryButton(event) {
    // button === 0 -> left ka primary mouse button
    return isButton(event, 0);
  }

  /**
   * @param {MouseEvent} event
   *
   * @return {boolean}
   */
  function isAuxiliaryButton(event) {
    // button === 1 -> auxiliary ka wheel button
    return isButton(event, 1);
  }

  /**
   * @param {MouseEvent} event
   *
   * @return {boolean}
   */
  function hasPrimaryModifier(event) {
    var originalEvent = getOriginal$1(event) || event;
    if (!isPrimaryButton(event)) {
      return false;
    }

    // Use cmd as primary modifier key for mac OS
    if (isMac()) {
      return originalEvent.metaKey;
    } else {
      return originalEvent.ctrlKey;
    }
  }

  /**
   * @param {MouseEvent} event
   *
   * @return {boolean}
   */
  function hasSecondaryModifier(event) {
    var originalEvent = getOriginal$1(event) || event;
    return isPrimaryButton(event) && originalEvent.shiftKey;
  }

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../../draw/Styles').default} Styles
   *
   * @typedef {import('../../util/Types').Point} Point
   */

  function allowAll(event) {
    return true;
  }
  function allowPrimaryAndAuxiliary(event) {
    return isPrimaryButton(event) || isAuxiliaryButton(event);
  }
  var LOW_PRIORITY$m = 500;

  /**
   * A plugin that provides interaction events for diagram elements.
   *
   * It emits the following events:
   *
   *   * element.click
   *   * element.contextmenu
   *   * element.dblclick
   *   * element.hover
   *   * element.mousedown
   *   * element.mousemove
   *   * element.mouseup
   *   * element.out
   *
   * Each event is a tuple { element, gfx, originalEvent }.
   *
   * Canceling the event via Event#preventDefault()
   * prevents the original DOM operation.
   *
   * @param {EventBus} eventBus
   * @param {ElementRegistry} elementRegistry
   * @param {Styles} styles
   */
  function InteractionEvents$1(eventBus, elementRegistry, styles) {
    var self = this;

    /**
     * Fire an interaction event.
     *
     * @param {string} type local event name, e.g. element.click.
     * @param {MouseEvent|TouchEvent} event native event
     * @param {Element} [element] the diagram element to emit the event on;
     *                                   defaults to the event target
     */
    function fire(type, event, element) {
      if (isIgnored(type, event)) {
        return;
      }
      var target, gfx, returnValue;
      if (!element) {
        target = event.delegateTarget || event.target;
        if (target) {
          gfx = target;
          element = elementRegistry.get(gfx);
        }
      } else {
        gfx = elementRegistry.getGraphics(element);
      }
      if (!gfx || !element) {
        return;
      }
      returnValue = eventBus.fire(type, {
        element: element,
        gfx: gfx,
        originalEvent: event
      });
      if (returnValue === false) {
        event.stopPropagation();
        event.preventDefault();
      }
    }

    // TODO(nikku): document this
    var handlers = {};
    function mouseHandler(localEventName) {
      return handlers[localEventName];
    }
    function isIgnored(localEventName, event) {
      var filter = ignoredFilters[localEventName] || isPrimaryButton;

      // only react on left mouse button interactions
      // except for interaction events that are enabled
      // for secundary mouse button
      return !filter(event);
    }
    var bindings = {
      click: 'element.click',
      contextmenu: 'element.contextmenu',
      dblclick: 'element.dblclick',
      mousedown: 'element.mousedown',
      mousemove: 'element.mousemove',
      mouseover: 'element.hover',
      mouseout: 'element.out',
      mouseup: 'element.mouseup'
    };
    var ignoredFilters = {
      'element.contextmenu': allowAll,
      'element.mousedown': allowPrimaryAndAuxiliary,
      'element.mouseup': allowPrimaryAndAuxiliary,
      'element.click': allowPrimaryAndAuxiliary,
      'element.dblclick': allowPrimaryAndAuxiliary
    };

    // manual event trigger //////////

    /**
     * Trigger an interaction event (based on a native dom event)
     * on the target shape or connection.
     *
     * @param {string} eventName the name of the triggered DOM event
     * @param {MouseEvent|TouchEvent} event
     * @param {Element} targetElement
     */
    function triggerMouseEvent(eventName, event, targetElement) {
      // i.e. element.mousedown...
      var localEventName = bindings[eventName];
      if (!localEventName) {
        throw new Error('unmapped DOM event name <' + eventName + '>');
      }
      return fire(localEventName, event, targetElement);
    }
    var ELEMENT_SELECTOR = 'svg, .djs-element';

    // event handling ///////

    function registerEvent(node, event, localEvent, ignoredFilter) {
      var handler = handlers[localEvent] = function (event) {
        fire(localEvent, event);
      };
      if (ignoredFilter) {
        ignoredFilters[localEvent] = ignoredFilter;
      }
      handler.$delegate = delegate.bind(node, ELEMENT_SELECTOR, event, handler);
    }
    function unregisterEvent(node, event, localEvent) {
      var handler = mouseHandler(localEvent);
      if (!handler) {
        return;
      }
      delegate.unbind(node, event, handler.$delegate);
    }
    function registerEvents(svg) {
      forEach$3(bindings, function (val, key) {
        registerEvent(svg, key, val);
      });
    }
    function unregisterEvents(svg) {
      forEach$3(bindings, function (val, key) {
        unregisterEvent(svg, key, val);
      });
    }
    eventBus.on('canvas.destroy', function (event) {
      unregisterEvents(event.svg);
    });
    eventBus.on('canvas.init', function (event) {
      registerEvents(event.svg);
    });

    // hit box updating ////////////////

    eventBus.on(['shape.added', 'connection.added'], function (event) {
      var element = event.element,
        gfx = event.gfx;
      eventBus.fire('interactionEvents.createHit', {
        element: element,
        gfx: gfx
      });
    });

    // Update djs-hit on change.
    // A low priortity is necessary, because djs-hit of labels has to be updated
    // after the label bounds have been updated in the renderer.
    eventBus.on(['shape.changed', 'connection.changed'], LOW_PRIORITY$m, function (event) {
      var element = event.element,
        gfx = event.gfx;
      eventBus.fire('interactionEvents.updateHit', {
        element: element,
        gfx: gfx
      });
    });
    eventBus.on('interactionEvents.createHit', LOW_PRIORITY$m, function (event) {
      var element = event.element,
        gfx = event.gfx;
      self.createDefaultHit(element, gfx);
    });
    eventBus.on('interactionEvents.updateHit', function (event) {
      var element = event.element,
        gfx = event.gfx;
      self.updateDefaultHit(element, gfx);
    });

    // hit styles ////////////

    var STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-stroke');
    var CLICK_STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-click-stroke');
    var ALL_HIT_STYLE = createHitStyle('djs-hit djs-hit-all');
    var NO_MOVE_HIT_STYLE = createHitStyle('djs-hit djs-hit-no-move');
    var HIT_TYPES = {
      'all': ALL_HIT_STYLE,
      'click-stroke': CLICK_STROKE_HIT_STYLE,
      'stroke': STROKE_HIT_STYLE,
      'no-move': NO_MOVE_HIT_STYLE
    };
    function createHitStyle(classNames, attrs) {
      attrs = assign$4({
        stroke: 'white',
        strokeWidth: 15
      }, attrs || {});
      return styles.cls(classNames, ['no-fill', 'no-border'], attrs);
    }

    // style helpers ///////////////

    function applyStyle(hit, type) {
      var attrs = HIT_TYPES[type];
      if (!attrs) {
        throw new Error('invalid hit type <' + type + '>');
      }
      attr(hit, attrs);
      return hit;
    }
    function appendHit(gfx, hit) {
      append(gfx, hit);
    }

    // API

    /**
     * Remove hints on the given graphics.
     *
     * @param {SVGElement} gfx
     */
    this.removeHits = function (gfx) {
      var hits = all('.djs-hit', gfx);
      forEach$3(hits, remove$3);
    };

    /**
     * Create default hit for the given element.
     *
     * @param {Element} element
     * @param {SVGElement} gfx
     *
     * @return {SVGElement} created hit
     */
    this.createDefaultHit = function (element, gfx) {
      var waypoints = element.waypoints,
        isFrame = element.isFrame,
        boxType;
      if (waypoints) {
        return this.createWaypointsHit(gfx, waypoints);
      } else {
        boxType = isFrame ? 'stroke' : 'all';
        return this.createBoxHit(gfx, boxType, {
          width: element.width,
          height: element.height
        });
      }
    };

    /**
     * Create hits for the given waypoints.
     *
     * @param {SVGElement} gfx
     * @param {Point[]} waypoints
     *
     * @return {SVGElement}
     */
    this.createWaypointsHit = function (gfx, waypoints) {
      var hit = createLine(waypoints);
      applyStyle(hit, 'stroke');
      appendHit(gfx, hit);
      return hit;
    };

    /**
     * Create hits for a box.
     *
     * @param {SVGElement} gfx
     * @param {string} type
     * @param {Object} attrs
     *
     * @return {SVGElement}
     */
    this.createBoxHit = function (gfx, type, attrs) {
      attrs = assign$4({
        x: 0,
        y: 0
      }, attrs);
      var hit = create$2('rect');
      applyStyle(hit, type);
      attr(hit, attrs);
      appendHit(gfx, hit);
      return hit;
    };

    /**
     * Update default hit of the element.
     *
     * @param {Element} element
     * @param {SVGElement} gfx
     *
     * @return {SVGElement} updated hit
     */
    this.updateDefaultHit = function (element, gfx) {
      var hit = query('.djs-hit', gfx);
      if (!hit) {
        return;
      }
      if (element.waypoints) {
        updateLine(hit, element.waypoints);
      } else {
        attr(hit, {
          width: element.width,
          height: element.height
        });
      }
      return hit;
    };
    this.fire = fire;
    this.triggerMouseEvent = triggerMouseEvent;
    this.mouseHandler = mouseHandler;
    this.registerEvent = registerEvent;
    this.unregisterEvent = unregisterEvent;
  }
  InteractionEvents$1.$inject = ['eventBus', 'elementRegistry', 'styles'];

  /**
   * An event indicating that the mouse hovered over an element
   *
   * @event element.hover
   *
   * @type {Object}
   * @property {Element} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has left an element
   *
   * @event element.out
   *
   * @type {Object}
   * @property {Element} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has clicked an element
   *
   * @event element.click
   *
   * @type {Object}
   * @property {Element} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has double clicked an element
   *
   * @event element.dblclick
   *
   * @type {Object}
   * @property {Element} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has gone down on an element.
   *
   * @event element.mousedown
   *
   * @type {Object}
   * @property {Element} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has gone up on an element.
   *
   * @event element.mouseup
   *
   * @type {Object}
   * @property {Element} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the context menu action is triggered
   * via mouse or touch controls.
   *
   * @event element.contextmenu
   *
   * @type {Object}
   * @property {Element} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var InteractionEventsModule = {
    __init__: ['interactionEvents'],
    interactionEvents: ['type', InteractionEvents$1]
  };

  var LOW_PRIORITY$l = 500;
  var DEFAULT_PRIORITY$7 = 1000;

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../../draw/Styles').default} Styles
   */

  /**
   * @class
   *
   * A plugin that adds an outline to shapes and connections that may be activated and styled
   * via CSS classes.
   *
   * @param {EventBus} eventBus
   * @param {Styles} styles
   */
  function Outline$1(eventBus, styles) {
    this._eventBus = eventBus;
    this.offset = 5;
    var OUTLINE_STYLE = styles.cls('djs-outline', ['no-fill']);
    var self = this;

    /**
     * @param {SVGElement} gfx
     *
     * @return {SVGElement} outline
     */
    function createOutline(gfx) {
      var outline = create$2('rect');
      attr(outline, assign$4({
        x: 0,
        y: 0,
        rx: 4,
        width: 100,
        height: 100
      }, OUTLINE_STYLE));
      return outline;
    }

    // A low priortity is necessary, because outlines of labels have to be updated
    // after the label bounds have been updated in the renderer.
    eventBus.on(['shape.added', 'shape.changed'], LOW_PRIORITY$l, function (event) {
      var element = event.element,
        gfx = event.gfx;
      var outline = query('.djs-outline', gfx);
      if (!outline) {
        outline = self.getOutline(element) || createOutline();
        append(gfx, outline);
      }
      self.updateShapeOutline(outline, element);
    });
    eventBus.on(['connection.added', 'connection.changed'], function (event) {
      var element = event.element,
        gfx = event.gfx;
      var outline = query('.djs-outline', gfx);
      if (!outline) {
        outline = createOutline();
        append(gfx, outline);
      }
      self.updateConnectionOutline(outline, element);
    });
  }

  /**
   * Updates the outline of a shape respecting the dimension of the
   * element and an outline offset.
   *
   * @param {SVGElement} outline
   * @param {Element} element
   */
  Outline$1.prototype.updateShapeOutline = function (outline, element) {
    var updated = false;
    var providers = this._getProviders();
    if (providers.length) {
      forEach$3(providers, function (provider) {
        updated = updated || provider.updateOutline(element, outline);
      });
    }
    if (!updated) {
      attr(outline, {
        x: -this.offset,
        y: -this.offset,
        width: element.width + this.offset * 2,
        height: element.height + this.offset * 2
      });
    }
  };

  /**
   * Updates the outline of a connection respecting the bounding box of
   * the connection and an outline offset.
   * Register an outline provider with the given priority.
   *
   * @param {SVGElement} outline
   * @param {Element} connection
   */
  Outline$1.prototype.updateConnectionOutline = function (outline, connection) {
    var bbox = getBBox(connection);
    attr(outline, {
      x: bbox.x - this.offset,
      y: bbox.y - this.offset,
      width: bbox.width + this.offset * 2,
      height: bbox.height + this.offset * 2
    });
  };

  /**
   * Register an outline provider with the given priority.
   *
   * @param {number} priority
   * @param {OutlineProvider} provider
   */
  Outline$1.prototype.registerProvider = function (priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY$7;
    }
    this._eventBus.on('outline.getProviders', priority, function (event) {
      event.providers.push(provider);
    });
  };

  /**
   * Returns the registered outline providers.
   *
   * @returns {OutlineProvider[]}
   */
  Outline$1.prototype._getProviders = function () {
    var event = this._eventBus.createEvent({
      type: 'outline.getProviders',
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };

  /**
   * Returns the outline for an element.
   *
   * @param {Element} element
   **/
  Outline$1.prototype.getOutline = function (element) {
    var outline;
    var providers = this._getProviders();
    forEach$3(providers, function (provider) {
      if (!isFunction$2(provider.getOutline)) {
        return;
      }
      outline = outline || provider.getOutline(element);
    });
    return outline;
  };
  Outline$1.$inject = ['eventBus', 'styles', 'elementRegistry'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var Outline = {
    __init__: ['outline'],
    outline: ['type', Outline$1]
  };

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  /**
   * A service that offers the current selection in a diagram.
   * Offers the api to control the selection, too.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function Selection$1(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;

    /**
     * @type {Object[]}
     */
    this._selectedElements = [];
    var self = this;
    eventBus.on(['shape.remove', 'connection.remove'], function (e) {
      var element = e.element;
      self.deselect(element);
    });
    eventBus.on(['diagram.clear', 'root.set'], function (e) {
      self.select(null);
    });
  }
  Selection$1.$inject = ['eventBus', 'canvas'];

  /**
   * Deselect an element.
   *
   * @param {Object} element The element to deselect.
   */
  Selection$1.prototype.deselect = function (element) {
    var selectedElements = this._selectedElements;
    var idx = selectedElements.indexOf(element);
    if (idx !== -1) {
      var oldSelection = selectedElements.slice();
      selectedElements.splice(idx, 1);
      this._eventBus.fire('selection.changed', {
        oldSelection: oldSelection,
        newSelection: selectedElements
      });
    }
  };

  /**
   * Get the selected elements.
   *
   * @return {Object[]} The selected elements.
   */
  Selection$1.prototype.get = function () {
    return this._selectedElements;
  };

  /**
   * Check whether an element is selected.
   *
   * @param {Object} element The element.
   *
   * @return {boolean} Whether the element is selected.
   */
  Selection$1.prototype.isSelected = function (element) {
    return this._selectedElements.indexOf(element) !== -1;
  };

  /**
   * Select one or many elements.
   *
   * @param {Object|Object[]} elements The element(s) to select.
   * @param {boolean} [add] Whether to add the element(s) to the selected elements.
   * Defaults to `false`.
   */
  Selection$1.prototype.select = function (elements, add) {
    var selectedElements = this._selectedElements,
      oldSelection = selectedElements.slice();
    if (!isArray$6(elements)) {
      elements = elements ? [elements] : [];
    }
    var canvas = this._canvas;
    var rootElement = canvas.getRootElement();
    elements = elements.filter(function (element) {
      var elementRoot = canvas.findRoot(element);
      return rootElement === elementRoot;
    });

    // selection may be cleared by passing an empty array or null
    // to the method
    if (add) {
      forEach$3(elements, function (element) {
        if (selectedElements.indexOf(element) !== -1) {
          // already selected
          return;
        } else {
          selectedElements.push(element);
        }
      });
    } else {
      this._selectedElements = selectedElements = elements.slice();
    }
    this._eventBus.fire('selection.changed', {
      oldSelection: oldSelection,
      newSelection: selectedElements
    });
  };

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('./Selection').default} Selection
   */

  var MARKER_HOVER = 'hover',
    MARKER_SELECTED = 'selected';
  var SELECTION_OUTLINE_PADDING = 6;

  /**
   * A plugin that adds a visible selection UI to shapes and connections
   * by appending the <code>hover</code> and <code>selected</code> classes to them.
   *
   * @class
   *
   * Makes elements selectable, too.
   *
   * @param {Canvas} canvas
   * @param {EventBus} eventBus
   * @param {Selection} selection
   */
  function SelectionVisuals(canvas, eventBus, selection) {
    this._canvas = canvas;
    var self = this;
    this._multiSelectionBox = null;
    function addMarker(e, cls) {
      canvas.addMarker(e, cls);
    }
    function removeMarker(e, cls) {
      canvas.removeMarker(e, cls);
    }
    eventBus.on('element.hover', function (event) {
      addMarker(event.element, MARKER_HOVER);
    });
    eventBus.on('element.out', function (event) {
      removeMarker(event.element, MARKER_HOVER);
    });
    eventBus.on('selection.changed', function (event) {
      function deselect(s) {
        removeMarker(s, MARKER_SELECTED);
      }
      function select(s) {
        addMarker(s, MARKER_SELECTED);
      }
      var oldSelection = event.oldSelection,
        newSelection = event.newSelection;
      forEach$3(oldSelection, function (e) {
        if (newSelection.indexOf(e) === -1) {
          deselect(e);
        }
      });
      forEach$3(newSelection, function (e) {
        if (oldSelection.indexOf(e) === -1) {
          select(e);
        }
      });
      self._updateSelectionOutline(newSelection);
    });
    eventBus.on('element.changed', function (event) {
      if (selection.isSelected(event.element)) {
        self._updateSelectionOutline(selection.get());
      }
    });
  }
  SelectionVisuals.$inject = ['canvas', 'eventBus', 'selection'];
  SelectionVisuals.prototype._updateSelectionOutline = function (selection) {
    var layer = this._canvas.getLayer('selectionOutline');
    clear(layer);
    var enabled = selection.length > 1;
    var container = this._canvas.getContainer();
    classes(container)[enabled ? 'add' : 'remove']('djs-multi-select');
    if (!enabled) {
      return;
    }
    var bBox = addSelectionOutlinePadding(getBBox(selection));
    var rect = create$2('rect');
    attr(rect, assign$4({
      rx: 3
    }, bBox));
    classes(rect).add('djs-selection-outline');
    append(layer, rect);
  };

  // helpers //////////

  function addSelectionOutlinePadding(bBox) {
    return {
      x: bBox.x - SELECTION_OUTLINE_PADDING,
      y: bBox.y - SELECTION_OUTLINE_PADDING,
      width: bBox.width + SELECTION_OUTLINE_PADDING * 2,
      height: bBox.height + SELECTION_OUTLINE_PADDING * 2
    };
  }

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('./Selection').default} Selection
   */

  /**
   * @param {EventBus} eventBus
   * @param {Selection} selection
   * @param {Canvas} canvas
   * @param {ElementRegistry} elementRegistry
   */
  function SelectionBehavior$1(eventBus, selection, canvas, elementRegistry) {
    // Select elements on create
    eventBus.on('create.end', 500, function (event) {
      var context = event.context,
        canExecute = context.canExecute,
        elements = context.elements,
        hints = context.hints || {},
        autoSelect = hints.autoSelect;
      if (canExecute) {
        if (autoSelect === false) {
          // Select no elements
          return;
        }
        if (isArray$6(autoSelect)) {
          selection.select(autoSelect);
        } else {
          // Select all elements by default
          selection.select(elements.filter(isShown));
        }
      }
    });

    // Select connection targets on connect
    eventBus.on('connect.end', 500, function (event) {
      var context = event.context,
        connection = context.connection;
      if (connection) {
        selection.select(connection);
      }
    });

    // Select shapes on move
    eventBus.on('shape.move.end', 500, function (event) {
      var previousSelection = event.previousSelection || [];
      var shape = elementRegistry.get(event.context.shape.id);

      // Always select main shape on move
      var isSelected = find$2(previousSelection, function (selectedShape) {
        return shape.id === selectedShape.id;
      });
      if (!isSelected) {
        selection.select(shape);
      }
    });

    // Select elements on click
    eventBus.on('element.click', function (event) {
      if (!isPrimaryButton(event)) {
        return;
      }
      var element = event.element;
      if (element === canvas.getRootElement()) {
        element = null;
      }
      var isSelected = selection.isSelected(element),
        isMultiSelect = selection.get().length > 1;

      // Add to selection if CTRL or SHIFT pressed
      var add = hasPrimaryModifier(event) || hasSecondaryModifier(event);
      if (isSelected && isMultiSelect) {
        if (add) {
          // Deselect element
          return selection.deselect(element);
        } else {
          // Select element only
          return selection.select(element);
        }
      } else if (!isSelected) {
        // Select element
        selection.select(element, add);
      } else {
        // Deselect element
        selection.deselect(element);
      }
    });
  }
  SelectionBehavior$1.$inject = ['eventBus', 'selection', 'canvas', 'elementRegistry'];
  function isShown(element) {
    return !element.hidden;
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var SelectionModule = {
    __init__: ['selectionVisuals', 'selectionBehavior'],
    __depends__: [InteractionEventsModule, Outline],
    selection: ['type', Selection$1],
    selectionVisuals: ['type', SelectionVisuals],
    selectionBehavior: ['type', SelectionBehavior$1]
  };

  /**
   * Util that provides unique IDs.
   *
   * @class
   * @constructor
   *
   * The ids can be customized via a given prefix and contain a random value to avoid collisions.
   *
   * @param {string} [prefix] a prefix to prepend to generated ids (for better readability)
   */
  function IdGenerator(prefix) {
    this._counter = 0;
    this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
  }

  /**
   * Returns a next unique ID.
   *
   * @return {string} the id
   */
  IdGenerator.prototype.next = function () {
    return this._prefix + ++this._counter;
  };

  // document wide unique overlay ids
  var ids = new IdGenerator('ov');
  var LOW_PRIORITY$k = 500;

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   *
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef { {
   *   minZoom?: number,
   *   maxZoom?: number
   * } } OverlaysConfigShow
   *
   * @typedef { {
   *   min?: number,
   *   max?: number
   * } } OverlaysConfigScale
   *
   * @typedef { {
  *   id: string,
  *   type: string | null,
  *   element: Element | string
  * } & OverlayAttrs } Overlay
  *
   * @typedef { {
   *   html: HTMLElement | string,
   *   position: {
   *     top?: number,
   *     right?: number,
   *     bottom?: number,
   *     left?: number
   *   }
   * } & OverlaysConfigDefault } OverlayAttrs
   *
   * @typedef { {
   *   html: HTMLElement,
   *   element: Element,
   *   overlays: Overlay[]
   * } } OverlayContainer
   *
   * @typedef {{
   *   defaults?: OverlaysConfigDefault
   * }} OverlaysConfig
   *
   * @typedef { {
   *  show?: OverlaysConfigShow,
   *  scale?: OverlaysConfigScale | boolean
   * } } OverlaysConfigDefault
   *
   * @typedef { {
   *   id?: string;
   *   element?: Element | string;
   *   type?: string;
   * } | string } OverlaysFilter
   */

  /**
   * A service that allows users to attach overlays to diagram elements.
   *
   * The overlay service will take care of overlay positioning during updates.
   *
   * @example
   *
   * ```javascript
   * // add a pink badge on the top left of the shape
   *
   * overlays.add(someShape, {
   *   position: {
   *     top: -5,
   *     left: -5
   *   },
   *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
   * });
   *
   * // or add via shape id
   *
   * overlays.add('some-element-id', {
   *   position: {
   *     top: -5,
   *     left: -5
   *   }
   *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
   * });
   *
   * // or add with optional type
   *
   * overlays.add(someShape, 'badge', {
   *   position: {
   *     top: -5,
   *     left: -5
   *   }
   *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
   * });
   * ```
   *
   * ```javascript
   * // remove an overlay
   *
   * var id = overlays.add(...);
   * overlays.remove(id);
   *
   *
   * You may configure overlay defaults during tool by providing a `config` module
   * with `overlays.defaults` as an entry:
   *
   * {
   *   overlays: {
   *     defaults: {
   *       show: {
   *         minZoom: 0.7,
   *         maxZoom: 5.0
   *       },
   *       scale: {
   *         min: 1
   *       }
   *     }
   * }
   * ```
   *
   * @param {OverlaysConfig} config
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {ElementRegistry} elementRegistry
   */
  function Overlays(config, eventBus, canvas, elementRegistry) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._elementRegistry = elementRegistry;
    this._ids = ids;

    /**
     * @type {OverlaysConfigDefault}
     */
    this._overlayDefaults = assign$4({
      // no show constraints
      show: null,
      // always scale
      scale: true
    }, config && config.defaults);

    /**
     * @type {Map<string, Overlay>}
     */
    this._overlays = {};

    /**
     * @type {OverlayContainer[]}
     */
    this._overlayContainers = [];

    /**
     * @type {HTMLElement}
     */
    this._overlayRoot = createRoot(canvas.getContainer());
    this._init();
  }
  Overlays.$inject = ['config.overlays', 'eventBus', 'canvas', 'elementRegistry'];

  /**
   * Returns the overlay with the specified ID or a list of overlays
   * for an element with a given type.
   *
   * @example
   *
   * ```javascript
   * // return the single overlay with the given ID
   * overlays.get('some-id');
   *
   * // return all overlays for the shape
   * overlays.get({ element: someShape });
   *
   * // return all overlays on shape with type 'badge'
   * overlays.get({ element: someShape, type: 'badge' });
   *
   * // shape can also be specified as ID
   * overlays.get({ element: 'element-id', type: 'badge' });
   * ```
   *
   * @param {OverlaysFilter} search The filter to be used to find the overlay(s).
   *
   * @return {Overlay|Overlay[]} The overlay(s).
   */
  Overlays.prototype.get = function (search) {
    if (isString$4(search)) {
      search = {
        id: search
      };
    }
    if (isString$4(search.element)) {
      search.element = this._elementRegistry.get(search.element);
    }
    if (search.element) {
      var container = this._getOverlayContainer(search.element, true);

      // return a list of overlays when searching by element (+type)
      if (container) {
        return search.type ? filter$2(container.overlays, matchPattern({
          type: search.type
        })) : container.overlays.slice();
      } else {
        return [];
      }
    } else if (search.type) {
      return filter$2(this._overlays, matchPattern({
        type: search.type
      }));
    } else {
      // return single element when searching by id
      return search.id ? this._overlays[search.id] : null;
    }
  };

  /**
   * Adds an HTML overlay to an element.
   *
   * @param {Element|string} element The element to add the overlay to.
   * @param {string} [type] An optional type that can be used to filter.
   * @param {OverlayAttrs} overlay The overlay.
   *
   * @return {string} The overlay's ID that can be used to get or remove it.
   */
  Overlays.prototype.add = function (element, type, overlay) {
    if (isObject$2(type)) {
      overlay = type;
      type = null;
    }
    if (!element.id) {
      element = this._elementRegistry.get(element);
    }
    if (!overlay.position) {
      throw new Error('must specifiy overlay position');
    }
    if (!overlay.html) {
      throw new Error('must specifiy overlay html');
    }
    if (!element) {
      throw new Error('invalid element specified');
    }
    var id = this._ids.next();
    overlay = assign$4({}, this._overlayDefaults, overlay, {
      id: id,
      type: type,
      element: element,
      html: overlay.html
    });
    this._addOverlay(overlay);
    return id;
  };

  /**
   * Remove an overlay with the given ID or all overlays matching the given filter.
   *
   * @see Overlays#get for filter options.
   *
   * @param {OverlaysFilter} filter The filter to be used to find the overlay.
   */
  Overlays.prototype.remove = function (filter) {
    var overlays = this.get(filter) || [];
    if (!isArray$6(overlays)) {
      overlays = [overlays];
    }
    var self = this;
    forEach$3(overlays, function (overlay) {
      var container = self._getOverlayContainer(overlay.element, true);
      if (overlay) {
        remove$4(overlay.html);
        remove$4(overlay.htmlContainer);
        delete overlay.htmlContainer;
        delete overlay.element;
        delete self._overlays[overlay.id];
      }
      if (container) {
        var idx = container.overlays.indexOf(overlay);
        if (idx !== -1) {
          container.overlays.splice(idx, 1);
        }
      }
    });
  };

  /**
   * Checks whether overlays are shown.
   *
   * @return {boolean} Whether overlays are shown.
   */
  Overlays.prototype.isShown = function () {
    return this._overlayRoot.style.display !== 'none';
  };

  /**
   * Show all overlays.
   */
  Overlays.prototype.show = function () {
    setVisible(this._overlayRoot);
  };

  /**
   * Hide all overlays.
   */
  Overlays.prototype.hide = function () {
    setVisible(this._overlayRoot, false);
  };

  /**
   * Remove all overlays and their container.
   */
  Overlays.prototype.clear = function () {
    this._overlays = {};
    this._overlayContainers = [];
    clear$1(this._overlayRoot);
  };
  Overlays.prototype._updateOverlayContainer = function (container) {
    var element = container.element,
      html = container.html;

    // update container left,top according to the elements x,y coordinates
    // this ensures we can attach child elements relative to this container

    var x = element.x,
      y = element.y;
    if (element.waypoints) {
      var bbox = getBBox(element);
      x = bbox.x;
      y = bbox.y;
    }
    setPosition(html, x, y);
    attr$1(container.html, 'data-container-id', element.id);
  };
  Overlays.prototype._updateOverlay = function (overlay) {
    var position = overlay.position,
      htmlContainer = overlay.htmlContainer,
      element = overlay.element;

    // update overlay html relative to shape because
    // it is already positioned on the element

    // update relative
    var left = position.left,
      top = position.top;
    if (position.right !== undefined) {
      var width;
      if (element.waypoints) {
        width = getBBox(element).width;
      } else {
        width = element.width;
      }
      left = position.right * -1 + width;
    }
    if (position.bottom !== undefined) {
      var height;
      if (element.waypoints) {
        height = getBBox(element).height;
      } else {
        height = element.height;
      }
      top = position.bottom * -1 + height;
    }
    setPosition(htmlContainer, left || 0, top || 0);
    this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
  };
  Overlays.prototype._createOverlayContainer = function (element) {
    var html = domify$1('<div class="djs-overlays" />');
    assign(html, {
      position: 'absolute'
    });
    this._overlayRoot.appendChild(html);
    var container = {
      html: html,
      element: element,
      overlays: []
    };
    this._updateOverlayContainer(container);
    this._overlayContainers.push(container);
    return container;
  };
  Overlays.prototype._updateRoot = function (viewbox) {
    var scale = viewbox.scale || 1;
    var matrix = 'matrix(' + [scale, 0, 0, scale, -1 * viewbox.x * scale, -1 * viewbox.y * scale].join(',') + ')';
    setTransform(this._overlayRoot, matrix);
  };
  Overlays.prototype._getOverlayContainer = function (element, raw) {
    var container = find$2(this._overlayContainers, function (c) {
      return c.element === element;
    });
    if (!container && !raw) {
      return this._createOverlayContainer(element);
    }
    return container;
  };
  Overlays.prototype._addOverlay = function (overlay) {
    var id = overlay.id,
      element = overlay.element,
      html = overlay.html,
      htmlContainer,
      overlayContainer;

    // unwrap jquery (for those who need it)
    if (html.get && html.constructor.prototype.jquery) {
      html = html.get(0);
    }

    // create proper html elements from
    // overlay HTML strings
    if (isString$4(html)) {
      html = domify$1(html);
    }
    overlayContainer = this._getOverlayContainer(element);
    htmlContainer = domify$1('<div class="djs-overlay" data-overlay-id="' + id + '">');
    assign(htmlContainer, {
      position: 'absolute'
    });
    htmlContainer.appendChild(html);
    if (overlay.type) {
      classes$1(htmlContainer).add('djs-overlay-' + overlay.type);
    }
    var elementRoot = this._canvas.findRoot(element);
    var activeRoot = this._canvas.getRootElement();
    setVisible(htmlContainer, elementRoot === activeRoot);
    overlay.htmlContainer = htmlContainer;
    overlayContainer.overlays.push(overlay);
    overlayContainer.html.appendChild(htmlContainer);
    this._overlays[id] = overlay;
    this._updateOverlay(overlay);
    this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
  };
  Overlays.prototype._updateOverlayVisibilty = function (overlay, viewbox) {
    var show = overlay.show,
      rootElement = this._canvas.findRoot(overlay.element),
      minZoom = show && show.minZoom,
      maxZoom = show && show.maxZoom,
      htmlContainer = overlay.htmlContainer,
      activeRootElement = this._canvas.getRootElement(),
      visible = true;
    if (rootElement !== activeRootElement) {
      visible = false;
    } else if (show) {
      if (isDefined(minZoom) && minZoom > viewbox.scale || isDefined(maxZoom) && maxZoom < viewbox.scale) {
        visible = false;
      }
    }
    setVisible(htmlContainer, visible);
    this._updateOverlayScale(overlay, viewbox);
  };
  Overlays.prototype._updateOverlayScale = function (overlay, viewbox) {
    var shouldScale = overlay.scale,
      minScale,
      maxScale,
      htmlContainer = overlay.htmlContainer;
    var scale,
      transform = '';
    if (shouldScale !== true) {
      if (shouldScale === false) {
        minScale = 1;
        maxScale = 1;
      } else {
        minScale = shouldScale.min;
        maxScale = shouldScale.max;
      }
      if (isDefined(minScale) && viewbox.scale < minScale) {
        scale = (1 / viewbox.scale || 1) * minScale;
      }
      if (isDefined(maxScale) && viewbox.scale > maxScale) {
        scale = (1 / viewbox.scale || 1) * maxScale;
      }
    }
    if (isDefined(scale)) {
      transform = 'scale(' + scale + ',' + scale + ')';
    }
    setTransform(htmlContainer, transform);
  };
  Overlays.prototype._updateOverlaysVisibilty = function (viewbox) {
    var self = this;
    forEach$3(this._overlays, function (overlay) {
      self._updateOverlayVisibilty(overlay, viewbox);
    });
  };
  Overlays.prototype._init = function () {
    var eventBus = this._eventBus;
    var self = this;

    // scroll/zoom integration

    function updateViewbox(viewbox) {
      self._updateRoot(viewbox);
      self._updateOverlaysVisibilty(viewbox);
      self.show();
    }
    eventBus.on('canvas.viewbox.changing', function (event) {
      self.hide();
    });
    eventBus.on('canvas.viewbox.changed', function (event) {
      updateViewbox(event.viewbox);
    });

    // remove integration

    eventBus.on(['shape.remove', 'connection.remove'], function (e) {
      var element = e.element;
      var overlays = self.get({
        element: element
      });
      forEach$3(overlays, function (o) {
        self.remove(o.id);
      });
      var container = self._getOverlayContainer(element);
      if (container) {
        remove$4(container.html);
        var i = self._overlayContainers.indexOf(container);
        if (i !== -1) {
          self._overlayContainers.splice(i, 1);
        }
      }
    });

    // move integration

    eventBus.on('element.changed', LOW_PRIORITY$k, function (e) {
      var element = e.element;
      var container = self._getOverlayContainer(element, true);
      if (container) {
        forEach$3(container.overlays, function (overlay) {
          self._updateOverlay(overlay);
        });
        self._updateOverlayContainer(container);
      }
    });

    // marker integration, simply add them on the overlays as classes, too.

    eventBus.on('element.marker.update', function (e) {
      var container = self._getOverlayContainer(e.element, true);
      if (container) {
        classes$1(container.html)[e.add ? 'add' : 'remove'](e.marker);
      }
    });
    eventBus.on('root.set', function () {
      self._updateOverlaysVisibilty(self._canvas.viewbox());
    });

    // clear overlays with diagram

    eventBus.on('diagram.clear', this.clear, this);
  };

  // helpers /////////////////////////////

  function createRoot(parentNode) {
    var root = domify$1('<div class="djs-overlay-container" />');
    assign(root, {
      position: 'absolute',
      width: 0,
      height: 0
    });
    parentNode.insertBefore(root, parentNode.firstChild);
    return root;
  }
  function setPosition(el, x, y) {
    assign(el, {
      left: x + 'px',
      top: y + 'px'
    });
  }

  /**
   * Set element visible
   *
   * @param {DOMElement} el
   * @param {boolean} [visible=true]
   */
  function setVisible(el, visible) {
    el.style.display = visible === false ? 'none' : '';
  }
  function setTransform(el, transform) {
    el.style['transform-origin'] = 'top left';
    ['', '-ms-', '-webkit-'].forEach(function (prefix) {
      el.style[prefix + 'transform'] = transform;
    });
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var OverlaysModule = {
    __init__: ['overlays'],
    overlays: ['type', Overlays]
  };

  function DefinitionPropertiesView(eventBus, canvas, translate) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._translate = translate;
    eventBus.on('diagram.init', function () {
      this._init();
    }, this);
    eventBus.on('import.done', function (event) {
      if (!event.error) {
        this.update();
      }
    }, this);

    /* markup definition */

    this.HTML_MARKUP = '<div class="dmn-definitions">' + '<div class="dmn-definitions-name" title="' + this._translate('Definition name') + '" spellcheck="false">' + '</div>' + '<div class="dmn-definitions-id" title="' + this._translate('Definition ID') + '" spellcheck="false">' + '</div>' + '</div>';
  }
  DefinitionPropertiesView.$inject = ['eventBus', 'canvas', 'translate'];

  /**
   * Initialize
   */
  DefinitionPropertiesView.prototype._init = function () {
    var canvas = this._canvas,
      eventBus = this._eventBus;
    var parent = canvas.getContainer(),
      container = this._container = domify$1(this.HTML_MARKUP);
    parent.appendChild(container);
    this.nameElement = query('.dmn-definitions-name', this._container);
    this.idElement = query('.dmn-definitions-id', this._container);
    delegate.bind(container, '.dmn-definitions-name, .dmn-definitions-id', 'mousedown', function (event) {
      event.stopPropagation();
    });
    eventBus.fire('definitionIdView.create', {
      html: container
    });
  };
  DefinitionPropertiesView.prototype.update = function () {
    var businessObject = this._canvas.getRootElement().businessObject;
    this.nameElement.textContent = businessObject.name;
    this.idElement.textContent = businessObject.id;
  };

  function PaletteAdapter(eventBus, canvas) {
    function toggleMarker(cls, on) {
      var container = canvas.getContainer();
      classes$1(container).toggle(cls, on);
    }
    eventBus.on('palette.create', function () {
      toggleMarker('with-palette', true);
    });
    eventBus.on('palette.changed', function (event) {
      toggleMarker('with-palette-two-column', event.twoColumn);
    });
  }
  PaletteAdapter.$inject = ['eventBus', 'canvas'];

  var DefinitionPropertiesViewer = {
    __depends__: [TranslateModule],
    __init__: ['definitionPropertiesView', 'definitionPropertiesPaletteAdapter'],
    definitionPropertiesView: ['type', DefinitionPropertiesView],
    definitionPropertiesPaletteAdapter: ['type', PaletteAdapter]
  };

  var PROVIDERS = [{
    className: 'dmn-icon-decision-table',
    matches: function matches(el) {
      var businessObject = el.businessObject;
      return is$1(businessObject, 'dmn:Decision') && is$1(businessObject.decisionLogic, 'dmn:DecisionTable');
    }
  }, {
    className: 'dmn-icon-literal-expression',
    matches: function matches(el) {
      var businessObject = el.businessObject;
      return is$1(businessObject, 'dmn:Decision') && is$1(businessObject.decisionLogic, 'dmn:LiteralExpression');
    }
  }];

  /**
   * Displays overlays that can be clicked in order to drill
   * down into a DMN element.
   */
  var DrillDown = /*#__PURE__*/function () {
    function DrillDown(injector, eventBus, overlays, config) {
      var _this = this;
      _classCallCheck(this, DrillDown);
      this._injector = injector;
      this._eventBus = eventBus;
      this._overlays = overlays;
      this._config = config || {
        enabled: true
      };
      eventBus.on(['shape.added'], function (_ref) {
        var element = _ref.element;
        for (var i = 0; i < PROVIDERS.length; i++) {
          var _PROVIDERS$i = PROVIDERS[i],
            matches = _PROVIDERS$i.matches,
            className = _PROVIDERS$i.className;
          var editable = matches && matches(element);
          if (editable) {
            _this.addOverlay(element, className);
          }
        }
      });
    }

    /**
     * Add overlay to an element that enables drill down.
     *
     * @param {Object} element Element to add overlay to.
     * @param {string} className
     *        CSS class that will be added to overlay in order to display icon.
     */
    _createClass(DrillDown, [{
      key: "addOverlay",
      value: function addOverlay(element, className) {
        var enabled = this._config.enabled !== false;
        var html = domify$1("\n      <div class=\"drill-down-overlay\">\n        ".concat(enabled ? "<button type=\"button\" class=\"".concat(className, "\"></button>") : "<span class=\"".concat(className, "\"></span>"), "\n      </div>\n    "));
        var overlayId = this._overlays.add(element, {
          position: {
            top: 2,
            left: 2
          },
          html: html
        });

        // TODO(nikku): can we remove renamed to drillDown.enabled
        if (enabled) {
          classes$1(html).add('interactive');
          this.bindEventListener(element, html, overlayId);
        }
      }

      /**
       * @param {Object} element
       * @param {Object} overlay
       * @param {string} id
       */
    }, {
      key: "bindEventListener",
      value: function bindEventListener(element, overlay, id) {
        var _this2 = this;
        var overlays = this._overlays,
          eventBus = this._eventBus;
        var overlaysRoot = overlays._overlayRoot;
        delegate.bind(overlaysRoot, '[data-overlay-id="' + id + '"]', 'click', function () {
          var triggerDefault = eventBus.fire('drillDown.click', {
            element: element
          });
          if (triggerDefault === false) {
            return;
          }
          _this2.drillDown(element);
        });
      }

      /**
       * Drill down into the specific element.
       *
       * @param  {djs.model.Base} element
       *
       * @return {boolean} whether drill down was executed
       */
    }, {
      key: "drillDown",
      value: function drillDown(element) {
        var parent = this._injector.get('_parent', false);

        // no parent; skip drill down
        if (!parent) {
          return false;
        }
        var view = parent.getView(element.businessObject);

        // no view to drill down to
        if (!view) {
          return false;
        }
        parent.open(view);
        return true;
      }
    }]);
    return DrillDown;
  }();
  DrillDown.$inject = ['injector', 'eventBus', 'overlays', 'config.drillDown'];

  var DrillDownModule = {
    __depends__: [OverlaysModule],
    __init__: ['drillDown'],
    drillDown: ['type', DrillDown]
  };

  /**
   * This file must not be changed or exchanged.
   *
   * @see http://bpmn.io/license for more information.
   */


  // inlined ../../../../resources/logo.svg
  // eslint-disable-next-line
  var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.02 5.57" width="53" height="21" style="vertical-align:middle"><path fill="#000000" d="M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"/><path fill="#000000" d="M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"/></svg>';
  var BPMNIO_IMG = BPMNIO_LOGO_SVG;
  function css(attrs) {
    return attrs.join(';');
  }
  var LIGHTBOX_STYLES = css(['z-index: 1001', 'position: fixed', 'top: 0', 'left: 0', 'right: 0', 'bottom: 0']);
  var BACKDROP_STYLES = css(['width: 100%', 'height: 100%', 'background: rgba(40,40,40,0.2)']);
  var NOTICE_STYLES = css(['position: absolute', 'left: 50%', 'top: 40%', 'transform: translate(-50%)', 'width: 260px', 'padding: 10px', 'background: white', 'box-shadow: 0 1px 4px rgba(0,0,0,0.3)', 'font-family: Helvetica, Arial, sans-serif', 'font-size: 14px', 'display: flex', 'line-height: 1.3']);

  /* eslint-disable max-len */
  var LIGHTBOX_MARKUP = '<div class="bjs-powered-by-lightbox" style="' + LIGHTBOX_STYLES + '">' + '<div class="backdrop" style="' + BACKDROP_STYLES + '"></div>' + '<div class="notice" style="' + NOTICE_STYLES + '">' + '<a href="https://bpmn.io" target="_blank" rel="noopener" style="margin: 15px 20px 15px 10px; align-self: center;' + '">' + BPMNIO_IMG + '</a>' + '<span>' + 'Web-based tooling for BPMN, DMN and CMMN diagrams ' + 'powered by <a href="https://bpmn.io" target="_blank" rel="noopener">bpmn.io</a>.' + '</span>' + '</div>' + '</div>';
  /* eslint-enable */

  var lightbox;
  function open() {
    if (!lightbox) {
      lightbox = domify$1(LIGHTBOX_MARKUP);
      delegate.bind(lightbox, '.backdrop', 'click', function (event) {
        document.body.removeChild(lightbox);
      });
    }
    document.body.appendChild(lightbox);
  }

  var _excluded$9 = ["additionalModules", "canvas"];
  function ownKeys$b(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$b(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$b(Object(source), !0).forEach(function (key) {
        _defineProperty$K(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$K(obj, key, value) {
    key = _toPropertyKey$H(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$H(arg) {
    var key = _toPrimitive$H(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$H(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _objectWithoutProperties$6(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$6(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$6(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  /**
   * @typedef {import('dmn-js-shared/lib/base/View).OpenResult} OpenResult
   */

  /**
   * @typedef {import('dmn-js-shared/lib/base/View).OpenError} OpenError
   */

  /**
   * A viewer for DMN diagrams.
   *
   * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include
   * additional features.
   *
   *
   * ## Extending the Viewer
   *
   * In order to extend the viewer pass extension modules to bootstrap via the
   * `additionalModules` option. An extension module is an object that exposes
   * named services.
   *
   * The following example depicts the integration of a simple
   * logging component that integrates with interaction events:
   *
   *
   * ```javascript
   *
   * // logging component
   * function InteractionLogger(eventBus) {
   *   eventBus.on('element.hover', function(event) {
   *     console.log()
   *   })
   * }
   *
   * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
   *
   * // extension module
   * var extensionModule = {
   *   __init__: [ 'interactionLogger' ],
   *   interactionLogger: [ 'type', InteractionLogger ]
   * };
   *
   * // extend the viewer
   * var drdViewer = new Viewer({ additionalModules: [ extensionModule ] });
   * drdViewer.importXML(...);
   * ```
   *
   * @param {Object} options configuration options to pass to the viewer
   * @param {DOMElement} [options.container]
   *        the container to render the viewer in, defaults to body
   * @param {Array<didi.Module>} [options.modules]
   *        a list of modules to override the default modules
   * @param {Array<didi.Module>} [options.additionalModules]
   *        a list of modules to use with the default modules
   */
  function Viewer$3(options) {
    this._container = this._createContainer();

    /* <project-logo> */

    addProjectLogo(this._container);

    /* </project-logo> */

    this._init(this._container, options);
  }
  e$2(Viewer$3, Diagram);

  /**
   * The saveSVG result.
   *
   * @typedef {Object} SaveSVGResult
   *
   * @property {string} svg
   */

  /**
   * Export the currently displayed DMN diagram as
   * an SVG image.
   *
   * @param {Object} [options]
   *
   * @return {Promise<SaveSVGResult>}
   */
  Viewer$3.prototype.saveSVG = wrapForCompatibility(function (options) {
    var self = this;
    return new Promise(function (resolve) {
      var canvas = self.get('canvas');
      var contentNode = canvas.getActiveLayer(),
        defsNode = query('defs', canvas._svg);
      var contents = innerSVG(contentNode),
        defs = defsNode && defsNode.outerHTML || '';
      var bbox = contentNode.getBBox();

      /* eslint-disable max-len */
      var svg = '<?xml version="1.0" encoding="utf-8"?>\n' + '<!-- created with dmn-js / http://bpmn.io -->\n' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' + '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'width="' + bbox.width + '" height="' + bbox.height + '" ' + 'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' + defs + contents + '</svg>';
      /* eslint-enable */

      resolve({
        svg: svg
      });
    });
  });
  Viewer$3.prototype.getModules = function () {
    return this._modules;
  };

  /**
   * Destroy the viewer instance and remove all its
   * remainders from the document tree.
   */
  Viewer$3.prototype.destroy = function () {
    // diagram destroy
    Diagram.prototype.destroy.call(this);

    // dom detach
    remove$4(this._container);
  };

  /**
   * Register an event listener
   *
   * Remove a previously added listener via {@link #off(event, callback)}.
   *
   * @param {string} event
   * @param {number} [priority]
   * @param {Function} callback
   * @param {Object} [that]
   */
  Viewer$3.prototype.on = function (event, priority, callback, target) {
    return this.get('eventBus').on(event, priority, callback, target);
  };

  /**
   * De-register an event listener
   *
   * @param {string} event
   * @param {Function} callback
   */
  Viewer$3.prototype.off = function (event, callback) {
    this.get('eventBus').off(event, callback);
  };
  Viewer$3.prototype._init = function (container, options) {
    var additionalModules = options.additionalModules,
      canvas = options.canvas,
      additionalOptions = _objectWithoutProperties$6(options, _excluded$9);
    var baseModules = options.modules || this.getModules(),
      staticModules = [{
        drd: ['value', this]
      }];
    var modules = [].concat(staticModules, _toConsumableArray(baseModules), _toConsumableArray(additionalModules || []));
    var diagramOptions = _objectSpread$b(_objectSpread$b({}, additionalOptions), {}, {
      canvas: _objectSpread$b(_objectSpread$b({}, canvas), {}, {
        container: container
      }),
      modules: modules
    });

    // invoke diagram constructor
    Diagram.call(this, diagramOptions);
    if (options && options.container) {
      this.attachTo(options.container);
    }
  };

  /**
   * Emit an event on the underlying {@link EventBus}
   *
   * @param  {string} type
   * @param  {Object} event
   *
   * @return {Object} event processing result (if any)
   */
  Viewer$3.prototype._emit = function (type, event) {
    return this.get('eventBus').fire(type, event);
  };
  Viewer$3.prototype._createContainer = function () {
    return domify$1('<div class="dmn-drd-container"></div>');
  };

  /**
   * Open diagram element.
   *
   * @param  {ModdleElement} definitions
   * @returns {Promise} Resolves with {OpenResult} when successful
   * or rejects with {OpenError}
   */
  Viewer$3.prototype.open = function (definitions) {
    var self = this;
    return new Promise(function (resolve, reject) {
      var err;

      // use try/catch to not swallow synchronous exceptions
      // that may be raised during model parsing
      try {
        if (self._definitions) {
          // clear existing rendered diagram
          self.clear();
        }

        // update definitions
        self._definitions = definitions;

        // perform graphical import
        return importDRD(self, definitions, function (err, warnings) {
          if (err) {
            err.warnings = warnings || [];
            reject(err);
          } else {
            resolve({
              warnings: warnings || []
            });
          }
        });
      } catch (e) {
        err = e;
      }
      if (err) {
        err.warnings = err.warnings || [];
        reject(err);
      } else {
        resolve({
          warnings: []
        });
      }
    });
  };

  /**
   * Attach viewer to given parent node.
   *
   * @param  {Element} parentNode
   */
  Viewer$3.prototype.attachTo = function (parentNode) {
    if (!parentNode) {
      throw new Error('parentNode required');
    }

    // ensure we detach from the
    // previous, old parent
    this.detach();
    var container = this._container;
    parentNode.appendChild(container);
    this._emit('attach', {});
    this.get('canvas').resized();
  };

  /**
   * Detach viewer from parent node, if attached.
   */
  Viewer$3.prototype.detach = function () {
    var container = this._container,
      parentNode = container.parentNode;
    if (!parentNode) {
      return;
    }
    this._emit('detach', {});
    parentNode.removeChild(container);
  };
  Viewer$3.prototype._modules = [CoreModule$1, TranslateModule, SelectionModule, OverlaysModule, DefinitionPropertiesViewer, DrillDownModule];

  /**
   * Adds the project logo to the diagram container as
   * required by the bpmn.io license.
   *
   * @see http://bpmn.io/license
   *
   * @param {Element} container
   */
  function addProjectLogo(container) {
    var linkMarkup = '<a href="http://bpmn.io" ' + 'target="_blank" ' + 'class="bjs-powered-by" ' + 'title="Powered by bpmn.io" ' + 'style="position: absolute; bottom: 15px; right: 15px; z-index: 100;">' + BPMNIO_IMG + '</a>';
    var linkElement = domify$1(linkMarkup);
    container.appendChild(linkElement);
    event.bind(linkElement, 'click', function (event) {
      open();
      event.preventDefault();
    });
  }

  /* </project-logo> */

  /**
   * @typedef {import('../util/Types').Point} Point
   * @typedef {import('../util/Types').Rect} Rect
   */

  /**
   * @param {Rect} bounds
   * @return {Point}
   */
  function center(bounds) {
    return {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  }

  /**
   * @param {Point} a
   * @param {Point} b
   * @return {Point}
   */
  function delta(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }

  /**
   * Get the logarithm of x with base 10.
   *
   * @param {number} x
   */
  function log10(x) {
    return Math.log(x) / Math.log(10);
  }

  /**
   * Get step size for given range and number of steps.
   *
   * @param {Object} range
   * @param {number} range.min
   * @param {number} range.max
   * @param {number} steps
   */
  function getStepSize(range, steps) {
    var minLinearRange = log10(range.min),
      maxLinearRange = log10(range.max);
    var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
    return absoluteLinearRange / steps;
  }

  /**
   * @param {Object} range
   * @param {number} range.min
   * @param {number} range.max
   * @param {number} scale
   */
  function cap(range, scale) {
    return Math.max(range.min, Math.min(range.max, scale));
  }

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   *
   * @typedef {import('../../util/Types').Point} Point
   */

  var sign = Math.sign || function (n) {
    return n >= 0 ? 1 : -1;
  };
  var RANGE$2 = {
      min: 0.2,
      max: 4
    },
    NUM_STEPS = 10;
  var DELTA_THRESHOLD = 0.1;
  var DEFAULT_SCALE = 0.75;

  /**
   * An implementation of zooming and scrolling within the
   * {@link Canvas} via the mouse wheel.
   *
   * Mouse wheel zooming / scrolling may be disabled using
   * the {@link toggle(enabled)} method.
   *
   * @param {Object} [config]
   * @param {boolean} [config.enabled=true] default enabled state
   * @param {number} [config.scale=.75] scroll sensivity
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function ZoomScroll$1(config, eventBus, canvas) {
    config = config || {};
    this._enabled = false;
    this._canvas = canvas;
    this._container = canvas._container;
    this._handleWheel = bind$3(this._handleWheel, this);
    this._totalDelta = 0;
    this._scale = config.scale || DEFAULT_SCALE;
    var self = this;
    eventBus.on('canvas.init', function (e) {
      self._init(config.enabled !== false);
    });
  }
  ZoomScroll$1.$inject = ['config.zoomScroll', 'eventBus', 'canvas'];

  /**
   * @param {Point} delta
   */
  ZoomScroll$1.prototype.scroll = function scroll(delta) {
    this._canvas.scroll(delta);
  };
  ZoomScroll$1.prototype.reset = function reset() {
    this._canvas.zoom('fit-viewport');
  };

  /**
   * Zoom depending on delta.
   *
   * @param {number} delta
   * @param {Point} position
   */
  ZoomScroll$1.prototype.zoom = function zoom(delta, position) {
    // zoom with half the step size of stepZoom
    var stepSize = getStepSize(RANGE$2, NUM_STEPS * 2);

    // add until threshold reached
    this._totalDelta += delta;
    if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
      this._zoom(delta, position, stepSize);

      // reset
      this._totalDelta = 0;
    }
  };
  ZoomScroll$1.prototype._handleWheel = function handleWheel(event) {
    // event is already handled by '.djs-scrollable'
    if (closest(event.target, '.djs-scrollable', true)) {
      return;
    }
    var element = this._container;
    event.preventDefault();

    // pinch to zoom is mapped to wheel + ctrlKey = true
    // in modern browsers (!)

    var isZoom = event.ctrlKey || isMac() && event.metaKey;
    var isHorizontalScroll = event.shiftKey;
    var factor = -1 * this._scale,
      delta;
    if (isZoom) {
      factor *= event.deltaMode === 0 ? 0.020 : 0.32;
    } else {
      factor *= event.deltaMode === 0 ? 1.0 : 16.0;
    }
    if (isZoom) {
      var elementRect = element.getBoundingClientRect();
      var offset = {
        x: event.clientX - elementRect.left,
        y: event.clientY - elementRect.top
      };
      delta = Math.sqrt(Math.pow(event.deltaY, 2) + Math.pow(event.deltaX, 2)) * sign(event.deltaY) * factor;

      // zoom in relative to diagram {x,y} coordinates
      this.zoom(delta, offset);
    } else {
      if (isHorizontalScroll) {
        delta = {
          dx: factor * event.deltaY,
          dy: 0
        };
      } else {
        delta = {
          dx: factor * event.deltaX,
          dy: factor * event.deltaY
        };
      }
      this.scroll(delta);
    }
  };

  /**
   * Zoom with fixed step size.
   *
   * @param {number} delta Zoom delta (1 for zooming in, -1 for zooming out).
   * @param {Point} position
   */
  ZoomScroll$1.prototype.stepZoom = function stepZoom(delta, position) {
    var stepSize = getStepSize(RANGE$2, NUM_STEPS);
    this._zoom(delta, position, stepSize);
  };

  /**
   * Zoom in/out given a step size.
   *
   * @param {number} delta
   * @param {Point} position
   * @param {number} stepSize
   */
  ZoomScroll$1.prototype._zoom = function (delta, position, stepSize) {
    var canvas = this._canvas;
    var direction = delta > 0 ? 1 : -1;
    var currentLinearZoomLevel = log10(canvas.zoom());

    // snap to a proximate zoom step
    var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;

    // increase or decrease one zoom step in the given direction
    newLinearZoomLevel += stepSize * direction;

    // calculate the absolute logarithmic zoom level based on the linear zoom level
    // (e.g. 2 for an absolute x2 zoom)
    var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
    canvas.zoom(cap(RANGE$2, newLogZoomLevel), position);
  };

  /**
   * Toggle the zoom scroll ability via mouse wheel.
   *
   * @param {boolean} [newEnabled] new enabled state
   */
  ZoomScroll$1.prototype.toggle = function toggle(newEnabled) {
    var element = this._container;
    var handleWheel = this._handleWheel;
    var oldEnabled = this._enabled;
    if (typeof newEnabled === 'undefined') {
      newEnabled = !oldEnabled;
    }

    // only react on actual changes
    if (oldEnabled !== newEnabled) {
      // add or remove wheel listener based on
      // changed enabled state
      event[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);
    }
    this._enabled = newEnabled;
    return newEnabled;
  };
  ZoomScroll$1.prototype._init = function (newEnabled) {
    this.toggle(newEnabled);
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var ZoomScroll = {
    __init__: ['zoomScroll'],
    zoomScroll: ['type', ZoomScroll$1]
  };

  var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;

  /**
   * @param {string} mode
   */
  function set(mode) {
    var classes = classes$1(document.body);
    classes.removeMatching(CURSOR_CLS_PATTERN);
    if (mode) {
      classes.add('djs-cursor-' + mode);
    }
  }
  function unset() {
    set(null);
  }

  /**
   * @typedef {import('../core/EventBus').EventBus} EventBus
   */

  var TRAP_PRIORITY = 5000;

  /**
   * Installs a click trap that prevents a ghost click following a dragging operation.
   *
   * @param {EventBus} eventBus
   * @param {string} [eventName='element.click']
   *
   * @return {() => void} a function to immediately remove the installed trap.
   */
  function install(eventBus, eventName) {
    eventName = eventName || 'element.click';
    function trap() {
      return false;
    }
    eventBus.once(eventName, TRAP_PRIORITY, trap);
    return function () {
      eventBus.off(eventName, trap);
    };
  }

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  var THRESHOLD$1 = 15;

  /**
   * Move the canvas via mouse.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function MoveCanvas$1(eventBus, canvas) {
    var context;

    // listen for move on element mouse down;
    // allow others to hook into the event before us though
    // (dragging / element moving will do this)
    eventBus.on('element.mousedown', 500, function (e) {
      return handleStart(e.originalEvent);
    });
    function handleMove(event) {
      var start = context.start,
        button = context.button,
        position = toPoint(event),
        delta$1 = delta(position, start);
      if (!context.dragging && length(delta$1) > THRESHOLD$1) {
        context.dragging = true;
        if (button === 0) {
          install(eventBus);
        }
        set('grab');
      }
      if (context.dragging) {
        var lastPosition = context.last || context.start;
        delta$1 = delta(position, lastPosition);
        canvas.scroll({
          dx: delta$1.x,
          dy: delta$1.y
        });
        context.last = position;
      }

      // prevent select
      event.preventDefault();
    }
    function handleEnd(event$1) {
      event.unbind(document, 'mousemove', handleMove);
      event.unbind(document, 'mouseup', handleEnd);
      context = null;
      unset();
    }
    function handleStart(event$1) {
      // event is already handled by '.djs-draggable'
      if (closest(event$1.target, '.djs-draggable')) {
        return;
      }
      var button = event$1.button;

      // reject right mouse button or modifier key
      if (button >= 2 || event$1.ctrlKey || event$1.shiftKey || event$1.altKey) {
        return;
      }
      context = {
        button: button,
        start: toPoint(event$1)
      };
      event.bind(document, 'mousemove', handleMove);
      event.bind(document, 'mouseup', handleEnd);

      // we've handled the event
      return true;
    }
    this.isActive = function () {
      return !!context;
    };
  }
  MoveCanvas$1.$inject = ['eventBus', 'canvas'];

  // helpers ///////

  function length(point) {
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var MoveCanvas = {
    __init__: ['moveCanvas'],
    moveCanvas: ['type', MoveCanvas$1]
  };

  var hammer = {exports: {}};

  (function (module) {
    (function (window, document, exportName, undefined$1) {

      var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
      var TEST_ELEMENT = document.createElement('div');
      var TYPE_FUNCTION = 'function';
      var round = Math.round;
      var abs = Math.abs;
      var now = Date.now;

      /**
       * set a timeout with a given scope
       * @param {Function} fn
       * @param {Number} timeout
       * @param {Object} context
       * @returns {number}
       */
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }

      /**
       * if the argument is an array, we want to execute the fn on each entry
       * if it aint an array we don't want to do a thing.
       * this is used by all the methods that accept a single and array argument.
       * @param {*|Array} arg
       * @param {String} fn
       * @param {Object} [context]
       * @returns {Boolean}
       */
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }

      /**
       * walk objects and arrays
       * @param {Object} obj
       * @param {Function} iterator
       * @param {Object} context
       */
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined$1) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }

      /**
       * wrap a method with a deprecation warning and stack trace
       * @param {Function} method
       * @param {String} name
       * @param {String} message
       * @returns {Function} A new function wrapping the supplied method.
       */
      function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function () {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
            log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }

      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} target
       * @param {...Object} objects_to_assign
       * @returns {Object} target
       */
      var assign;
      if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
          if (target === undefined$1 || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined$1 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }

      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} dest
       * @param {Object} src
       * @param {Boolean} [merge=false]
       * @returns {Object} dest
       */
      var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge || merge && dest[keys[i]] === undefined$1) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }, 'extend', 'Use `assign`.');

      /**
       * merge the values from src in the dest.
       * means that properties that exist in dest will not be overwritten by src
       * @param {Object} dest
       * @param {Object} src
       * @returns {Object} dest
       */
      var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
      }, 'merge', 'Use `assign`.');

      /**
       * simple class inheritance
       * @param {Function} child
       * @param {Function} base
       * @param {Object} [properties]
       */
      function inherit(child, base, properties) {
        var baseP = base.prototype,
          childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }

      /**
       * simple function bind
       * @param {Function} fn
       * @param {Object} context
       * @returns {Function}
       */
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }

      /**
       * let a boolean value also be a function that must return a boolean
       * this first item in args will be used as the context
       * @param {Boolean|Function} val
       * @param {Array} [args]
       * @returns {Boolean}
       */
      function boolOrFn(val, args) {
        if (_typeof(val) == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
        }
        return val;
      }

      /**
       * use the val2 when val1 is undefined
       * @param {*} val1
       * @param {*} val2
       * @returns {*}
       */
      function ifUndefined(val1, val2) {
        return val1 === undefined$1 ? val2 : val1;
      }

      /**
       * addEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.addEventListener(type, handler, false);
        });
      }

      /**
       * removeEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.removeEventListener(type, handler, false);
        });
      }

      /**
       * find if a node is in the given parent
       * @method hasParent
       * @param {HTMLElement} node
       * @param {HTMLElement} parent
       * @return {Boolean} found
       */
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }

      /**
       * small indexOf wrapper
       * @param {String} str
       * @param {String} find
       * @returns {Boolean} found
       */
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }

      /**
       * split string on whitespace
       * @param {String} str
       * @returns {Array} words
       */
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }

      /**
       * find if a array contains the object using indexOf or a simple polyFill
       * @param {Array} src
       * @param {String} find
       * @param {String} [findByKey]
       * @return {Boolean|Number} false when not found, or the index
       */
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }

      /**
       * convert array-like objects to real arrays
       * @param {Object} obj
       * @returns {Array}
       */
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }

      /**
       * unique array with objects based on a key (like 'id') or just by the array's value
       * @param {Array} src [{id:1},{id:2},{id:1}]
       * @param {String} [key]
       * @param {Boolean} [sort=False]
       * @returns {Array} [{id:1},{id:2}]
       */
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }

      /**
       * get the prefixed property
       * @param {Object} obj
       * @param {String} property
       * @returns {String|Undefined} prefixed
       */
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined$1;
      }

      /**
       * get a unique id
       * @returns {number} uniqueId
       */
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }

      /**
       * get the window object of an element
       * @param {HTMLElement} element
       * @returns {DocumentView|Window}
       */
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = ('ontouchstart' in window);
      var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = 'touch';
      var INPUT_TYPE_PEN = 'pen';
      var INPUT_TYPE_MOUSE = 'mouse';
      var INPUT_TYPE_KINECT = 'kinect';
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ['x', 'y'];
      var PROPS_CLIENT_XY = ['clientX', 'clientY'];

      /**
       * create new input type manager
       * @param {Manager} manager
       * @param {Function} callback
       * @returns {Input}
       * @constructor
       */
      function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function handler() {},
        /**
         * bind the events
         */
        init: function init() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function destroy() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };

      /**
       * create new input type manager
       * called by the Manager constructor
       * @param {Hammer} manager
       * @returns {Input}
       */
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }

      /**
       * handle input events
       * @param {Manager} manager
       * @param {String} eventType
       * @param {Object} input
       */
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }

      /**
       * extend the data with some usable properties like scale, rotate, velocity etc
       * @param {Object} manager
       * @param {Object} input
       */
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }

      /**
       * velocity is calculated every x ms
       * @param {Object} session
       * @param {Object} input
       */
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity,
          velocityX,
          velocityY,
          direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }

      /**
       * create a simple clone from the input used for storage of firstInput and firstMultiple
       * @param {Object} input
       * @returns {Object} clonedInputData
       */
      function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }

      /**
       * get the center of all the pointers
       * @param {Array} pointers
       * @return {Object} center contains `x` and `y` properties
       */
      function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
          return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
          };
        }
        var x = 0,
          y = 0,
          i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
        };
      }

      /**
       * calculate the velocity between two points. unit is in px per ms.
       * @param {Number} deltaTime
       * @param {Number} x
       * @param {Number} y
       * @return {Object} velocity `x` and `y`
       */
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }

      /**
       * get the direction between two points
       * @param {Number} x
       * @param {Number} y
       * @return {Number} direction
       */
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }

      /**
       * calculate the absolute distance between two points
       * @param {Object} p1 {x, y}
       * @param {Object} p2 {x, y}
       * @param {Array} [props] containing x and y keys
       * @return {Number} distance
       */
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }

      /**
       * calculate the angle between two coordinates
       * @param {Object} p1
       * @param {Object} p2
       * @param {Array} [props] containing x and y keys
       * @return {Number} angle
       */
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }

      /**
       * calculate the rotation degrees between two pointersets
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} rotation
       */
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }

      /**
       * calculate the scale factor between two pointersets
       * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} scale
       */
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = 'mousedown';
      var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

      /**
       * Mouse events input
       * @constructor
       * @extends Input
       */
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }

          // mouse must be down
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };

      // in IE10 the pointer types is defined as an enum
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
      };

      var POINTER_ELEMENT_EVENTS = 'pointerdown';
      var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

      // IE10 has prefixed support, and case-sensitive
      if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
      }

      /**
       * Pointer events input
       * @constructor
       * @extends Input
       */
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
            return;
          }

          // update the event in the store
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
      var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

      /**
       * Touch events input
       * @constructor
       * @extends Input
       */
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });

      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

      /**
       * Multi-user touch events input
       * @constructor
       * @extends Input
       */
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });

      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
          return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
      }

      /**
       * Combined touch and mouse input
       *
       * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
       * This because touch devices also emit mouse events while doing a touch.
       *
       * @constructor
       * @extends Input
       */

      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
            isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }

          // when we're in a touch event, record touches to  de-dupe synthetic mouse event
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = {
            x: touch.clientX,
            y: touch.clientY
          };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function removeLastTouch() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX,
          y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x),
            dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;

      // magical touchAction value
      var TOUCH_ACTION_COMPUTE = 'compute';
      var TOUCH_ACTION_AUTO = 'auto';
      var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
      var TOUCH_ACTION_NONE = 'none';
      var TOUCH_ACTION_PAN_X = 'pan-x';
      var TOUCH_ACTION_PAN_Y = 'pan-y';
      var TOUCH_ACTION_MAP = getTouchActionProps();

      /**
       * Touch Action
       * sets the touchAction property or uses the js alternative
       * @param {Manager} manager
       * @param {String} value
       * @constructor
       */
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function set(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function update() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function compute() {
          var actions = [];
          each(this.manager.recognizers, function (recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(' '));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function preventDefaults(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function preventSrc(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };

      /**
       * when the touchActions are collected they are not a valid value, so we need to clean things up. *
       * @param {String} actions
       * @returns {*}
       */
      function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
      }

      /**
       * Recognizer flow explained; *
       * All recognizers have the initial state of POSSIBLE when a input session starts.
       * The definition of a input session is from the first input until the last input, with all it's movement in it. *
       * Example session for mouse-input: mousedown -> mousemove -> mouseup
       *
       * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
       * which determines with state it should be.
       *
       * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
       * POSSIBLE to give it another change on the next cycle.
       *
       *               Possible
       *                  |
       *            +-----+---------------+
       *            |                     |
       *      +-----+-----+               |
       *      |           |               |
       *   Failed      Cancelled          |
       *                          +-------+------+
       *                          |              |
       *                      Recognized       Began
       *                                         |
       *                                      Changed
       *                                         |
       *                                  Ended/Recognized
       */
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;

      /**
       * Recognizer
       * Every recognizer needs to extend from this class.
       * @constructor
       * @param {Object} options
       */
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function set(options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function recognizeWith(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function requireFailure(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function dropRequireFailure(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function hasRequireFailures() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function canRecognizeWith(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function emit(input) {
          var self = this;
          var state = this.state;
          function emit(event) {
            self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }
          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) {
            // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function tryEmit(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function canEmit() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function recognize(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function process(inputData) {},
        // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function getTouchAction() {},
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function reset() {}
      };

      /**
       * get a usable string, used as event postfix
       * @param {Const} state
       * @returns {String} state
       */
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return 'cancel';
        } else if (state & STATE_ENDED) {
          return 'end';
        } else if (state & STATE_CHANGED) {
          return 'move';
        } else if (state & STATE_BEGAN) {
          return 'start';
        }
        return '';
      }

      /**
       * direction cons to string
       * @param {Const} direction
       * @returns {String}
       */
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return 'down';
        } else if (direction == DIRECTION_UP) {
          return 'up';
        } else if (direction == DIRECTION_LEFT) {
          return 'left';
        } else if (direction == DIRECTION_RIGHT) {
          return 'right';
        }
        return '';
      }

      /**
       * get a recognizer by name if it is bound to a manager
       * @param {Recognizer|String} otherRecognizer
       * @param {Recognizer} recognizer
       * @returns {Recognizer}
       */
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }

      /**
       * This recognizer is just used as a base for the simple attribute recognizers.
       * @constructor
       * @extends Recognizer
       */
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function attrTest(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function process(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });

      /**
       * Pan
       * Recognized when the pointer is down and moved in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function getTouchAction() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function directionTest(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function attrTest(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function emit(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });

      /**
       * Pinch
       * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
       * @constructor
       * @extends AttrRecognizer
       */
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function attrTest(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function emit(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });

      /**
       * Press
       * Recognized when the pointer is down for x ms without any movement.
       * @constructor
       * @extends Recognizer
       */
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: 'press',
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function process(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function reset() {
          clearTimeout(this._timer);
        },
        emit: function emit(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + 'up', input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });

      /**
       * Rotate
       * Recognized when two or more pointer are moving in a circular motion.
       * @constructor
       * @extends AttrRecognizer
       */
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function attrTest(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });

      /**
       * Swipe
       * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function getTouchAction() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function attrTest(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function emit(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });

      /**
       * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
       * between the given interval and position. The delay option can be used to recognize multi-taps without firing
       * a single tap.
       *
       * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
       * multi-taps being recognized.
       * @constructor
       * @extends Recognizer
       */
      function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function process(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              // no failing requirements, immediately trigger the tap event
              // or wait as long as the multitap interval to trigger
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function () {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function failTimeout() {
          this._timer = setTimeoutContext(function () {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function reset() {
          clearTimeout(this._timer);
        },
        emit: function emit() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });

      /**
       * Simple way to create a manager with a default set of recognizers.
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */
      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
      }

      /**
       * @const {string}
       */
      Hammer.VERSION = '2.0.7';

      /**
       * default settings
       * @namespace
       */
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {
          enable: false
        }], [PinchRecognizer, {
          enable: false
        }, ['rotate']], [SwipeRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }], [PanRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }, ['swipe']], [TapRecognizer], [TapRecognizer, {
          event: 'doubletap',
          taps: 2
        }, ['tap']], [PressRecognizer]],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;

      /**
       * Manager
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */
      function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function (item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function set(options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function stop(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function recognize(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && (
            // 1
            !curRecognizer || recognizer == curRecognizer ||
            // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              // 3
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function get(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function add(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function remove(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
          }
          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);
            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function on(events, handler) {
          if (events === undefined$1) {
            return;
          }
          if (handler === undefined$1) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function off(events, handler) {
          if (events === undefined$1) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function emit(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function () {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function destroy() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };

      /**
       * add/remove the css properties as defined in manager.options.cssProps
       * @param {Manager} manager
       * @param {Boolean} add
       */
      function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function (value, name) {
          prop = prefixed(element.style, name);
          if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
          }
        });
        if (!add) {
          manager.oldCssProps = {};
        }
      }

      /**
       * trigger dom event
       * @param {String} event
       * @param {Object} data
       */
      function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
      });

      // this prevents errors when Hammer is loaded in the presence of an AMD
      //  style loader but by script tag, not by the loader.
      var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line
      freeGlobal.Hammer = Hammer;
      if (typeof undefined$1 === 'function' && undefined$1.amd) {
        undefined$1(function () {
          return Hammer;
        });
      } else if (module.exports) {
        module.exports = Hammer;
      } else {
        window[exportName] = Hammer;
      }
    })(window, document, 'Hammer');
  })(hammer);
  var hammerExports = hammer.exports;
  var Hammer = /*@__PURE__*/getDefaultExportFromCjs(hammerExports);

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../interaction-events/InteractionEvents').default} InteractionEvents
   */

  var MIN_ZOOM = 0.2,
    MAX_ZOOM = 4;
  var mouseEvents = ['mousedown', 'mouseup', 'mouseover', 'mouseout', 'click', 'dblclick'];
  function get(service, injector) {
    return injector.get(service, false);
  }
  function stopEvent$1(event) {
    event.preventDefault();
    if (typeof event.stopPropagation === 'function') {
      event.stopPropagation();
    } else if (event.srcEvent && typeof event.srcEvent.stopPropagation === 'function') {
      // iPhone & iPad
      event.srcEvent.stopPropagation();
    }
    if (typeof event.stopImmediatePropagation === 'function') {
      event.stopImmediatePropagation();
    }
  }
  function createTouchRecognizer(node) {
    function stopMouse(event$1) {
      forEach$3(mouseEvents, function (e) {
        event.bind(node, e, stopEvent$1, true);
      });
    }
    function allowMouse(event$1) {
      setTimeout(function () {
        forEach$3(mouseEvents, function (e) {
          event.unbind(node, e, stopEvent$1, true);
        });
      }, 500);
    }
    event.bind(node, 'touchstart', stopMouse, true);
    event.bind(node, 'touchend', allowMouse, true);
    event.bind(node, 'touchcancel', allowMouse, true);

    // A touch event recognizer that handles
    // touch events only (we know, we can already handle
    // mouse events out of the box)

    var recognizer = new Hammer.Manager(node, {
      inputClass: Hammer.TouchInput,
      recognizers: [],
      domEvents: true
    });
    var tap = new Hammer.Tap();
    var pan = new Hammer.Pan({
      threshold: 10
    });
    var press = new Hammer.Press();
    var pinch = new Hammer.Pinch();
    var doubleTap = new Hammer.Tap({
      event: 'doubletap',
      taps: 2
    });
    pinch.requireFailure(pan);
    pinch.requireFailure(press);
    recognizer.add([pan, press, pinch, doubleTap, tap]);
    recognizer.reset = function (force) {
      var recognizers = this.recognizers,
        session = this.session;
      if (session.stopped) {
        return;
      }
      recognizer.stop(force);
      setTimeout(function () {
        var i, r;
        for (i = 0; r = recognizers[i]; i++) {
          r.reset();
          r.state = 8; // FAILED STATE
        }

        session.curRecognizer = null;
      }, 0);
    };
    recognizer.on('hammer.input', function (event) {
      if (event.srcEvent.defaultPrevented) {
        recognizer.reset(true);
      }
    });
    return recognizer;
  }

  /**
   * A plugin that provides touch events for elements.
   *
   * @param {Injector} injector
   * @param {Canvas} canvas
   * @param {EventBus} eventBus
   * @param {ElementRegistry} elementRegistry
   * @param {InteractionEvents} interactionEvents
   */
  function TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {
    // optional integrations
    var dragging = get('dragging', injector),
      move = get('move', injector),
      contextPad = get('contextPad', injector),
      palette = get('palette', injector);

    // the touch recognizer
    var recognizer;
    function handler(type, buttonType) {
      return function (event) {
        var gfx = getGfx(event.target),
          element = gfx && elementRegistry.get(gfx);

        // translate into an actual mouse click event
        if (buttonType) {
          event.srcEvent.button = buttonType;
        }
        return interactionEvents.fire(type, event, element);
      };
    }
    function getGfx(target) {
      var node = closest(target, 'svg, .djs-element', true);
      return node;
    }
    function initEvents(svg) {
      // touch recognizer
      recognizer = createTouchRecognizer(svg);
      function startGrabCanvas(event) {
        var lx = 0,
          ly = 0;
        function update(e) {
          var dx = e.deltaX - lx,
            dy = e.deltaY - ly;
          canvas.scroll({
            dx: dx,
            dy: dy
          });
          lx = e.deltaX;
          ly = e.deltaY;
        }
        function end(e) {
          recognizer.off('panmove', update);
          recognizer.off('panend', end);
          recognizer.off('pancancel', end);
        }
        recognizer.on('panmove', update);
        recognizer.on('panend', end);
        recognizer.on('pancancel', end);
      }
      function startGrab(event) {
        var gfx = getGfx(event.target),
          element = gfx && elementRegistry.get(gfx);

        // recognizer
        if (move && canvas.getRootElement() !== element) {
          return move.start(event, element, true);
        } else {
          startGrabCanvas();
        }
      }
      function startZoom(e) {
        var zoom = canvas.zoom(),
          mid = e.center;
        function update(e) {
          var ratio = 1 - (1 - e.scale) / 1.50,
            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));
          canvas.zoom(newZoom, mid);
          stopEvent$1(e);
        }
        function end(e) {
          recognizer.off('pinchmove', update);
          recognizer.off('pinchend', end);
          recognizer.off('pinchcancel', end);
          recognizer.reset(true);
        }
        recognizer.on('pinchmove', update);
        recognizer.on('pinchend', end);
        recognizer.on('pinchcancel', end);
      }
      recognizer.on('tap', handler('element.click'));
      recognizer.on('doubletap', handler('element.dblclick', 1));
      recognizer.on('panstart', startGrab);
      recognizer.on('press', startGrab);
      recognizer.on('pinchstart', startZoom);
    }
    if (dragging) {
      // simulate hover during dragging
      eventBus.on('drag.move', function (event) {
        var originalEvent = event.originalEvent;
        if (!originalEvent || originalEvent instanceof MouseEvent) {
          return;
        }
        var position = toPoint(originalEvent);

        // this gets really expensive ...
        var node = document.elementFromPoint(position.x, position.y),
          gfx = getGfx(node),
          element = gfx && elementRegistry.get(gfx);
        if (element !== event.hover) {
          if (event.hover) {
            dragging.out(event);
          }
          if (element) {
            dragging.hover({
              element: element,
              gfx: gfx
            });
            event.hover = element;
            event.hoverGfx = gfx;
          }
        }
      });
    }
    if (contextPad) {
      eventBus.on('contextPad.create', function (event) {
        var node = event.pad.html;

        // touch recognizer
        var padRecognizer = createTouchRecognizer(node);
        padRecognizer.on('panstart', function (event) {
          contextPad.trigger('dragstart', event, true);
        });
        padRecognizer.on('press', function (event) {
          contextPad.trigger('dragstart', event, true);
        });
        padRecognizer.on('tap', function (event) {
          contextPad.trigger('click', event);
        });
      });
    }
    if (palette) {
      eventBus.on('palette.create', function (event) {
        var node = event.container;

        // touch recognizer
        var padRecognizer = createTouchRecognizer(node);
        padRecognizer.on('panstart', function (event) {
          palette.trigger('dragstart', event, true);
        });
        padRecognizer.on('press', function (event) {
          palette.trigger('dragstart', event, true);
        });
        padRecognizer.on('tap', function (event) {
          palette.trigger('click', event);
        });
      });
    }
    eventBus.on('canvas.init', function (event) {
      initEvents(event.svg);
    });
  }
  TouchInteractionEvents.$inject = ['injector', 'canvas', 'eventBus', 'elementRegistry', 'interactionEvents', 'touchFix'];

  /**
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  /**
   * @param {EventBus} eventBus
   */
  function TouchFix(eventBus) {
    var self = this;
    eventBus.on('canvas.init', function (e) {
      self.addBBoxMarker(e.svg);
    });
  }
  TouchFix.$inject = ['eventBus'];

  /**
   * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element
   * if there is no shape between 0,0 and viewport elements origin.
   *
   * So touchstart event is only fired when the <g class="viewport"> element was hit.
   * Putting an element over and below the 'viewport' fixes that behavior.
   *
   * @param {SVGElement} svg
   */
  TouchFix.prototype.addBBoxMarker = function (svg) {
    var markerStyle = {
      fill: 'none',
      "class": 'outer-bound-marker'
    };
    var rect1 = create$2('rect');
    attr(rect1, {
      x: -10000,
      y: 10000,
      width: 10,
      height: 10
    });
    attr(rect1, markerStyle);
    append(svg, rect1);
    var rect2 = create$2('rect');
    attr(rect2, {
      x: 10000,
      y: 10000,
      width: 10,
      height: 10
    });
    attr(rect2, markerStyle);
    append(svg, rect2);
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var TouchModule$1 = {
    __depends__: [InteractionEventsModule],
    __init__: ['touchInteractionEvents'],
    touchInteractionEvents: ['type', TouchInteractionEvents],
    touchFix: ['type', TouchFix]
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var TouchModule = {
    __depends__: [TouchModule$1]
  };

  /**
   * @param {string} str
   *
   * @return {string}
   */
  function escapeCSS(str) {
    return CSS.escape(str);
  }
  var HTML_ESCAPE_MAP = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#39;'
  };

  /**
   * @param {string} str
   *
   * @return {string}
   */
  function escapeHTML(str) {
    str = '' + str;
    return str && str.replace(/[&<>"']/g, function (match) {
      return HTML_ESCAPE_MAP[match];
    });
  }

  var KEYS_COPY = ['c', 'C'];
  var KEYS_PASTE = ['v', 'V'];
  var KEYS_REDO = ['y', 'Y'];
  var KEYS_UNDO = ['z', 'Z'];

  /**
   * Returns true if event was triggered with any modifier
   * @param {KeyboardEvent} event
   */
  function hasModifier(event) {
    return event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;
  }

  /**
   * @param {KeyboardEvent} event
   * @return {boolean}
   */
  function isCmd$5(event) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (event.altKey) {
      return false;
    }
    return event.ctrlKey || event.metaKey;
  }

  /**
   * Checks if key pressed is one of provided keys.
   *
   * @param {string|string[]} keys
   * @param {KeyboardEvent} event
   * @return {boolean}
   */
  function isKey(keys, event) {
    keys = isArray$6(keys) ? keys : [keys];
    return keys.indexOf(event.key) !== -1 || keys.indexOf(event.code) !== -1;
  }

  /**
   * @param {KeyboardEvent} event
   */
  function isShift$2(event) {
    return event.shiftKey;
  }

  /**
   * @param {KeyboardEvent} event
   */
  function isCopy(event) {
    return isCmd$5(event) && isKey(KEYS_COPY, event);
  }

  /**
   * @param {KeyboardEvent} event
   */
  function isPaste(event) {
    return isCmd$5(event) && isKey(KEYS_PASTE, event);
  }

  /**
   * @param {KeyboardEvent} event
   */
  function isUndo(event) {
    return isCmd$5(event) && !isShift$2(event) && isKey(KEYS_UNDO, event);
  }

  /**
   * @param {KeyboardEvent} event
   */
  function isRedo(event) {
    return isCmd$5(event) && (isKey(KEYS_REDO, event) || isKey(KEYS_UNDO, event) && isShift$2(event));
  }

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../overlays/Overlays').default} Overlays
   * @typedef {import('../selection/Selection').default} Selection
   *
   * @typedef {import('../overlays/Overlays').OverlayAttrs} OverlayAttrs
   *
   * @typedef {import('../../util/Types').Dimensions} Dimensions
   *
   * @typedef {import('./SearchPadProvider').default} SearchPadProvider
   * @typedef {import('./SearchPadProvider').SearchResult} SearchResult
   * @typedef {import('./SearchPadProvider').Token} Token
   */

  /**
   * Provides searching infrastructure.
   *
   * @param {Canvas} canvas
   * @param {EventBus} eventBus
   * @param {Overlays} overlays
   * @param {Selection} selection
   */
  function SearchPad(canvas, eventBus, overlays, selection) {
    this._open = false;
    this._results = [];
    this._eventMaps = [];
    this._canvas = canvas;
    this._eventBus = eventBus;
    this._overlays = overlays;
    this._selection = selection;

    // setup elements
    this._container = domify$1(SearchPad.BOX_HTML);
    this._searchInput = query(SearchPad.INPUT_SELECTOR, this._container);
    this._resultsContainer = query(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);

    // attach search pad
    this._canvas.getContainer().appendChild(this._container);

    // cleanup on destroy
    eventBus.on(['canvas.destroy', 'diagram.destroy'], this.close, this);
  }
  SearchPad.$inject = ['canvas', 'eventBus', 'overlays', 'selection'];

  /**
   * Binds and keeps track of all event listereners
   */
  SearchPad.prototype._bindEvents = function () {
    var self = this;
    function listen(el, selector, type, fn) {
      self._eventMaps.push({
        el: el,
        type: type,
        listener: delegate.bind(el, selector, type, fn)
      });
    }

    // close search on clicking anywhere outside
    listen(document, 'html', 'click', function (e) {
      self.close();
    });

    // stop event from propagating and closing search
    // focus on input
    listen(this._container, SearchPad.INPUT_SELECTOR, 'click', function (e) {
      e.stopPropagation();
      e.delegateTarget.focus();
    });

    // preselect result on hover
    listen(this._container, SearchPad.RESULT_SELECTOR, 'mouseover', function (e) {
      e.stopPropagation();
      self._scrollToNode(e.delegateTarget);
      self._preselect(e.delegateTarget);
    });

    // selects desired result on mouse click
    listen(this._container, SearchPad.RESULT_SELECTOR, 'click', function (e) {
      e.stopPropagation();
      self._select(e.delegateTarget);
    });

    // prevent cursor in input from going left and right when using up/down to
    // navigate results
    listen(this._container, SearchPad.INPUT_SELECTOR, 'keydown', function (e) {
      if (isKey('ArrowUp', e)) {
        e.preventDefault();
      }
      if (isKey('ArrowDown', e)) {
        e.preventDefault();
      }
    });

    // handle keyboard input
    listen(this._container, SearchPad.INPUT_SELECTOR, 'keyup', function (e) {
      if (isKey('Escape', e)) {
        return self.close();
      }
      if (isKey('Enter', e)) {
        var selected = self._getCurrentResult();
        return selected ? self._select(selected) : self.close();
      }
      if (isKey('ArrowUp', e)) {
        return self._scrollToDirection(true);
      }
      if (isKey('ArrowDown', e)) {
        return self._scrollToDirection();
      }

      // do not search while navigating text input
      if (isKey(['ArrowLeft', 'ArrowRight'], e)) {
        return;
      }

      // anything else
      self._search(e.delegateTarget.value);
    });
  };

  /**
   * Unbinds all previously established listeners
   */
  SearchPad.prototype._unbindEvents = function () {
    this._eventMaps.forEach(function (m) {
      delegate.unbind(m.el, m.type, m.listener);
    });
  };

  /**
   * Performs a search for the given pattern.
   *
   * @param {string} pattern
   */
  SearchPad.prototype._search = function (pattern) {
    var self = this;
    this._clearResults();

    // do not search on empty query
    if (!pattern || pattern === '') {
      return;
    }
    var searchResults = this._searchProvider.find(pattern);
    if (!searchResults.length) {
      return;
    }

    // append new results
    searchResults.forEach(function (result) {
      var id = result.element.id;
      var node = self._createResultNode(result, id);
      self._results[id] = {
        element: result.element,
        node: node
      };
    });

    // preselect first result
    var node = query(SearchPad.RESULT_SELECTOR, this._resultsContainer);
    this._scrollToNode(node);
    this._preselect(node);
  };

  /**
   * Navigate to the previous/next result. Defaults to next result.
   *
   * @param {boolean} previous
   */
  SearchPad.prototype._scrollToDirection = function (previous) {
    var selected = this._getCurrentResult();
    if (!selected) {
      return;
    }
    var node = previous ? selected.previousElementSibling : selected.nextElementSibling;
    if (node) {
      this._scrollToNode(node);
      this._preselect(node);
    }
  };

  /**
   * Scroll to the node if it is not visible.
   *
   * @param {HTMLElement} node
   */
  SearchPad.prototype._scrollToNode = function (node) {
    if (!node || node === this._getCurrentResult()) {
      return;
    }
    var nodeOffset = node.offsetTop;
    var containerScroll = this._resultsContainer.scrollTop;
    var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node.clientHeight;
    if (nodeOffset < containerScroll) {
      this._resultsContainer.scrollTop = nodeOffset;
    } else if (containerScroll < bottomScroll) {
      this._resultsContainer.scrollTop = bottomScroll;
    }
  };

  /**
   * Clears all results data.
   */
  SearchPad.prototype._clearResults = function () {
    clear$1(this._resultsContainer);
    this._results = [];
    this._resetOverlay();
    this._eventBus.fire('searchPad.cleared');
  };

  /**
   * Get currently selected result.
   *
   * @return {HTMLElement}
   */
  SearchPad.prototype._getCurrentResult = function () {
    return query(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
  };

  /**
   * Create result DOM element within results container
   * that corresponds to a search result.
   *
   * 'result' : one of the elements returned by Pad
   * 'id' : id attribute value to assign to the new DOM node
   * return : created DOM element
   *
   * @param {SearchResult} result
   * @param {string} id
   *
   * @return {HTMLElement}
   */
  SearchPad.prototype._createResultNode = function (result, id) {
    var node = domify$1(SearchPad.RESULT_HTML);

    // create only if available
    if (result.primaryTokens.length > 0) {
      createInnerTextNode(node, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
    }

    // secondary tokens (represent element ID) are allways available
    createInnerTextNode(node, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);
    attr$1(node, SearchPad.RESULT_ID_ATTRIBUTE, id);
    this._resultsContainer.appendChild(node);
    return node;
  };

  /**
   * Register search element provider.
   *
   * @param {SearchPadProvider} provider
   */
  SearchPad.prototype.registerProvider = function (provider) {
    this._searchProvider = provider;
  };

  /**
   * Open search pad.
   */
  SearchPad.prototype.open = function () {
    if (!this._searchProvider) {
      throw new Error('no search provider registered');
    }
    if (this.isOpen()) {
      return;
    }
    this._bindEvents();
    this._open = true;
    classes$1(this._container).add('open');
    this._searchInput.focus();
    this._eventBus.fire('searchPad.opened');
  };

  /**
   * Close search pad.
   */
  SearchPad.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }
    this._unbindEvents();
    this._open = false;
    classes$1(this._container).remove('open');
    this._clearResults();
    this._searchInput.value = '';
    this._searchInput.blur();
    this._resetOverlay();
    this._eventBus.fire('searchPad.closed');
  };

  /**
   * Toggles search pad on/off.
   */
  SearchPad.prototype.toggle = function () {
    this.isOpen() ? this.close() : this.open();
  };

  /**
   * Report state of search pad.
   */
  SearchPad.prototype.isOpen = function () {
    return this._open;
  };

  /**
   * Preselect result entry.
   *
   * @param {HTMLElement} element
   */
  SearchPad.prototype._preselect = function (node) {
    var selectedNode = this._getCurrentResult();

    // already selected
    if (node === selectedNode) {
      return;
    }

    // removing preselection from current node
    if (selectedNode) {
      classes$1(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
    }
    var id = attr$1(node, SearchPad.RESULT_ID_ATTRIBUTE);
    var element = this._results[id].element;
    classes$1(node).add(SearchPad.RESULT_SELECTED_CLASS);
    this._resetOverlay(element);
    this._canvas.scrollToElement(element, {
      top: 400
    });
    this._selection.select(element);
    this._eventBus.fire('searchPad.preselected', element);
  };

  /**
   * Select result node.
   *
   * @param {HTMLElement} element
   */
  SearchPad.prototype._select = function (node) {
    var id = attr$1(node, SearchPad.RESULT_ID_ATTRIBUTE);
    var element = this._results[id].element;
    this.close();
    this._resetOverlay();
    this._canvas.scrollToElement(element, {
      top: 400
    });
    this._selection.select(element);
    this._eventBus.fire('searchPad.selected', element);
  };

  /**
   * Reset overlay removes and, optionally, set
   * overlay to a new element.
   *
   * @param {HTMLElement} element
   */
  SearchPad.prototype._resetOverlay = function (element) {
    if (this._overlayId) {
      this._overlays.remove(this._overlayId);
    }
    if (element) {
      var box = getBBox(element);
      var overlay = constructOverlay(box);
      this._overlayId = this._overlays.add(element, overlay);
    }
  };

  /**
   * Construct overlay object for the given bounding box.
   *
   * @param {Dimensions} box
   *
   * @return {OverlayAttrs}
   */
  function constructOverlay(box) {
    var offset = 6;
    var w = box.width + offset * 2;
    var h = box.height + offset * 2;
    var styles = {
      width: w + 'px',
      height: h + 'px'
    };
    var html = domify$1('<div class="' + SearchPad.OVERLAY_CLASS + '"></div>');
    assign(html, styles);
    return {
      position: {
        bottom: h - offset,
        right: w - offset
      },
      show: true,
      html: html
    };
  }

  /**
   * Creates and appends child node from result tokens and HTML template.
   *
   * @param {HTMLElement} node
   * @param {Token[]} tokens
   * @param {string} template
   */
  function createInnerTextNode(parentNode, tokens, template) {
    var text = createHtmlText(tokens);
    var childNode = domify$1(template);
    childNode.innerHTML = text;
    parentNode.appendChild(childNode);
  }

  /**
   * Create internal HTML markup from result tokens.
   * Caters for highlighting pattern matched tokens.
   *
   * @param {Token[]} tokens
   *
   * @return {string|null}
   */
  function createHtmlText(tokens) {
    var htmlText = '';
    tokens.forEach(function (t) {
      if (t.matched) {
        htmlText += '<strong class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + escapeHTML(t.matched) + '</strong>';
      } else {
        htmlText += escapeHTML(t.normal);
      }
    });
    return htmlText !== '' ? htmlText : null;
  }

  /**
   * CONSTANTS
   */
  SearchPad.CONTAINER_SELECTOR = '.djs-search-container';
  SearchPad.INPUT_SELECTOR = '.djs-search-input input';
  SearchPad.RESULTS_CONTAINER_SELECTOR = '.djs-search-results';
  SearchPad.RESULT_SELECTOR = '.djs-search-result';
  SearchPad.RESULT_SELECTED_CLASS = 'djs-search-result-selected';
  SearchPad.RESULT_SELECTED_SELECTOR = '.' + SearchPad.RESULT_SELECTED_CLASS;
  SearchPad.RESULT_ID_ATTRIBUTE = 'data-result-id';
  SearchPad.RESULT_HIGHLIGHT_CLASS = 'djs-search-highlight';
  SearchPad.OVERLAY_CLASS = 'djs-search-overlay';
  SearchPad.BOX_HTML = '<div class="djs-search-container djs-draggable djs-scrollable">' + '<div class="djs-search-input">' + '<input type="text"/>' + '</div>' + '<div class="djs-search-results"></div>' + '</div>';
  SearchPad.RESULT_HTML = '<div class="djs-search-result"></div>';
  SearchPad.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>';
  SearchPad.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>';

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var SearchPadModule = {
    __depends__: [OverlaysModule, SelectionModule],
    searchPad: ['type', SearchPad]
  };

  function getLabelAttr(semantic) {
    if (is$1(semantic, 'dmn:Decision') || is$1(semantic, 'dmn:BusinessKnowledgeModel') || is$1(semantic, 'dmn:InputData') || is$1(semantic, 'dmn:KnowledgeSource')) {
      return 'name';
    }
    if (is$1(semantic, 'dmn:TextAnnotation')) {
      return 'text';
    }
  }
  function getLabel(element) {
    var semantic = element.businessObject,
      attr = getLabelAttr(semantic);
    if (attr) {
      return semantic[attr] || '';
    }
  }
  function setLabel(element, text, isExternal) {
    var semantic = element.businessObject,
      attr = getLabelAttr(semantic);
    if (attr) {
      semantic[attr] = text;
    }

    // show external label if not empty
    if (isExternal) {
      element.hidden = !text;
    }
    return element;
  }

  /**
   * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas
   * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry
   * @typedef {import('diagram-js/lib/features/search-pad/SearchPad').default} SearchPad
   *
   * @typedef {import('diagram-js/lib/features/search-pad/SearchPadProvider').default
   * } SearchPadProvider
   * @typedef {import('diagram-js/lib/features/search-pad/SearchPadProvider').SearchResult
   * } SearchResult
   */

  /**
   * Provides ability to search for DMN elements.
   *
   * @implements {SearchPadProvider}
   *
   * @param {ElementRegistry} elementRegistry
   * @param {SearchPad} searchPad
   * @param {Canvas} canvas
   */
  function DmnSearchProvider(elementRegistry, searchPad, canvas) {
    this._elementRegistry = elementRegistry;
    this._canvas = canvas;
    searchPad.registerProvider(this);
  }
  DmnSearchProvider.$inject = ['elementRegistry', 'searchPad', 'canvas'];

  /**
   * @param {string} pattern
   *
   * @return {SearchResult[]}
   */
  DmnSearchProvider.prototype.find = function (pattern) {
    var rootElement = this._canvas.getRootElement();
    var elements = this._elementRegistry.filter(function (element) {
      if (element.labelTarget) {
        return false;
      }
      return true;
    });

    // do not include root element
    elements = filter$2(elements, function (element) {
      return element !== rootElement;
    });
    elements = map$2(elements, function (element) {
      return {
        primaryTokens: matchAndSplit(getLabel(element), pattern),
        secondaryTokens: matchAndSplit(element.id, pattern),
        element: element
      };
    });

    // exclude non-matched elements
    elements = filter$2(elements, function (element) {
      return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);
    });
    elements = sortBy(elements, function (element) {
      return getLabel(element.element) + element.element.id;
    });
    return elements;
  };

  /**
   * @param {Token[]} tokens
   *
   * @return {boolean}
   */
  function hasMatched(tokens) {
    var matched = filter$2(tokens, function (token) {
      return !!token.matched;
    });
    return matched.length > 0;
  }

  /**
   * @param {string} text
   * @param {string} pattern
   *
   * @return {Token[]}
   */
  function matchAndSplit(text, pattern) {
    var tokens = [],
      originalText = text;
    if (!text) {
      return tokens;
    }
    text = text.toLowerCase();
    pattern = pattern.toLowerCase();
    var i = text.indexOf(pattern);
    if (i > -1) {
      if (i !== 0) {
        tokens.push({
          normal: originalText.substr(0, i)
        });
      }
      tokens.push({
        matched: originalText.substr(i, pattern.length)
      });
      if (pattern.length + i < text.length) {
        tokens.push({
          normal: originalText.substr(pattern.length + i, text.length)
        });
      }
    } else {
      tokens.push({
        normal: originalText
      });
    }
    return tokens;
  }

  var DmnSearchModule = {
    __depends__: [SearchPadModule],
    __init__: ['dmnSearch'],
    dmnSearch: ['type', DmnSearchProvider]
  };

  /**
   * A viewer that includes mouse navigation facilities
   *
   * @param {Object} options
   */
  function NavigatedViewer(options) {
    Viewer$3.call(this, options);
  }
  e$2(NavigatedViewer, Viewer$3);
  NavigatedViewer.prototype._navigationModules = [ZoomScroll, MoveCanvas, TouchModule, DmnSearchModule];
  NavigatedViewer.prototype._modules = [].concat(NavigatedViewer.prototype._modules, NavigatedViewer.prototype._navigationModules);

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   *
   * @typedef {import('../../util/Types').Axis} Axis
   * @typedef {import('../../util/Types').Dimension} Dimension
   *
   * @typedef { 'top' | 'right' | 'bottom' | 'left' | 'center' | 'middle' } Alignment
   */

  function last$1(arr) {
    return arr && arr[arr.length - 1];
  }
  function sortTopOrMiddle(element) {
    return element.y;
  }
  function sortLeftOrCenter(element) {
    return element.x;
  }

  /**
   * Sorting functions for different alignments.
   *
   * @type {Record<string, Function>}
   */
  var ALIGNMENT_SORTING = {
    left: sortLeftOrCenter,
    center: sortLeftOrCenter,
    right: function right(element) {
      return element.x + element.width;
    },
    top: sortTopOrMiddle,
    middle: sortTopOrMiddle,
    bottom: function bottom(element) {
      return element.y + element.height;
    }
  };

  /**
   * @param {Modeling} modeling
   * @param {Rules} rules
   */
  function AlignElements$1(modeling, rules) {
    this._modeling = modeling;
    this._rules = rules;
  }
  AlignElements$1.$inject = ['modeling', 'rules'];

  /**
   * Get relevant axis and dimension for given alignment.
   *
   * @param {Alignment} type
   *
   * @return { {
   *   axis: Axis;
   *   dimension: Dimension;
   * } }
   */
  AlignElements$1.prototype._getOrientationDetails = function (type) {
    var vertical = ['top', 'bottom', 'middle'],
      axis = 'x',
      dimension = 'width';
    if (vertical.indexOf(type) !== -1) {
      axis = 'y';
      dimension = 'height';
    }
    return {
      axis: axis,
      dimension: dimension
    };
  };
  AlignElements$1.prototype._isType = function (type, types) {
    return types.indexOf(type) !== -1;
  };

  /**
   * Get point on relevant axis for given alignment.
   *
   * @param {Alignment} type
   * @param {Element[]} sortedElements
   *
   * @return {Partial<Record<Alignment, number>>}
   */
  AlignElements$1.prototype._alignmentPosition = function (type, sortedElements) {
    var orientation = this._getOrientationDetails(type),
      axis = orientation.axis,
      dimension = orientation.dimension,
      alignment = {},
      centers = {},
      hasSharedCenters = false,
      centeredElements,
      firstElement,
      lastElement;
    function getMiddleOrTop(first, last) {
      return Math.round((first[axis] + last[axis] + last[dimension]) / 2);
    }
    if (this._isType(type, ['left', 'top'])) {
      alignment[type] = sortedElements[0][axis];
    } else if (this._isType(type, ['right', 'bottom'])) {
      lastElement = last$1(sortedElements);
      alignment[type] = lastElement[axis] + lastElement[dimension];
    } else if (this._isType(type, ['center', 'middle'])) {
      // check if there is a center shared by more than one shape
      // if not, just take the middle of the range
      forEach$3(sortedElements, function (element) {
        var center = element[axis] + Math.round(element[dimension] / 2);
        if (centers[center]) {
          centers[center].elements.push(element);
        } else {
          centers[center] = {
            elements: [element],
            center: center
          };
        }
      });
      centeredElements = sortBy(centers, function (center) {
        if (center.elements.length > 1) {
          hasSharedCenters = true;
        }
        return center.elements.length;
      });
      if (hasSharedCenters) {
        alignment[type] = last$1(centeredElements).center;
        return alignment;
      }
      firstElement = sortedElements[0];
      sortedElements = sortBy(sortedElements, function (element) {
        return element[axis] + element[dimension];
      });
      lastElement = last$1(sortedElements);
      alignment[type] = getMiddleOrTop(firstElement, lastElement);
    }
    return alignment;
  };

  /**
   * Align elements on relevant axis for given alignment.
   *
   * @param {Element[]} elements
   * @param {Alignment} type
   */
  AlignElements$1.prototype.trigger = function (elements, type) {
    var modeling = this._modeling,
      allowed;

    // filter out elements which cannot be aligned
    var filteredElements = filter$2(elements, function (element) {
      return !(element.waypoints || element.host || element.labelTarget);
    });

    // filter out elements via rules
    allowed = this._rules.allowed('elements.align', {
      elements: filteredElements
    });
    if (isArray$6(allowed)) {
      filteredElements = allowed;
    }
    if (filteredElements.length < 2 || !allowed) {
      return;
    }
    var sortFn = ALIGNMENT_SORTING[type];
    var sortedElements = sortBy(filteredElements, sortFn);
    var alignment = this._alignmentPosition(type, sortedElements);
    modeling.alignElements(sortedElements, alignment);
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var AlignElementsModule = {
    __init__: ['alignElements'],
    alignElements: ['type', AlignElements$1]
  };

  /**
   * @typedef {import('../../model/Types').Connection} Connection
   * @typedef {import('../../model/Types').Element} Element
   * @typedef {import('../../model/Types').Shape} Shape
   *
   * @typedef {import('../../util/Types').Point} Point
   */

  // padding to detect element placement
  var PLACEMENT_DETECTION_PAD = 10;
  var DEFAULT_DISTANCE = 50;
  var DEFAULT_MAX_DISTANCE = 250;

  /**
   * Get free position starting from given position.
   *
   * @param {Shape} source
   * @param {Shape} element
   * @param {Point} position
   * @param {(element: Element, position: Point, connectedAtPosition: Element) => Element} getNextPosition
   *
   * @return {Point}
   */
  function findFreePosition(source, element, position, getNextPosition) {
    var connectedAtPosition;
    while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {
      position = getNextPosition(element, position, connectedAtPosition);
    }
    return position;
  }

  /**
   * Returns function that returns next position.
   *
   * @param {Object} nextPositionDirection
   * @param {Object} [nextPositionDirection.x]
   * @param {Object} [nextPositionDirection.y]
   *
   * @return {(element: Element, previousPosition: Point, connectedAtPosition: Element) => Point}
   */
  function generateGetNextPosition(nextPositionDirection) {
    return function (element, previousPosition, connectedAtPosition) {
      var nextPosition = {
        x: previousPosition.x,
        y: previousPosition.y
      };
      ['x', 'y'].forEach(function (axis) {
        var nextPositionDirectionForAxis = nextPositionDirection[axis];
        if (!nextPositionDirectionForAxis) {
          return;
        }
        var dimension = axis === 'x' ? 'width' : 'height';
        var margin = nextPositionDirectionForAxis.margin,
          minDistance = nextPositionDirectionForAxis.minDistance;
        if (margin < 0) {
          nextPosition[axis] = Math.min(connectedAtPosition[axis] + margin - element[dimension] / 2, previousPosition[axis] - minDistance + margin);
        } else {
          nextPosition[axis] = Math.max(connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2, previousPosition[axis] + minDistance + margin);
        }
      });
      return nextPosition;
    };
  }

  /**
   * Return target at given position, if defined.
   *
   * This takes connected elements from host and attachers
   * into account, too.
   */
  function getConnectedAtPosition(source, position, element) {
    var bounds = {
      x: position.x - element.width / 2,
      y: position.y - element.height / 2,
      width: element.width,
      height: element.height
    };
    var closure = getAutoPlaceClosure(source);
    return find$2(closure, function (target) {
      if (target === element) {
        return false;
      }
      var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);
      return orientation === 'intersect';
    });
  }

  /**
  * Compute optimal distance between source and target based on existing connections to and from source.
  * Assumes left-to-right and top-to-down modeling.
  *
  * @param {Shape} source
  * @param {Object} [hints]
  * @param {number} [hints.defaultDistance]
  * @param {string} [hints.direction]
  * @param {(connection: Connection) => boolean} [hints.filter]
  * @param {(connection: Connection) => number} [hints.getWeight]
  * @param {number} [hints.maxDistance]
  * @param {string} [hints.reference]
  *
  * @return {number}
  */
  function getConnectedDistance(source, hints) {
    if (!hints) {
      hints = {};
    }

    // targets > sources by default
    function getDefaultWeight(connection) {
      return connection.source === source ? 1 : -1;
    }
    var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE,
      direction = hints.direction || 'e',
      filter = hints.filter,
      getWeight = hints.getWeight || getDefaultWeight,
      maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE,
      reference = hints.reference || 'start';
    if (!filter) {
      filter = noneFilter;
    }
    function getDistance(a, b) {
      if (direction === 'n') {
        if (reference === 'start') {
          return asTRBL(a).top - asTRBL(b).bottom;
        } else if (reference === 'center') {
          return asTRBL(a).top - getMid(b).y;
        } else {
          return asTRBL(a).top - asTRBL(b).top;
        }
      } else if (direction === 'w') {
        if (reference === 'start') {
          return asTRBL(a).left - asTRBL(b).right;
        } else if (reference === 'center') {
          return asTRBL(a).left - getMid(b).x;
        } else {
          return asTRBL(a).left - asTRBL(b).left;
        }
      } else if (direction === 's') {
        if (reference === 'start') {
          return asTRBL(b).top - asTRBL(a).bottom;
        } else if (reference === 'center') {
          return getMid(b).y - asTRBL(a).bottom;
        } else {
          return asTRBL(b).bottom - asTRBL(a).bottom;
        }
      } else {
        if (reference === 'start') {
          return asTRBL(b).left - asTRBL(a).right;
        } else if (reference === 'center') {
          return getMid(b).x - asTRBL(a).right;
        } else {
          return asTRBL(b).right - asTRBL(a).right;
        }
      }
    }
    var sourcesDistances = source.incoming.filter(filter).map(function (connection) {
      var weight = getWeight(connection);
      var distance = weight < 0 ? getDistance(connection.source, source) : getDistance(source, connection.source);
      return {
        id: connection.source.id,
        distance: distance,
        weight: weight
      };
    });
    var targetsDistances = source.outgoing.filter(filter).map(function (connection) {
      var weight = getWeight(connection);
      var distance = weight > 0 ? getDistance(source, connection.target) : getDistance(connection.target, source);
      return {
        id: connection.target.id,
        distance: distance,
        weight: weight
      };
    });
    var distances = sourcesDistances.concat(targetsDistances).reduce(function (accumulator, currentValue) {
      accumulator[currentValue.id + '__weight_' + currentValue.weight] = currentValue;
      return accumulator;
    }, {});
    var distancesGrouped = reduce(distances, function (accumulator, currentValue) {
      var distance = currentValue.distance,
        weight = currentValue.weight;
      if (distance < 0 || distance > maxDistance) {
        return accumulator;
      }
      if (!accumulator[String(distance)]) {
        accumulator[String(distance)] = 0;
      }
      accumulator[String(distance)] += 1 * weight;
      if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance)]) {
        accumulator.distance = distance;
      }
      return accumulator;
    }, {});
    return distancesGrouped.distance || defaultDistance;
  }

  /**
   * Returns all connected elements around the given source.
   *
   * This includes:
   *
   *   - connected elements
   *   - host connected elements
   *   - attachers connected elements
   *
   * @param {Shape} source
   *
   * @return {Shape[]}
   */
  function getAutoPlaceClosure(source) {
    var allConnected = getConnected(source);
    if (source.host) {
      allConnected = allConnected.concat(getConnected(source.host));
    }
    if (source.attachers) {
      allConnected = allConnected.concat(source.attachers.reduce(function (shapes, attacher) {
        return shapes.concat(getConnected(attacher));
      }, []));
    }
    return allConnected;
  }
  function getConnected(element) {
    return getTargets(element).concat(getSources(element));
  }
  function getSources(shape) {
    return shape.incoming.map(function (connection) {
      return connection.source;
    });
  }
  function getTargets(shape) {
    return shape.outgoing.map(function (connection) {
      return connection.target;
    });
  }
  function noneFilter() {
    return true;
  }

  /**
   * @typedef {import('../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../modeling/Modeling').default} Modeling
   */

  var LOW_PRIORITY$j = 100;

  /**
   * A service that places elements connected to existing ones
   * to an appropriate position in an _automated_ fashion.
   *
   * @param {EventBus} eventBus
   * @param {Modeling} modeling
   * @param {Canvas} canvas
   */
  function AutoPlace$1(eventBus, modeling, canvas) {
    eventBus.on('autoPlace', LOW_PRIORITY$j, function (context) {
      var shape = context.shape,
        source = context.source;
      return getNewShapePosition$1(source, shape);
    });
    eventBus.on('autoPlace.end', function (event) {
      canvas.scrollToElement(event.shape);
    });

    /**
     * Append shape to source at appropriate position.
     *
     * @param {Shape} source
     * @param {Shape} shape
     *
     * @return {Shape} appended shape
     */
    this.append = function (source, shape, hints) {
      eventBus.fire('autoPlace.start', {
        source: source,
        shape: shape
      });

      // allow others to provide the position
      var position = eventBus.fire('autoPlace', {
        source: source,
        shape: shape
      });
      var newShape = modeling.appendShape(source, shape, position, source.parent, hints);
      eventBus.fire('autoPlace.end', {
        source: source,
        shape: newShape
      });
      return newShape;
    };
  }
  AutoPlace$1.$inject = ['eventBus', 'modeling', 'canvas'];

  // helpers //////////

  /**
   * Find the new position for the target element to
   * connect to source.
   *
   * @param {Shape} source
   * @param {Shape} element
   * @param {Object} [hints]
   * @param {Object} [hints.defaultDistance]
   *
   * @return {Point}
   */
  function getNewShapePosition$1(source, element, hints) {
    if (!hints) {
      hints = {};
    }
    var distance = hints.defaultDistance || DEFAULT_DISTANCE;
    var sourceMid = getMid(source),
      sourceTrbl = asTRBL(source);

    // simply put element right next to source
    return {
      x: sourceTrbl.right + distance + element.width / 2,
      y: sourceMid.y
    };
  }

  /**
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../selection/Selection').default} Selection
   */

  /**
   * Select element after auto placement.
   *
   * @param {EventBus} eventBus
   * @param {Selection} selection
   */
  function AutoPlaceSelectionBehavior(eventBus, selection) {
    eventBus.on('autoPlace.end', 500, function (e) {
      selection.select(e.shape);
    });
  }
  AutoPlaceSelectionBehavior.$inject = ['eventBus', 'selection'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var AutoPlaceModule$1 = {
    __init__: ['autoPlaceSelectionBehavior'],
    autoPlace: ['type', AutoPlace$1],
    autoPlaceSelectionBehavior: ['type', AutoPlaceSelectionBehavior]
  };

  var BUSINESS_KNOWLEDGE_MODEL_SIZE = {
    width: 135,
    height: 46
  };
  var DECISION_SIZE = {
    width: 180,
    height: 80
  };
  var INPUT_DATA_SIZE = {
    width: 125,
    height: 45
  };
  var KNOWLEDGE_SOURCE_SIZE = {
    width: 100,
    height: 63
  };

  /**
   * A drd-aware factory for diagram-js shapes
   */
  function ElementFactory$2(drdFactory) {
    ElementFactory$3.call(this);
    this._drdFactory = drdFactory;
  }
  e$2(ElementFactory$2, ElementFactory$3);
  ElementFactory$2.$inject = ['drdFactory'];
  ElementFactory$2.prototype.baseCreate = ElementFactory$3.prototype.create;
  ElementFactory$2.prototype.create = function (elementType, attrs) {
    return this.createDrdElement(elementType, attrs);
  };
  ElementFactory$2.prototype.createDrdElement = function (elementType, attrs) {
    var drdFactory = this._drdFactory;
    var size;
    attrs = attrs || {};
    var businessObject = attrs.businessObject;
    if (!businessObject) {
      if (!attrs.type) {
        throw new Error('no shape type specified');
      }
      businessObject = drdFactory.create(attrs.type);
    }
    if (!businessObject.di) {
      if (elementType === 'connection') {
        businessObject.di = drdFactory.createDiEdge(businessObject, []);
      } else if (elementType === 'shape') {
        businessObject.di = drdFactory.createDiShape(businessObject, {});
      }
    }
    size = this._getDefaultSize(businessObject);
    attrs = assign$4({
      businessObject: businessObject,
      id: businessObject.id
    }, size, attrs);
    return this.baseCreate(elementType, attrs);
  };
  ElementFactory$2.prototype._getDefaultSize = function (semantic) {
    if (is$1(semantic, 'dmn:BusinessKnowledgeModel')) {
      return BUSINESS_KNOWLEDGE_MODEL_SIZE;
    }
    if (is$1(semantic, 'dmn:Decision')) {
      return DECISION_SIZE;
    }
    if (is$1(semantic, 'dmn:InputData')) {
      return INPUT_DATA_SIZE;
    }
    if (is$1(semantic, 'dmn:KnowledgeSource')) {
      return KNOWLEDGE_SOURCE_SIZE;
    }
    return {
      width: 100,
      height: 80
    };
  };

  var DIRECTION_LEFT = 'left',
    DIRECTION_RIGHT = 'right';
  var DRG_ELEMENT_MARGIN = 60,
    DRG_ELEMENT_ROW_SIZE = DECISION_SIZE.width;
  function getNewShapePosition(source, element) {
    if (is$1(element, 'dmn:TextAnnotation')) {
      return getTextAnnotationPosition(source, element);
    }
    if (is$1(element, 'dmn:DRGElement')) {
      return getDRGElementPosition(source, element);
    }
  }

  /**
   * Always try to place text annotations top right of source.
   */
  function getTextAnnotationPosition(source, element) {
    var sourceTrbl = asTRBL(source);
    var position = {
      x: sourceTrbl.right + element.width / 2,
      y: sourceTrbl.top - 50 - element.height / 2
    };
    var nextPositionDirection = {
      y: {
        margin: -30,
        minDistance: 20
      }
    };
    return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
  }

  /**
   * Get position for DRG elements.
   *
   * @param {djs.model.Shape} source
   * @param {djs.model.Shape} element
   *
   * @returns {Point}
   */
  function getDRGElementPosition(source, element) {
    var sourceTrbl = asTRBL(source),
      sourceMid = getMid(source);
    function getWeight(connection) {
      return connection.target === source ? 1 : -1;
    }
    var verticalDistance = getConnectedDistance(source, {
      defaultDistance: 180,
      direction: 's',
      getWeight: getWeight,
      filter: filter,
      reference: 'center'
    });
    var position = {
      x: sourceMid.x,
      y: sourceTrbl.bottom + verticalDistance
    };
    return findFreePosition(source, element, position, generateGetNextDRGElementPosition(source));
  }

  // helpers //////////

  function filter(connection) {
    return !is$1(connection, 'dmn:Association');
  }
  function getHorizontalDistance(a, b) {
    return Math.abs(b.x - a.x);
  }
  function generateGetNextDRGElementPosition(source) {
    var sourceMid = getMid(source);
    var connectedAtPositionLeft, connectedAtPositionRight;
    return function (element, previousPosition, connectedAtPreviousPosition) {
      var direction;

      // (1) get direction
      if (!connectedAtPositionLeft) {
        connectedAtPositionLeft = connectedAtPreviousPosition;
        connectedAtPositionRight = connectedAtPreviousPosition;
        if (getMid(connectedAtPreviousPosition).x - sourceMid.x > 0) {
          direction = DIRECTION_LEFT;
        } else {
          direction = DIRECTION_RIGHT;
        }
      } else {
        if (previousPosition.x < sourceMid.x) {
          connectedAtPositionLeft = connectedAtPreviousPosition;
        } else {
          connectedAtPositionRight = connectedAtPreviousPosition;
        }
        if (getHorizontalDistance(sourceMid, getMid(connectedAtPositionLeft)) < getHorizontalDistance(sourceMid, getMid(connectedAtPositionRight))) {
          direction = DIRECTION_LEFT;
        } else {
          direction = DIRECTION_RIGHT;
        }
      }

      // (2) get next position
      if (direction === DIRECTION_LEFT) {
        return {
          x: Math.min(getMid(connectedAtPositionLeft).x - DRG_ELEMENT_ROW_SIZE - DRG_ELEMENT_MARGIN, asTRBL(connectedAtPositionLeft).left - DRG_ELEMENT_MARGIN - element.width / 2),
          y: previousPosition.y
        };
      } else {
        return {
          x: Math.max(getMid(connectedAtPositionRight).x + DRG_ELEMENT_ROW_SIZE + DRG_ELEMENT_MARGIN, asTRBL(connectedAtPositionRight).right + DRG_ELEMENT_MARGIN + element.width / 2),
          y: previousPosition.y
        };
      }
    };
  }

  /**
   * DMN auto-place behavior.
   *
   * @param {EventBus} eventBus
   */
  function AutoPlace(eventBus) {
    eventBus.on('autoPlace', function (context) {
      var shape = context.shape,
        source = context.source;
      return getNewShapePosition(source, shape);
    });
  }
  AutoPlace.$inject = ['eventBus'];

  var AutoPlaceModule = {
    __depends__: [AutoPlaceModule$1],
    __init__: ['dmnAutoPlace'],
    dmnAutoPlace: ['type', AutoPlace]
  };

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  var HIGH_PRIORITY$b = 1500;

  /**
   * Browsers may swallow certain events (hover, out ...) if users are to
   * fast with the mouse.
   *
   * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event
   *
   * The fix implemented in this component ensure that we
   *
   * 1) have a hover state after a successful drag.move event
   * 2) have an out event when dragging leaves an element
   *
   * @param {ElementRegistry} elementRegistry
   * @param {EventBus} eventBus
   * @param {Injector} injector
   */
  function HoverFix(elementRegistry, eventBus, injector) {
    var self = this;
    var dragging = injector.get('dragging', false);

    /**
     * Make sure we are god damn hovering!
     *
     * @param {Event} dragging event
     */
    function ensureHover(event) {
      if (event.hover) {
        return;
      }
      var originalEvent = event.originalEvent;
      var gfx = self._findTargetGfx(originalEvent);
      var element = gfx && elementRegistry.get(gfx);
      if (gfx && element) {
        // 1) cancel current mousemove
        event.stopPropagation();

        // 2) emit fake hover for new target
        dragging.hover({
          element: element,
          gfx: gfx
        });

        // 3) re-trigger move event
        dragging.move(originalEvent);
      }
    }
    if (dragging) {
      /**
       * We wait for a specific sequence of events before
       * emitting a fake drag.hover event.
       *
       * Event Sequence:
       *
       * drag.start
       * drag.move >> ensure we are hovering
       */
      eventBus.on('drag.start', function (event) {
        eventBus.once('drag.move', HIGH_PRIORITY$b, function (event) {
          ensureHover(event);
        });
      });
    }

    /**
     * We make sure that element.out is always fired, even if the
     * browser swallows an element.out event.
     *
     * Event sequence:
     *
     * element.hover
     * (element.out >> sometimes swallowed)
     * element.hover >> ensure we fired element.out
     */
    (function () {
      var hoverGfx;
      var hover;
      eventBus.on('element.hover', function (event) {
        // (1) remember current hover element
        hoverGfx = event.gfx;
        hover = event.element;
      });
      eventBus.on('element.hover', HIGH_PRIORITY$b, function (event) {
        // (3) am I on an element still?
        if (hover) {
          // (4) that is a problem, gotta "simulate the out"
          eventBus.fire('element.out', {
            element: hover,
            gfx: hoverGfx
          });
        }
      });
      eventBus.on('element.out', function () {
        // (2) unset hover state if we correctly outed us *GG*
        hoverGfx = null;
        hover = null;
      });
    })();
    this._findTargetGfx = function (event) {
      var position, target;
      if (!(event instanceof MouseEvent)) {
        return;
      }
      position = toPoint(event);

      // damn expensive operation, ouch!
      target = document.elementFromPoint(position.x, position.y);
      return getGfx(target);
    };
  }
  HoverFix.$inject = ['elementRegistry', 'eventBus', 'injector'];

  // helpers /////////////////////

  function getGfx(target) {
    return closest(target, 'svg, .djs-element', true);
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var HoverFixModule = {
    __init__: ['hoverFix'],
    hoverFix: ['type', HoverFix]
  };

  var round$8 = Math.round;

  /**
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../selection/Selection').default} Selection
   */

  var DRAG_ACTIVE_CLS = 'djs-drag-active';
  function preventDefault$1(event) {
    event.preventDefault();
  }
  function isTouchEvent(event) {
    // check for TouchEvent being available first
    // (i.e. not available on desktop Firefox)
    return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;
  }
  function getLength(point) {
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
  }

  /**
   * A helper that fires canvas localized drag events and realizes
   * the general "drag-and-drop" look and feel.
   *
   * Calling {@link Dragging#activate} activates dragging on a canvas.
   *
   * It provides the following:
   *
   *   * emits life cycle events, namespaced with a prefix assigned
   *     during dragging activation
   *   * sets and restores the cursor
   *   * sets and restores the selection if elements still exist
   *   * ensures there can be only one drag operation active at a time
   *
   * Dragging may be canceled manually by calling {@link Dragging#cancel}
   * or by pressing ESC.
   *
   *
   * ## Life-cycle events
   *
   * Dragging can be in three different states, off, initialized
   * and active.
   *
   * (1) off: no dragging operation is in progress
   * (2) initialized: a new drag operation got initialized but not yet
   *                  started (i.e. because of no initial move)
   * (3) started: dragging is in progress
   *
   * Eventually dragging will be off again after a drag operation has
   * been ended or canceled via user click or ESC key press.
   *
   * To indicate transitions between these states dragging emits generic
   * life-cycle events with the `drag.` prefix _and_ events namespaced
   * to a prefix choosen by a user during drag initialization.
   *
   * The following events are emitted (appropriately prefixed) via
   * the {@link EventBus}.
   *
   * * `init`
   * * `start`
   * * `move`
   * * `end`
   * * `ended` (dragging already in off state)
   * * `cancel` (only if previously started)
   * * `canceled` (dragging already in off state, only if previously started)
   * * `cleanup`
   *
   *
   * @example
   *
   * ```javascript
   * function MyDragComponent(eventBus, dragging) {
   *
   *   eventBus.on('mydrag.start', function(event) {
   *     console.log('yes, we start dragging');
   *   });
   *
   *   eventBus.on('mydrag.move', function(event) {
   *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);
   *
   *     // local drag data is passed with the event
   *     event.context.foo; // "BAR"
   *
   *     // the original mouse event, too
   *     event.originalEvent; // MouseEvent(...)
   *   });
   *
   *   eventBus.on('element.click', function(event) {
   *     dragging.init(event, 'mydrag', {
   *       cursor: 'grabbing',
   *       data: {
   *         context: {
   *           foo: "BAR"
   *         }
   *       }
   *     });
   *   });
   * }
   * ```
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Selection} selection
   * @param {ElementRegistry} elementRegistry
   */
  function Dragging(eventBus, canvas, selection, elementRegistry) {
    var defaultOptions = {
      threshold: 5,
      trapClick: true
    };

    // the currently active drag operation
    // dragging is active as soon as this context exists.
    //
    // it is visually _active_ only when a context.active flag is set to true.
    var context;

    /* convert a global event into local coordinates */
    function toLocalPoint(globalPosition) {
      var viewbox = canvas.viewbox();
      var clientRect = canvas._container.getBoundingClientRect();
      return {
        x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
        y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
      };
    }

    // helpers

    function fire(type, dragContext) {
      dragContext = dragContext || context;
      var event = eventBus.createEvent(assign$4({}, dragContext.payload, dragContext.data, {
        isTouch: dragContext.isTouch
      }));

      // default integration
      if (eventBus.fire('drag.' + type, event) === false) {
        return false;
      }
      return eventBus.fire(dragContext.prefix + '.' + type, event);
    }
    function restoreSelection(previousSelection) {
      var existingSelection = previousSelection.filter(function (element) {
        return elementRegistry.get(element.id);
      });
      existingSelection.length && selection.select(existingSelection);
    }

    // event listeners

    function move(event, activate) {
      var payload = context.payload,
        displacement = context.displacement;
      var globalStart = context.globalStart,
        globalCurrent = toPoint(event),
        globalDelta = delta(globalCurrent, globalStart);
      var localStart = context.localStart,
        localCurrent = toLocalPoint(globalCurrent),
        localDelta = delta(localCurrent, localStart);

      // activate context explicitly or once threshold is reached
      if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {
        // fire start event with original
        // starting coordinates

        assign$4(payload, {
          x: round$8(localStart.x + displacement.x),
          y: round$8(localStart.y + displacement.y),
          dx: 0,
          dy: 0
        }, {
          originalEvent: event
        });
        if (false === fire('start')) {
          return cancel();
        }
        context.active = true;

        // unset selection and remember old selection
        // the previous (old) selection will always passed
        // with the event via the event.previousSelection property
        if (!context.keepSelection) {
          payload.previousSelection = selection.get();
          selection.select(null);
        }

        // allow custom cursor
        if (context.cursor) {
          set(context.cursor);
        }

        // indicate dragging via marker on root element
        canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
      }
      stopPropagation$3(event);
      if (context.active) {
        // update payload with actual coordinates
        assign$4(payload, {
          x: round$8(localCurrent.x + displacement.x),
          y: round$8(localCurrent.y + displacement.y),
          dx: round$8(localDelta.x),
          dy: round$8(localDelta.y)
        }, {
          originalEvent: event
        });

        // emit move event
        fire('move');
      }
    }
    function end(event) {
      var previousContext,
        returnValue = true;
      if (context.active) {
        if (event) {
          context.payload.originalEvent = event;

          // suppress original event (click, ...)
          // because we just ended a drag operation
          stopPropagation$3(event);
        }

        // implementations may stop restoring the
        // original state (selections, ...) by preventing the
        // end events default action
        returnValue = fire('end');
      }
      if (returnValue === false) {
        fire('rejected');
      }
      previousContext = cleanup(returnValue !== true);

      // last event to be fired when all drag operations are done
      // at this point in time no drag operation is in progress anymore
      fire('ended', previousContext);
    }

    // cancel active drag operation if the user presses
    // the ESC key on the keyboard

    function checkCancel(event) {
      if (isKey('Escape', event)) {
        preventDefault$1(event);
        cancel();
      }
    }

    // prevent ghost click that might occur after a finished
    // drag and drop session

    function trapClickAndEnd(event) {
      var untrap;

      // trap the click in case we are part of an active
      // drag operation. This will effectively prevent
      // the ghost click that cannot be canceled otherwise.
      if (context.active) {
        untrap = install(eventBus);

        // remove trap after minimal delay
        setTimeout(untrap, 400);

        // prevent default action (click)
        preventDefault$1(event);
      }
      end(event);
    }
    function trapTouch(event) {
      move(event);
    }

    // update the drag events model element (`hover`) and graphical element (`hoverGfx`)
    // properties during hover and out and fire {prefix}.hover and {prefix}.out properties
    // respectively

    function hover(event) {
      var payload = context.payload;
      payload.hoverGfx = event.gfx;
      payload.hover = event.element;
      fire('hover');
    }
    function out(event) {
      fire('out');
      var payload = context.payload;
      payload.hoverGfx = null;
      payload.hover = null;
    }

    // life-cycle methods

    function cancel(restore) {
      var previousContext;
      if (!context) {
        return;
      }
      var wasActive = context.active;
      if (wasActive) {
        fire('cancel');
      }
      previousContext = cleanup(restore);
      if (wasActive) {
        // last event to be fired when all drag operations are done
        // at this point in time no drag operation is in progress anymore
        fire('canceled', previousContext);
      }
    }
    function cleanup(restore) {
      var previousContext, endDrag;
      fire('cleanup');

      // reset cursor
      unset();
      if (context.trapClick) {
        endDrag = trapClickAndEnd;
      } else {
        endDrag = end;
      }

      // reset dom listeners
      event.unbind(document, 'mousemove', move);
      event.unbind(document, 'dragstart', preventDefault$1);
      event.unbind(document, 'selectstart', preventDefault$1);
      event.unbind(document, 'mousedown', endDrag, true);
      event.unbind(document, 'mouseup', endDrag, true);
      event.unbind(document, 'keyup', checkCancel);
      event.unbind(document, 'touchstart', trapTouch, true);
      event.unbind(document, 'touchcancel', cancel, true);
      event.unbind(document, 'touchmove', move, true);
      event.unbind(document, 'touchend', end, true);
      eventBus.off('element.hover', hover);
      eventBus.off('element.out', out);

      // remove drag marker on root element
      canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);

      // restore selection, unless it has changed
      var previousSelection = context.payload.previousSelection;
      if (restore !== false && previousSelection && !selection.get().length) {
        restoreSelection(previousSelection);
      }
      previousContext = context;
      context = null;
      return previousContext;
    }

    /**
     * Initialize a drag operation.
     *
     * If `localPosition` is given, drag events will be emitted
     * relative to it.
     *
     * @param {MouseEvent|TouchEvent} [event]
     * @param {Point} [relativeTo] actual diagram local position this drag operation should start at
     * @param {string} prefix
     * @param {Object} [options]
     */
    function init(event$1, relativeTo, prefix, options) {
      // only one drag operation may be active, at a time
      if (context) {
        cancel(false);
      }
      if (typeof relativeTo === 'string') {
        options = prefix;
        prefix = relativeTo;
        relativeTo = null;
      }
      options = assign$4({}, defaultOptions, options || {});
      var data = options.data || {},
        originalEvent,
        globalStart,
        localStart,
        endDrag,
        isTouch;
      if (options.trapClick) {
        endDrag = trapClickAndEnd;
      } else {
        endDrag = end;
      }
      if (event$1) {
        originalEvent = getOriginal$1(event$1) || event$1;
        globalStart = toPoint(event$1);
        stopPropagation$3(event$1);

        // prevent default browser dragging behavior
        if (originalEvent.type === 'dragstart') {
          preventDefault$1(originalEvent);
        }
      } else {
        originalEvent = null;
        globalStart = {
          x: 0,
          y: 0
        };
      }
      localStart = toLocalPoint(globalStart);
      if (!relativeTo) {
        relativeTo = localStart;
      }
      isTouch = isTouchEvent(originalEvent);
      context = assign$4({
        prefix: prefix,
        data: data,
        payload: {},
        globalStart: globalStart,
        displacement: delta(relativeTo, localStart),
        localStart: localStart,
        isTouch: isTouch
      }, options);

      // skip dom registration if trigger
      // is set to manual (during testing)
      if (!options.manual) {
        // add dom listeners

        if (isTouch) {
          event.bind(document, 'touchstart', trapTouch, true);
          event.bind(document, 'touchcancel', cancel, true);
          event.bind(document, 'touchmove', move, true);
          event.bind(document, 'touchend', end, true);
        } else {
          // assume we use the mouse to interact per default
          event.bind(document, 'mousemove', move);

          // prevent default browser drag and text selection behavior
          event.bind(document, 'dragstart', preventDefault$1);
          event.bind(document, 'selectstart', preventDefault$1);
          event.bind(document, 'mousedown', endDrag, true);
          event.bind(document, 'mouseup', endDrag, true);
        }
        event.bind(document, 'keyup', checkCancel);
        eventBus.on('element.hover', hover);
        eventBus.on('element.out', out);
      }
      fire('init');
      if (options.autoActivate) {
        move(event$1, true);
      }
    }

    // cancel on diagram destruction
    eventBus.on('diagram.destroy', cancel);

    // API

    this.init = init;
    this.move = move;
    this.hover = hover;
    this.out = out;
    this.end = end;
    this.cancel = cancel;

    // for introspection

    this.context = function () {
      return context;
    };
    this.setOptions = function (options) {
      assign$4(defaultOptions, options);
    };
  }
  Dragging.$inject = ['eventBus', 'canvas', 'selection', 'elementRegistry'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DraggingModule = {
    __depends__: [HoverFixModule, SelectionModule],
    dragging: ['type', Dragging]
  };

  /**
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../../core/Canvas').default} Canvas
   */

  /**
   * Initiates canvas scrolling if current cursor point is close to a border.
   * Cancelled when current point moves back inside the scrolling borders
   * or cancelled manually.
   *
   * Default options :
   *   scrollThresholdIn: [ 20, 20, 20, 20 ],
   *   scrollThresholdOut: [ 0, 0, 0, 0 ],
   *   scrollRepeatTimeout: 15,
   *   scrollStep: 10
   *
   * Threshold order:
   *   [ left, top, right, bottom ]
   *
   * @param {Object} config
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function AutoScroll(config, eventBus, canvas) {
    this._canvas = canvas;
    this._opts = assign$4({
      scrollThresholdIn: [20, 20, 20, 20],
      scrollThresholdOut: [0, 0, 0, 0],
      scrollRepeatTimeout: 15,
      scrollStep: 10
    }, config);
    var self = this;
    eventBus.on('drag.move', function (e) {
      var point = self._toBorderPoint(e);
      self.startScroll(point);
    });
    eventBus.on(['drag.cleanup'], function () {
      self.stopScroll();
    });
  }
  AutoScroll.$inject = ['config.autoScroll', 'eventBus', 'canvas'];

  /**
   * Starts scrolling loop.
   * Point is given in global scale in canvas container box plane.
   *
   * @param {Point} point
   */
  AutoScroll.prototype.startScroll = function (point) {
    var canvas = this._canvas;
    var opts = this._opts;
    var self = this;
    var clientRect = canvas.getContainer().getBoundingClientRect();
    var diff = [point.x, point.y, clientRect.width - point.x, clientRect.height - point.y];
    this.stopScroll();
    var dx = 0,
      dy = 0;
    for (var i = 0; i < 4; i++) {
      if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {
        if (i === 0) {
          dx = opts.scrollStep;
        } else if (i == 1) {
          dy = opts.scrollStep;
        } else if (i == 2) {
          dx = -opts.scrollStep;
        } else if (i == 3) {
          dy = -opts.scrollStep;
        }
      }
    }
    if (dx !== 0 || dy !== 0) {
      canvas.scroll({
        dx: dx,
        dy: dy
      });
      this._scrolling = setTimeout(function () {
        self.startScroll(point);
      }, opts.scrollRepeatTimeout);
    }
  };
  function between(val, start, end) {
    if (start < val && val < end) {
      return true;
    }
    return false;
  }

  /**
   * Stops scrolling loop.
   */
  AutoScroll.prototype.stopScroll = function () {
    clearTimeout(this._scrolling);
  };

  /**
   * Overrides defaults options.
   *
   * @param {Object} options
   */
  AutoScroll.prototype.setOptions = function (options) {
    this._opts = assign$4({}, this._opts, options);
  };

  /**
   * Converts event to a point in canvas container plane in global scale.
   *
   * @param {Event} event
   * @return {Point}
   */
  AutoScroll.prototype._toBorderPoint = function (event) {
    var clientRect = this._canvas._container.getBoundingClientRect();
    var globalPosition = toPoint(event.originalEvent);
    return {
      x: globalPosition.x - clientRect.left,
      y: globalPosition.y - clientRect.top
    };
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var AutoScrollModule = {
    __depends__: [DraggingModule],
    __init__: ['autoScroll'],
    autoScroll: ['type', AutoScroll]
  };

  /**
   * @typedef {import('didi').Injector} Injector
   */

  /**
   * A service that provides rules for certain diagram actions.
   *
   * The default implementation will hook into the {@link CommandStack}
   * to perform the actual rule evaluation. Make sure to provide the
   * `commandStack` service with this module if you plan to use it.
   *
   * Together with this implementation you may use the {@link import('./RuleProvider').default}
   * to implement your own rule checkers.
   *
   * This module is ment to be easily replaced, thus the tiny foot print.
   *
   * @param {Injector} injector
   */
  function Rules$6(injector) {
    this._commandStack = injector.get('commandStack', false);
  }
  Rules$6.$inject = ['injector'];

  /**
   * Returns whether or not a given modeling action can be executed
   * in the specified context.
   *
   * This implementation will respond with allow unless anyone
   * objects.
   *
   * @param {string} action The action to be allowed or disallowed.
   * @param {Object} [context] The context for allowing or disallowing the action.
   *
   * @return {boolean|null} Wether the action is allowed. Returns `null` if the action
   * is to be ignored.
   */
  Rules$6.prototype.allowed = function (action, context) {
    var allowed = true;
    var commandStack = this._commandStack;
    if (commandStack) {
      allowed = commandStack.canExecute(action, context);
    }

    // map undefined to true, i.e. no rules
    return allowed === undefined ? true : allowed;
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var Rules$5 = {
    __init__: ['rules'],
    rules: ['type', Rules$6]
  };

  /**
   * @typedef {import('../util/Types').Point} Point
   *
   * @typedef { {
   *   bendpoint?: boolean;
   *   index: number;
   *   point: Point;
   * } } Intersection
   */

  var round$7 = Math.round,
    max$2 = Math.max;
  function circlePath(center, r) {
    var x = center.x,
      y = center.y;
    return [['M', x, y], ['m', 0, -r], ['a', r, r, 0, 1, 1, 0, 2 * r], ['a', r, r, 0, 1, 1, 0, -2 * r], ['z']];
  }
  function linePath(points) {
    var segments = [];
    points.forEach(function (p, idx) {
      segments.push([idx === 0 ? 'M' : 'L', p.x, p.y]);
    });
    return segments;
  }
  var INTERSECTION_THRESHOLD = 10;

  /**
   * @param {Point[]} waypoints
   * @param {Point} reference
   *
   * @return {Intersection|null}
   */
  function getBendpointIntersection(waypoints, reference) {
    var i, w;
    for (i = 0; w = waypoints[i]; i++) {
      if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {
        return {
          point: waypoints[i],
          bendpoint: true,
          index: i
        };
      }
    }
    return null;
  }

  /**
   * @param {Point[]} waypoints
   * @param {Point} reference
   *
   * @return {Intersection|null}
   */
  function getPathIntersection(waypoints, reference) {
    var intersections = intersectPaths(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));
    var a = intersections[0],
      b = intersections[intersections.length - 1],
      idx;
    if (!a) {
      // no intersection
      return null;
    }
    if (a !== b) {
      if (a.segment2 !== b.segment2) {
        // we use the bendpoint in between both segments
        // as the intersection point

        idx = max$2(a.segment2, b.segment2) - 1;
        return {
          point: waypoints[idx],
          bendpoint: true,
          index: idx
        };
      }
      return {
        point: {
          x: round$7(a.x + b.x) / 2,
          y: round$7(a.y + b.y) / 2
        },
        index: a.segment2
      };
    }
    return {
      point: {
        x: round$7(a.x),
        y: round$7(a.y)
      },
      index: a.segment2
    };
  }

  /**
   * Returns the closest point on the connection towards a given reference point.
   *
   * @param {Point[]} waypoints
   * @param {Point} reference
   *
   * @return {Intersection|null}
   */
  function getApproxIntersection(waypoints, reference) {
    return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
  }

  /**
   * @typedef {import('../../util/Types').Point} Point
   * @typedef {import('../../util/Types').Vector} Vector
   */

  /**
   * Returns the length of a vector.
   *
   * @param {Vector} vector
   *
   * @return {number}
   */
  function vectorLength(vector) {
    return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
  }

  /**
   * Solves a 2D equation system
   * a + r*b = c, where a,b,c are 2D vectors
   *
   * @param {Vector} a
   * @param {Vector} b
   * @param {Vector} c
   *
   * @return {number}
   */
  function solveLambaSystem(a, b, c) {
    // the 2d system
    var system = [{
      n: a[0] - c[0],
      lambda: b[0]
    }, {
      n: a[1] - c[1],
      lambda: b[1]
    }];

    // solve
    var n = system[0].n * b[0] + system[1].n * b[1],
      l = system[0].lambda * b[0] + system[1].lambda * b[1];
    return -n / l;
  }

  /**
   * Calculates the position of the perpendicular foot.
   *
   * @param {Point} point
   * @param {Point[]} line
   *
   * @return {Point}
   */
  function perpendicularFoot(point, line) {
    var a = line[0],
      b = line[1];

    // relative position of b from a
    var bd = {
      x: b.x - a.x,
      y: b.y - a.y
    };

    // solve equation system to the parametrized vectors param real value
    var r = solveLambaSystem([a.x, a.y], [bd.x, bd.y], [point.x, point.y]);
    return {
      x: a.x + r * bd.x,
      y: a.y + r * bd.y
    };
  }

  /**
   * Calculates the distance between a point and a line.
   *
   * @param {Point} point
   * @param {Point[]} line
   *
   * @return {number}
   */
  function getDistancePointLine(point, line) {
    var pfPoint = perpendicularFoot(point, line);

    // distance vector
    var connectionVector = {
      x: pfPoint.x - point.x,
      y: pfPoint.y - point.y
    };
    return vectorLength(connectionVector);
  }

  /**
   * @typedef {import('../../core/Types').ConnectionLike} Connection
   *
   * @typedef {import('../../util/Types').Point} Point
   */

  var BENDPOINT_CLS = 'djs-bendpoint';
  var SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';
  function toCanvasCoordinates(canvas, event) {
    var position = toPoint(event),
      clientRect = canvas._container.getBoundingClientRect(),
      offset;

    // canvas relative position

    offset = {
      x: clientRect.left,
      y: clientRect.top
    };

    // update actual event payload with canvas relative measures

    var viewbox = canvas.viewbox();
    return {
      x: viewbox.x + (position.x - offset.x) / viewbox.scale,
      y: viewbox.y + (position.y - offset.y) / viewbox.scale
    };
  }
  function getConnectionIntersection(canvas, waypoints, event) {
    var localPosition = toCanvasCoordinates(canvas, event),
      intersection = getApproxIntersection(waypoints, localPosition);
    return intersection;
  }
  function addBendpoint(parentGfx, cls) {
    var groupGfx = create$2('g');
    classes(groupGfx).add(BENDPOINT_CLS);
    append(parentGfx, groupGfx);
    var visual = create$2('circle');
    attr(visual, {
      cx: 0,
      cy: 0,
      r: 4
    });
    classes(visual).add('djs-visual');
    append(groupGfx, visual);
    var hit = create$2('circle');
    attr(hit, {
      cx: 0,
      cy: 0,
      r: 10
    });
    classes(hit).add('djs-hit');
    append(groupGfx, hit);
    if (cls) {
      classes(groupGfx).add(cls);
    }
    return groupGfx;
  }
  function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
    var draggerGfx = create$2('g');
    append(parentGfx, draggerGfx);
    var width = 18,
      height = 6,
      padding = 11,
      hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment),
      hitHeight = height + padding;
    var visual = create$2('rect');
    attr(visual, {
      x: -width / 2,
      y: -height / 2,
      width: width,
      height: height
    });
    classes(visual).add('djs-visual');
    append(draggerGfx, visual);
    var hit = create$2('rect');
    attr(hit, {
      x: -hitWidth / 2,
      y: -hitHeight / 2,
      width: hitWidth,
      height: hitHeight
    });
    classes(hit).add('djs-hit');
    append(draggerGfx, hit);
    rotate(draggerGfx, alignment === 'v' ? 90 : 0);
    return draggerGfx;
  }
  function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {
    var groupGfx = create$2('g'),
      mid = getMidPoint(segmentStart, segmentEnd),
      alignment = pointsAligned(segmentStart, segmentEnd);
    append(parentGfx, groupGfx);
    createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);
    classes(groupGfx).add(SEGMENT_DRAGGER_CLS);
    classes(groupGfx).add(alignment === 'h' ? 'horizontal' : 'vertical');
    translate$1(groupGfx, mid.x, mid.y);
    return groupGfx;
  }

  /**
   * Calculates region for segment move which is 2/3 of the full segment length
   * @param {number} segmentLength
   *
   * @return {number}
   */
  function calculateSegmentMoveRegion(segmentLength) {
    return Math.abs(Math.round(segmentLength * 2 / 3));
  }

  /**
   * Returns the point with the closest distance that is on the connection path.
   *
   * @param {Point} position
   * @param {Connection} connection
   * @return {Point}
   */
  function getClosestPointOnConnection(position, connection) {
    var segment = getClosestSegment(position, connection);
    return perpendicularFoot(position, segment);
  }

  // helper //////////

  function calculateHitWidth(segmentStart, segmentEnd, alignment) {
    var segmentLengthXAxis = segmentEnd.x - segmentStart.x,
      segmentLengthYAxis = segmentEnd.y - segmentStart.y;
    return alignment === 'h' ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);
  }
  function getClosestSegment(position, connection) {
    var waypoints = connection.waypoints;
    var minDistance = Infinity,
      segmentIndex;
    for (var i = 0; i < waypoints.length - 1; i++) {
      var start = waypoints[i],
        end = waypoints[i + 1],
        distance = getDistancePointLine(position, [start, end]);
      if (distance < minDistance) {
        minDistance = distance;
        segmentIndex = i;
      }
    }
    return [waypoints[segmentIndex], waypoints[segmentIndex + 1]];
  }

  /**
   * @typedef {import('../bendpoints/BendpointMove').default} BendpointMove
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../bendpoints/ConnectionSegmentMove').default} ConnectionSegmentMove
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../interaction-events/InteractionEvents').default} InteractionEvents
   */

  /**
   * A service that adds editable bendpoints to connections.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {InteractionEvents} interactionEvents
   * @param {BendpointMove} bendpointMove
   * @param {ConnectionSegmentMove} connectionSegmentMove
   */
  function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {
    /**
     * Returns true if intersection point is inside middle region of segment, adjusted by
     * optional threshold
     */
    function isIntersectionMiddle(intersection, waypoints, treshold) {
      var idx = intersection.index,
        p = intersection.point,
        p0,
        p1,
        mid,
        aligned,
        xDelta,
        yDelta;
      if (idx <= 0 || intersection.bendpoint) {
        return false;
      }
      p0 = waypoints[idx - 1];
      p1 = waypoints[idx];
      mid = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
      xDelta = Math.abs(p.x - mid.x);
      yDelta = Math.abs(p.y - mid.y);
      return aligned && xDelta <= treshold && yDelta <= treshold;
    }

    /**
     * Calculates the threshold from a connection's middle which fits the two-third-region
     */
    function calculateIntersectionThreshold(connection, intersection) {
      var waypoints = connection.waypoints,
        relevantSegment,
        alignment,
        segmentLength,
        threshold;
      if (intersection.index <= 0 || intersection.bendpoint) {
        return null;
      }

      // segment relative to connection intersection
      relevantSegment = {
        start: waypoints[intersection.index - 1],
        end: waypoints[intersection.index]
      };
      alignment = pointsAligned(relevantSegment.start, relevantSegment.end);
      if (!alignment) {
        return null;
      }
      if (alignment === 'h') {
        segmentLength = relevantSegment.end.x - relevantSegment.start.x;
      } else {
        segmentLength = relevantSegment.end.y - relevantSegment.start.y;
      }

      // calculate threshold relative to 2/3 of segment length
      threshold = calculateSegmentMoveRegion(segmentLength) / 2;
      return threshold;
    }
    function activateBendpointMove(event, connection) {
      var waypoints = connection.waypoints,
        intersection = getConnectionIntersection(canvas, waypoints, event),
        threshold;
      if (!intersection) {
        return;
      }
      threshold = calculateIntersectionThreshold(connection, intersection);
      if (isIntersectionMiddle(intersection, waypoints, threshold)) {
        connectionSegmentMove.start(event, connection, intersection.index);
      } else {
        bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);
      }

      // we've handled the event
      return true;
    }
    function bindInteractionEvents(node, eventName, element) {
      event.bind(node, eventName, function (event) {
        interactionEvents.triggerMouseEvent(eventName, event, element);
        event.stopPropagation();
      });
    }
    function getBendpointsContainer(element, create) {
      var layer = canvas.getLayer('overlays'),
        gfx = query('.djs-bendpoints[data-element-id="' + escapeCSS(element.id) + '"]', layer);
      if (!gfx && create) {
        gfx = create$2('g');
        attr(gfx, {
          'data-element-id': element.id
        });
        classes(gfx).add('djs-bendpoints');
        append(layer, gfx);
        bindInteractionEvents(gfx, 'mousedown', element);
        bindInteractionEvents(gfx, 'click', element);
        bindInteractionEvents(gfx, 'dblclick', element);
      }
      return gfx;
    }
    function getSegmentDragger(idx, parentGfx) {
      return query('.djs-segment-dragger[data-segment-idx="' + idx + '"]', parentGfx);
    }
    function createBendpoints(gfx, connection) {
      connection.waypoints.forEach(function (p, idx) {
        var bendpoint = addBendpoint(gfx);
        append(gfx, bendpoint);
        translate$1(bendpoint, p.x, p.y);
      });

      // add floating bendpoint
      addBendpoint(gfx, 'floating');
    }
    function createSegmentDraggers(gfx, connection) {
      var waypoints = connection.waypoints;
      var segmentStart, segmentEnd, segmentDraggerGfx;
      for (var i = 1; i < waypoints.length; i++) {
        segmentStart = waypoints[i - 1];
        segmentEnd = waypoints[i];
        if (pointsAligned(segmentStart, segmentEnd)) {
          segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);
          attr(segmentDraggerGfx, {
            'data-segment-idx': i
          });
          bindInteractionEvents(segmentDraggerGfx, 'mousemove', connection);
        }
      }
    }
    function clearBendpoints(gfx) {
      forEach$3(all('.' + BENDPOINT_CLS, gfx), function (node) {
        remove$3(node);
      });
    }
    function clearSegmentDraggers(gfx) {
      forEach$3(all('.' + SEGMENT_DRAGGER_CLS, gfx), function (node) {
        remove$3(node);
      });
    }
    function addHandles(connection) {
      var gfx = getBendpointsContainer(connection);
      if (!gfx) {
        gfx = getBendpointsContainer(connection, true);
        createBendpoints(gfx, connection);
        createSegmentDraggers(gfx, connection);
      }
      return gfx;
    }
    function updateHandles(connection) {
      var gfx = getBendpointsContainer(connection);
      if (gfx) {
        clearSegmentDraggers(gfx);
        clearBendpoints(gfx);
        createSegmentDraggers(gfx, connection);
        createBendpoints(gfx, connection);
      }
    }
    function updateFloatingBendpointPosition(parentGfx, intersection) {
      var floating = query('.floating', parentGfx),
        point = intersection.point;
      if (!floating) {
        return;
      }
      translate$1(floating, point.x, point.y);
    }
    function updateSegmentDraggerPosition(parentGfx, intersection, waypoints) {
      var draggerGfx = getSegmentDragger(intersection.index, parentGfx),
        segmentStart = waypoints[intersection.index - 1],
        segmentEnd = waypoints[intersection.index],
        point = intersection.point,
        mid = getMidPoint(segmentStart, segmentEnd),
        alignment = pointsAligned(segmentStart, segmentEnd),
        draggerVisual,
        relativePosition;
      if (!draggerGfx) {
        return;
      }
      draggerVisual = getDraggerVisual(draggerGfx);
      relativePosition = {
        x: point.x - mid.x,
        y: point.y - mid.y
      };
      if (alignment === 'v') {
        // rotate position
        relativePosition = {
          x: relativePosition.y,
          y: relativePosition.x
        };
      }
      translate$1(draggerVisual, relativePosition.x, relativePosition.y);
    }
    eventBus.on('connection.changed', function (event) {
      updateHandles(event.element);
    });
    eventBus.on('connection.remove', function (event) {
      var gfx = getBendpointsContainer(event.element);
      if (gfx) {
        remove$3(gfx);
      }
    });
    eventBus.on('element.marker.update', function (event) {
      var element = event.element,
        bendpointsGfx;
      if (!element.waypoints) {
        return;
      }
      bendpointsGfx = addHandles(element);
      if (event.add) {
        classes(bendpointsGfx).add(event.marker);
      } else {
        classes(bendpointsGfx).remove(event.marker);
      }
    });
    eventBus.on('element.mousemove', function (event) {
      var element = event.element,
        waypoints = element.waypoints,
        bendpointsGfx,
        intersection;
      if (waypoints) {
        bendpointsGfx = getBendpointsContainer(element, true);
        intersection = getConnectionIntersection(canvas, waypoints, event.originalEvent);
        if (!intersection) {
          return;
        }
        updateFloatingBendpointPosition(bendpointsGfx, intersection);
        if (!intersection.bendpoint) {
          updateSegmentDraggerPosition(bendpointsGfx, intersection, waypoints);
        }
      }
    });
    eventBus.on('element.mousedown', function (event) {
      if (!isPrimaryButton(event)) {
        return;
      }
      var originalEvent = event.originalEvent,
        element = event.element;
      if (!element.waypoints) {
        return;
      }
      return activateBendpointMove(originalEvent, element);
    });
    eventBus.on('selection.changed', function (event) {
      var newSelection = event.newSelection,
        primary = newSelection[0];
      if (primary && primary.waypoints) {
        addHandles(primary);
      }
    });
    eventBus.on('element.hover', function (event) {
      var element = event.element;
      if (element.waypoints) {
        addHandles(element);
        interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');
      }
    });
    eventBus.on('element.out', function (event) {
      interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');
    });

    // update bendpoint container data attribute on element ID change
    eventBus.on('element.updateId', function (context) {
      var element = context.element,
        newId = context.newId;
      if (element.waypoints) {
        var bendpointContainer = getBendpointsContainer(element);
        if (bendpointContainer) {
          attr(bendpointContainer, {
            'data-element-id': newId
          });
        }
      }
    });

    // API

    this.addHandles = addHandles;
    this.updateHandles = updateHandles;
    this.getBendpointsContainer = getBendpointsContainer;
    this.getSegmentDragger = getSegmentDragger;
  }
  Bendpoints.$inject = ['eventBus', 'canvas', 'interactionEvents', 'bendpointMove', 'connectionSegmentMove'];

  // helper /////////////

  function getDraggerVisual(draggerGfx) {
    return query('.djs-visual', draggerGfx);
  }

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   */

  var round$6 = Math.round;
  var RECONNECT_START$2 = 'reconnectStart',
    RECONNECT_END$2 = 'reconnectEnd',
    UPDATE_WAYPOINTS$1 = 'updateWaypoints';

  /**
   * Move bendpoints through drag and drop to add/remove bendpoints or reconnect connection.
   *
   * @param {Injector} injector
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Dragging} dragging
   * @param {Rules} rules
   * @param {Modeling} modeling
   */
  function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
    this._injector = injector;
    this.start = function (event, connection, bendpointIndex, insert) {
      var gfx = canvas.getGraphics(connection),
        source = connection.source,
        target = connection.target,
        waypoints = connection.waypoints,
        type;
      if (!insert && bendpointIndex === 0) {
        type = RECONNECT_START$2;
      } else if (!insert && bendpointIndex === waypoints.length - 1) {
        type = RECONNECT_END$2;
      } else {
        type = UPDATE_WAYPOINTS$1;
      }
      var command = type === UPDATE_WAYPOINTS$1 ? 'connection.updateWaypoints' : 'connection.reconnect';
      var allowed = rules.allowed(command, {
        connection: connection,
        source: source,
        target: target
      });
      if (allowed === false) {
        allowed = rules.allowed(command, {
          connection: connection,
          source: target,
          target: source
        });
      }
      if (allowed === false) {
        return;
      }
      dragging.init(event, 'bendpoint.move', {
        data: {
          connection: connection,
          connectionGfx: gfx,
          context: {
            allowed: allowed,
            bendpointIndex: bendpointIndex,
            connection: connection,
            source: source,
            target: target,
            insert: insert,
            type: type
          }
        }
      });
    };
    eventBus.on('bendpoint.move.hover', function (event) {
      var context = event.context,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        hover = event.hover,
        type = context.type;

      // cache hover state
      context.hover = hover;
      var allowed;
      if (!hover) {
        return;
      }
      var command = type === UPDATE_WAYPOINTS$1 ? 'connection.updateWaypoints' : 'connection.reconnect';
      allowed = context.allowed = rules.allowed(command, {
        connection: connection,
        source: type === RECONNECT_START$2 ? hover : source,
        target: type === RECONNECT_END$2 ? hover : target
      });
      if (allowed) {
        context.source = type === RECONNECT_START$2 ? hover : source;
        context.target = type === RECONNECT_END$2 ? hover : target;
        return;
      }
      if (allowed === false) {
        allowed = context.allowed = rules.allowed(command, {
          connection: connection,
          source: type === RECONNECT_END$2 ? hover : target,
          target: type === RECONNECT_START$2 ? hover : source
        });
      }
      if (allowed) {
        context.source = type === RECONNECT_END$2 ? hover : target;
        context.target = type === RECONNECT_START$2 ? hover : source;
      }
    });
    eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], function (event) {
      var context = event.context,
        type = context.type;
      context.hover = null;
      context.source = null;
      context.target = null;
      if (type !== UPDATE_WAYPOINTS$1) {
        context.allowed = false;
      }
    });
    eventBus.on('bendpoint.move.end', function (event) {
      var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        newWaypoints = connection.waypoints.slice(),
        source = context.source,
        target = context.target,
        type = context.type,
        hints = context.hints || {};

      // ensure integer values (important if zoom level was > 1 during move)
      var docking = {
        x: round$6(event.x),
        y: round$6(event.y)
      };
      if (!allowed) {
        return false;
      }
      if (type === UPDATE_WAYPOINTS$1) {
        if (insert) {
          // insert new bendpoint
          newWaypoints.splice(bendpointIndex, 0, docking);
        } else {
          // swap previous waypoint with moved one
          newWaypoints[bendpointIndex] = docking;
        }

        // pass hints about actual moved bendpoint
        // useful for connection/label layout
        hints.bendpointMove = {
          insert: insert,
          bendpointIndex: bendpointIndex
        };
        newWaypoints = this.cropWaypoints(connection, newWaypoints);
        modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);
      } else {
        if (type === RECONNECT_START$2) {
          hints.docking = 'source';
          if (isReverse$1(context)) {
            hints.docking = 'target';
            hints.newWaypoints = newWaypoints.reverse();
          }
        } else if (type === RECONNECT_END$2) {
          hints.docking = 'target';
          if (isReverse$1(context)) {
            hints.docking = 'source';
            hints.newWaypoints = newWaypoints.reverse();
          }
        }
        modeling.reconnect(connection, source, target, docking, hints);
      }
    }, this);
  }
  BendpointMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'rules', 'modeling'];
  BendpointMove.prototype.cropWaypoints = function (connection, newWaypoints) {
    var connectionDocking = this._injector.get('connectionDocking', false);
    if (!connectionDocking) {
      return newWaypoints;
    }
    var waypoints = connection.waypoints;
    connection.waypoints = newWaypoints;
    connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
    newWaypoints = connection.waypoints;
    connection.waypoints = waypoints;
    return newWaypoints;
  };

  // helpers //////////

  function isReverse$1(context) {
    var hover = context.hover,
      source = context.source,
      target = context.target,
      type = context.type;
    if (type === RECONNECT_START$2) {
      return hover && target && hover === target && source !== target;
    }
    if (type === RECONNECT_END$2) {
      return hover && source && hover === source && source !== target;
    }
  }

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../bendpoints/BendpointMove').default} BendpointMove
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  var RECONNECT_START$1 = 'reconnectStart',
    RECONNECT_END$1 = 'reconnectEnd',
    UPDATE_WAYPOINTS = 'updateWaypoints';
  var MARKER_OK$3 = 'connect-ok',
    MARKER_NOT_OK$3 = 'connect-not-ok',
    MARKER_CONNECT_HOVER$1 = 'connect-hover',
    MARKER_CONNECT_UPDATING$1 = 'djs-updating',
    MARKER_DRAGGER = 'djs-dragging';
  var HIGH_PRIORITY$a = 1100;

  /**
   * Preview connection while moving bendpoints.
   *
   * @param {BendpointMove} bendpointMove
   * @param {Injector} injector
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
    this._injector = injector;
    var connectionPreview = injector.get('connectionPreview', false);
    eventBus.on('bendpoint.move.start', function (event) {
      var context = event.context,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        waypoints = connection.waypoints,
        newWaypoints = waypoints.slice();
      context.waypoints = waypoints;
      if (insert) {
        // insert placeholder for new bendpoint
        newWaypoints.splice(bendpointIndex, 0, {
          x: event.x,
          y: event.y
        });
      }
      connection.waypoints = newWaypoints;

      // add dragger gfx
      var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer('overlays'));
      classes(draggerGfx).add('djs-dragging');
      canvas.addMarker(connection, MARKER_DRAGGER);
      canvas.addMarker(connection, MARKER_CONNECT_UPDATING$1);
    });
    eventBus.on('bendpoint.move.hover', function (event) {
      var context = event.context,
        allowed = context.allowed,
        hover = context.hover,
        type = context.type;
      if (hover) {
        canvas.addMarker(hover, MARKER_CONNECT_HOVER$1);
        if (type === UPDATE_WAYPOINTS) {
          return;
        }
        if (allowed) {
          canvas.removeMarker(hover, MARKER_NOT_OK$3);
          canvas.addMarker(hover, MARKER_OK$3);
        } else if (allowed === false) {
          canvas.removeMarker(hover, MARKER_OK$3);
          canvas.addMarker(hover, MARKER_NOT_OK$3);
        }
      }
    });
    eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], HIGH_PRIORITY$a, function (event) {
      var context = event.context,
        hover = context.hover,
        target = context.target;
      if (hover) {
        canvas.removeMarker(hover, MARKER_CONNECT_HOVER$1);
        canvas.removeMarker(hover, target ? MARKER_OK$3 : MARKER_NOT_OK$3);
      }
    });
    eventBus.on('bendpoint.move.move', function (event) {
      var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        type = context.type,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        newWaypoints = connection.waypoints.slice(),
        bendpoint = {
          x: event.x,
          y: event.y
        },
        hints = context.hints || {},
        drawPreviewHints = {};
      if (connectionPreview) {
        if (hints.connectionStart) {
          drawPreviewHints.connectionStart = hints.connectionStart;
        }
        if (hints.connectionEnd) {
          drawPreviewHints.connectionEnd = hints.connectionEnd;
        }
        if (type === RECONNECT_START$1) {
          if (isReverse$1(context)) {
            drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
            drawPreviewHints.source = target;
            drawPreviewHints.target = hover || source;
            newWaypoints = newWaypoints.reverse();
          } else {
            drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
            drawPreviewHints.source = hover || source;
            drawPreviewHints.target = target;
          }
        } else if (type === RECONNECT_END$1) {
          if (isReverse$1(context)) {
            drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
            drawPreviewHints.source = hover || target;
            drawPreviewHints.target = source;
            newWaypoints = newWaypoints.reverse();
          } else {
            drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
            drawPreviewHints.source = source;
            drawPreviewHints.target = hover || target;
          }
        } else {
          drawPreviewHints.noCropping = true;
          drawPreviewHints.noLayout = true;
          newWaypoints[bendpointIndex] = bendpoint;
        }
        if (type === UPDATE_WAYPOINTS) {
          newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
        }
        drawPreviewHints.waypoints = newWaypoints;
        connectionPreview.drawPreview(context, allowed, drawPreviewHints);
      }
      translate$1(draggerGfx, event.x, event.y);
    }, this);
    eventBus.on(['bendpoint.move.end', 'bendpoint.move.cancel'], HIGH_PRIORITY$a, function (event) {
      var context = event.context,
        connection = context.connection,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        target = context.target,
        waypoints = context.waypoints;
      connection.waypoints = waypoints;

      // remove dragger gfx
      remove$3(draggerGfx);
      canvas.removeMarker(connection, MARKER_CONNECT_UPDATING$1);
      canvas.removeMarker(connection, MARKER_DRAGGER);
      if (hover) {
        canvas.removeMarker(hover, MARKER_OK$3);
        canvas.removeMarker(hover, target ? MARKER_OK$3 : MARKER_NOT_OK$3);
      }
      if (connectionPreview) {
        connectionPreview.cleanUp(context);
      }
    });
  }
  BendpointMovePreview.$inject = ['bendpointMove', 'injector', 'eventBus', 'canvas'];

  var MARKER_CONNECT_HOVER = 'connect-hover',
    MARKER_CONNECT_UPDATING = 'djs-updating';

  /**
   * @typedef {import('../../model/Types').Shape} Shape
   *
   * @typedef {import('../../util/Types').Axis} Axis
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory
   * @typedef {import('../modeling/Modeling').default} Modeling
   */

  function axisAdd(point, axis, delta) {
    return axisSet(point, axis, point[axis] + delta);
  }
  function axisSet(point, axis, value) {
    return {
      x: axis === 'x' ? value : point.x,
      y: axis === 'y' ? value : point.y
    };
  }
  function axisFenced(position, segmentStart, segmentEnd, axis) {
    var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),
      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);
    var padding = 20;
    var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);
    return axisSet(segmentStart, axis, fencedValue);
  }
  function flipAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  /**
   * Get the docking point on the given element.
   *
   * Compute a reasonable docking, if non exists.
   *
   * @param {Point} point
   * @param {Shape} referenceElement
   * @param {Axis} moveAxis
   *
   * @return {Point}
   */
  function getDocking$1(point, referenceElement, moveAxis) {
    var referenceMid, inverseAxis;
    if (point.original) {
      return point.original;
    } else {
      referenceMid = getMid(referenceElement);
      inverseAxis = flipAxis(moveAxis);
      return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
    }
  }

  /**
   * A component that implements moving of bendpoints.
   *
   * @param {Injector} injector
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Canvas} dragging
   * @param {GraphicsFactory} graphicsFactory
   * @param {Modeling} modeling
   */
  function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {
    // optional connection docking integration
    var connectionDocking = injector.get('connectionDocking', false);

    // API

    this.start = function (event, connection, idx) {
      var context,
        gfx = canvas.getGraphics(connection),
        segmentStartIndex = idx - 1,
        segmentEndIndex = idx,
        waypoints = connection.waypoints,
        segmentStart = waypoints[segmentStartIndex],
        segmentEnd = waypoints[segmentEndIndex],
        intersection = getConnectionIntersection(canvas, waypoints, event),
        direction,
        axis,
        dragPosition;
      direction = pointsAligned(segmentStart, segmentEnd);

      // do not move diagonal connection
      if (!direction) {
        return;
      }

      // the axis where we are going to move things
      axis = direction === 'v' ? 'x' : 'y';
      if (segmentStartIndex === 0) {
        segmentStart = getDocking$1(segmentStart, connection.source, axis);
      }
      if (segmentEndIndex === waypoints.length - 1) {
        segmentEnd = getDocking$1(segmentEnd, connection.target, axis);
      }
      if (intersection) {
        dragPosition = intersection.point;
      } else {
        // set to segment center as default
        dragPosition = {
          x: (segmentStart.x + segmentEnd.x) / 2,
          y: (segmentStart.y + segmentEnd.y) / 2
        };
      }
      context = {
        connection: connection,
        segmentStartIndex: segmentStartIndex,
        segmentEndIndex: segmentEndIndex,
        segmentStart: segmentStart,
        segmentEnd: segmentEnd,
        axis: axis,
        dragPosition: dragPosition
      };
      dragging.init(event, dragPosition, 'connectionSegment.move', {
        cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',
        data: {
          connection: connection,
          connectionGfx: gfx,
          context: context
        }
      });
    };

    /**
     * Crop connection if connection cropping is provided.
     *
     * @param {Connection} connection
     * @param {Point[]} newWaypoints
     *
     * @return {Point[]} cropped connection waypoints
     */
    function cropConnection(connection, newWaypoints) {
      // crop connection, if docking service is provided only
      if (!connectionDocking) {
        return newWaypoints;
      }
      var oldWaypoints = connection.waypoints,
        croppedWaypoints;

      // temporary set new waypoints
      connection.waypoints = newWaypoints;
      croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);

      // restore old waypoints
      connection.waypoints = oldWaypoints;
      return croppedWaypoints;
    }

    // DRAGGING IMPLEMENTATION

    function redrawConnection(data) {
      graphicsFactory.update('connection', data.connection, data.connectionGfx);
    }
    function updateDragger(context, segmentOffset, event) {
      var newWaypoints = context.newWaypoints,
        segmentStartIndex = context.segmentStartIndex + segmentOffset,
        segmentStart = newWaypoints[segmentStartIndex],
        segmentEndIndex = context.segmentEndIndex + segmentOffset,
        segmentEnd = newWaypoints[segmentEndIndex],
        axis = flipAxis(context.axis);

      // make sure the dragger does not move
      // outside the connection
      var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);

      // update dragger
      translate$1(context.draggerGfx, draggerPosition.x, draggerPosition.y);
    }

    /**
     * Filter waypoints for redundant ones (i.e. on the same axis).
     * Returns the filtered waypoints and the offset related to the segment move.
     *
     * @param {Point[]} waypoints
     * @param {Integer} segmentStartIndex of moved segment start
     *
     * @return {Object} { filteredWaypoints, segmentOffset }
     */
    function filterRedundantWaypoints(waypoints, segmentStartIndex) {
      var segmentOffset = 0;
      var filteredWaypoints = waypoints.filter(function (r, idx) {
        if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {
          // remove point and increment offset
          segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
          return false;
        }

        // dont remove point
        return true;
      });
      return {
        waypoints: filteredWaypoints,
        segmentOffset: segmentOffset
      };
    }
    eventBus.on('connectionSegment.move.start', function (event) {
      var context = event.context,
        connection = event.connection,
        layer = canvas.getLayer('overlays');
      context.originalWaypoints = connection.waypoints.slice();

      // add dragger gfx
      context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
      classes(context.draggerGfx).add('djs-dragging');
      canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
    });
    eventBus.on('connectionSegment.move.move', function (event) {
      var context = event.context,
        connection = context.connection,
        segmentStartIndex = context.segmentStartIndex,
        segmentEndIndex = context.segmentEndIndex,
        segmentStart = context.segmentStart,
        segmentEnd = context.segmentEnd,
        axis = context.axis;
      var newWaypoints = context.originalWaypoints.slice(),
        newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),
        newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);

      // original waypoint count and added / removed
      // from start waypoint delta. We use the later
      // to retrieve the updated segmentStartIndex / segmentEndIndex
      var waypointCount = newWaypoints.length,
        segmentOffset = 0;

      // move segment start / end by axis delta
      newWaypoints[segmentStartIndex] = newSegmentStart;
      newWaypoints[segmentEndIndex] = newSegmentEnd;
      var sourceToSegmentOrientation, targetToSegmentOrientation;

      // handle first segment
      if (segmentStartIndex < 2) {
        sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);

        // first bendpoint, remove first segment if intersecting
        if (segmentStartIndex === 1) {
          if (sourceToSegmentOrientation === 'intersect') {
            newWaypoints.shift();
            newWaypoints[0] = newSegmentStart;
            segmentOffset--;
          }
        }

        // docking point, add segment if not intersecting anymore
        else {
          if (sourceToSegmentOrientation !== 'intersect') {
            newWaypoints.unshift(segmentStart);
            segmentOffset++;
          }
        }
      }

      // handle last segment
      if (segmentEndIndex > waypointCount - 3) {
        targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);

        // last bendpoint, remove last segment if intersecting
        if (segmentEndIndex === waypointCount - 2) {
          if (targetToSegmentOrientation === 'intersect') {
            newWaypoints.pop();
            newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
          }
        }

        // last bendpoint, remove last segment if intersecting
        else {
          if (targetToSegmentOrientation !== 'intersect') {
            newWaypoints.push(segmentEnd);
          }
        }
      }

      // update connection waypoints
      context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);

      // update dragger position
      updateDragger(context, segmentOffset, event);

      // save segmentOffset in context
      context.newSegmentStartIndex = segmentStartIndex + segmentOffset;

      // redraw connection
      redrawConnection(event);
    });
    eventBus.on('connectionSegment.move.hover', function (event) {
      event.context.hover = event.hover;
      canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);
    });
    eventBus.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (event) {
      // remove connect marker
      // if it was added
      var hover = event.context.hover;
      if (hover) {
        canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
      }
    });
    eventBus.on('connectionSegment.move.cleanup', function (event) {
      var context = event.context,
        connection = context.connection;

      // remove dragger gfx
      if (context.draggerGfx) {
        remove$3(context.draggerGfx);
      }
      canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
    });
    eventBus.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (event) {
      var context = event.context,
        connection = context.connection;
      connection.waypoints = context.originalWaypoints;
      redrawConnection(event);
    });
    eventBus.on('connectionSegment.move.end', function (event) {
      var context = event.context,
        connection = context.connection,
        newWaypoints = context.newWaypoints,
        newSegmentStartIndex = context.newSegmentStartIndex;

      // ensure we have actual pixel values bendpoint
      // coordinates (important when zoom level was > 1 during move)
      newWaypoints = newWaypoints.map(function (p) {
        return {
          original: p.original,
          x: Math.round(p.x),
          y: Math.round(p.y)
        };
      });

      // apply filter redunant waypoints
      var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);

      // get filtered waypoints
      var filteredWaypoints = filtered.waypoints,
        croppedWaypoints = cropConnection(connection, filteredWaypoints),
        segmentOffset = filtered.segmentOffset;
      var hints = {
        segmentMove: {
          segmentStartIndex: context.segmentStartIndex,
          newSegmentStartIndex: newSegmentStartIndex + segmentOffset
        }
      };
      modeling.updateWaypoints(connection, croppedWaypoints, hints);
    });
  }
  ConnectionSegmentMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'modeling'];

  /**
   * @typedef {import('../../core/Types').ConnectionLike} Connection
   * @typedef {import('../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../core/EventBus').Event} Event
   *
   * @typedef {import('../../util/Types').Axis} Axis
   */

  var abs$1 = Math.abs,
    round$5 = Math.round;

  /**
   * Snap value to a collection of reference values.
   *
   * @param {number} value
   * @param {Array<number>} values
   * @param {number} [tolerance=10]
   *
   * @return {number} the value we snapped to or null, if none snapped
   */
  function snapTo(value, values, tolerance) {
    tolerance = tolerance === undefined ? 10 : tolerance;
    var idx, snapValue;
    for (idx = 0; idx < values.length; idx++) {
      snapValue = values[idx];
      if (abs$1(snapValue - value) <= tolerance) {
        return snapValue;
      }
    }
  }
  function topLeft(bounds) {
    return {
      x: bounds.x,
      y: bounds.y
    };
  }
  function bottomRight(bounds) {
    return {
      x: bounds.x + bounds.width,
      y: bounds.y + bounds.height
    };
  }
  function mid$1(bounds, defaultValue) {
    if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
      return defaultValue;
    }
    return {
      x: round$5(bounds.x + bounds.width / 2),
      y: round$5(bounds.y + bounds.height / 2)
    };
  }

  /**
   * Retrieve the snap state of the given event.
   *
   * @param {Event} event
   * @param {Axis} axis
   *
   * @return {boolean} the snapped state
   *
   */
  function isSnapped(event, axis) {
    var snapped = event.snapped;
    if (!snapped) {
      return false;
    }
    if (typeof axis === 'string') {
      return snapped[axis];
    }
    return snapped.x && snapped.y;
  }

  /**
   * Set the given event as snapped.
   *
   * This method may change the x and/or y position of the shape
   * from the given event!
   *
   * @param {Event} event
   * @param {Axis} axis
   * @param {number|boolean} value
   *
   * @return {number} old value
   */
  function setSnapped(event, axis, value) {
    if (typeof axis !== 'string') {
      throw new Error('axis must be in [x, y]');
    }
    if (typeof value !== 'number' && value !== false) {
      throw new Error('value must be Number or false');
    }
    var delta,
      previousValue = event[axis];
    var snapped = event.snapped = event.snapped || {};
    if (value === false) {
      snapped[axis] = false;
    } else {
      snapped[axis] = true;
      delta = value - previousValue;
      event[axis] += delta;
      event['d' + axis] += delta;
    }
    return previousValue;
  }

  /**
   * Get children of a shape.
   *
   * @param {Shape} parent
   *
   * @return {Array<Shape|Connection>}
   */
  function getChildren(parent) {
    return parent.children || [];
  }

  /**
   * @typedef {import('../../core/EventBus').default} EventBus
   */
  var abs = Math.abs,
    round$4 = Math.round;
  var TOLERANCE = 10;

  /**
   * @param {EventBus} eventBus
   */
  function BendpointSnapping(eventBus) {
    function snapTo(values, value) {
      if (isArray$6(values)) {
        var i = values.length;
        while (i--) if (abs(values[i] - value) <= TOLERANCE) {
          return values[i];
        }
      } else {
        values = +values;
        var rem = value % values;
        if (rem < TOLERANCE) {
          return value - rem;
        }
        if (rem > values - TOLERANCE) {
          return value - rem + values;
        }
      }
      return value;
    }
    function getSnapPoint(element, event) {
      if (element.waypoints) {
        return getClosestPointOnConnection(event, element);
      }
      if (element.width) {
        return {
          x: round$4(element.width / 2 + element.x),
          y: round$4(element.height / 2 + element.y)
        };
      }
    }

    // connection segment snapping //////////////////////

    function getConnectionSegmentSnaps(event) {
      var context = event.context,
        snapPoints = context.snapPoints,
        connection = context.connection,
        waypoints = connection.waypoints,
        segmentStart = context.segmentStart,
        segmentStartIndex = context.segmentStartIndex,
        segmentEnd = context.segmentEnd,
        segmentEndIndex = context.segmentEndIndex,
        axis = context.axis;
      if (snapPoints) {
        return snapPoints;
      }
      var referenceWaypoints = [waypoints[segmentStartIndex - 1], segmentStart, segmentEnd, waypoints[segmentEndIndex + 1]];
      if (segmentStartIndex < 2) {
        referenceWaypoints.unshift(getSnapPoint(connection.source, event));
      }
      if (segmentEndIndex > waypoints.length - 3) {
        referenceWaypoints.unshift(getSnapPoint(connection.target, event));
      }
      context.snapPoints = snapPoints = {
        horizontal: [],
        vertical: []
      };
      forEach$3(referenceWaypoints, function (p) {
        // we snap on existing bendpoints only,
        // not placeholders that are inserted during add
        if (p) {
          p = p.original || p;
          if (axis === 'y') {
            snapPoints.horizontal.push(p.y);
          }
          if (axis === 'x') {
            snapPoints.vertical.push(p.x);
          }
        }
      });
      return snapPoints;
    }
    eventBus.on('connectionSegment.move.move', 1500, function (event) {
      var snapPoints = getConnectionSegmentSnaps(event),
        x = event.x,
        y = event.y,
        sx,
        sy;
      if (!snapPoints) {
        return;
      }

      // snap
      sx = snapTo(snapPoints.vertical, x);
      sy = snapTo(snapPoints.horizontal, y);

      // correction x/y
      var cx = x - sx,
        cy = y - sy;

      // update delta
      assign$4(event, {
        dx: event.dx - cx,
        dy: event.dy - cy,
        x: sx,
        y: sy
      });

      // only set snapped if actually snapped
      if (cx || snapPoints.vertical.indexOf(x) !== -1) {
        setSnapped(event, 'x', sx);
      }
      if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
        setSnapped(event, 'y', sy);
      }
    });

    // bendpoint snapping //////////////////////

    function getBendpointSnaps(context) {
      var snapPoints = context.snapPoints,
        waypoints = context.connection.waypoints,
        bendpointIndex = context.bendpointIndex;
      if (snapPoints) {
        return snapPoints;
      }
      var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];
      context.snapPoints = snapPoints = {
        horizontal: [],
        vertical: []
      };
      forEach$3(referenceWaypoints, function (p) {
        // we snap on existing bendpoints only,
        // not placeholders that are inserted during add
        if (p) {
          p = p.original || p;
          snapPoints.horizontal.push(p.y);
          snapPoints.vertical.push(p.x);
        }
      });
      return snapPoints;
    }

    // Snap Endpoint of new connection
    eventBus.on(['connect.hover', 'connect.move', 'connect.end'], 1500, function (event) {
      var context = event.context,
        hover = context.hover,
        hoverMid = hover && getSnapPoint(hover, event);

      // only snap on connections, elements can have multiple connect endpoints
      if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {
        return;
      }
      setSnapped(event, 'x', hoverMid.x);
      setSnapped(event, 'y', hoverMid.y);
    });
    eventBus.on(['bendpoint.move.move', 'bendpoint.move.end'], 1500, function (event) {
      var context = event.context,
        snapPoints = getBendpointSnaps(context),
        hover = context.hover,
        hoverMid = hover && getSnapPoint(hover, event),
        x = event.x,
        y = event.y,
        sx,
        sy;
      if (!snapPoints) {
        return;
      }

      // snap to hover mid
      sx = snapTo(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x);
      sy = snapTo(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y);

      // correction x/y
      var cx = x - sx,
        cy = y - sy;

      // update delta
      assign$4(event, {
        dx: event.dx - cx,
        dy: event.dy - cy,
        x: event.x - cx,
        y: event.y - cy
      });

      // only set snapped if actually snapped
      if (cx || snapPoints.vertical.indexOf(x) !== -1) {
        setSnapped(event, 'x', sx);
      }
      if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
        setSnapped(event, 'y', sy);
      }
    });
  }
  BendpointSnapping.$inject = ['eventBus'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var BendpointsModule = {
    __depends__: [DraggingModule, Rules$5],
    __init__: ['bendpoints', 'bendpointSnapping', 'bendpointMovePreview'],
    bendpoints: ['type', Bendpoints],
    bendpointMove: ['type', BendpointMove],
    bendpointMovePreview: ['type', BendpointMovePreview],
    connectionSegmentMove: ['type', ConnectionSegmentMove],
    bendpointSnapping: ['type', BendpointSnapping]
  };

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../util/Types').Rect} Rect
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../overlays/Overlays').default} Overlays
   *
   * @typedef {import('../overlays/Overlays').Overlay} Overlay
   *
   * @typedef {import('./ContextPadProvider').default} ContextPadProvider
   * @typedef {import('./ContextPadProvider').ContextPadEntries} ContextPadEntries
   *
   * @typedef { {
   *   scale?: {
   *     min?: number;
   *     max?: number;
   *   };
   * } } ContextPadConfig
   */

  /**
   * @template {Element} [ElementType=Element]
   *
   * @typedef {ElementType|ElementType[]} ContextPadTarget
   */

  var entrySelector = '.entry';
  var DEFAULT_PRIORITY$6 = 1000;
  var CONTEXT_PAD_PADDING = 12;
  var HOVER_DELAY = 300;

  /**
   * A context pad that displays element specific, contextual actions next
   * to a diagram element.
   *
   * @param {Canvas} canvas
   * @param {ContextPadConfig} config
   * @param {EventBus} eventBus
   * @param {Overlays} overlays
   */
  function ContextPad(canvas, config, eventBus, overlays) {
    this._canvas = canvas;
    this._eventBus = eventBus;
    this._overlays = overlays;
    var scale = isDefined(config && config.scale) ? config.scale : {
      min: 1,
      max: 1.5
    };
    this._overlaysConfig = {
      scale: scale
    };
    this._current = null;
    this._init();
  }
  ContextPad.$inject = ['canvas', 'config.contextPad', 'eventBus', 'overlays'];

  /**
   * Registers events needed for interaction with other components.
   */
  ContextPad.prototype._init = function () {
    var self = this;
    this._eventBus.on('selection.changed', function (event) {
      var selection = event.newSelection;
      var target = selection.length ? selection.length === 1 ? selection[0] : selection : null;
      if (target) {
        self.open(target, true);
      } else {
        self.close();
      }
    });
    this._eventBus.on('elements.changed', function (event) {
      var elements = event.elements,
        current = self._current;
      if (!current) {
        return;
      }
      var currentTarget = current.target;
      var currentChanged = some(isArray$6(currentTarget) ? currentTarget : [currentTarget], function (element) {
        return includes$3(elements, element);
      });

      // re-open if elements in current selection changed
      if (currentChanged) {
        self.open(currentTarget, true);
      }
    });
  };

  /**
   * @overlord
   *
   * Register a context pad provider with the default priority. See
   * {@link ContextPadProvider} for examples.
   *
   * @param {ContextPadProvider} provider
   */

  /**
   * Register a context pad provider with the given priority. See
   * {@link ContextPadProvider} for examples.
   *
   * @param {number} priority
   * @param {ContextPadProvider} provider
   */
  ContextPad.prototype.registerProvider = function (priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY$6;
    }
    this._eventBus.on('contextPad.getProviders', priority, function (event) {
      event.providers.push(provider);
    });
  };

  /**
   * Get context pad entries for given elements.
   *
   * @param {ContextPadTarget} target
   *
   * @return {ContextPadEntries} list of entries
   */
  ContextPad.prototype.getEntries = function (target) {
    var providers = this._getProviders();
    var provideFn = isArray$6(target) ? 'getMultiElementContextPadEntries' : 'getContextPadEntries';
    var entries = {};

    // loop through all providers and their entries.
    // group entries by id so that overriding an entry is possible
    forEach$3(providers, function (provider) {
      if (!isFunction$2(provider[provideFn])) {
        return;
      }
      var entriesOrUpdater = provider[provideFn](target);
      if (isFunction$2(entriesOrUpdater)) {
        entries = entriesOrUpdater(entries);
      } else {
        forEach$3(entriesOrUpdater, function (entry, id) {
          entries[id] = entry;
        });
      }
    });
    return entries;
  };

  /**
   * Trigger context pad via DOM event.
   *
   * The entry to trigger is determined by the target element.
   *
   * @param {string} action
   * @param {Event} event
   * @param {boolean} [autoActivate=false]
   */
  ContextPad.prototype.trigger = function (action, event, autoActivate) {
    var _this = this;
    var entry,
      originalEvent,
      button = event.delegateTarget || event.target;
    if (!button) {
      return event.preventDefault();
    }
    entry = attr$1(button, 'data-action');
    originalEvent = event.originalEvent || event;
    if (action === 'mouseover') {
      this._timeout = setTimeout(function () {
        _this._mouseout = _this.triggerEntry(entry, 'hover', originalEvent, autoActivate);
      }, HOVER_DELAY);
    } else if (action === 'mouseout') {
      clearTimeout(this._timeout);
      if (this._mouseout) {
        this._mouseout();
        this._mouseout = null;
      }
    }
    return this.triggerEntry(entry, action, originalEvent, autoActivate);
  };

  /**
   * Trigger action on context pad entry entry, e.g. click, mouseover or mouseout.
   *
   * @param {string} entryId
   * @param {string} action
   * @param {Event} event
   * @param {boolean} [autoActivate=false]
   */
  ContextPad.prototype.triggerEntry = function (entryId, action, event, autoActivate) {
    if (!this.isShown()) {
      return;
    }
    var target = this._current.target,
      entries = this._current.entries;
    var entry = entries[entryId];
    if (!entry) {
      return;
    }
    var handler = entry.action;
    if (this._eventBus.fire('contextPad.trigger', {
      entry: entry,
      event: event
    }) === false) {
      return;
    }

    // simple action (via callback function)
    if (isFunction$2(handler)) {
      if (action === 'click') {
        return handler(event, target, autoActivate);
      }
    } else {
      if (handler[action]) {
        return handler[action](event, target, autoActivate);
      }
    }

    // silence other actions
    event.preventDefault();
  };

  /**
   * Open the context pad for given elements.
   *
   * @param {ContextPadTarget} target
   * @param {boolean} [force=false] - Force re-opening context pad.
   */
  ContextPad.prototype.open = function (target, force) {
    if (!force && this.isOpen(target)) {
      return;
    }
    this.close();
    this._updateAndOpen(target);
  };
  ContextPad.prototype._getProviders = function () {
    var event = this._eventBus.createEvent({
      type: 'contextPad.getProviders',
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };

  /**
   * @param {ContextPadTarget} target
   */
  ContextPad.prototype._updateAndOpen = function (target) {
    var entries = this.getEntries(target),
      pad = this.getPad(target),
      html = pad.html,
      image;
    forEach$3(entries, function (entry, id) {
      var grouping = entry.group || 'default',
        control = domify$1(entry.html || '<div class="entry" draggable="true"></div>'),
        container;
      attr$1(control, 'data-action', id);
      container = query('[data-group=' + escapeCSS(grouping) + ']', html);
      if (!container) {
        container = domify$1('<div class="group"></div>');
        attr$1(container, 'data-group', grouping);
        html.appendChild(container);
      }
      container.appendChild(control);
      if (entry.className) {
        addClasses$1(control, entry.className);
      }
      if (entry.title) {
        attr$1(control, 'title', entry.title);
      }
      if (entry.imageUrl) {
        image = domify$1('<img>');
        attr$1(image, 'src', entry.imageUrl);
        image.style.width = '100%';
        image.style.height = '100%';
        control.appendChild(image);
      }
    });
    classes$1(html).add('open');
    this._current = {
      target: target,
      entries: entries,
      pad: pad
    };
    this._eventBus.fire('contextPad.open', {
      current: this._current
    });
  };

  /**
   * @param {ContextPadTarget} target
   *
   * @return {Overlay}
   */
  ContextPad.prototype.getPad = function (target) {
    if (this.isOpen()) {
      return this._current.pad;
    }
    var self = this;
    var overlays = this._overlays;
    var html = domify$1('<div class="djs-context-pad"></div>');
    var position = this._getPosition(target);
    var overlaysConfig = assign$4({
      html: html
    }, this._overlaysConfig, position);
    delegate.bind(html, entrySelector, 'click', function (event) {
      self.trigger('click', event);
    });
    delegate.bind(html, entrySelector, 'dragstart', function (event) {
      self.trigger('dragstart', event);
    });
    delegate.bind(html, entrySelector, 'mouseover', function (event) {
      self.trigger('mouseover', event);
    });
    delegate.bind(html, entrySelector, 'mouseout', function (event) {
      self.trigger('mouseout', event);
    });

    // stop propagation of mouse events
    event.bind(html, 'mousedown', function (event) {
      event.stopPropagation();
    });
    var activeRootElement = this._canvas.getRootElement();
    this._overlayId = overlays.add(activeRootElement, 'context-pad', overlaysConfig);
    var pad = overlays.get(this._overlayId);
    this._eventBus.fire('contextPad.create', {
      target: target,
      pad: pad
    });
    return pad;
  };

  /**
   * Close the context pad
   */
  ContextPad.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }
    clearTimeout(this._timeout);
    this._overlays.remove(this._overlayId);
    this._overlayId = null;
    this._eventBus.fire('contextPad.close', {
      current: this._current
    });
    this._current = null;
  };

  /**
   * Check if pad is open.
   *
   * If target is provided, check if it is opened
   * for the given target (single or multiple elements).
   *
   * @param {ContextPadTarget} [target]
   * @return {boolean}
   */
  ContextPad.prototype.isOpen = function (target) {
    var current = this._current;
    if (!current) {
      return false;
    }

    // basic no-args is open check
    if (!target) {
      return true;
    }
    var currentTarget = current.target;

    // strict handling of single vs. multi-selection
    if (isArray$6(target) !== isArray$6(currentTarget)) {
      return false;
    }
    if (isArray$6(target)) {
      return target.length === currentTarget.length && every(target, function (element) {
        return includes$3(currentTarget, element);
      });
    } else {
      return currentTarget === target;
    }
  };

  /**
   * Check if pad is open and not hidden.
   *
   * @return {boolean}
   */
  ContextPad.prototype.isShown = function () {
    return this.isOpen() && this._overlays.isShown();
  };

  /**
   * Get contex pad position.
   *
   * If target is a connection, the context pad will be placed according to the
   * connection's last waypoint.
   *
   * If multiple targets, the context pad will be placed according to the bounding
   * box containing all targets.
   *
   * @param {ContextPadTarget} target
   *
   * @return {Rect}
   */
  ContextPad.prototype._getPosition = function (target) {
    target = isConnection(target) ? getLastWaypoint(target) : target;
    var elements = isArray$6(target) ? target : [target];
    var bBox = getBBox(elements);
    return {
      position: {
        left: bBox.x + bBox.width + CONTEXT_PAD_PADDING,
        top: bBox.y - CONTEXT_PAD_PADDING / 2
      }
    };
  };

  // helpers //////////

  function addClasses$1(element, classNames) {
    var classes = classes$1(element);
    classNames = isArray$6(classNames) ? classNames : classNames.split(/\s+/g);
    classNames.forEach(function (cls) {
      classes.add(cls);
    });
  }

  /**
   * @param {any[]} array
   * @param {any} item
   *
   * @return {boolean}
   */
  function includes$3(array, item) {
    return array.indexOf(item) !== -1;
  }
  function getLastWaypoint(connection) {
    return connection.waypoints[connection.waypoints.length - 1];
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramContextPad = {
    __depends__: [InteractionEventsModule, OverlaysModule],
    contextPad: ['type', ContextPad]
  };

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   */

  /**
   * @param {EventBus} eventBus
   * @param {Dragging} dragging
   * @param {Modeling} modeling
   * @param {Rules} rules
   */
  function Connect(eventBus, dragging, modeling, rules) {
    // rules

    function canConnect(source, target) {
      return rules.allowed('connection.create', {
        source: source,
        target: target
      });
    }
    function canConnectReverse(source, target) {
      return canConnect(target, source);
    }

    // event handlers

    eventBus.on('connect.hover', function (event) {
      var context = event.context,
        start = context.start,
        hover = event.hover,
        canExecute;

      // cache hover state
      context.hover = hover;
      canExecute = context.canExecute = canConnect(start, hover);

      // ignore hover
      if (isNil(canExecute)) {
        return;
      }
      if (canExecute !== false) {
        context.source = start;
        context.target = hover;
        return;
      }
      canExecute = context.canExecute = canConnectReverse(start, hover);

      // ignore hover
      if (isNil(canExecute)) {
        return;
      }
      if (canExecute !== false) {
        context.source = hover;
        context.target = start;
      }
    });
    eventBus.on(['connect.out', 'connect.cleanup'], function (event) {
      var context = event.context;
      context.hover = null;
      context.source = null;
      context.target = null;
      context.canExecute = false;
    });
    eventBus.on('connect.end', function (event) {
      var context = event.context,
        canExecute = context.canExecute,
        connectionStart = context.connectionStart,
        connectionEnd = {
          x: event.x,
          y: event.y
        },
        source = context.source,
        target = context.target;
      if (!canExecute) {
        return false;
      }
      var attrs = null,
        hints = {
          connectionStart: isReverse(context) ? connectionEnd : connectionStart,
          connectionEnd: isReverse(context) ? connectionStart : connectionEnd
        };
      if (isObject$2(canExecute)) {
        attrs = canExecute;
      }
      context.connection = modeling.connect(source, target, attrs, hints);
    });

    // API

    /**
     * Start connect operation.
     *
     * @param {MouseEvent|TouchEvent} event
     * @param {Element} start
     * @param {Point} [connectionStart]
     * @param {boolean} [autoActivate=false]
     */
    this.start = function (event, start, connectionStart, autoActivate) {
      if (!isObject$2(connectionStart)) {
        autoActivate = connectionStart;
        connectionStart = getMid(start);
      }
      dragging.init(event, 'connect', {
        autoActivate: autoActivate,
        data: {
          shape: start,
          context: {
            start: start,
            connectionStart: connectionStart
          }
        }
      });
    };
  }
  Connect.$inject = ['eventBus', 'dragging', 'modeling', 'rules'];

  // helpers //////////

  function isReverse(context) {
    var hover = context.hover,
      source = context.source,
      target = context.target;
    return hover && source && hover === source && source !== target;
  }

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  var HIGH_PRIORITY$9 = 1100,
    LOW_PRIORITY$i = 900;
  var MARKER_OK$2 = 'connect-ok',
    MARKER_NOT_OK$2 = 'connect-not-ok';

  /**
   * Shows connection preview during connect.
   *
   * @param {Injector} injector
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function ConnectPreview(injector, eventBus, canvas) {
    var connectionPreview = injector.get('connectionPreview', false);
    connectionPreview && eventBus.on('connect.move', function (event) {
      var context = event.context,
        canConnect = context.canExecute,
        hover = context.hover,
        source = context.source,
        start = context.start,
        startPosition = context.startPosition,
        target = context.target,
        connectionStart = context.connectionStart || startPosition,
        connectionEnd = context.connectionEnd || {
          x: event.x,
          y: event.y
        },
        previewStart = connectionStart,
        previewEnd = connectionEnd;
      if (isReverse(context)) {
        previewStart = connectionEnd;
        previewEnd = connectionStart;
      }
      connectionPreview.drawPreview(context, canConnect, {
        source: source || start,
        target: target || hover,
        connectionStart: previewStart,
        connectionEnd: previewEnd
      });
    });
    eventBus.on('connect.hover', LOW_PRIORITY$i, function (event) {
      var context = event.context,
        hover = event.hover,
        canExecute = context.canExecute;

      // ignore hover
      if (canExecute === null) {
        return;
      }
      canvas.addMarker(hover, canExecute ? MARKER_OK$2 : MARKER_NOT_OK$2);
    });
    eventBus.on(['connect.out', 'connect.cleanup'], HIGH_PRIORITY$9, function (event) {
      var hover = event.hover;
      if (hover) {
        canvas.removeMarker(hover, MARKER_OK$2);
        canvas.removeMarker(hover, MARKER_NOT_OK$2);
      }
    });
    connectionPreview && eventBus.on('connect.cleanup', function (event) {
      connectionPreview.cleanUp(event.context);
    });
  }
  ConnectPreview.$inject = ['injector', 'eventBus', 'canvas'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramConnect = {
    __depends__: [SelectionModule, Rules$5, DraggingModule],
    __init__: ['connectPreview'],
    connect: ['type', Connect],
    connectPreview: ['type', ConnectPreview]
  };

  /**
   * @typedef {import('../../core/Types').ElementLike} Element
   * @typedef {import('../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../../draw/Styles').default} Styles
   */

  var MARKER_TYPES = ['marker-start', 'marker-mid', 'marker-end'];
  var NODES_CAN_HAVE_MARKER = ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'path', 'rect'];

  /**
   * Adds support for previews of moving/resizing elements.
   *
   * @param {ElementRegistry} elementRegistry
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Styles} styles
   */
  function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
    this._elementRegistry = elementRegistry;
    this._canvas = canvas;
    this._styles = styles;
    this._clonedMarkers = {};
    var self = this;
    eventBus.on('drag.cleanup', function () {
      self.cleanUp();
    });
  }
  PreviewSupport.$inject = ['elementRegistry', 'eventBus', 'canvas', 'styles'];
  PreviewSupport.prototype.cleanUp = function () {
    var self = this;
    forEach$3(self._clonedMarkers, function (clonedMarker) {
      remove$3(clonedMarker);
    });
    self._clonedMarkers = {};
  };

  /**
   * Returns graphics of an element.
   *
   * @param {Element} element
   *
   * @return {SVGElement}
   */
  PreviewSupport.prototype.getGfx = function (element) {
    return this._elementRegistry.getGraphics(element);
  };

  /**
   * Adds a move preview of a given shape to a given SVG group.
   *
   * @param {Element} element The element to be moved.
   * @param {SVGElement} group The SVG group to add the preview to.
   * @param {SVGElement} [gfx] The optional graphical element of the element.
   * @param {string} [className="djs-dragger"] The optional class name to add to the preview.
   *
   * @return {SVGElement} The preview.
   */
  PreviewSupport.prototype.addDragger = function (element, group, gfx) {
    var className = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'djs-dragger';
    gfx = gfx || this.getGfx(element);
    var dragger = clone$1(gfx);
    var bbox = gfx.getBoundingClientRect();
    this._cloneMarkers(getVisual(dragger), className);
    attr(dragger, this._styles.cls(className, [], {
      x: bbox.top,
      y: bbox.left
    }));
    append(group, dragger);
    attr(dragger, 'data-preview-support-element-id', element.id);
    return dragger;
  };

  /**
   * Adds a resize preview of a given shape to a given SVG group.
   *
   * @param {Shape} shape The element to be resized.
   * @param {SVGElement} group The SVG group to add the preview to.
   *
   * @return {SVGElement} The preview.
   */
  PreviewSupport.prototype.addFrame = function (shape, group) {
    var frame = create$2('rect', {
      "class": 'djs-resize-overlay',
      width: shape.width,
      height: shape.height,
      x: shape.x,
      y: shape.y
    });
    append(group, frame);
    attr(frame, 'data-preview-support-element-id', shape.id);
    return frame;
  };

  /**
   * Clone all markers referenced by a node and its child nodes.
   *
   * @param {SVGElement} gfx
   * @param {string} [className="djs-dragger"]
   */
  PreviewSupport.prototype._cloneMarkers = function (gfx) {
    var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'djs-dragger';
    var self = this;
    if (gfx.childNodes) {
      // TODO: use forEach once we drop PhantomJS
      for (var i = 0; i < gfx.childNodes.length; i++) {
        // recursively clone markers of child nodes
        self._cloneMarkers(gfx.childNodes[i], className);
      }
    }
    if (!canHaveMarker(gfx)) {
      return;
    }
    MARKER_TYPES.forEach(function (markerType) {
      if (attr(gfx, markerType)) {
        var marker = getMarker(gfx, markerType, self._canvas.getContainer());
        self._cloneMarker(gfx, marker, markerType, className);
      }
    });
  };

  /**
   * Clone marker referenced by an element.
   *
   * @param {SVGElement} gfx
   * @param {SVGElement} marker
   * @param {string} markerType
   * @param {string} [className="djs-dragger"]
   */
  PreviewSupport.prototype._cloneMarker = function (gfx, marker, markerType) {
    var className = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'djs-dragger';
    var markerId = marker.id + '-' + className;
    var clonedMarker = this._clonedMarkers[markerId];
    if (!clonedMarker) {
      clonedMarker = clone$1(marker);
      var clonedMarkerId = markerId + '-clone';
      clonedMarker.id = clonedMarkerId;
      classes(clonedMarker).add(className);
      this._clonedMarkers[markerId] = clonedMarker;
      var defs = query('defs', this._canvas._svg);
      if (!defs) {
        defs = create$2('defs');
        append(this._canvas._svg, defs);
      }
      append(defs, clonedMarker);
    }
    var reference = idToReference(this._clonedMarkers[markerId].id);
    attr(gfx, markerType, reference);
  };

  // helpers //////////

  /**
   * Get marker of given type referenced by node.
   *
   * @param {HTMLElement} node
   * @param {string} markerType
   * @param {HTMLElement} [parentNode]
   *
   * @param {HTMLElement}
   */
  function getMarker(node, markerType, parentNode) {
    var id = referenceToId(attr(node, markerType));
    return query('marker#' + id, parentNode || document);
  }

  /**
   * Get ID of fragment within current document from its functional IRI reference.
   * References may use single or double quotes.
   *
   * @param {string} reference
   *
   * @return {string}
   */
  function referenceToId(reference) {
    return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
  }

  /**
   * Get functional IRI reference for given ID of fragment within current document.
   *
   * @param {string} id
   *
   * @return {string}
   */
  function idToReference(id) {
    return 'url(#' + id + ')';
  }

  /**
   * Check wether node type can have marker attributes.
   *
   * @param {HTMLElement} node
   *
   * @return {boolean}
   */
  function canHaveMarker(node) {
    return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var PreviewSupportModule = {
    __init__: ['previewSupport'],
    previewSupport: ['type', PreviewSupport]
  };

  var MARKER_OK$1 = 'drop-ok',
    MARKER_NOT_OK$1 = 'drop-not-ok',
    MARKER_ATTACH$1 = 'attach-ok',
    MARKER_NEW_PARENT$1 = 'new-parent';

  /**
   * @typedef {import('../../core/Types').ElementLike} Element
   * @typedef {import('../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   */

  var PREFIX = 'create';
  var HIGH_PRIORITY$8 = 2000;

  /**
   * Create new elements through drag and drop.
   *
   * @param {Canvas} canvas
   * @param {Dragging} dragging
   * @param {EventBus} eventBus
   * @param {Modeling} modeling
   * @param {Rules} rules
   */
  function Create(canvas, dragging, eventBus, modeling, rules) {
    // rules //////////

    /**
     * Check wether elements can be created.
     *
     * @param {Element[]} elements
     * @param {Shape} target
     * @param {Point} position
     * @param {Element} [source]
     *
     * @return {boolean|null|Object}
     */
    function canCreate(elements, target, position, source, hints) {
      if (!target) {
        return false;
      }

      // ignore child elements and external labels
      elements = filter$2(elements, function (element) {
        var labelTarget = element.labelTarget;
        return !element.parent && !(isLabel$1(element) && elements.indexOf(labelTarget) !== -1);
      });
      var shape = find$2(elements, function (element) {
        return !isConnection(element);
      });
      var attach = false,
        connect = false,
        create = false;

      // (1) attaching single shapes
      if (isSingleShape(elements)) {
        attach = rules.allowed('shape.attach', {
          position: position,
          shape: shape,
          target: target
        });
      }
      if (!attach) {
        // (2) creating elements
        if (isSingleShape(elements)) {
          create = rules.allowed('shape.create', {
            position: position,
            shape: shape,
            source: source,
            target: target
          });
        } else {
          create = rules.allowed('elements.create', {
            elements: elements,
            position: position,
            target: target
          });
        }
      }
      var connectionTarget = hints.connectionTarget;

      // (3) appending single shapes
      if (create || attach) {
        if (shape && source) {
          connect = rules.allowed('connection.create', {
            source: connectionTarget === source ? shape : source,
            target: connectionTarget === source ? source : shape,
            hints: {
              targetParent: target,
              targetAttach: attach
            }
          });
        }
        return {
          attach: attach,
          connect: connect
        };
      }

      // ignore wether or not elements can be created
      if (create === null || attach === null) {
        return null;
      }
      return false;
    }
    function setMarker(element, marker) {
      [MARKER_ATTACH$1, MARKER_OK$1, MARKER_NOT_OK$1, MARKER_NEW_PARENT$1].forEach(function (m) {
        if (m === marker) {
          canvas.addMarker(element, m);
        } else {
          canvas.removeMarker(element, m);
        }
      });
    }

    // event handling //////////

    eventBus.on(['create.move', 'create.hover'], function (event) {
      var context = event.context,
        elements = context.elements,
        hover = event.hover,
        source = context.source,
        hints = context.hints || {};
      if (!hover) {
        context.canExecute = false;
        context.target = null;
        return;
      }
      ensureConstraints$1(event);
      var position = {
        x: event.x,
        y: event.y
      };
      var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);
      if (hover && canExecute !== null) {
        context.target = hover;
        if (canExecute && canExecute.attach) {
          setMarker(hover, MARKER_ATTACH$1);
        } else {
          setMarker(hover, canExecute ? MARKER_NEW_PARENT$1 : MARKER_NOT_OK$1);
        }
      }
    });
    eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {
      var hover = event.hover;
      if (hover) {
        setMarker(hover, null);
      }
    });
    eventBus.on('create.end', function (event) {
      var context = event.context,
        source = context.source,
        shape = context.shape,
        elements = context.elements,
        target = context.target,
        canExecute = context.canExecute,
        attach = canExecute && canExecute.attach,
        connect = canExecute && canExecute.connect,
        hints = context.hints || {};
      if (canExecute === false || !target) {
        return false;
      }
      ensureConstraints$1(event);
      var position = {
        x: event.x,
        y: event.y
      };
      if (connect) {
        shape = modeling.appendShape(source, shape, position, target, {
          attach: attach,
          connection: connect === true ? {} : connect,
          connectionTarget: hints.connectionTarget
        });
      } else {
        elements = modeling.createElements(elements, position, target, assign$4({}, hints, {
          attach: attach
        }));

        // update shape
        shape = find$2(elements, function (element) {
          return !isConnection(element);
        });
      }

      // update elements and shape
      assign$4(context, {
        elements: elements,
        shape: shape
      });
      assign$4(event, {
        elements: elements,
        shape: shape
      });
    });
    function cancel() {
      var context = dragging.context();
      if (context && context.prefix === PREFIX) {
        dragging.cancel();
      }
    }

    // cancel on <elements.changed> that is not result of <drag.end>
    eventBus.on('create.init', function () {
      eventBus.on('elements.changed', cancel);
      eventBus.once(['create.cancel', 'create.end'], HIGH_PRIORITY$8, function () {
        eventBus.off('elements.changed', cancel);
      });
    });

    // API //////////

    this.start = function (event, elements, context) {
      if (!isArray$6(elements)) {
        elements = [elements];
      }
      var shape = find$2(elements, function (element) {
        return !isConnection(element);
      });
      if (!shape) {
        // at least one shape is required
        return;
      }
      context = assign$4({
        elements: elements,
        hints: {},
        shape: shape
      }, context || {});

      // make sure each element has x and y
      forEach$3(elements, function (element) {
        if (!isNumber$3(element.x)) {
          element.x = 0;
        }
        if (!isNumber$3(element.y)) {
          element.y = 0;
        }
      });
      var visibleElements = filter$2(elements, function (element) {
        return !element.hidden;
      });
      var bbox = getBBox(visibleElements);

      // center elements around cursor
      forEach$3(elements, function (element) {
        if (isConnection(element)) {
          element.waypoints = map$2(element.waypoints, function (waypoint) {
            return {
              x: waypoint.x - bbox.x - bbox.width / 2,
              y: waypoint.y - bbox.y - bbox.height / 2
            };
          });
        }
        assign$4(element, {
          x: element.x - bbox.x - bbox.width / 2,
          y: element.y - bbox.y - bbox.height / 2
        });
      });
      dragging.init(event, PREFIX, {
        cursor: 'grabbing',
        autoActivate: true,
        data: {
          shape: shape,
          elements: elements,
          context: context
        }
      });
    };
  }
  Create.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules'];

  // helpers //////////

  function ensureConstraints$1(event) {
    var context = event.context,
      createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    if (createConstraints.left) {
      event.x = Math.max(event.x, createConstraints.left);
    }
    if (createConstraints.right) {
      event.x = Math.min(event.x, createConstraints.right);
    }
    if (createConstraints.top) {
      event.y = Math.max(event.y, createConstraints.top);
    }
    if (createConstraints.bottom) {
      event.y = Math.min(event.y, createConstraints.bottom);
    }
  }
  function isSingleShape(elements) {
    return elements && elements.length === 1 && !isConnection(elements[0]);
  }

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory
   * @typedef {import('../preview-support/PreviewSupport').default} PreviewSupport
   * @typedef {import('../../draw/Styles').default} Styles
   */

  var LOW_PRIORITY$h = 750;

  /**
   * @param {Canvas} canvas
   * @param {EventBus} eventBus
   * @param {GraphicsFactory} graphicsFactory
   * @param {PreviewSupport} previewSupport
   * @param {Styles} styles
   */
  function CreatePreview(canvas, eventBus, graphicsFactory, previewSupport, styles) {
    function createDragGroup(elements) {
      var dragGroup = create$2('g');
      attr(dragGroup, styles.cls('djs-drag-group', ['no-events']));
      var childrenGfx = create$2('g');
      elements.forEach(function (element) {
        // create graphics
        var gfx;
        if (element.hidden) {
          return;
        }
        if (element.waypoints) {
          gfx = graphicsFactory._createContainer('connection', childrenGfx);
          graphicsFactory.drawConnection(getVisual(gfx), element);
        } else {
          gfx = graphicsFactory._createContainer('shape', childrenGfx);
          graphicsFactory.drawShape(getVisual(gfx), element);
          translate$1(gfx, element.x, element.y);
        }

        // add preview
        previewSupport.addDragger(element, dragGroup, gfx);
      });
      return dragGroup;
    }
    eventBus.on('create.move', LOW_PRIORITY$h, function (event) {
      var hover = event.hover,
        context = event.context,
        elements = context.elements,
        dragGroup = context.dragGroup;

      // lazily create previews
      if (!dragGroup) {
        dragGroup = context.dragGroup = createDragGroup(elements);
      }
      var activeLayer;
      if (hover) {
        if (!dragGroup.parentNode) {
          activeLayer = canvas.getActiveLayer();
          append(activeLayer, dragGroup);
        }
        translate$1(dragGroup, event.x, event.y);
      } else {
        remove$3(dragGroup);
      }
    });
    eventBus.on('create.cleanup', function (event) {
      var context = event.context,
        dragGroup = context.dragGroup;
      if (dragGroup) {
        remove$3(dragGroup);
      }
    });
  }
  CreatePreview.$inject = ['canvas', 'eventBus', 'graphicsFactory', 'previewSupport', 'styles'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramCreate = {
    __depends__: [DraggingModule, PreviewSupportModule, Rules$5, SelectionModule],
    __init__: ['create', 'createPreview'],
    create: ['type', Create],
    createPreview: ['type', CreatePreview]
  };

  var n$1,
    l$2,
    u$1,
    t$3,
    r$3,
    o$1,
    f$1,
    c$1 = {},
    s$1 = [],
    a$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function h$1(n, l) {
    for (var u in l) n[u] = l[u];
    return n;
  }
  function v$1(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function y$1(l, u, i) {
    var t,
      r,
      o,
      f = {};
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n$1.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === f[o] && (f[o] = l.defaultProps[o]);
    return p$2(l, f, t, r, null);
  }
  function p$2(n, i, t, r, o) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: r,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++u$1 : o
    };
    return null == o && null != l$2.vnode && l$2.vnode(f), f;
  }
  function _$1(n) {
    return n.children;
  }
  function k$1(n, l) {
    this.props = n, this.context = l;
  }
  function b$1(n, l) {
    if (null == l) return n.__ ? b$1(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? b$1(n) : null;
  }
  function g$1(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
      return g$1(n);
    }
  }
  function m$2(n) {
    (!n.__d && (n.__d = !0) && t$3.push(n) && !w$1.__r++ || r$3 !== l$2.debounceRendering) && ((r$3 = l$2.debounceRendering) || o$1)(w$1);
  }
  function w$1() {
    var n, l, u, i, r, o, e, c;
    for (t$3.sort(f$1); n = t$3.shift();) n.__d && (l = t$3.length, i = void 0, r = void 0, e = (o = (u = n).__v).__e, (c = u.__P) && (i = [], (r = h$1({}, o)).__v = o.__v + 1, L(c, o, r, u.__n, void 0 !== c.ownerSVGElement, null != o.__h ? [e] : null, i, null == e ? b$1(o) : e, o.__h), M(i, o), o.__e != e && g$1(o)), t$3.length > l && t$3.sort(f$1));
    w$1.__r = 0;
  }
  function x(n, l, u, i, t, r, o, f, e, a) {
    var h,
      v,
      y,
      d,
      k,
      g,
      m,
      w = i && i.__k || s$1,
      x = w.length;
    for (u.__k = [], h = 0; h < l.length; h++) if (null != (d = u.__k[h] = null == (d = l[h]) || "boolean" == typeof d || "function" == typeof d ? null : "string" == typeof d || "number" == typeof d || "bigint" == typeof d ? p$2(null, d, null, null, d) : Array.isArray(d) ? p$2(_$1, {
      children: d
    }, null, null, null) : d.__b > 0 ? p$2(d.type, d.props, d.key, d.ref ? d.ref : null, d.__v) : d)) {
      if (d.__ = u, d.__b = u.__b + 1, null === (y = w[h]) || y && d.key == y.key && d.type === y.type) w[h] = void 0;else for (v = 0; v < x; v++) {
        if ((y = w[v]) && d.key == y.key && d.type === y.type) {
          w[v] = void 0;
          break;
        }
        y = null;
      }
      L(n, d, y = y || c$1, t, r, o, f, e, a), k = d.__e, (v = d.ref) && y.ref != v && (m || (m = []), y.ref && m.push(y.ref, null, d), m.push(v, d.__c || k, d)), null != k ? (null == g && (g = k), "function" == typeof d.type && d.__k === y.__k ? d.__d = e = A(d, e, n) : e = C$1(n, d, y, w, k, e), "function" == typeof u.type && (u.__d = e)) : e && y.__e == e && e.parentNode != n && (e = b$1(y));
    }
    for (u.__e = g, h = x; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = $(i).nextSibling), S(w[h], w[h]));
    if (m) for (h = 0; h < m.length; h++) O(m[h], m[++h], m[++h]);
  }
  function A(n, l, u) {
    for (var i, t = n.__k, r = 0; t && r < t.length; r++) (i = t[r]) && (i.__ = n, l = "function" == typeof i.type ? A(i, l, u) : C$1(u, i, i, t, i.__e, l));
    return l;
  }
  function C$1(n, l, u, i, t, r) {
    var o, f, e;
    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {
      for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1) if (f == t) break n;
      n.insertBefore(t, r), o = r;
    }
    return void 0 !== o ? o : t.nextSibling;
  }
  function $(n) {
    var l, u, i;
    if (null == n.type || "string" == typeof n.type) return n.__e;
    if (n.__k) for (l = n.__k.length - 1; l >= 0; l--) if ((u = n.__k[l]) && (i = $(u))) return i;
    return null;
  }
  function H(n, l, u, i, t) {
    var r;
    for (r in u) "children" === r || "key" === r || r in l || T$1(n, r, null, u[r], i);
    for (r in l) t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || T$1(n, r, l[r], u[r], i);
  }
  function I(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || a$1.test(l) ? u : u + "px";
  }
  function T$1(n, l, u, i, t) {
    var r;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || I(n.style, l, "");
        if (u) for (l in u) i && u[l] === i[l] || I(n.style, l, u[l]);
      }
    } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? z$1 : j$1, r) : n.removeEventListener(l, r ? z$1 : j$1, r);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function j$1(n) {
    return this.l[n.type + !1](l$2.event ? l$2.event(n) : n);
  }
  function z$1(n) {
    return this.l[n.type + !0](l$2.event ? l$2.event(n) : n);
  }
  function L(n, u, i, t, r, o, f, e, c) {
    var s,
      a,
      v,
      y,
      p,
      d,
      b,
      g,
      m,
      w,
      A,
      P,
      C,
      $,
      H,
      I = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l$2.__b) && s(u);
    try {
      n: if ("function" == typeof I) {
        if (g = u.props, m = (s = I.contextType) && t[s.__c], w = s ? m ? m.props.value : s.__ : t, i.__c ? b = (a = u.__c = i.__c).__ = a.__E : ("prototype" in I && I.prototype.render ? u.__c = a = new I(g, w) : (u.__c = a = new k$1(g, w), a.constructor = I, a.render = q), m && m.sub(a), a.props = g, a.state || (a.state = {}), a.context = w, a.__n = t, v = a.__d = !0, a.__h = [], a._sb = []), null == a.__s && (a.__s = a.state), null != I.getDerivedStateFromProps && (a.__s == a.state && (a.__s = h$1({}, a.__s)), h$1(a.__s, I.getDerivedStateFromProps(g, a.__s))), y = a.props, p = a.state, a.__v = u, v) null == I.getDerivedStateFromProps && null != a.componentWillMount && a.componentWillMount(), null != a.componentDidMount && a.__h.push(a.componentDidMount);else {
          if (null == I.getDerivedStateFromProps && g !== y && null != a.componentWillReceiveProps && a.componentWillReceiveProps(g, w), !a.__e && null != a.shouldComponentUpdate && !1 === a.shouldComponentUpdate(g, a.__s, w) || u.__v === i.__v) {
            for (u.__v !== i.__v && (a.props = g, a.state = a.__s, a.__d = !1), a.__e = !1, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < a._sb.length; A++) a.__h.push(a._sb[A]);
            a._sb = [], a.__h.length && f.push(a);
            break n;
          }
          null != a.componentWillUpdate && a.componentWillUpdate(g, a.__s, w), null != a.componentDidUpdate && a.__h.push(function () {
            a.componentDidUpdate(y, p, d);
          });
        }
        if (a.context = w, a.props = g, a.__P = n, P = l$2.__r, C = 0, "prototype" in I && I.prototype.render) {
          for (a.state = a.__s, a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), $ = 0; $ < a._sb.length; $++) a.__h.push(a._sb[$]);
          a._sb = [];
        } else do {
          a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), a.state = a.__s;
        } while (a.__d && ++C < 25);
        a.state = a.__s, null != a.getChildContext && (t = h$1(h$1({}, t), a.getChildContext())), v || null == a.getSnapshotBeforeUpdate || (d = a.getSnapshotBeforeUpdate(y, p)), H = null != s && s.type === _$1 && null == s.key ? s.props.children : s, x(n, Array.isArray(H) ? H : [H], u, i, t, r, o, f, e, c), a.base = u.__e, u.__h = null, a.__h.length && f.push(a), b && (a.__E = a.__ = null), a.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = N(i.__e, u, i, t, r, o, f, c);
      (s = l$2.diffed) && s(u);
    } catch (n) {
      u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$2.__e(n, u, i);
    }
  }
  function M(n, u) {
    l$2.__c && l$2.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$2.__e(n, u.__v);
      }
    });
  }
  function N(l, u, i, t, r, o, f, e) {
    var s,
      a,
      h,
      y = i.props,
      p = u.props,
      d = u.type,
      _ = 0;
    if ("svg" === d && (r = !0), null != o) for (; _ < o.length; _++) if ((s = o[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
      l = s, o[_] = null;
      break;
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = r ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), o = null, e = !1;
    }
    if (null === d) y === p || e && l.data === p || (l.data = p);else {
      if (o = o && n$1.call(l.childNodes), a = (y = i.props || c$1).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !e) {
        if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
        (h || a) && (h && (a && h.__html == a.__html || h.__html === l.innerHTML) || (l.innerHTML = h && h.__html || ""));
      }
      if (H(l, p, y, r, e), h) u.__k = [];else if (_ = u.props.children, x(l, Array.isArray(_) ? _ : [_], u, i, t, r && "foreignObject" !== d, o, f, o ? o[0] : i.__k && b$1(i, 0), e), null != o) for (_ = o.length; _--;) null != o[_] && v$1(o[_]);
      e || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && T$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && T$1(l, "checked", _, y.checked, !1));
    }
    return l;
  }
  function O(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$2.__e(n, i);
    }
  }
  function S(n, u, i) {
    var t, r;
    if (l$2.unmount && l$2.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || O(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$2.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (r = 0; r < t.length; r++) t[r] && S(t[r], u, i || "function" != typeof n.type);
    i || null == n.__e || v$1(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function q(n, l, u) {
    return this.constructor(n, u);
  }
  function B$1(u, i, t) {
    var r, o, f;
    l$2.__ && l$2.__(u, i), o = (r = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], L(i, u = (!r && t || i).__k = y$1(_$1, null, [u]), o || c$1, c$1, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n$1.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), M(f, u);
  }
  n$1 = s$1.slice, l$2 = {
    __e: function __e(n, l, u, i) {
      for (var t, r, o; l = l.__;) if ((t = l.__c) && !t.__) try {
        if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;
      } catch (l) {
        n = l;
      }
      throw n;
    }
  }, u$1 = 0, k$1.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h$1({}, this.state), "function" == typeof n && (n = n(h$1({}, u), this.props)), n && h$1(u, n), null != n && this.__v && (l && this._sb.push(l), m$2(this));
  }, k$1.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), m$2(this));
  }, k$1.prototype.render = _$1, t$3 = [], o$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$1 = function f(n, l) {
    return n.__v.__b - l.__v.__b;
  }, w$1.__r = 0;

  var n = function n(t, s, r, e) {
      var u;
      s[0] = 0;
      for (var h = 1; h < s.length; h++) {
        var p = s[h++],
          a = s[h] ? (s[0] |= p ? 1 : 2, r[s[h++]]) : s[++h];
        3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h]] = a : 6 === p ? e[1][s[++h]] += a + "" : p ? (u = t.apply(a, n(t, a, r, ["", null])), e.push(u), a[0] ? s[0] |= 2 : (s[h - 2] = 0, s[h] = u)) : e.push(a);
      }
      return e;
    },
    t$2 = new Map();
  function e$1 (s) {
    var r = t$2.get(this);
    return r || (r = new Map(), t$2.set(this, r)), (r = n(this, r.get(s) || (r.set(s, r = function (n) {
      for (var t, s, r = 1, e = "", u = "", h = [0], p = function p(n) {
          1 === r && (n || (e = e.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h.push(0, n, e) : 3 === r && (n || e) ? (h.push(3, n, e), r = 2) : 2 === r && "..." === e && n ? h.push(4, n, 0) : 2 === r && e && !n ? h.push(5, 0, !0, e) : r >= 5 && ((e || !n && 5 === r) && (h.push(r, 0, e, s), r = 6), n && (h.push(r, n, 0, s), r = 6)), e = "";
        }, a = 0; a < n.length; a++) {
        a && (1 === r && p(), p(a));
        for (var l = 0; l < n[a].length; l++) t = n[a][l], 1 === r ? "<" === t ? (p(), h = [h], r = 3) : e += t : 4 === r ? "--" === e && ">" === t ? (r = 1, e = "") : e = t + e[0] : u ? t === u ? u = "" : e += t : '"' === t || "'" === t ? u = t : ">" === t ? (p(), r = 1) : r && ("=" === t ? (r = 5, s = e, e = "") : "/" === t && (r < 5 || ">" === n[a][l + 1]) ? (p(), 3 === r && (h = h[0]), r = h, (h = h[0]).push(2, 0, r), r = 0) : " " === t || "\t" === t || "\n" === t || "\r" === t ? (p(), r = 2) : e += t), 3 === r && "!--" === e && (r = 4, h = h[0]);
      }
      return p(), h;
    }(s)), r), arguments, [])).length > 1 ? r : r[0];
  }

  var m$1 = e$1.bind(y$1);

  var t$1,
    r$2,
    u,
    i$2,
    o = 0,
    f = [],
    c = [],
    e = l$2.__b,
    a = l$2.__r,
    v = l$2.diffed,
    l$1 = l$2.__c,
    m = l$2.unmount;
  function d(t, u) {
    l$2.__h && l$2.__h(r$2, t, o || u), o = 0;
    var i = r$2.__H || (r$2.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c
    }), i.__[t];
  }
  function h(n) {
    return o = 1, s(B, n);
  }
  function s(n, u, i) {
    var o = d(t$1++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$2, !r$2.u)) {
      var f = function f(n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !c || c.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!c || c.call(this, n, t, r));
      };
      r$2.u = !0;
      var c = r$2.shouldComponentUpdate,
        e = r$2.componentWillUpdate;
      r$2.componentWillUpdate = function (n, t, r) {
        if (this.__e) {
          var u = c;
          c = void 0, f(n, t, r), c = u;
        }
        e && e.call(this, n, t, r);
      }, r$2.shouldComponentUpdate = f;
    }
    return o.__N || o.__;
  }
  function p$1(u, i) {
    var o = d(t$1++, 3);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__H.__h.push(o));
  }
  function y(u, i) {
    var o = d(t$1++, 4);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__h.push(o));
  }
  function _(n) {
    return o = 5, F(function () {
      return {
        current: n
      };
    }, []);
  }
  function F(n, r) {
    var u = d(t$1++, 7);
    return z(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T(n, t) {
    return o = 8, F(function () {
      return n;
    }, t);
  }
  function b() {
    for (var t; t = f.shift();) if (t.__P && t.__H) try {
      t.__H.__h.forEach(k), t.__H.__h.forEach(w), t.__H.__h = [];
    } catch (r) {
      t.__H.__h = [], l$2.__e(r, t.__v);
    }
  }
  l$2.__b = function (n) {
    r$2 = null, e && e(n);
  }, l$2.__r = function (n) {
    a && a(n), t$1 = 0;
    var i = (r$2 = n.__c).__H;
    i && (u === r$2 ? (i.__h = [], r$2.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k), i.__h.forEach(w), i.__h = [])), u = r$2;
  }, l$2.diffed = function (t) {
    v && v(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f.push(o) && i$2 === l$2.requestAnimationFrame || ((i$2 = l$2.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;
    })), u = r$2 = null;
  }, l$2.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k), t.__h = t.__h.filter(function (n) {
          return !n.__ || w(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$2.__e(u, t.__v);
      }
    }), l$1 && l$1(t, r);
  }, l$2.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$2.__e(r, u.__v));
  };
  var g = "function" == typeof requestAnimationFrame;
  function j(n) {
    var t,
      r = function r() {
        clearTimeout(u), g && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g && (t = requestAnimationFrame(r));
  }
  function k(n) {
    var t = r$2,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$2 = t;
  }
  function w(n) {
    var t = r$2;
    n.__c = n.__(), r$2 = t;
  }
  function z(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B(n, t) {
    return "function" == typeof t ? t(n) : t;
  }

  function r$1(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == _typeof(e)) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r$1(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r$1(e)) && (n && (n += " "), n += t);
    return n;
  }

  var _templateObject$3, _templateObject2$2, _templateObject3$2, _templateObject4$2, _templateObject5$1, _templateObject6$1;

  /**
   * @typedef {import('./PopupMenuProvider').PopupMenuEntry} PopupMenuEntry
   */

  /**
   * Component that renders a popup menu entry.
   *
   * @param {Object} props
   * @param {string} props.key
   * @param {PopupMenuEntry} props.entry
   * @param {boolean} props.selected
   * @param {(event: MouseEvent) => void} props.onMouseEnter
   * @param {(event: MouseEvent) => void} props.onMouseLeave
   * @param {(event: MouseEvent, entry?: PopupMenuEntry, action?: string) => void} props.onAction
   */
  function PopupMenuItem(props) {
    var entry = props.entry,
      selected = props.selected,
      onMouseEnter = props.onMouseEnter,
      onMouseLeave = props.onMouseLeave,
      onAction = props.onAction;
    return m$1(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n    <li\n      class=", "\n      data-id=", "\n      title=", "\n      onClick=", "\n      onMouseEnter=", "\n      onMouseLeave=", "\n      onDragStart=", "\n      draggable=", "\n    >\n      <div class=\"djs-popup-entry-content\">\n        <span\n          class=", "\n        >\n          ", "\n\n          ", "\n        </span>\n        ", "\n      </div>\n      ", "\n    </li>\n  "])), clsx('entry', {
      selected: selected
    }), entry.id, entry.title || entry.label, onAction, onMouseEnter, onMouseLeave, function (event) {
      return onAction(event, entry, 'dragstart');
    }, true, clsx('djs-popup-entry-name', entry.className), entry.imageUrl && m$1(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral(["<img class=\"djs-popup-entry-icon\" src=", " alt=\"\" />"])), entry.imageUrl) || entry.imageHtml && m$1(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral(["<div class=\"djs-popup-entry-icon\" dangerouslySetInnerHTML=", " />"])), {
      __html: entry.imageHtml
    }), entry.label ? m$1(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteral(["\n            <span class=\"djs-popup-label\">\n              ", "\n            </span>\n          "])), entry.label) : null, entry.description && m$1(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteral(["\n          <span\n            class=\"djs-popup-entry-description\"\n            title=", "\n          >\n            ", "\n          </span>\n        "])), entry.description, entry.description), entry.documentationRef && m$1(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteral(["\n        <div class=\"djs-popup-entry-docs\">\n          <a\n            href=\"", "\"\n            onClick=", "\n            title=\"Open element documentation\"\n            target=\"_blank\"\n            rel=\"noopener\"\n          >\n            <svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n              <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z\" fill=\"#818798\"/>\n            </svg>\n          </a>\n        </div>\n      "])), entry.documentationRef, function (event) {
      return event.stopPropagation();
    }));
  }

  var _templateObject$2, _templateObject2$1, _templateObject3$1, _templateObject4$1;
  var _excluded$8 = ["selectedEntry", "setSelectedEntry", "entries"];

  /**
   * @typedef {import('./PopupMenuProvider').PopupMenuEntry} PopupMenuEntry
   */

  /**
   * Component that renders a popup menu entry list.
   *
   * @param {Object} props
   * @param {PopupMenuEntry[]} props.entries
   * @param {PopupMenuEntry} props.selectedEntry
   * @param {(entry: PopupMenuEntry | null) => void} props.setSelectedEntry
   */
  function PopupMenuList(props) {
    var selectedEntry = props.selectedEntry,
      setSelectedEntry = props.setSelectedEntry,
      entries = props.entries,
      restProps = _objectWithoutProperties$7(props, _excluded$8);
    var resultsRef = _();
    var groups = F(function () {
      return groupEntries(entries);
    }, [entries]);

    // scroll to selected result
    y(function () {
      var containerEl = resultsRef.current;
      if (!containerEl) return;
      var selectedEl = containerEl.querySelector('.selected');
      if (selectedEl) {
        scrollIntoView$1(selectedEl);
      }
    }, [selectedEntry]);
    return m$1(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["\n    <div class=\"djs-popup-results\" ref=", ">\n      ", "\n    </div>\n  "])), resultsRef, groups.map(function (group) {
      return m$1(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral(["\n        ", "\n        <ul class=\"djs-popup-group\" data-group=", ">\n          ", "\n        </ul>\n      "])), group.name && m$1(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral(["\n          <div key=", " class=\"entry-header\" title=", ">\n            ", "\n          </div>\n        "])), group.id, group.name, group.name), group.id, group.entries.map(function (entry) {
        return m$1(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral(["\n            <", "\n              key=", "\n              entry=", "\n              selected=", "\n              onMouseEnter=", "\n              onMouseLeave=", "\n              ...", "\n            />\n          "])), PopupMenuItem, entry.id, entry, entry === selectedEntry, function () {
          return setSelectedEntry(entry);
        }, function () {
          return setSelectedEntry(null);
        }, restProps);
      }));
    }));
  }

  // helpers
  function groupEntries(entries) {
    var groups = [];
    var getGroup = function getGroup(group) {
      return groups.find(function (elem) {
        return group.id === elem.id;
      });
    };
    var containsGroup = function containsGroup(group) {
      return !!getGroup(group);
    };

    // legacy support for provider built for the old popUp menu
    var formatGroup = function formatGroup(group) {
      return typeof group === 'string' ? {
        id: group
      } : group;
    };
    entries.forEach(function (entry) {
      // assume a default group when none is provided
      var group = entry.group ? formatGroup(entry.group) : {
        id: 'default'
      };
      if (!containsGroup(group)) {
        groups.push(_objectSpread2(_objectSpread2({}, group), {}, {
          entries: [entry]
        }));
      } else {
        getGroup(group).entries.push(entry);
      }
    });
    return groups;
  }

  // helpers ////////////////

  function scrollIntoView$1(el) {
    if (typeof el.scrollIntoViewIfNeeded === 'function') {
      el.scrollIntoViewIfNeeded();
    } else {
      el.scrollIntoView({
        scrollMode: 'if-needed',
        block: 'nearest'
      });
    }
  }

  var _templateObject$1, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10;

  /**
   * @typedef {import('./PopupMenuProvider').PopupMenuEntry} PopupMenuEntry
   * @typedef {import('./PopupMenuProvider').PopupMenuHeaderEntry} PopupMenuHeaderEntry
   *
   * @typedef {import('../../util/Types').Point} Point
   */

  /**
   * A component that renders the popup menus.
   *
   * @param {Object} props
   * @param {() => void} props.onClose
   * @param {(element: HTMLElement) => Point} props.position
   * @param {string} props.className
   * @param {PopupMenuEntry[]} props.entries
   * @param {PopupMenuHeaderEntry[]} props.headerEntries
   * @param {number} props.scale
   * @param {string} [props.title]
   * @param {boolean} [props.search]
   * @param {number} [props.width]
   */
  function PopupMenuComponent(props) {
    var onClose = props.onClose,
      onSelect = props.onSelect,
      className = props.className,
      headerEntries = props.headerEntries,
      position = props.position,
      title = props.title,
      width = props.width,
      scale = props.scale,
      search = props.search,
      originalEntries = props.entries,
      onOpened = props.onOpened,
      onClosed = props.onClosed;
    var searchable = F(function () {
      if (!isDefined(search)) {
        return false;
      }
      return originalEntries.length > 5;
    }, [search, originalEntries]);
    var inputRef = _();
    var _useState = h(''),
      _useState2 = _slicedToArray$1(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];
    var filterEntries = T(function (originalEntries, value) {
      if (!searchable) {
        return originalEntries;
      }
      var filter = function filter(entry) {
        if (!value) {
          return (entry.rank || 0) >= 0;
        }
        var search = [entry.description || '', entry.label || '', entry.search || ''].join('---').toLowerCase();
        return value.toLowerCase().split(/\s/g).every(function (term) {
          return search.includes(term);
        });
      };
      return originalEntries.filter(filter);
    }, [searchable]);
    var _useState3 = h(filterEntries(originalEntries, value)),
      _useState4 = _slicedToArray$1(_useState3, 2),
      entries = _useState4[0],
      setEntries = _useState4[1];
    var _useState5 = h(entries[0]),
      _useState6 = _slicedToArray$1(_useState5, 2),
      selectedEntry = _useState6[0],
      setSelectedEntry = _useState6[1];
    var updateEntries = T(function (newEntries) {
      // select first entry if non is selected
      if (!selectedEntry || !newEntries.includes(selectedEntry)) {
        setSelectedEntry(newEntries[0]);
      }
      setEntries(newEntries);
    }, [selectedEntry, setEntries, setSelectedEntry]);

    // filter entries on value change
    p$1(function () {
      updateEntries(filterEntries(originalEntries, value));
    }, [value, originalEntries]);

    // register global <Escape> handler
    p$1(function () {
      var handleKeyDown = function handleKeyDown(event) {
        if (event.key === 'Escape') {
          event.preventDefault();
          return onClose();
        }
      };
      document.documentElement.addEventListener('keydown', handleKeyDown);
      return function () {
        document.documentElement.removeEventListener('keydown', handleKeyDown);
      };
    }, []);

    // focus input on initial mount
    y(function () {
      inputRef.current && inputRef.current.focus();
    }, []);

    // handle keyboard seleciton
    var keyboardSelect = T(function (direction) {
      var idx = entries.indexOf(selectedEntry);
      var nextIdx = idx + direction;
      if (nextIdx < 0) {
        nextIdx = entries.length - 1;
      }
      if (nextIdx >= entries.length) {
        nextIdx = 0;
      }
      setSelectedEntry(entries[nextIdx]);
    }, [entries, selectedEntry, setSelectedEntry]);
    var handleKeyDown = T(function (event) {
      if (event.key === 'Enter' && selectedEntry) {
        return onSelect(event, selectedEntry);
      }

      // ARROW_UP or SHIFT + TAB navigation
      if (event.key === 'ArrowUp' || event.key === 'Tab' && event.shiftKey) {
        keyboardSelect(-1);
        return event.preventDefault();
      }

      // ARROW_DOWN or TAB navigation
      if (event.key === 'ArrowDown' || event.key === 'Tab') {
        keyboardSelect(1);
        return event.preventDefault();
      }
    }, [onSelect, onClose, selectedEntry, keyboardSelect]);
    var handleKey = T(function (event) {
      if (matches(event.target, 'input')) {
        setValue(function () {
          return event.target.value;
        });
      }
    }, [setValue]);
    p$1(function () {
      onOpened();
      return function () {
        onClosed();
      };
    }, []);
    var displayHeader = F(function () {
      return title || headerEntries.length > 0;
    }, [title, headerEntries]);
    return m$1(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n    <", "\n      onClose=", "\n      onKeyup=", "\n      onKeydown=", "\n      className=", "\n      position=", "\n      width=", "\n      scale=", "\n    >\n      ", "\n      ", "\n    </", ">\n  "])), PopupMenuWrapper, onClose, handleKey, handleKeyDown, className, position, width, scale, displayHeader && m$1(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n        <div class=\"djs-popup-header\">\n          <h3 class=\"djs-popup-title\" title=", ">", "</h3>\n          ", "\n        </div>\n      "])), title, title, headerEntries.map(function (entry) {
      return m$1(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n            <span\n              class=", "\n              onClick=", "\n              title=", "\n              data-id=", "\n              onMouseEnter=", "\n              onMouseLeave=", "\n            >\n            ", "\n\n              ", "\n            </span>\n          "])), getHeaderClasses(entry, entry === selectedEntry), function (event) {
        return onSelect(event, entry);
      }, entry.title || entry.label, entry.id, function () {
        return setSelectedEntry(entry);
      }, function () {
        return setSelectedEntry(null);
      }, entry.imageUrl && m$1(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["<img class=\"djs-popup-entry-icon\" src=", " alt=\"\" />"])), entry.imageUrl) || entry.imageHtml && m$1(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["<div class=\"djs-popup-entry-icon\" dangerouslySetInnerHTML=", " />"])), {
        __html: entry.imageHtml
      }), entry.label ? m$1(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n                <span class=\"djs-popup-label\">", "</span>\n              "])), entry.label) : null);
    })), originalEntries.length > 0 && m$1(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n        <div class=\"djs-popup-body\">\n\n          ", "\n\n          <", "\n            entries=", "\n            selectedEntry=", "\n            setSelectedEntry=", "\n            onAction=", "\n          />\n        </div>\n        ", "\n      "])), searchable && m$1(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n          <div class=\"djs-popup-search\">\n            <svg class=\"djs-popup-search-icon\" width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n              <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z\" fill=\"#22242A\"/>\n            </svg>\n            <input\n                ref=", "\n                type=\"text\"\n              />\n          </div>\n          "])), inputRef), PopupMenuList, entries, selectedEntry, setSelectedEntry, onSelect, entries.length === 0 && m$1(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n          <div class=\"djs-popup-no-results\">No matching entries found.</div>\n        "])))), PopupMenuWrapper);
  }

  /**
   * A component that wraps the popup menu.
   *
   * @param {*} props
   */
  function PopupMenuWrapper(props) {
    var onClose = props.onClose,
      onKeydown = props.onKeydown,
      onKeyup = props.onKeyup,
      className = props.className,
      children = props.children,
      positionGetter = props.position;
    var popupRef = _();
    var checkClose = T(function (event) {
      var popup = closest(event.target, '.djs-popup', true);
      if (popup) {
        return;
      }
      onClose();
    }, [onClose]);
    y(function () {
      if (typeof positionGetter !== 'function') {
        return;
      }
      var popupEl = popupRef.current;
      var position = positionGetter(popupEl);
      popupEl.style.left = "".concat(position.x, "px");
      popupEl.style.top = "".concat(position.y, "px");
    }, [popupRef.current, positionGetter]);

    // focus popup initially, on mount
    y(function () {
      popupRef.current && popupRef.current.focus();
    }, []);
    return m$1(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n    <div\n      class=\"djs-popup-backdrop\"\n      onClick=", "\n    >\n      <div\n        class=", "\n        style=", "\n        onKeydown=", "\n        onKeyup=", "\n        ref=", "\n        tabIndex=\"-1\"\n      >\n        ", "\n      </div>\n    </div>\n  "])), checkClose, clsx('djs-popup', className), getPopupStyle(props), onKeydown, onKeyup, popupRef, children);
  }

  // helpers //////////////////////

  function getPopupStyle(props) {
    return {
      transform: "scale(".concat(props.scale, ")"),
      width: "".concat(props.width, "px")
    };
  }
  function getHeaderClasses(entry, selected) {
    return clsx('entry', entry.className, entry.active ? 'active' : '', entry.disabled ? 'disabled' : '', selected ? 'selected' : '');
  }

  var _templateObject;

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   *
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('./PopupMenuProvider').PopupMenuEntries} PopupMenuEntries
   * @typedef {import('./PopupMenuProvider').PopupMenuEntry} PopupMenuEntry
   * @typedef {import('./PopupMenuProvider').PopupMenuHeaderEntries} PopupMenuHeaderEntries
   * @typedef {import('./PopupMenuProvider').PopupMenuHeaderEntry} PopupMenuHeaderEntry
   * @typedef {import('./PopupMenuProvider').default} PopupMenuProvider
   *
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef { {
   *   scale?: {
   *     min?: number;
   *     max?: number;
   *   } | boolean;
   * } } PopupMenuConfig
   *
   * @typedef {Element|Element[]} PopupMenuTarget;
   */

  var DATA_REF = 'data-id';
  var CLOSE_EVENTS = ['contextPad.close', 'canvas.viewbox.changing', 'commandStack.changed'];
  var DEFAULT_PRIORITY$5 = 1000;

  /**
   * A popup menu to show a number of actions on the canvas.
   *
   * @param {PopupMenuConfig} config
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function PopupMenu$1(config, eventBus, canvas) {
    var _this = this;
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._current = null;
    var scale = isDefined(config && config.scale) ? config.scale : {
      min: 1,
      max: 1.5
    };
    this._config = {
      scale: scale
    };
    eventBus.on('diagram.destroy', function () {
      _this.close();
    });
    eventBus.on('element.changed', function (event) {
      var element = _this.isOpen() && _this._current.target;
      if (event.element === element) {
        _this._render();
      }
    });
  }
  PopupMenu$1.$inject = ['config.popupMenu', 'eventBus', 'canvas'];
  PopupMenu$1.prototype._render = function () {
    var _this2 = this;
    var _this$_current = this._current,
      _position = _this$_current.position,
      className = _this$_current.className,
      entries = _this$_current.entries,
      headerEntries = _this$_current.headerEntries,
      options = _this$_current.options;
    var entriesArray = Object.entries(entries).map(function (_ref) {
      var _ref2 = _slicedToArray$1(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      return _objectSpread2({
        id: key
      }, value);
    });
    var headerEntriesArray = Object.entries(headerEntries).map(function (_ref3) {
      var _ref4 = _slicedToArray$1(_ref3, 2),
        key = _ref4[0],
        value = _ref4[1];
      return _objectSpread2({
        id: key
      }, value);
    });
    var position = _position && function (container) {
      return _this2._ensureVisible(container, _position);
    };
    var scale = this._updateScale(this._current.container);
    var onClose = function onClose(result) {
      return _this2.close(result);
    };
    var onSelect = function onSelect(event, entry, action) {
      return _this2.trigger(event, entry, action);
    };
    B$1(m$1(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      <", "\n        onClose=", "\n        onSelect=", "\n        position=", "\n        className=", "\n        entries=", "\n        headerEntries=", "\n        scale=", "\n        onOpened=", "\n        onClosed=", "\n        ...", "\n      />\n    "])), PopupMenuComponent, onClose, onSelect, position, className, entriesArray, headerEntriesArray, scale, this._onOpened.bind(this), this._onClosed.bind(this), _objectSpread2({}, options)), this._current.container);
  };

  /**
   * Open the popup menu at the given position.
   *
   * @param {PopupMenuTarget} target
   * @param {string} providerId
   * @param {Point} position
   * @param {Object} [options]
   */
  PopupMenu$1.prototype.open = function (target, providerId, position, options) {
    if (!target) {
      throw new Error('target is missing');
    }
    if (!providerId) {
      throw new Error('providers for <' + providerId + '> not found');
    }
    if (!position) {
      throw new Error('position is missing');
    }
    if (this.isOpen()) {
      this.close();
    }
    var _this$_getContext = this._getContext(target, providerId),
      entries = _this$_getContext.entries,
      headerEntries = _this$_getContext.headerEntries;
    this._current = {
      position: position,
      className: providerId,
      target: target,
      entries: entries,
      headerEntries: headerEntries,
      container: this._createContainer({
        provider: providerId
      }),
      options: options
    };
    this._emit('open');
    this._bindAutoClose();
    this._render();
  };
  PopupMenu$1.prototype._getContext = function (target, provider) {
    var providers = this._getProviders(provider);
    if (!providers || !providers.length) {
      throw new Error('provider for <' + provider + '> not found');
    }
    var entries = this._getEntries(target, providers);
    var headerEntries = this._getHeaderEntries(target, providers);
    return {
      entries: entries,
      headerEntries: headerEntries,
      empty: !(Object.keys(entries).length || Object.keys(headerEntries).length)
    };
  };
  PopupMenu$1.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }
    this._emit('close');
    this.reset();
    this._current = null;
  };
  PopupMenu$1.prototype.reset = function () {
    var container = this._current.container;
    B$1(null, container);
    remove$4(container);
  };
  PopupMenu$1.prototype._emit = function (event, payload) {
    this._eventBus.fire("popupMenu.".concat(event), payload);
  };
  PopupMenu$1.prototype._onOpened = function () {
    this._emit('opened');
  };
  PopupMenu$1.prototype._onClosed = function () {
    this._emit('closed');
  };
  PopupMenu$1.prototype._createContainer = function (config) {
    var canvas = this._canvas,
      parent = canvas.getContainer();
    var container = domify$1("<div class=\"djs-popup-parent djs-scrollable\" data-popup=".concat(config.provider, "></div>"));
    parent.appendChild(container);
    return container;
  };

  /**
   * Set up listener to close popup automatically on certain events.
   */
  PopupMenu$1.prototype._bindAutoClose = function () {
    this._eventBus.once(CLOSE_EVENTS, this.close, this);
  };

  /**
   * Remove the auto-closing listener.
  */
  PopupMenu$1.prototype._unbindAutoClose = function () {
    this._eventBus.off(CLOSE_EVENTS, this.close, this);
  };

  /**
   * Updates popup style.transform with respect to the config and zoom level.
   *
   * @return {number}
   */
  PopupMenu$1.prototype._updateScale = function () {
    var zoom = this._canvas.zoom();
    var scaleConfig = this._config.scale,
      minScale,
      maxScale,
      scale = zoom;
    if (scaleConfig !== true) {
      if (scaleConfig === false) {
        minScale = 1;
        maxScale = 1;
      } else {
        minScale = scaleConfig.min;
        maxScale = scaleConfig.max;
      }
      if (isDefined(minScale) && zoom < minScale) {
        scale = minScale;
      }
      if (isDefined(maxScale) && zoom > maxScale) {
        scale = maxScale;
      }
    }
    return scale;
  };
  PopupMenu$1.prototype._ensureVisible = function (container, position) {
    var documentBounds = document.documentElement.getBoundingClientRect();
    var containerBounds = container.getBoundingClientRect();
    var overAxis = {},
      left = position.x,
      top = position.y;
    if (position.x + containerBounds.width > documentBounds.width) {
      overAxis.x = true;
    }
    if (position.y + containerBounds.height > documentBounds.height) {
      overAxis.y = true;
    }
    if (overAxis.x && overAxis.y) {
      left = position.x - containerBounds.width;
      top = position.y - containerBounds.height;
    } else if (overAxis.x) {
      left = position.x - containerBounds.width;
      top = position.y;
    } else if (overAxis.y && position.y < containerBounds.height) {
      left = position.x;
      top = 10;
    } else if (overAxis.y) {
      left = position.x;
      top = position.y - containerBounds.height;
    }

    // underAxis
    if (position.y < documentBounds.top) {
      top = position.y + containerBounds.height;
    }
    return {
      x: left,
      y: top
    };
  };

  /**
   * Check whether there are no popup menu providers or provided entries for the
   * given target.
   *
   * @param {PopupMenuTarget} target
   * @param {string} providerId
   *
   * @return {boolean}
   */
  PopupMenu$1.prototype.isEmpty = function (target, providerId) {
    if (!target) {
      throw new Error('target is missing');
    }
    if (!providerId) {
      throw new Error('provider ID is missing');
    }
    var providers = this._getProviders(providerId);
    if (!providers || !providers.length) {
      return true;
    }
    return this._getContext(target, providerId).empty;
  };

  /**
   * @overlord
   *
   * Register a popup menu provider with default priority. See
   * {@link PopupMenuProvider} for examples.
   *
   * @param {string} id
   * @param {PopupMenuProvider} provider
   */

  /**
   * Register a popup menu provider with the given priority. See
   * {@link PopupMenuProvider} for examples.
   *
   * @param {string} id
   * @param {number} priority
   * @param {PopupMenuProvider} provider
   */
  PopupMenu$1.prototype.registerProvider = function (id, priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY$5;
    }
    this._eventBus.on('popupMenu.getProviders.' + id, priority, function (event) {
      event.providers.push(provider);
    });
  };

  /**
   * @param {string} id
   *
   * @return {PopupMenuProvider[]}
   */
  PopupMenu$1.prototype._getProviders = function (id) {
    var event = this._eventBus.createEvent({
      type: 'popupMenu.getProviders.' + id,
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };

  /**
   * @param {PopupMenuTarget} target
   * @param {PopupMenuProvider[]} providers
   *
   * @return {PopupMenuEntries}
   */
  PopupMenu$1.prototype._getEntries = function (target, providers) {
    var entries = {};
    forEach$3(providers, function (provider) {
      // handle legacy method
      if (!provider.getPopupMenuEntries) {
        forEach$3(provider.getEntries(target), function (entry) {
          var id = entry.id;
          if (!id) {
            throw new Error('entry ID is missing');
          }
          entries[id] = omit(entry, ['id']);
        });
        return;
      }
      var entriesOrUpdater = provider.getPopupMenuEntries(target);
      if (isFunction$2(entriesOrUpdater)) {
        entries = entriesOrUpdater(entries);
      } else {
        forEach$3(entriesOrUpdater, function (entry, id) {
          entries[id] = entry;
        });
      }
    });
    return entries;
  };

  /**
   * @param {PopupMenuTarget} target
   * @param {PopupMenuProvider[]} providers
   *
   * @return {PopupMenuHeaderEntries}
   */
  PopupMenu$1.prototype._getHeaderEntries = function (target, providers) {
    var entries = {};
    forEach$3(providers, function (provider) {
      // handle legacy method
      if (!provider.getPopupMenuHeaderEntries) {
        if (!provider.getHeaderEntries) {
          return;
        }
        forEach$3(provider.getHeaderEntries(target), function (entry) {
          var id = entry.id;
          if (!id) {
            throw new Error('entry ID is missing');
          }
          entries[id] = omit(entry, ['id']);
        });
        return;
      }
      var entriesOrUpdater = provider.getPopupMenuHeaderEntries(target);
      if (isFunction$2(entriesOrUpdater)) {
        entries = entriesOrUpdater(entries);
      } else {
        forEach$3(entriesOrUpdater, function (entry, id) {
          entries[id] = entry;
        });
      }
    });
    return entries;
  };

  /**
   * Check if the popup menu is open.
   *
   * @return {boolean}
   */
  PopupMenu$1.prototype.isOpen = function () {
    return !!this._current;
  };

  /**
   * Trigger an action associated with an entry.
   *
   * @param {Event} event
   * @param {PopupMenuEntry} entry
   * @param {string} [action='click']
   *
   * @return {any}
   */
  PopupMenu$1.prototype.trigger = function (event, entry) {
    var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'click';
    // silence other actions
    event.preventDefault();
    if (!entry) {
      var element = closest(event.delegateTarget || event.target, '.entry', true);
      var entryId = attr$1(element, DATA_REF);
      entry = _objectSpread2({
        id: entryId
      }, this._getEntry(entryId));
    }
    var handler = entry.action;
    if (this._emit('trigger', {
      entry: entry,
      event: event
    }) === false) {
      return;
    }
    if (isFunction$2(handler)) {
      if (action === 'click') {
        return handler(event, entry);
      }
    } else {
      if (handler[action]) {
        return handler[action](event, entry);
      }
    }
  };

  /**
   * Get the entry (entry or header entry) with the given ID.
   *
   * @param {string} entryId
   *
   * @return {PopupMenuEntry|PopupMenuHeaderEntry}
   */
  PopupMenu$1.prototype._getEntry = function (entryId) {
    var entry = this._current.entries[entryId] || this._current.headerEntries[entryId];
    if (!entry) {
      throw new Error('entry not found');
    }
    return entry;
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramPopupMenu = {
    __init__: ['popupMenu'],
    popupMenu: ['type', PopupMenu$1]
  };

  /**
   * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus
   * @typedef {import('../modeling/Modeling').default} Modeling
   *
   * @typedef {import('../../core/Types').ShapeLike} Shape
   */

  var round$3 = Math.round;

  /**
   * Service that allows replacing of elements.
   *
   * @param {Modeling} modeling
   * @param {EventBus} eventBus
   */
  function Replace$1(modeling, eventBus) {
    this._modeling = modeling;
    this._eventBus = eventBus;
  }
  Replace$1.$inject = ['modeling', 'eventBus'];

  /**
   * Replace an element.
   *
   * @param {Shape} oldElement The element to be replaced.
   * @param {Object} attrs Containing information about the new element, for
   * example the new bounds and type.
   * @param {Object} hints Custom hints that will be attached to the context. It
   * can be used to inject data that is needed in the command chain. For example
   * it could be used in eventbus.on('commandStack.shape.replace.postExecute') to
   * change shape attributes after shape creation.
   *
   * @return {Shape}
   */
  Replace$1.prototype.replaceElement = function (oldElement, attrs, hints) {
    if (oldElement.waypoints) {
      // TODO(nikku): we do not replace connections, yet
      return null;
    }
    var modeling = this._modeling;
    var eventBus = this._eventBus;
    eventBus.fire('replace.start', {
      element: oldElement,
      attrs: attrs,
      hints: hints
    });
    var width = attrs.width || oldElement.width,
      height = attrs.height || oldElement.height,
      x = attrs.x || oldElement.x,
      y = attrs.y || oldElement.y,
      centerX = round$3(x + width / 2),
      centerY = round$3(y + height / 2);

    // modeling API requires center coordinates,
    // account for that when handling shape bounds

    var newElement = modeling.replaceShape(oldElement, assign$4({}, attrs, {
      x: centerX,
      y: centerY,
      width: width,
      height: height
    }), hints);
    eventBus.fire('replace.end', {
      element: oldElement,
      newElement: newElement,
      hints: hints
    });
    return newElement;
  };

  function ReplaceSelectionBehavior(selection, eventBus) {
    eventBus.on('replace.end', 500, function (event) {
      var newElement = event.newElement,
        _event$hints = event.hints,
        hints = _event$hints === void 0 ? {} : _event$hints;
      if (hints.select === false) {
        return;
      }
      selection.select(newElement);
    });
  }
  ReplaceSelectionBehavior.$inject = ['selection', 'eventBus'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramReplace = {
    __init__: ['replace', 'replaceSelectionBehavior'],
    replaceSelectionBehavior: ['type', ReplaceSelectionBehavior],
    replace: ['type', Replace$1]
  };

  /**
   * This module takes care of replacing DRD elements
   */
  function DrdReplace(drdFactory, replace, selection, modeling) {
    /**
     * Prepares a new business object for the replacement element
     * and triggers the replace operation.
     *
     * @param  {djs.model.Base} element
     * @param  {Object} target
     * @param  {Object} [hints]
     *
     * @return {djs.model.Base} the newly created element
     */
    function replaceElement(element, target, hints) {
      hints = hints || {};
      var type = target.type,
        oldBusinessObject = element.businessObject;
      var newBusinessObject = drdFactory.create(type);
      var newElement = {
        type: type,
        businessObject: newBusinessObject
      };
      newElement.width = element.width;
      newElement.height = element.height;
      newBusinessObject.name = oldBusinessObject.name;
      if (target.table) {
        var table = drdFactory.create('dmn:DecisionTable');
        newBusinessObject.decisionLogic = table;
        table.$parent = newBusinessObject;
        var output = drdFactory.create('dmn:OutputClause');
        output.typeRef = 'string';
        output.$parent = table;
        table.output = [output];
        var input = drdFactory.create('dmn:InputClause');
        input.$parent = table;
        var inputExpression = drdFactory.create('dmn:LiteralExpression', {
          typeRef: 'string'
        });
        input.inputExpression = inputExpression;
        inputExpression.$parent = input;
        table.input = [input];
      }
      if (target.expression) {
        newBusinessObject.decisionLogic = drdFactory.create('dmn:LiteralExpression');
        newBusinessObject.variable = drdFactory.create('dmn:InformationItem');
      }
      return replace.replaceElement(element, newElement, hints);
    }
    this.replaceElement = replaceElement;
  }
  DrdReplace.$inject = ['drdFactory', 'replace', 'selection', 'modeling'];

  var Replace = {
    __depends__: [DiagramReplace, SelectionModule],
    drdReplace: ['type', DrdReplace]
  };

  var replaceOptions = {
    DECISION: [{
      label: 'Empty',
      actionName: 'replace-with-empty-decision',
      className: 'dmn-icon-clear',
      target: {
        type: 'dmn:Decision',
        table: false,
        expression: false
      }
    }, {
      label: 'Decision table',
      actionName: 'replace-with-decision-table',
      className: 'dmn-icon-decision-table',
      target: {
        type: 'dmn:Decision',
        table: true,
        expression: false
      }
    }, {
      label: 'Literal expression',
      actionName: 'replace-with-literal-expression',
      className: 'dmn-icon-literal-expression',
      target: {
        type: 'dmn:Decision',
        table: false,
        expression: true
      }
    }]
  };

  /**
   * This module is an element agnostic replace menu provider for the popup menu.
   */
  function ReplaceMenuProvider(popupMenu, modeling, moddle, drdReplace, rules, translate) {
    this._popupMenu = popupMenu;
    this._modeling = modeling;
    this._moddle = moddle;
    this._drdReplace = drdReplace;
    this._rules = rules;
    this._translate = translate;
    this.register();
  }
  ReplaceMenuProvider.$inject = ['popupMenu', 'modeling', 'moddle', 'drdReplace', 'rules', 'translate'];

  /**
   * Register replace menu provider in the popup menu
   */
  ReplaceMenuProvider.prototype.register = function () {
    this._popupMenu.registerProvider('dmn-replace', this);
  };

  /**
   * Get all entries from replaceOptions for the given element.
   *
   * @param {djs.model.Base} element
   *
   * @return {Array<Object>} a list of menu entry items
   */
  ReplaceMenuProvider.prototype.getEntries = function (element) {
    var businessObject = element.businessObject;
    var rules = this._rules;
    if (!rules.allowed('shape.replace', {
      element: element
    })) {
      return [];
    }
    if (is$1(businessObject, 'dmn:Decision')) {
      var options = filter$2(replaceOptions.DECISION, function (option) {
        var notEmpty = option.actionName === 'replace-with-empty-decision' && businessObject.decisionLogic;
        var notTable = option.actionName === 'replace-with-decision-table' && !is$1(businessObject.decisionLogic, 'dmn:DecisionTable');
        var notExp = option.actionName === 'replace-with-literal-expression' && !is$1(businessObject.decisionLogic, 'dmn:LiteralExpression');
        return notEmpty || notTable || notExp;
      });
      return this._createEntries(element, options);
    }
    return [];
  };

  /**
   * Creates an array of menu entry objects for a given element.
   *
   * @param  {djs.model.Base} element
   * @param  {Object} replaceOptions
   *
   * @return {Array<Object>} a list of menu items
   */
  ReplaceMenuProvider.prototype._createEntries = function (element, replaceOptions) {
    var menuEntries = [];
    var self = this;
    forEach$3(replaceOptions, function (definition) {
      var entry = self._createMenuEntry(definition, element);
      menuEntries.push(entry);
    });
    return menuEntries;
  };

  /**
   * Creates and returns a single menu entry item.
   *
   * @param  {Object} definition a single replace options definition object
   * @param  {djs.model.Base} element
   * @param  {Function} [action] an action callback function which gets called when
   *                             the menu entry is being triggered.
   *
   * @return {Object} menu entry item
   */
  ReplaceMenuProvider.prototype._createMenuEntry = function (definition, element, action) {
    var replaceElement = this._drdReplace.replaceElement;
    var translate = this._translate;
    var replaceAction = function replaceAction() {
      return replaceElement(element, definition.target);
    };
    action = action || replaceAction;
    var menuEntry = {
      label: translate(definition.label),
      className: definition.className,
      id: definition.actionName,
      action: action
    };
    return menuEntry;
  };
  ReplaceMenuProvider.prototype.getHeaderEntries = function (element) {
    return [];
  };

  var PopupMenu = {
    __depends__: [TranslateModule, DiagramPopupMenu, Replace],
    __init__: ['replaceMenuProvider'],
    replaceMenuProvider: ['type', ReplaceMenuProvider]
  };

  /**
  * A provider for DMN elements context pad
  */
  function ContextPadProvider(eventBus, contextPad, modeling, elementFactory, connect, create, rules, popupMenu, canvas, translate, config, injector) {
    config = config || {};
    contextPad.registerProvider(this);
    this._contextPad = contextPad;
    this._modeling = modeling;
    this._elementFactory = elementFactory;
    this._connect = connect;
    this._create = create;
    this._rules = rules;
    this._popupMenu = popupMenu;
    this._canvas = canvas;
    this._translate = translate;
    if (config.autoPlace !== false) {
      this._autoPlace = injector.get('autoPlace', false);
    }
    eventBus.on('create.end', 250, function (event) {
      var shape = event.context.shape;
      if (!hasPrimaryModifier(event)) {
        return;
      }
      var entries = contextPad.getEntries(shape);
      if (entries.replace) {
        entries.replace.action.click(event, shape);
      }
    });
  }
  ContextPadProvider.$inject = ['eventBus', 'contextPad', 'modeling', 'elementFactory', 'connect', 'create', 'rules', 'popupMenu', 'canvas', 'translate', 'config.contextPad', 'injector'];
  ContextPadProvider.prototype.getContextPadEntries = function (element) {
    var modeling = this._modeling,
      elementFactory = this._elementFactory,
      connect = this._connect,
      create = this._create,
      popupMenu = this._popupMenu,
      canvas = this._canvas,
      contextPad = this._contextPad,
      rules = this._rules,
      translate = this._translate,
      autoPlace = this._autoPlace;
    var actions = {};
    if (element.type === 'label') {
      return actions;
    }
    var businessObject = element.businessObject;
    function startConnect(event, element, autoActivate) {
      connect.start(event, element, autoActivate);
    }
    function removeElement(e) {
      modeling.removeElements([element]);
    }
    function getReplaceMenuPosition(element) {
      var Y_OFFSET = 5;
      var diagramContainer = canvas.getContainer(),
        pad = contextPad.getPad(element).html;
      var diagramRect = diagramContainer.getBoundingClientRect(),
        padRect = pad.getBoundingClientRect();
      var top = padRect.top - diagramRect.top;
      var left = padRect.left - diagramRect.left;
      var pos = {
        x: left,
        y: top + padRect.height + Y_OFFSET
      };
      return pos;
    }

    /**
    * Create an append action
    *
    * @param {string} type
    * @param {string} className
    * @param {string} title
    * @param {Object} [options]
    *
    * @return {Object} descriptor
    */
    function appendAction(type, className, title, options) {
      function appendStart(event, element) {
        var shape = elementFactory.createShape(assign$4({
          type: type
        }, options));
        create.start(event, shape, {
          source: element,
          hints: {
            connectionTarget: element
          }
        });
      }
      var append = autoPlace ? function (event, element) {
        var shape = elementFactory.createShape(assign$4({
          type: type
        }, options));
        autoPlace.append(element, shape, {
          connectionTarget: element
        });
      } : appendStart;
      return {
        group: 'model',
        className: className,
        title: title,
        action: {
          dragstart: appendStart,
          click: append
        }
      };
    }
    if (is$1(businessObject, 'dmn:Decision')) {
      assign$4(actions, {
        'append.decision': appendAction('dmn:Decision', 'dmn-icon-decision', translate('Append decision'))
      });
    }
    if (isAny(businessObject, ['dmn:BusinessKnowledgeModel', 'dmn:Decision', 'dmn:KnowledgeSource'])) {
      assign$4(actions, {
        'append.knowledge-source': appendAction('dmn:KnowledgeSource', 'dmn-icon-knowledge-source', translate('Append knowledge source'))
      });
    }
    if (isAny(businessObject, ['dmn:BusinessKnowledgeModel', 'dmn:Decision'])) {
      assign$4(actions, {
        'append.business-knowledge-model': appendAction('dmn:BusinessKnowledgeModel', 'dmn-icon-business-knowledge', translate('Append business knowledge model'))
      });
    }
    if (isAny(businessObject, ['dmn:Decision', 'dmn:KnowledgeSource'])) {
      assign$4(actions, {
        'append.input-data': appendAction('dmn:InputData', 'dmn-icon-input-data', translate('Append input data'))
      });
    }
    if (is$1(businessObject, 'dmn:DRGElement')) {
      assign$4(actions, {
        'append.text-annotation': appendAction('dmn:TextAnnotation', 'dmn-icon-text-annotation'),
        'connect': {
          group: 'connect',
          className: 'dmn-icon-connection-multi',
          title: translate('Connect using authority/information/knowledge requirement or association'),
          action: {
            click: startConnect,
            dragstart: startConnect
          }
        }
      });
    }
    if (is$1(businessObject, 'dmn:TextAnnotation')) {
      assign$4(actions, {
        'connect': {
          group: 'connect',
          className: 'dmn-icon-connection-multi',
          title: translate('Connect using association'),
          action: {
            click: startConnect,
            dragstart: startConnect
          }
        }
      });
    }
    if (!popupMenu.isEmpty(element, 'dmn-replace')) {
      // Replace menu entry
      assign$4(actions, {
        'replace': {
          group: 'edit',
          className: 'dmn-icon-screw-wrench',
          title: translate('Change type'),
          action: {
            click: function click(event, element) {
              var position = assign$4(getReplaceMenuPosition(element), {
                cursor: {
                  x: event.x,
                  y: event.y
                }
              });
              popupMenu.open(element, 'dmn-replace', position);
            }
          }
        }
      });
    }

    // delete element entry, only show if allowed by rules
    var deleteAllowed = rules.allowed('elements.delete', {
      elements: [element]
    });
    if (isArray$6(deleteAllowed)) {
      // was the element returned as a deletion candidate?
      deleteAllowed = deleteAllowed[0] === element;
    }
    if (deleteAllowed) {
      assign$4(actions, {
        'delete': {
          group: 'edit',
          className: 'dmn-icon-trash',
          title: translate('Remove'),
          action: {
            click: removeElement
          }
        }
      });
    }
    return actions;
  };

  var ContextPadModule = {
    __depends__: [TranslateModule, DiagramContextPad, SelectionModule, DiagramConnect, DiagramCreate, PopupMenu],
    __init__: ['contextPadProvider'],
    contextPadProvider: ['type', ContextPadProvider]
  };

  /**
   * @typedef {import('../../model/Types').Element} Element
   * @typedef {import('../../model/Types').Connection} Connection
   * @typedef {import('../../model/Types').Shape} Shape
   *
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/ElementFactory').default} ElementFactory
   * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory
   */

  var MARKER_CONNECTION_PREVIEW = 'djs-dragger';

  /**
   * Draws connection preview. Optionally, this can use layouter and connection docking to draw
   * better looking previews.
   *
   * @param {Injector} injector
   * @param {Canvas} canvas
   * @param {GraphicsFactory} graphicsFactory
   * @param {ElementFactory} elementFactory
   */
  function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {
    this._canvas = canvas;
    this._graphicsFactory = graphicsFactory;
    this._elementFactory = elementFactory;

    // optional components
    this._connectionDocking = injector.get('connectionDocking', false);
    this._layouter = injector.get('layouter', false);
  }
  ConnectionPreview.$inject = ['injector', 'canvas', 'graphicsFactory', 'elementFactory'];

  /**
   * Draw connection preview.
   *
   * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.
   * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.
   *
   * @param {Object} context
   * @param {Object|boolean} canConnect
   * @param {Object} hints
   * @param {Element} [hints.source] source element
   * @param {Element} [hints.target] target element
   * @param {Point} [hints.connectionStart] connection preview start
   * @param {Point} [hints.connectionEnd] connection preview end
   * @param {Point[]} [hints.waypoints] provided waypoints for preview
   * @param {boolean} [hints.noLayout] true if preview should not be laid out
   * @param {boolean} [hints.noCropping] true if preview should not be cropped
   * @param {boolean} [hints.noNoop] true if simple connection should not be drawn
   */
  ConnectionPreview.prototype.drawPreview = function (context, canConnect, hints) {
    hints = hints || {};
    var connectionPreviewGfx = context.connectionPreviewGfx,
      getConnection = context.getConnection,
      source = hints.source,
      target = hints.target,
      waypoints = hints.waypoints,
      connectionStart = hints.connectionStart,
      connectionEnd = hints.connectionEnd,
      noLayout = hints.noLayout,
      noCropping = hints.noCropping,
      noNoop = hints.noNoop,
      connection;
    var self = this;
    if (!connectionPreviewGfx) {
      connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
    }
    clear(connectionPreviewGfx);
    if (!getConnection) {
      getConnection = context.getConnection = cacheReturnValues(function (canConnect, source, target) {
        return self.getConnection(canConnect, source, target);
      });
    }
    if (canConnect) {
      connection = getConnection(canConnect, source, target);
    }
    if (!connection) {
      !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
      return;
    }
    connection.waypoints = waypoints || [];

    // optional layout
    if (this._layouter && !noLayout) {
      connection.waypoints = this._layouter.layoutConnection(connection, {
        source: source,
        target: target,
        connectionStart: connectionStart,
        connectionEnd: connectionEnd,
        waypoints: hints.waypoints || connection.waypoints
      });
    }

    // fallback if no waypoints were provided nor created with layouter
    if (!connection.waypoints || !connection.waypoints.length) {
      connection.waypoints = [source ? getMid(source) : connectionStart, target ? getMid(target) : connectionEnd];
    }

    // optional cropping
    if (this._connectionDocking && (source || target) && !noCropping) {
      connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
    }
    this._graphicsFactory.drawConnection(connectionPreviewGfx, connection, {
      stroke: 'var(--element-dragger-color)'
    });
  };

  /**
   * Draw simple connection between source and target or provided points.
   *
   * @param {SVGElement} connectionPreviewGfx container for the connection
   * @param {Object} hints
   * @param {Element} [hints.source] source element
   * @param {Element} [hints.target] target element
   * @param {Point} [hints.connectionStart] required if source is not provided
   * @param {Point} [hints.connectionEnd] required if target is not provided
   */
  ConnectionPreview.prototype.drawNoopPreview = function (connectionPreviewGfx, hints) {
    var source = hints.source,
      target = hints.target,
      start = hints.connectionStart || getMid(source),
      end = hints.connectionEnd || getMid(target);
    var waypoints = this.cropWaypoints(start, end, source, target);
    var connection = this.createNoopConnection(waypoints[0], waypoints[1]);
    append(connectionPreviewGfx, connection);
  };

  /**
   * Return cropped waypoints.
   *
   * @param {Point} start
   * @param {Point} end
   * @param {Element} source
   * @param {Element} target
   *
   * @return {Point[]}
   */
  ConnectionPreview.prototype.cropWaypoints = function (start, end, source, target) {
    var graphicsFactory = this._graphicsFactory,
      sourcePath = source && graphicsFactory.getShapePath(source),
      targetPath = target && graphicsFactory.getShapePath(target),
      connectionPath = graphicsFactory.getConnectionPath({
        waypoints: [start, end]
      });
    start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;
    end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;
    return [start, end];
  };

  /**
   * Remove connection preview container if it exists.
   *
   * @param {Object} [context]
   * @param {SVGElement} [context.connectionPreviewGfx] preview container
   */
  ConnectionPreview.prototype.cleanUp = function (context) {
    if (context && context.connectionPreviewGfx) {
      remove$3(context.connectionPreviewGfx);
    }
  };

  /**
   * Get connection that connects source and target.
   *
   * @param {Object|boolean} canConnect
   *
   * @return {Connection}
   */
  ConnectionPreview.prototype.getConnection = function (canConnect) {
    var attrs = ensureConnectionAttrs(canConnect);
    return this._elementFactory.createConnection(attrs);
  };

  /**
   * Add and return preview graphics.
   *
   * @return {SVGElement}
   */
  ConnectionPreview.prototype.createConnectionPreviewGfx = function () {
    var gfx = create$2('g');
    attr(gfx, {
      pointerEvents: 'none'
    });
    classes(gfx).add(MARKER_CONNECTION_PREVIEW);
    append(this._canvas.getActiveLayer(), gfx);
    return gfx;
  };

  /**
   * Create and return simple connection.
   *
   * @param {Point} start
   * @param {Point} end
   *
   * @return {SVGElement}
   */
  ConnectionPreview.prototype.createNoopConnection = function (start, end) {
    return createLine([start, end], {
      'stroke': '#333',
      'strokeDasharray': [1],
      'strokeWidth': 2,
      'pointer-events': 'none'
    });
  };

  // helpers //////////

  /**
   * Returns function that returns cached return values referenced by stringified first argument.
   *
   * @param {Function} fn
   *
   * @return {Function}
   */
  function cacheReturnValues(fn) {
    var returnValues = {};

    /**
     * Return cached return value referenced by stringified first argument.
     *
     * @return {*}
     */
    return function (firstArgument) {
      var key = JSON.stringify(firstArgument);
      var returnValue = returnValues[key];
      if (!returnValue) {
        returnValue = returnValues[key] = fn.apply(null, arguments);
      }
      return returnValue;
    };
  }

  /**
   * Ensure connection attributes is object.
   *
   * @param {Object|boolean} canConnect
   *
   * @return {Object}
   */
  function ensureConnectionAttrs(canConnect) {
    if (isObject$2(canConnect)) {
      return canConnect;
    } else {
      return {};
    }
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var ConnectPreviewModule = {
    __init__: ['connectionPreview'],
    connectionPreview: ['type', ConnectionPreview]
  };

  var SPACE_REGEX = /\s/;

  // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
  var QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;

  // for ID validation as per BPMN Schema (QName - Namespace)
  var ID_REGEX = /^[a-z_][\w-.]*$/i;
  var PLACEHOLDER_REGEX = /\$\{([^}]*)\}/g;

  /**
   * Validates an ID.
   *
   * @param {ModdleElement} businessObject
   * @param {string} id
   *
   * @return {string} error message
   */
  function validateId(businessObject, id) {
    var assigned = businessObject.$model.ids.assigned(id);
    var idExists = assigned && assigned !== businessObject;
    if (!id) {
      return 'Element must have ID.';
    }
    if (idExists) {
      return 'Element must have unique ID.';
    }
    return validateIdFormat(id);
  }
  function validateIdFormat(id) {
    id = stripPlaceholders(id);
    if (containsSpace(id)) {
      return 'Id must not contain spaces.';
    }
    if (!ID_REGEX.test(id)) {
      if (QNAME_REGEX.test(id)) {
        return 'Id must not contain prefix.';
      }
      return 'Id must be a valid QName.';
    }
  }
  function containsSpace(value) {
    return SPACE_REGEX.test(value);
  }
  function stripPlaceholders(id) {
    // replace expression e.g. ${VERSION_TAG}
    // use only the content between ${}
    // for the REGEX check
    return id.replace(PLACEHOLDER_REGEX, '$1');
  }

  var DEBOUNCE_DELAY = 300;
  function DefinitionIdEdit(eventBus, modeling, canvas, definitionPropertiesView, translate) {
    this._eventBus = eventBus;
    this._modeling = modeling;
    this._canvas = canvas;
    this._definitionPropertiesView = definitionPropertiesView;
    this._translate = translate;
    eventBus.on('definitionIdView.create', function (event) {
      this._container = event.html;
      var nameElement = query('.dmn-definitions-name', this._container),
        idElement = query('.dmn-definitions-id', this._container);
      this._setup(nameElement, 'name');
      this._setup(idElement, 'id');
    }, this);
  }
  DefinitionIdEdit.$inject = ['eventBus', 'modeling', 'canvas', 'definitionPropertiesView', 'translate'];
  DefinitionIdEdit.prototype.update = function (type, newValue) {
    var element = this._canvas.getRootElement();
    var newProperties = {};
    newProperties[type] = newValue;
    if (type === 'id') {
      var errorMessage = validateId(getBusinessObject(element), newValue);
      if (errorMessage) {
        this._addErrorMessage(errorMessage);
        return;
      }
      this._clearErrorMessage();
    }
    this._modeling.updateProperties(element, newProperties);
  };
  DefinitionIdEdit.prototype._setup = function (node, type) {
    var self = this;
    node.setAttribute('contenteditable', true);
    node.addEventListener('input', debounce(function (evt) {
      var value = evt.target.value || evt.target.textContent;
      self.update(type, value.trim());
    }, DEBOUNCE_DELAY));
    node.addEventListener('keydown', function (evt) {
      if (evt.keyCode === 13) {
        node.blur();
        window.getSelection().removeAllRanges();
      }
    });
    node.addEventListener('blur', function () {
      self._clearErrorMessage();
      self._definitionPropertiesView.update();
    });
  };
  DefinitionIdEdit.prototype._addErrorMessage = function (errorMessage) {
    var errorHTML = '<span class="dmn-definitions-error-message">' + this._translate(errorMessage) + '</span>';
    var idElement = query('.dmn-definitions-id', this._container);

    // clear previous error message
    this._clearErrorMessage();

    // add current error message
    classes$1(idElement).add('dmn-definitions-error');
    idElement.parentElement.appendChild(domify$1(errorHTML));
  };
  DefinitionIdEdit.prototype._clearErrorMessage = function () {
    var idElement = query('.dmn-definitions-id', this._container);
    if (classes$1(idElement).has('dmn-definitions-error')) {
      classes$1(idElement).remove('dmn-definitions-error');
      var errorLabel = query('.dmn-definitions-error-message', this._container);
      idElement.parentNode.removeChild(errorLabel);
    }
  };

  var DefinitionPropertiesModule = {
    __depends__: [DefinitionPropertiesViewer],
    __init__: ['definitionPropertiesEdit', 'definitionPropertiesPaletteAdapter'],
    definitionPropertiesEdit: ['type', DefinitionIdEdit],
    definitionPropertiesPaletteAdapter: ['type', PaletteAdapter]
  };

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../util/Types').Axis} Axis
   * @typedef {import('../../util/Types').Dimension} Dimension
   * @typedef {import('../../util/Types').Rect} Rect
   *
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   *
   * @typedef { {
   *   min: number;
   *   max: number;
   * } } Range
   *
   * @typedef { {
   *   elements: Element[];
   *   range: Range;
   * } } Group
   */

  var AXIS_DIMENSIONS = {
    horizontal: ['x', 'width'],
    vertical: ['y', 'height']
  };
  var THRESHOLD = 5;

  /**
   * Groups and filters elements and then trigger even distribution.
   *
   * @param {Modeling} modeling
   * @param {Rules} rules
   */
  function DistributeElements$1(modeling, rules) {
    this._modeling = modeling;
    this._filters = [];
    this.registerFilter(function (elements) {
      var allowed = rules.allowed('elements.distribute', {
        elements: elements
      });
      if (isArray$6(allowed)) {
        return allowed;
      }
      return allowed ? elements : [];
    });
  }
  DistributeElements$1.$inject = ['modeling', 'rules'];

  /**
   * Registers filter functions that allow external parties to filter
   * out certain elements.
   *
   * @param {(distributableElements: Element[], axis: Axis, dimension: Dimension) => Element[]} filterFn
   */
  DistributeElements$1.prototype.registerFilter = function (filterFn) {
    if (typeof filterFn !== 'function') {
      throw new Error('the filter has to be a function');
    }
    this._filters.push(filterFn);
  };

  /**
   * Distributes the elements with a given orientation
   *
   * @param {Element[]} elements
   * @param {string} orientation
   */
  DistributeElements$1.prototype.trigger = function (elements, orientation) {
    var modeling = this._modeling;
    var groups, distributableElements;
    if (elements.length < 3) {
      return;
    }
    this._setOrientation(orientation);
    distributableElements = this._filterElements(elements);
    groups = this._createGroups(distributableElements);

    // nothing to distribute
    if (groups.length <= 2) {
      return;
    }
    modeling.distributeElements(groups, this._axis, this._dimension);
    return groups;
  };

  /**
   * Filters the elements with provided filters by external parties
   *
   * @param {Element[]} elements
   *
   * @return {Element[]}
   */
  DistributeElements$1.prototype._filterElements = function (elements) {
    var filters = this._filters,
      axis = this._axis,
      dimension = this._dimension,
      distributableElements = [].concat(elements);
    if (!filters.length) {
      return elements;
    }
    forEach$3(filters, function (filterFn) {
      distributableElements = filterFn(distributableElements, axis, dimension);
    });
    return distributableElements;
  };

  /**
   * Create range (min, max) groups. Also tries to group elements
   * together that share the same range.
   *
   * @example
   *
   * ```javascript
   *   const groups = [
   *     {
   *       range: { min: 100, max: 200 },
   *       elements: [ { id: 'shape1', ... } ]
   *     }
   *   ]
   * ```
   *
   * @param {Element[]} elements
   *
   * @return {Group[]}
   */
  DistributeElements$1.prototype._createGroups = function (elements) {
    var rangeGroups = [],
      self = this,
      axis = this._axis,
      dimension = this._dimension;
    if (!axis) {
      throw new Error('must have a defined "axis" and "dimension"');
    }

    // sort by 'left->right' or 'top->bottom'
    var sortedElements = sortBy(elements, axis);
    forEach$3(sortedElements, function (element, idx) {
      var elementRange = self._findRange(element, axis, dimension),
        range;
      var previous = rangeGroups[rangeGroups.length - 1];
      if (previous && self._hasIntersection(previous.range, elementRange)) {
        rangeGroups[rangeGroups.length - 1].elements.push(element);
      } else {
        range = {
          range: elementRange,
          elements: [element]
        };
        rangeGroups.push(range);
      }
    });
    return rangeGroups;
  };

  /**
   * Maps a direction to the according axis and dimension.
   *
   * @param {'horizontal' | 'vertical'} direction 'horizontal' or 'vertical'
   */
  DistributeElements$1.prototype._setOrientation = function (direction) {
    var orientation = AXIS_DIMENSIONS[direction];
    this._axis = orientation[0];
    this._dimension = orientation[1];
  };

  /**
   * Checks if the two ranges intercept each other.
   *
   * @param {Range} rangeA
   * @param {Range} rangeB
   *
   * @return {boolean}
   */
  DistributeElements$1.prototype._hasIntersection = function (rangeA, rangeB) {
    return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
  };

  /**
   * Returns the min and max values for an element
   *
   * @param {Element} element
   *
   * @return {Range}
   */
  DistributeElements$1.prototype._findRange = function (element) {
    var axis = element[this._axis],
      dimension = element[this._dimension];
    return {
      min: axis + THRESHOLD,
      max: axis + dimension - THRESHOLD
    };
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DistributeElementsModule$1 = {
    __init__: ['distributeElements'],
    distributeElements: ['type', DistributeElements$1]
  };

  /**
   * Registers element exclude filters for elements that
   * currently do not support distribution.
   */
  function DrdDistributeElements(distributeElements) {
    distributeElements.registerFilter(function (elements) {
      return filter$2(elements, function (element) {
        var cannotDistribute = isAny(element, ['dmn:AuthorityRequirement', 'dmn:InformationRequirement', 'dmn:KnowledgeRequirement', 'dmn:Association', 'dmn:TextAnnotation']);
        return !(element.labelTarget || cannotDistribute);
      });
    });
  }
  DrdDistributeElements.$inject = ['distributeElements'];

  var DistributeElementsModule = {
    __depends__: [DistributeElementsModule$1],
    __init__: ['drdDistributeElements'],
    drdDistributeElements: ['type', DrdDistributeElements]
  };

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  var NOT_REGISTERED_ERROR$2 = 'is not a registered action',
    IS_REGISTERED_ERROR$2 = 'is already registered';

  /**
   * An interface that provides access to modeling actions by decoupling
   * the one who requests the action to be triggered and the trigger itself.
   *
   * It's possible to add new actions by registering them with registerAction
   * and likewise unregister existing ones with unregisterAction.
   *
   *
   * ## Life-Cycle and configuration
   *
   * The editor actions will wait for diagram initialization before
   * registering default actions _and_ firing an `editorActions.init` event.
   *
   * Interested parties may listen to the `editorActions.init` event with
   * low priority to check, which actions got registered. Other components
   * may use the event to register their own actions via `registerAction`.
   *
   * @param {EventBus} eventBus
   * @param {Injector} injector
   */
  function EditorActions$3(eventBus, injector) {
    // initialize actions
    this._actions = {};
    var self = this;
    eventBus.on('diagram.init', function () {
      // all diagram modules got loaded; check which ones
      // are available and register the respective default actions
      self._registerDefaultActions(injector);

      // ask interested parties to register available editor
      // actions on diagram initialization
      eventBus.fire('editorActions.init', {
        editorActions: self
      });
    });
  }
  EditorActions$3.$inject = ['eventBus', 'injector'];

  /**
   * Register default actions.
   *
   * @param {Injector} injector
   */
  EditorActions$3.prototype._registerDefaultActions = function (injector) {
    // (1) retrieve optional components to integrate with

    var commandStack = injector.get('commandStack', false);
    var modeling = injector.get('modeling', false);
    var selection = injector.get('selection', false);
    var zoomScroll = injector.get('zoomScroll', false);
    var copyPaste = injector.get('copyPaste', false);
    var canvas = injector.get('canvas', false);
    var rules = injector.get('rules', false);
    var keyboardMove = injector.get('keyboardMove', false);
    var keyboardMoveSelection = injector.get('keyboardMoveSelection', false);

    // (2) check components and register actions

    if (commandStack) {
      this.register('undo', function () {
        commandStack.undo();
      });
      this.register('redo', function () {
        commandStack.redo();
      });
    }
    if (copyPaste && selection) {
      this.register('copy', function () {
        var selectedElements = selection.get();
        if (selectedElements.length) {
          return copyPaste.copy(selectedElements);
        }
      });
    }
    if (copyPaste) {
      this.register('paste', function () {
        copyPaste.paste();
      });
    }
    if (zoomScroll) {
      this.register('stepZoom', function (opts) {
        zoomScroll.stepZoom(opts.value);
      });
    }
    if (canvas) {
      this.register('zoom', function (opts) {
        canvas.zoom(opts.value);
      });
    }
    if (modeling && selection && rules) {
      this.register('removeSelection', function () {
        var selectedElements = selection.get();
        if (!selectedElements.length) {
          return;
        }
        var allowed = rules.allowed('elements.delete', {
            elements: selectedElements
          }),
          removableElements;
        if (allowed === false) {
          return;
        } else if (isArray$6(allowed)) {
          removableElements = allowed;
        } else {
          removableElements = selectedElements;
        }
        if (removableElements.length) {
          modeling.removeElements(removableElements.slice());
        }
      });
    }
    if (keyboardMove) {
      this.register('moveCanvas', function (opts) {
        keyboardMove.moveCanvas(opts);
      });
    }
    if (keyboardMoveSelection) {
      this.register('moveSelection', function (opts) {
        keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
      });
    }
  };

  /**
   * Triggers a registered action
   *
   * @param {string} action
   * @param {Object} opts
   *
   * @return {unknown} Returns what the registered listener returns
   */
  EditorActions$3.prototype.trigger = function (action, opts) {
    if (!this._actions[action]) {
      throw error$2(action, NOT_REGISTERED_ERROR$2);
    }
    return this._actions[action](opts);
  };

  /**
   * Registers a collections of actions.
   * The key of the object will be the name of the action.
   *
   * @example
   *
   * ```javascript
   * var actions = {
   *   spaceTool: function() {
   *     spaceTool.activateSelection();
   *   },
   *   lassoTool: function() {
   *     lassoTool.activateSelection();
   *   }
   * ];
   *
   * editorActions.register(actions);
   *
   * editorActions.isRegistered('spaceTool'); // true
   * ```
   *
   * @param {Object} actions
   */
  EditorActions$3.prototype.register = function (actions, listener) {
    var self = this;
    if (typeof actions === 'string') {
      return this._registerAction(actions, listener);
    }
    forEach$3(actions, function (listener, action) {
      self._registerAction(action, listener);
    });
  };

  /**
   * Registers a listener to an action key
   *
   * @param {string} action
   * @param {Function} listener
   */
  EditorActions$3.prototype._registerAction = function (action, listener) {
    if (this.isRegistered(action)) {
      throw error$2(action, IS_REGISTERED_ERROR$2);
    }
    this._actions[action] = listener;
  };

  /**
   * Unregister an existing action
   *
   * @param {string} action
   */
  EditorActions$3.prototype.unregister = function (action) {
    if (!this.isRegistered(action)) {
      throw error$2(action, NOT_REGISTERED_ERROR$2);
    }
    this._actions[action] = undefined;
  };

  /**
   * Returns the number of actions that are currently registered
   *
   * @return {number}
   */
  EditorActions$3.prototype.getActions = function () {
    return Object.keys(this._actions);
  };

  /**
   * Checks wether the given action is registered
   *
   * @param {string} action
   *
   * @return {boolean}
   */
  EditorActions$3.prototype.isRegistered = function (action) {
    return !!this._actions[action];
  };
  function error$2(action, message) {
    return new Error(action + ' ' + message);
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var EditorActionsModule$1 = {
    __init__: ['editorActions'],
    editorActions: ['type', EditorActions$3]
  };

  function DrdEditorActions(injector) {
    injector.invoke(EditorActions$3, this);
  }
  e$2(DrdEditorActions, EditorActions$3);
  DrdEditorActions.$inject = ['injector'];

  /**
   * Register default actions.
   *
   * @param {Injector} injector
   */
  DrdEditorActions.prototype._registerDefaultActions = function (injector) {
    // (0) invoke super method

    EditorActions$3.prototype._registerDefaultActions.call(this, injector);

    // (1) retrieve optional components to integrate with

    var canvas = injector.get('canvas', false),
      elementRegistry = injector.get('elementRegistry', false),
      selection = injector.get('selection', false),
      lassoTool = injector.get('lassoTool', false),
      handTool = injector.get('handTool', false),
      directEditing = injector.get('directEditing', false),
      distributeElements = injector.get('distributeElements', false),
      alignElements = injector.get('alignElements', false),
      searchPad = injector.get('searchPad', false);

    // (2) check components and register actions

    if (canvas && elementRegistry && selection) {
      this._registerAction('selectElements', function () {
        // select all elements except for the invisible
        // root element
        var rootElement = canvas.getRootElement();
        var elements = elementRegistry.filter(function (element) {
          return element !== rootElement;
        });
        selection.select(elements);
        return elements;
      });
    }
    if (selection && distributeElements) {
      this._registerAction('distributeElements', function (opts) {
        var currentSelection = selection.get(),
          type = opts.type;
        if (currentSelection.length > 2) {
          distributeElements.trigger(currentSelection, type);
        }
      });
    }
    if (selection && alignElements) {
      this._registerAction('alignElements', function (opts) {
        var currentSelection = selection.get(),
          type = opts.type;
        if (currentSelection.length > 1) {
          alignElements.trigger(currentSelection, type);
        }
      });
    }
    if (lassoTool) {
      this._registerAction('lassoTool', function () {
        lassoTool.toggle();
      });
    }
    if (handTool) {
      this._registerAction('handTool', function () {
        handTool.toggle();
      });
    }
    if (selection && directEditing) {
      this._registerAction('directEditing', function () {
        var currentSelection = selection.get();
        if (currentSelection.length) {
          directEditing.activate(currentSelection[0]);
        }
      });
    }
    if (selection && searchPad) {
      this._registerAction('find', function () {
        searchPad.toggle();
      });
    }
  };

  var EditorActionsModule = {
    __depends__: [EditorActionsModule$1],
    editorActions: ['type', DrdEditorActions]
  };

  /**
   * Does the definitions element contain graphical information?
   *
   * @param  {ModdleElement} definitions
   *
   * @return {boolean} true, if the definitions contains graphical information
   */
  function containsDi(definitions) {
    return definitions.dmnDI && definitions.dmnDI.diagrams && definitions.dmnDI.diagrams[0];
  }

  /**
   * Generates missing DI on import.
   *
   * @param {DrdFactory} drdFactory
   * @param {ElementFactory} elementFactory
   * @param {EventBus} eventBus
   */
  function DiGenerator(drdFactory, elementFactory, eventBus, drdUpdater) {
    function createDi(definitions) {
      // retrieve or create dmnDI
      var dmnDI = definitions.dmnDI;
      if (!dmnDI) {
        dmnDI = drdFactory.create('dmndi:DMNDI');
        definitions.set('dmnDI', dmnDI);
      }
      var diagram = drdFactory.create('dmndi:DMNDiagram');
      dmnDI.set('diagrams', [diagram]);
      var index = 0;
      forEach$3(definitions.get('drgElement'), function (drgElement) {
        // generate DI for decisions only
        if (!is$1(drgElement, 'dmn:Decision')) {
          return;
        }
        var dimensions = elementFactory._getDefaultSize(drgElement);
        var di = drdFactory.createDiShape(drgElement, {
          x: 150 + index * 30,
          y: 150 + index * 30,
          width: dimensions.width,
          height: dimensions.height
        });
        drdUpdater.updateDiParent(di, diagram);
        index++;
      });
    }
    eventBus.on('import.start', function (_ref) {
      var definitions = _ref.definitions;
      if (!containsDi(definitions)) {
        createDi(definitions);
      }
    });
  }
  DiGenerator.$inject = ['drdFactory', 'elementFactory', 'eventBus', 'drdUpdater'];

  var GenerateDiModule = {
    __init__: ['diGenerator'],
    diGenerator: ['type', DiGenerator]
  };

  var SPACING = 10;
  function quantize(value, quantum, fn) {
    if (!fn) {
      fn = 'round';
    }
    return Math[fn](value / quantum) * quantum;
  }

  /**
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  var LOWER_PRIORITY$1 = 1200;
  var LOW_PRIORITY$g = 800;

  /**
   * Basic grid snapping that covers connecting, creating, moving, resizing shapes, moving bendpoints
   * and connection segments.
   *
   * @param {ElementRegistry} elementRegistry
   * @param {EventBus} eventBus
   * @param {Object} config
   */
  function GridSnapping(elementRegistry, eventBus, config) {
    var active = !config || config.active !== false;
    this._eventBus = eventBus;
    var self = this;
    eventBus.on('diagram.init', LOW_PRIORITY$g, function () {
      self.setActive(active);
    });
    eventBus.on(['create.move', 'create.end', 'bendpoint.move.move', 'bendpoint.move.end', 'connect.move', 'connect.end', 'connectionSegment.move.move', 'connectionSegment.move.end', 'resize.move', 'resize.end', 'shape.move.move', 'shape.move.end'], LOWER_PRIORITY$1, function (event) {
      var originalEvent = event.originalEvent;
      if (!self.active || originalEvent && isCmd$5(originalEvent)) {
        return;
      }
      var context = event.context,
        gridSnappingContext = context.gridSnappingContext;
      if (!gridSnappingContext) {
        gridSnappingContext = context.gridSnappingContext = {};
      }
      ['x', 'y'].forEach(function (axis) {
        var options = {};

        // allow snapping with offset
        var snapOffset = getSnapOffset(event, axis, elementRegistry);
        if (snapOffset) {
          options.offset = snapOffset;
        }

        // allow snapping with min and max
        var snapConstraints = getSnapConstraints(event, axis);
        if (snapConstraints) {
          assign$4(options, snapConstraints);
        }
        if (!isSnapped(event, axis)) {
          self.snapEvent(event, axis, options);
        }
      });
    });
  }

  /**
   * Snap an events x or y with optional min, max and offset.
   *
   * @param {Object} event
   * @param {string} axis
   * @param {number} [options.min]
   * @param {number} [options.max]
   * @param {number} [options.offset]
   */
  GridSnapping.prototype.snapEvent = function (event, axis, options) {
    var snappedValue = this.snapValue(event[axis], options);
    setSnapped(event, axis, snappedValue);
  };

  /**
   * Expose grid spacing for third parties (i.e. extensions).
   *
   * @return {number} spacing of grid dots
   */
  GridSnapping.prototype.getGridSpacing = function () {
    return SPACING;
  };

  /**
   * Snap value with optional min, max and offset.
   *
   * @param {number} value
   * @param {Object} options
   * @param {number} [options.min]
   * @param {number} [options.max]
   * @param {number} [options.offset]
   */
  GridSnapping.prototype.snapValue = function (value, options) {
    var offset = 0;
    if (options && options.offset) {
      offset = options.offset;
    }
    value += offset;
    value = quantize(value, SPACING);
    var min, max;
    if (options && options.min) {
      min = options.min;
      if (isNumber$3(min)) {
        min = quantize(min + offset, SPACING, 'ceil');
        value = Math.max(value, min);
      }
    }
    if (options && options.max) {
      max = options.max;
      if (isNumber$3(max)) {
        max = quantize(max + offset, SPACING, 'floor');
        value = Math.min(value, max);
      }
    }
    value -= offset;
    return value;
  };
  GridSnapping.prototype.isActive = function () {
    return this.active;
  };
  GridSnapping.prototype.setActive = function (active) {
    this.active = active;
    this._eventBus.fire('gridSnapping.toggle', {
      active: active
    });
  };
  GridSnapping.prototype.toggleActive = function () {
    this.setActive(!this.active);
  };
  GridSnapping.$inject = ['elementRegistry', 'eventBus', 'config.gridSnapping'];

  // helpers //////////

  /**
   * Get minimum and maximum snap constraints.
   * Constraints are cached.
   *
   * @param {Object} event
   * @param {Object} event.context
   * @param {string} axis
   *
   * @return {boolean|Object}
   */
  function getSnapConstraints(event, axis) {
    var context = event.context,
      createConstraints = context.createConstraints,
      resizeConstraints = context.resizeConstraints || {},
      gridSnappingContext = context.gridSnappingContext,
      snapConstraints = gridSnappingContext.snapConstraints;

    // cache snap constraints
    if (snapConstraints && snapConstraints[axis]) {
      return snapConstraints[axis];
    }
    if (!snapConstraints) {
      snapConstraints = gridSnappingContext.snapConstraints = {};
    }
    if (!snapConstraints[axis]) {
      snapConstraints[axis] = {};
    }
    var direction = context.direction;

    // create
    if (createConstraints) {
      if (isHorizontal$1(axis)) {
        snapConstraints.x.min = createConstraints.left;
        snapConstraints.x.max = createConstraints.right;
      } else {
        snapConstraints.y.min = createConstraints.top;
        snapConstraints.y.max = createConstraints.bottom;
      }
    }

    // resize
    var minResizeConstraints = resizeConstraints.min,
      maxResizeConstraints = resizeConstraints.max;
    if (minResizeConstraints) {
      if (isHorizontal$1(axis)) {
        if (isWest(direction)) {
          snapConstraints.x.max = minResizeConstraints.left;
        } else {
          snapConstraints.x.min = minResizeConstraints.right;
        }
      } else {
        if (isNorth(direction)) {
          snapConstraints.y.max = minResizeConstraints.top;
        } else {
          snapConstraints.y.min = minResizeConstraints.bottom;
        }
      }
    }
    if (maxResizeConstraints) {
      if (isHorizontal$1(axis)) {
        if (isWest(direction)) {
          snapConstraints.x.min = maxResizeConstraints.left;
        } else {
          snapConstraints.x.max = maxResizeConstraints.right;
        }
      } else {
        if (isNorth(direction)) {
          snapConstraints.y.min = maxResizeConstraints.top;
        } else {
          snapConstraints.y.max = maxResizeConstraints.bottom;
        }
      }
    }
    return snapConstraints[axis];
  }

  /**
   * Get snap offset.
   * Offset is cached.
   *
   * @param {Object} event
   * @param {string} axis
   * @param {ElementRegistry} elementRegistry
   *
   * @return {number}
   */
  function getSnapOffset(event, axis, elementRegistry) {
    var context = event.context,
      shape = event.shape,
      gridSnappingContext = context.gridSnappingContext,
      snapLocation = gridSnappingContext.snapLocation,
      snapOffset = gridSnappingContext.snapOffset;

    // cache snap offset
    if (snapOffset && isNumber$3(snapOffset[axis])) {
      return snapOffset[axis];
    }
    if (!snapOffset) {
      snapOffset = gridSnappingContext.snapOffset = {};
    }
    if (!isNumber$3(snapOffset[axis])) {
      snapOffset[axis] = 0;
    }
    if (!shape) {
      return snapOffset[axis];
    }
    if (!elementRegistry.get(shape.id)) {
      if (isHorizontal$1(axis)) {
        snapOffset[axis] += shape[axis] + shape.width / 2;
      } else {
        snapOffset[axis] += shape[axis] + shape.height / 2;
      }
    }
    if (!snapLocation) {
      return snapOffset[axis];
    }
    if (axis === 'x') {
      if (/left/.test(snapLocation)) {
        snapOffset[axis] -= shape.width / 2;
      } else if (/right/.test(snapLocation)) {
        snapOffset[axis] += shape.width / 2;
      }
    } else {
      if (/top/.test(snapLocation)) {
        snapOffset[axis] -= shape.height / 2;
      } else if (/bottom/.test(snapLocation)) {
        snapOffset[axis] += shape.height / 2;
      }
    }
    return snapOffset[axis];
  }
  function isHorizontal$1(axis) {
    return axis === 'x';
  }
  function isNorth(direction) {
    return direction.indexOf('n') !== -1;
  }
  function isWest(direction) {
    return direction.indexOf('w') !== -1;
  }

  /**
   * @typedef {import('../core/Types').ElementLike} ElementLike
   * @typedef {import('../core/EventBus').default} EventBus
   * @typedef {import('./CommandStack').CommandContext} CommandContext
   *
   * @typedef {string|string[]} Events
   * @typedef { (context: CommandContext) => ElementLike[] | void } HandlerFunction
   * @typedef { (context: CommandContext) => void } ComposeHandlerFunction
   */

  var DEFAULT_PRIORITY$4 = 1000;

  /**
   * A utility that can be used to plug into the command execution for
   * extension and/or validation.
   *
   * @class
   * @constructor
   *
   * @example
   *
   * ```javascript
   * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';
   *
   * class CommandLogger extends CommandInterceptor {
   *   constructor(eventBus) {
   *     super(eventBus);
   *
   *   this.preExecute('shape.create', (event) => {
   *     console.log('commandStack.shape-create.preExecute', event);
   *   });
   * }
   * ```
   *
   * @param {EventBus} eventBus
   */
  function CommandInterceptor(eventBus) {
    /**
     * @type {EventBus}
     */
    this._eventBus = eventBus;
  }
  CommandInterceptor.$inject = ['eventBus'];
  function unwrapEvent(fn, that) {
    return function (event) {
      return fn.call(that || null, event.context, event.command, event);
    };
  }

  /**
   * Intercept a command during one of the phases.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {string} [hook] phase to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.on = function (events, hook, priority, handlerFn, unwrap, that) {
    if (isFunction$2(hook) || isNumber$3(hook)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = hook;
      hook = null;
    }
    if (isFunction$2(priority)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = DEFAULT_PRIORITY$4;
    }
    if (isObject$2(unwrap)) {
      that = unwrap;
      unwrap = false;
    }
    if (!isFunction$2(handlerFn)) {
      throw new Error('handlerFn must be a function');
    }
    if (!isArray$6(events)) {
      events = [events];
    }
    var eventBus = this._eventBus;
    forEach$3(events, function (event) {
      // concat commandStack(.event)?(.hook)?
      var fullEvent = ['commandStack', event, hook].filter(function (e) {
        return e;
      }).join('.');
      eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
    });
  };

  /**
   * Add a <canExecute> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.canExecute = createHook('canExecute');

  /**
   * Add a <preExecute> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.preExecute = createHook('preExecute');

  /**
   * Add a <preExecuted> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.preExecuted = createHook('preExecuted');

  /**
   * Add a <execute> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.execute = createHook('execute');

  /**
   * Add a <executed> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.executed = createHook('executed');

  /**
   * Add a <postExecute> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.postExecute = createHook('postExecute');

  /**
   * Add a <postExecuted> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.postExecuted = createHook('postExecuted');

  /**
   * Add a <revert> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.revert = createHook('revert');

  /**
   * Add a <reverted> phase of command interceptor.
   *
   * @param {Events} [events] command(s) to intercept
   * @param {number} [priority]
   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
   * @param {boolean} [unwrap] whether the event should be unwrapped
   * @param {any} [that]
   */
  CommandInterceptor.prototype.reverted = createHook('reverted');

  /*
   * Add prototype methods for each phase of command execution (e.g. execute,
   * revert).
   *
   * @param {string} hook
   *
   * @return { (
   *   events?: Events,
   *   priority?: number,
   *   handlerFn: ComposeHandlerFunction|HandlerFunction,
   *   unwrap?: boolean
   * ) => any }
   */
  function createHook(hook) {
    /**
     * @this {CommandInterceptor}
     *
     * @param {Events} [events]
     * @param {number} [priority]
     * @param {ComposeHandlerFunction|HandlerFunction} handlerFn
     * @param {boolean} [unwrap]
     * @param {any} [that]
     */
    var hookFn = function hookFn(events, priority, handlerFn, unwrap, that) {
      if (isFunction$2(events) || isNumber$3(events)) {
        that = unwrap;
        unwrap = handlerFn;
        handlerFn = priority;
        priority = events;
        events = null;
      }
      this.on(events, hook, priority, handlerFn, unwrap, that);
    };
    return hookFn;
  }

  /**
   * @typedef {import('../../../model/Types').Shape} Shape
   *
   * @typedef {import('../../../util/Types').Rect} Rect
   *
   * @typedef {import('../../../core/EventBus').default} EventBus
   * @typedef {import('../../grid-snapping/GridSnapping').default} GridSnapping
   */

  /**
   * Integrates resizing with grid snapping.
   *
   * @param {EventBus} eventBus
   * @param {GridSnapping} gridSnapping
   */
  function ResizeBehavior(eventBus, gridSnapping) {
    CommandInterceptor.call(this, eventBus);
    this._gridSnapping = gridSnapping;
    var self = this;
    this.preExecute('shape.resize', function (event) {
      var context = event.context,
        hints = context.hints || {},
        autoResize = hints.autoResize;
      if (!autoResize) {
        return;
      }
      var shape = context.shape,
        newBounds = context.newBounds;
      if (isString$4(autoResize)) {
        context.newBounds = self.snapComplex(newBounds, autoResize);
      } else {
        context.newBounds = self.snapSimple(shape, newBounds);
      }
    });
  }
  ResizeBehavior.$inject = ['eventBus', 'gridSnapping', 'modeling'];
  e$2(ResizeBehavior, CommandInterceptor);

  /**
   * Snap width and height in relation to center.
   *
   * @param {Shape} shape
   * @param {Rect} newBounds
   *
   * @return {Rect} Snapped bounds.
   */
  ResizeBehavior.prototype.snapSimple = function (shape, newBounds) {
    var gridSnapping = this._gridSnapping;
    newBounds.width = gridSnapping.snapValue(newBounds.width, {
      min: newBounds.width
    });
    newBounds.height = gridSnapping.snapValue(newBounds.height, {
      min: newBounds.height
    });
    newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;
    newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;
    return newBounds;
  };

  /**
   * Snap x, y, width and height according to given directions.
   *
   * @param {Rect} newBounds
   * @param {string} directions - Directions as {n|w|s|e}.
   *
   * @return {Rect} Snapped bounds.
   */
  ResizeBehavior.prototype.snapComplex = function (newBounds, directions) {
    if (/w|e/.test(directions)) {
      newBounds = this.snapHorizontally(newBounds, directions);
    }
    if (/n|s/.test(directions)) {
      newBounds = this.snapVertically(newBounds, directions);
    }
    return newBounds;
  };

  /**
   * Snap in one or both directions horizontally.
   *
   * @param {Rect} newBounds
   * @param {string} directions - Directions as {n|w|s|e}.
   *
   * @return {Rect} Snapped bounds.
   */
  ResizeBehavior.prototype.snapHorizontally = function (newBounds, directions) {
    var gridSnapping = this._gridSnapping,
      west = /w/.test(directions),
      east = /e/.test(directions);
    var snappedNewBounds = {};
    snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {
      min: newBounds.width
    });
    if (east) {
      // handle <we>
      if (west) {
        snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {
          max: newBounds.x
        });
        snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {
          min: newBounds.x - snappedNewBounds.x
        });
      }

      // handle <e>
      else {
        newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;
      }
    }

    // assign snapped x and width
    assign$4(newBounds, snappedNewBounds);
    return newBounds;
  };

  /**
   * Snap in one or both directions vertically.
   *
   * @param {Rect} newBounds
   * @param {string} directions - Directions as {n|w|s|e}.
   *
   * @return {Rect} Snapped bounds.
   */
  ResizeBehavior.prototype.snapVertically = function (newBounds, directions) {
    var gridSnapping = this._gridSnapping,
      north = /n/.test(directions),
      south = /s/.test(directions);
    var snappedNewBounds = {};
    snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {
      min: newBounds.height
    });
    if (north) {
      // handle <ns>
      if (south) {
        snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {
          max: newBounds.y
        });
        snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {
          min: newBounds.y - snappedNewBounds.y
        });
      }

      // handle <n>
      else {
        newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;
      }
    }

    // assign snapped y and height
    assign$4(newBounds, snappedNewBounds);
    return newBounds;
  };

  /**
   * @typedef {import('../../../core/EventBus').default} EventBus
   * @typedef {import('../../grid-snapping/GridSnapping').default} GridSnapping
   */

  var HIGH_PRIORITY$7 = 2000;

  /**
   * Integrates space tool with grid snapping.
   *
   * @param {EventBus} eventBus
   * @param {GridSnapping} gridSnapping
   */
  function SpaceToolBehavior(eventBus, gridSnapping) {
    eventBus.on(['spaceTool.move', 'spaceTool.end'], HIGH_PRIORITY$7, function (event) {
      var context = event.context;
      if (!context.initialized) {
        return;
      }
      var axis = context.axis;
      var snapped;
      if (axis === 'x') {
        // snap delta x to multiple of 10
        snapped = gridSnapping.snapValue(event.dx);
        event.x = event.x + snapped - event.dx;
        event.dx = snapped;
      } else {
        // snap delta y to multiple of 10
        snapped = gridSnapping.snapValue(event.dy);
        event.y = event.y + snapped - event.dy;
        event.dy = snapped;
      }
    });
  }
  SpaceToolBehavior.$inject = ['eventBus', 'gridSnapping'];

  var GridSnappingBehaviorModule = {
    __init__: ['gridSnappingResizeBehavior', 'gridSnappingSpaceToolBehavior'],
    gridSnappingResizeBehavior: ['type', ResizeBehavior],
    gridSnappingSpaceToolBehavior: ['type', SpaceToolBehavior]
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var GridSnappingModule = {
    __depends__: [GridSnappingBehaviorModule],
    __init__: ['gridSnapping'],
    gridSnapping: ['type', GridSnapping]
  };

  /**
   * @typedef {import('../../core/EventBus').default} EventBus
   *
   * @typedef {({ keyEvent: KeyboardEvent }) => any} Listener
   */

  var KEYDOWN_EVENT = 'keyboard.keydown',
    KEYUP_EVENT = 'keyboard.keyup';
  var HANDLE_MODIFIER_ATTRIBUTE = 'input-handle-modified-keys';
  var DEFAULT_PRIORITY$3 = 1000;

  /**
   * A keyboard abstraction that may be activated and
   * deactivated by users at will, consuming global key events
   * and triggering diagram actions.
   *
   * For keys pressed down, keyboard fires `keyboard.keydown` event.
   * The event context contains one field which is `KeyboardEvent` event.
   *
   * The implementation fires the following key events that allow
   * other components to hook into key handling:
   *
   *  - keyboard.bind
   *  - keyboard.unbind
   *  - keyboard.init
   *  - keyboard.destroy
   *
   * All events contain one field which is node.
   *
   * A default binding for the keyboard may be specified via the
   * `keyboard.bindTo` configuration option.
   *
   * @param {Object} config
   * @param {EventTarget} [config.bindTo]
   * @param {EventBus} eventBus
   */
  function Keyboard$2(config, eventBus) {
    var self = this;
    this._config = config || {};
    this._eventBus = eventBus;
    this._keydownHandler = this._keydownHandler.bind(this);
    this._keyupHandler = this._keyupHandler.bind(this);

    // properly clean dom registrations
    eventBus.on('diagram.destroy', function () {
      self._fire('destroy');
      self.unbind();
    });
    eventBus.on('diagram.init', function () {
      self._fire('init');
    });
    eventBus.on('attach', function () {
      if (config && config.bindTo) {
        self.bind(config.bindTo);
      }
    });
    eventBus.on('detach', function () {
      self.unbind();
    });
  }
  Keyboard$2.$inject = ['config.keyboard', 'eventBus'];
  Keyboard$2.prototype._keydownHandler = function (event) {
    this._keyHandler(event, KEYDOWN_EVENT);
  };
  Keyboard$2.prototype._keyupHandler = function (event) {
    this._keyHandler(event, KEYUP_EVENT);
  };
  Keyboard$2.prototype._keyHandler = function (event, type) {
    var eventBusResult;
    if (this._isEventIgnored(event)) {
      return;
    }
    var context = {
      keyEvent: event
    };
    eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
    if (eventBusResult) {
      event.preventDefault();
    }
  };
  Keyboard$2.prototype._isEventIgnored = function (event) {
    if (event.defaultPrevented) {
      return true;
    }
    return isInput(event.target) && this._isModifiedKeyIgnored(event);
  };
  Keyboard$2.prototype._isModifiedKeyIgnored = function (event) {
    if (!isCmd$5(event)) {
      return true;
    }
    var allowedModifiers = this._getAllowedModifiers(event.target);
    return allowedModifiers.indexOf(event.key) === -1;
  };
  Keyboard$2.prototype._getAllowedModifiers = function (element) {
    var modifierContainer = closest(element, '[' + HANDLE_MODIFIER_ATTRIBUTE + ']', true);
    if (!modifierContainer || this._node && !this._node.contains(modifierContainer)) {
      return [];
    }
    return modifierContainer.getAttribute(HANDLE_MODIFIER_ATTRIBUTE).split(',');
  };

  /**
   * Bind keyboard events to the given DOM node.
   *
   * @param {EventTarget} node
   */
  Keyboard$2.prototype.bind = function (node) {
    // make sure that the keyboard is only bound once to the DOM
    this.unbind();
    this._node = node;

    // bind key events
    event.bind(node, 'keydown', this._keydownHandler);
    event.bind(node, 'keyup', this._keyupHandler);
    this._fire('bind');
  };

  /**
   * @return {EventTarget}
   */
  Keyboard$2.prototype.getBinding = function () {
    return this._node;
  };
  Keyboard$2.prototype.unbind = function () {
    var node = this._node;
    if (node) {
      this._fire('unbind');

      // unbind key events
      event.unbind(node, 'keydown', this._keydownHandler);
      event.unbind(node, 'keyup', this._keyupHandler);
    }
    this._node = null;
  };

  /**
   * @param {string} event
   */
  Keyboard$2.prototype._fire = function (event) {
    this._eventBus.fire('keyboard.' + event, {
      node: this._node
    });
  };

  /**
   * Add a listener function that is notified with `KeyboardEvent` whenever
   * the keyboard is bound and the user presses a key. If no priority is
   * provided, the default value of 1000 is used.
   *
   * @param {number} [priority]
   * @param {Listener} listener
   * @param {string} [type='keyboard.keydown']
   */
  Keyboard$2.prototype.addListener = function (priority, listener, type) {
    if (isFunction$2(priority)) {
      type = listener;
      listener = priority;
      priority = DEFAULT_PRIORITY$3;
    }
    this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
  };

  /**
   * Remove a listener function.
   *
   * @param {Listener} listener
   * @param {string} [type='keyboard.keydown']
   */
  Keyboard$2.prototype.removeListener = function (listener, type) {
    this._eventBus.off(type || KEYDOWN_EVENT, listener);
  };
  Keyboard$2.prototype.hasModifier = hasModifier;
  Keyboard$2.prototype.isCmd = isCmd$5;
  Keyboard$2.prototype.isShift = isShift$2;
  Keyboard$2.prototype.isKey = isKey;

  // helpers ///////

  function isInput(target) {
    return target && (matches(target, 'input, textarea') || target.contentEditable === 'true');
  }

  var LOW_PRIORITY$f = 500;

  /**
   * Adds default keyboard bindings.
   *
   * This does not pull in any features will bind only actions that
   * have previously been registered against the editorActions component.
   *
   * @param {EventBus} eventBus
   * @param {Keyboard} keyboard
   */
  function KeyboardBindings(eventBus, keyboard) {
    var self = this;
    eventBus.on('editorActions.init', LOW_PRIORITY$f, function (event) {
      var editorActions = event.editorActions;
      self.registerBindings(keyboard, editorActions);
    });
  }
  KeyboardBindings.$inject = ['eventBus', 'keyboard'];

  /**
   * Register available keyboard bindings.
   *
   * @param {Keyboard} keyboard
   * @param {EditorActions} editorActions
   */
  KeyboardBindings.prototype.registerBindings = function (keyboard, editorActions) {
    /**
     * Add keyboard binding if respective editor action
     * is registered.
     *
     * @param {string} action name
     * @param {Function} fn that implements the key binding
     */
    function addListener(action, fn) {
      if (editorActions.isRegistered(action)) {
        keyboard.addListener(fn);
      }
    }

    // undo
    // (CTRL|CMD) + Z
    addListener('undo', function (context) {
      var event = context.keyEvent;
      if (isUndo(event)) {
        editorActions.trigger('undo');
        return true;
      }
    });

    // redo
    // CTRL + Y
    // CMD + SHIFT + Z
    addListener('redo', function (context) {
      var event = context.keyEvent;
      if (isRedo(event)) {
        editorActions.trigger('redo');
        return true;
      }
    });

    // copy
    // CTRL/CMD + C
    addListener('copy', function (context) {
      var event = context.keyEvent;
      if (isCopy(event)) {
        editorActions.trigger('copy');
        return true;
      }
    });

    // paste
    // CTRL/CMD + V
    addListener('paste', function (context) {
      var event = context.keyEvent;
      if (isPaste(event)) {
        editorActions.trigger('paste');
        return true;
      }
    });

    // zoom in one step
    // CTRL/CMD + +
    addListener('stepZoom', function (context) {
      var event = context.keyEvent;

      // quirk: it has to be triggered by `=` as well to work on international keyboard layout
      // cf: https://github.com/bpmn-io/bpmn-js/issues/1362#issuecomment-722989754
      if (isKey(['+', 'Add', '='], event) && isCmd$5(event)) {
        editorActions.trigger('stepZoom', {
          value: 1
        });
        return true;
      }
    });

    // zoom out one step
    // CTRL + -
    addListener('stepZoom', function (context) {
      var event = context.keyEvent;
      if (isKey(['-', 'Subtract'], event) && isCmd$5(event)) {
        editorActions.trigger('stepZoom', {
          value: -1
        });
        return true;
      }
    });

    // zoom to the default level
    // CTRL + 0
    addListener('zoom', function (context) {
      var event = context.keyEvent;
      if (isKey('0', event) && isCmd$5(event)) {
        editorActions.trigger('zoom', {
          value: 1
        });
        return true;
      }
    });

    // delete selected element
    // DEL
    addListener('removeSelection', function (context) {
      var event = context.keyEvent;
      if (isKey(['Backspace', 'Delete', 'Del'], event)) {
        editorActions.trigger('removeSelection');
        return true;
      }
    });
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var KeyboardModule$2 = {
    __init__: ['keyboard', 'keyboardBindings'],
    keyboard: ['type', Keyboard$2],
    keyboardBindings: ['type', KeyboardBindings]
  };

  /**
   * DRD specific key bindings.
   *
   * @param {Keyboard} keyboard
   * @param {EditorActions} editorActions
   */
  function DrdKeyboardBindings(injector) {
    injector.invoke(KeyboardBindings, this);
  }
  e$2(DrdKeyboardBindings, KeyboardBindings);
  DrdKeyboardBindings.$inject = ['injector'];

  /**
   * Register available keyboard bindings.
   *
   * @param {Keyboard} keyboard
   * @param {EditorActions} editorActions
   */
  DrdKeyboardBindings.prototype.registerBindings = function (keyboard, editorActions) {
    // inherit default bindings
    KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);

    /**
     * Add keyboard binding if respective editor action
     * is registered.
     *
     * @param {string} action name
     * @param {Function} fn that implements the key binding
     */
    function addListener(action, fn) {
      if (editorActions.isRegistered(action)) {
        keyboard.addListener(fn);
      }
    }

    // select all elements
    // CTRL + A
    addListener('selectElements', function (context) {
      var event = context.keyEvent;
      if (keyboard.isKey(['a', 'A'], event) && keyboard.isCmd(event)) {
        editorActions.trigger('selectElements');
        return true;
      }
    });

    // activate lasso tool
    // L
    addListener('lassoTool', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['l', 'L'], event)) {
        editorActions.trigger('lassoTool');
        return true;
      }
    });

    // activate hand tool
    // H
    addListener('handTool', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['h', 'H'], event)) {
        editorActions.trigger('handTool');
        return true;
      }
    });

    // activate direct editing
    // E
    addListener('directEditing', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['e', 'E'], event)) {
        editorActions.trigger('directEditing');
        return true;
      }
    });

    // search labels
    // CTRL + F
    addListener('find', function (context) {
      var event = context.keyEvent;
      if (keyboard.isKey(['f', 'F'], event) && keyboard.isCmd(event)) {
        editorActions.trigger('find');
        return true;
      }
    });
  };

  var KeyboardModule$1 = {
    __depends__: [KeyboardModule$2],
    __init__: ['keyboardBindings'],
    keyboardBindings: ['type', DrdKeyboardBindings]
  };

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../features/keyboard/Keyboard').default} Keyboard
   */

  var DEFAULT_CONFIG$1 = {
    moveSpeed: 50,
    moveSpeedAccelerated: 200
  };

  /**
   * A feature that allows users to move the canvas using the keyboard.
   *
   * @param {Object} config
   * @param {number} [config.moveSpeed=50]
   * @param {number} [config.moveSpeedAccelerated=200]
   * @param {Keyboard} keyboard
   * @param {Canvas} canvas
   */
  function KeyboardMove(config, keyboard, canvas) {
    var self = this;
    this._config = assign$4({}, DEFAULT_CONFIG$1, config || {});
    keyboard.addListener(arrowsListener);
    function arrowsListener(context) {
      var event = context.keyEvent,
        config = self._config;
      if (!keyboard.isCmd(event)) {
        return;
      }
      if (keyboard.isKey(['ArrowLeft', 'Left', 'ArrowUp', 'Up', 'ArrowDown', 'Down', 'ArrowRight', 'Right'], event)) {
        var speed = keyboard.isShift(event) ? config.moveSpeedAccelerated : config.moveSpeed;
        var direction;
        switch (event.key) {
          case 'ArrowLeft':
          case 'Left':
            direction = 'left';
            break;
          case 'ArrowUp':
          case 'Up':
            direction = 'up';
            break;
          case 'ArrowRight':
          case 'Right':
            direction = 'right';
            break;
          case 'ArrowDown':
          case 'Down':
            direction = 'down';
            break;
        }
        self.moveCanvas({
          speed: speed,
          direction: direction
        });
        return true;
      }
    }

    /**
     * @param {{
     *   direction: 'up' | 'down' | 'left' | 'right';
     *   speed: number;
     * }} options
     */
    this.moveCanvas = function (options) {
      var dx = 0,
        dy = 0,
        speed = options.speed;
      var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);
      switch (options.direction) {
        case 'left':
          // Left
          dx = actualSpeed;
          break;
        case 'up':
          // Up
          dy = actualSpeed;
          break;
        case 'right':
          // Right
          dx = -actualSpeed;
          break;
        case 'down':
          // Down
          dy = -actualSpeed;
          break;
      }
      canvas.scroll({
        dx: dx,
        dy: dy
      });
    };
  }
  KeyboardMove.$inject = ['config.keyboardMove', 'keyboard', 'canvas'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var KeyboardMoveModule = {
    __depends__: [KeyboardModule$2],
    __init__: ['keyboardMove'],
    keyboardMove: ['type', KeyboardMove]
  };

  /**
   * @typedef {import('../keyboard/Keyboard').default} Keyboard
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   * @typedef {import('../selection/Selection').default} Selection
   */

  var DEFAULT_CONFIG = {
    moveSpeed: 1,
    moveSpeedAccelerated: 10
  };
  var HIGHER_PRIORITY$3 = 1500;
  var LEFT$1 = 'left';
  var UP = 'up';
  var RIGHT$1 = 'right';
  var DOWN = 'down';
  var KEY_TO_DIRECTION = {
    ArrowLeft: LEFT$1,
    Left: LEFT$1,
    ArrowUp: UP,
    Up: UP,
    ArrowRight: RIGHT$1,
    Right: RIGHT$1,
    ArrowDown: DOWN,
    Down: DOWN
  };
  var DIRECTIONS_DELTA = {
    left: function left(speed) {
      return {
        x: -speed,
        y: 0
      };
    },
    up: function up(speed) {
      return {
        x: 0,
        y: -speed
      };
    },
    right: function right(speed) {
      return {
        x: speed,
        y: 0
      };
    },
    down: function down(speed) {
      return {
        x: 0,
        y: speed
      };
    }
  };

  /**
   * Enables to move selection with keyboard arrows.
   * Use with Shift for modified speed (default=1, with Shift=10).
   * Pressed Cmd/Ctrl turns the feature off.
   *
   * @param {Object} config
   * @param {number} [config.moveSpeed=1]
   * @param {number} [config.moveSpeedAccelerated=10]
   * @param {Keyboard} keyboard
   * @param {Modeling} modeling
   * @param {Rules} rules
   * @param {Selection} selection
   */
  function KeyboardMoveSelection(config, keyboard, modeling, rules, selection) {
    var self = this;
    this._config = assign$4({}, DEFAULT_CONFIG, config || {});
    keyboard.addListener(HIGHER_PRIORITY$3, function (event) {
      var keyEvent = event.keyEvent;
      var direction = KEY_TO_DIRECTION[keyEvent.key];
      if (!direction) {
        return;
      }
      if (keyboard.isCmd(keyEvent)) {
        return;
      }
      var accelerated = keyboard.isShift(keyEvent);
      self.moveSelection(direction, accelerated);
      return true;
    });

    /**
     * Move selected elements in the given direction,
     * optionally specifying accelerated movement.
     *
     * @param {string} direction
     * @param {boolean} [accelerated=false]
     */
    this.moveSelection = function (direction, accelerated) {
      var selectedElements = selection.get();
      if (!selectedElements.length) {
        return;
      }
      var speed = this._config[accelerated ? 'moveSpeedAccelerated' : 'moveSpeed'];
      var delta = DIRECTIONS_DELTA[direction](speed);
      var canMove = rules.allowed('elements.move', {
        shapes: selectedElements
      });
      if (canMove) {
        modeling.moveElements(selectedElements, delta);
      }
    };
  }
  KeyboardMoveSelection.$inject = ['config.keyboardMoveSelection', 'keyboard', 'modeling', 'rules', 'selection'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var KeyboardMoveSelectionModule = {
    __depends__: [KeyboardModule$2, SelectionModule],
    __init__: ['keyboardMoveSelection'],
    keyboardMoveSelection: ['type', KeyboardMoveSelection]
  };

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../core/Types').ElementLike} ElementLike
   *
   * @typedef {import('../core/EventBus').default} EventBus
   * @typedef {import('./CommandHandler').default} CommandHandler
   *
   * @typedef { any } CommandContext
   * @typedef { {
   *   new (...args: any[]) : CommandHandler
   * } } CommandHandlerConstructor
   * @typedef { {
   *   [key: string]: CommandHandler;
   * } } CommandHandlerMap
   * @typedef { {
   *   command: string;
   *   context: any;
   *   id?: any;
   * } } CommandStackAction
   * @typedef { {
   *   actions: CommandStackAction[];
   *   dirty: ElementLike[];
   *   trigger: 'execute' | 'undo' | 'redo' | 'clear' | null;
   *   atomic?: boolean;
   * } } CurrentExecution
   */

  /**
   * A service that offers un- and redoable execution of commands.
   *
   * The command stack is responsible for executing modeling actions
   * in a un- and redoable manner. To do this it delegates the actual
   * command execution to {@link CommandHandler}s.
   *
   * Command handlers provide {@link CommandHandler#execute(ctx)} and
   * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
   * identified by a command context.
   *
   *
   * ## Life-Cycle events
   *
   * In the process the command stack fires a number of life-cycle events
   * that other components to participate in the command execution.
   *
   *    * preExecute
   *    * preExecuted
   *    * execute
   *    * executed
   *    * postExecute
   *    * postExecuted
   *    * revert
   *    * reverted
   *
   * A special event is used for validating, whether a command can be
   * performed prior to its execution.
   *
   *    * canExecute
   *
   * Each of the events is fired as `commandStack.{eventName}` and
   * `commandStack.{commandName}.{eventName}`, respectively. This gives
   * components fine grained control on where to hook into.
   *
   * The event object fired transports `command`, the name of the
   * command and `context`, the command context.
   *
   *
   * ## Creating Command Handlers
   *
   * Command handlers should provide the {@link CommandHandler#execute(ctx)}
   * and {@link CommandHandler#revert(ctx)} methods to implement
   * redoing and undoing of a command.
   *
   * A command handler _must_ ensure undo is performed properly in order
   * not to break the undo chain. It must also return the shapes that
   * got changed during the `execute` and `revert` operations.
   *
   * Command handlers may execute other modeling operations (and thus
   * commands) in their `preExecute(d)` and `postExecute(d)` phases. The command
   * stack will properly group all commands together into a logical unit
   * that may be re- and undone atomically.
   *
   * Command handlers must not execute other commands from within their
   * core implementation (`execute`, `revert`).
   *
   *
   * ## Change Tracking
   *
   * During the execution of the CommandStack it will keep track of all
   * elements that have been touched during the command's execution.
   *
   * At the end of the CommandStack execution it will notify interested
   * components via an 'elements.changed' event with all the dirty
   * elements.
   *
   * The event can be picked up by components that are interested in the fact
   * that elements have been changed. One use case for this is updating
   * their graphical representation after moving / resizing or deletion.
   *
   * @see CommandHandler
   *
   * @param {EventBus} eventBus
   * @param {Injector} injector
   */
  function CommandStack$1(eventBus, injector) {
    /**
     * A map of all registered command handlers.
     *
     * @type {CommandHandlerMap}
     */
    this._handlerMap = {};

    /**
     * A stack containing all re/undoable actions on the diagram
     *
     * @type {CommandStackAction[]}
     */
    this._stack = [];

    /**
     * The current index on the stack
     *
     * @type {number}
     */
    this._stackIdx = -1;

    /**
     * Current active commandStack execution
     *
     * @type {CurrentExecution}
     */
    this._currentExecution = {
      actions: [],
      dirty: [],
      trigger: null
    };

    /**
     * @type {Injector}
     */
    this._injector = injector;

    /**
     * @type EventBus
     */
    this._eventBus = eventBus;

    /**
     * @type { number }
     */
    this._uid = 1;
    eventBus.on(['diagram.destroy', 'diagram.clear'], function () {
      this.clear(false);
    }, this);
  }
  CommandStack$1.$inject = ['eventBus', 'injector'];

  /**
   * Execute a command.
   *
   * @param {string} command The command to execute.
   * @param {CommandContext} context The context with which to execute the command.
   */
  CommandStack$1.prototype.execute = function (command, context) {
    if (!command) {
      throw new Error('command required');
    }
    this._currentExecution.trigger = 'execute';
    var action = {
      command: command,
      context: context
    };
    this._pushAction(action);
    this._internalExecute(action);
    this._popAction();
  };

  /**
   * Check whether a command can be executed.
   *
   * Implementors may hook into the mechanism on two ways:
   *
   *   * in event listeners:
   *
   *     Users may prevent the execution via an event listener.
   *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
   *
   *   * in command handlers:
   *
   *     If the method {@link CommandHandler#canExecute} is implemented in a handler
   *     it will be called to figure out whether the execution is allowed.
   *
   * @param {string} command The command to execute.
   * @param {CommandContext} context The context with which to execute the command.
   *
   * @return {boolean} Whether the command can be executed with the given context.
   */
  CommandStack$1.prototype.canExecute = function (command, context) {
    var action = {
      command: command,
      context: context
    };
    var handler = this._getHandler(command);
    var result = this._fire(command, 'canExecute', action);

    // handler#canExecute will only be called if no listener
    // decided on a result already
    if (result === undefined) {
      if (!handler) {
        return false;
      }
      if (handler.canExecute) {
        result = handler.canExecute(context);
      }
    }
    return result;
  };

  /**
   * Clear the command stack, erasing all undo / redo history.
   *
   * @param {boolean} [emit=true] Whether to fire an event. Defaults to `true`.
   */
  CommandStack$1.prototype.clear = function (emit) {
    this._stack.length = 0;
    this._stackIdx = -1;
    if (emit !== false) {
      this._fire('changed', {
        trigger: 'clear'
      });
    }
  };

  /**
   * Undo last command(s)
   */
  CommandStack$1.prototype.undo = function () {
    var action = this._getUndoAction(),
      next;
    if (action) {
      this._currentExecution.trigger = 'undo';
      this._pushAction(action);
      while (action) {
        this._internalUndo(action);
        next = this._getUndoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };

  /**
   * Redo last command(s)
   */
  CommandStack$1.prototype.redo = function () {
    var action = this._getRedoAction(),
      next;
    if (action) {
      this._currentExecution.trigger = 'redo';
      this._pushAction(action);
      while (action) {
        this._internalExecute(action, true);
        next = this._getRedoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };

  /**
   * Register a handler instance with the command stack.
   *
   * @param {string} command Command to be executed.
   * @param {CommandHandler} handler Handler to execute the command.
   */
  CommandStack$1.prototype.register = function (command, handler) {
    this._setHandler(command, handler);
  };

  /**
   * Register a handler type with the command stack  by instantiating it and
   * injecting its dependencies.
   *
   * @param {string} command Command to be executed.
   * @param {CommandHandlerConstructor} handlerCls Constructor to instantiate a {@link CommandHandler}.
   */
  CommandStack$1.prototype.registerHandler = function (command, handlerCls) {
    if (!command || !handlerCls) {
      throw new Error('command and handlerCls must be defined');
    }
    var handler = this._injector.instantiate(handlerCls);
    this.register(command, handler);
  };

  /**
   * @return {boolean}
   */
  CommandStack$1.prototype.canUndo = function () {
    return !!this._getUndoAction();
  };

  /**
   * @return {boolean}
   */
  CommandStack$1.prototype.canRedo = function () {
    return !!this._getRedoAction();
  };

  // stack access  //////////////////////

  CommandStack$1.prototype._getRedoAction = function () {
    return this._stack[this._stackIdx + 1];
  };
  CommandStack$1.prototype._getUndoAction = function () {
    return this._stack[this._stackIdx];
  };

  // internal functionality //////////////////////

  CommandStack$1.prototype._internalUndo = function (action) {
    var _this = this;
    var command = action.command,
      context = action.context;
    var handler = this._getHandler(command);

    // guard against illegal nested command stack invocations
    this._atomicDo(function () {
      _this._fire(command, 'revert', action);
      if (handler.revert) {
        _this._markDirty(handler.revert(context));
      }
      _this._revertedAction(action);
      _this._fire(command, 'reverted', action);
    });
  };
  CommandStack$1.prototype._fire = function (command, qualifier, event) {
    if (arguments.length < 3) {
      event = qualifier;
      qualifier = null;
    }
    var names = qualifier ? [command + '.' + qualifier, qualifier] : [command];
    var result;
    event = this._eventBus.createEvent(event);
    for (var _i = 0, _names = names; _i < _names.length; _i++) {
      var name = _names[_i];
      result = this._eventBus.fire('commandStack.' + name, event);
      if (event.cancelBubble) {
        break;
      }
    }
    return result;
  };
  CommandStack$1.prototype._createId = function () {
    return this._uid++;
  };
  CommandStack$1.prototype._atomicDo = function (fn) {
    var execution = this._currentExecution;
    execution.atomic = true;
    try {
      fn();
    } finally {
      execution.atomic = false;
    }
  };
  CommandStack$1.prototype._internalExecute = function (action, redo) {
    var _this2 = this;
    var command = action.command,
      context = action.context;
    var handler = this._getHandler(command);
    if (!handler) {
      throw new Error('no command handler registered for <' + command + '>');
    }
    this._pushAction(action);
    if (!redo) {
      this._fire(command, 'preExecute', action);
      if (handler.preExecute) {
        handler.preExecute(context);
      }
      this._fire(command, 'preExecuted', action);
    }

    // guard against illegal nested command stack invocations
    this._atomicDo(function () {
      _this2._fire(command, 'execute', action);
      if (handler.execute) {
        // actual execute + mark return results as dirty
        _this2._markDirty(handler.execute(context));
      }

      // log to stack
      _this2._executedAction(action, redo);
      _this2._fire(command, 'executed', action);
    });
    if (!redo) {
      this._fire(command, 'postExecute', action);
      if (handler.postExecute) {
        handler.postExecute(context);
      }
      this._fire(command, 'postExecuted', action);
    }
    this._popAction();
  };
  CommandStack$1.prototype._pushAction = function (action) {
    var execution = this._currentExecution,
      actions = execution.actions;
    var baseAction = actions[0];
    if (execution.atomic) {
      throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
    }
    if (!action.id) {
      action.id = baseAction && baseAction.id || this._createId();
    }
    actions.push(action);
  };
  CommandStack$1.prototype._popAction = function () {
    var execution = this._currentExecution,
      trigger = execution.trigger,
      actions = execution.actions,
      dirty = execution.dirty;
    actions.pop();
    if (!actions.length) {
      this._eventBus.fire('elements.changed', {
        elements: uniqueBy('id', dirty.reverse())
      });
      dirty.length = 0;
      this._fire('changed', {
        trigger: trigger
      });
      execution.trigger = null;
    }
  };
  CommandStack$1.prototype._markDirty = function (elements) {
    var execution = this._currentExecution;
    if (!elements) {
      return;
    }
    elements = isArray$6(elements) ? elements : [elements];
    execution.dirty = execution.dirty.concat(elements);
  };
  CommandStack$1.prototype._executedAction = function (action, redo) {
    var stackIdx = ++this._stackIdx;
    if (!redo) {
      this._stack.splice(stackIdx, this._stack.length, action);
    }
  };
  CommandStack$1.prototype._revertedAction = function (action) {
    this._stackIdx--;
  };
  CommandStack$1.prototype._getHandler = function (command) {
    return this._handlerMap[command];
  };
  CommandStack$1.prototype._setHandler = function (command, handler) {
    if (!command || !handler) {
      throw new Error('command and handler required');
    }
    if (this._handlerMap[command]) {
      throw new Error('overriding handler for command <' + command + '>');
    }
    this._handlerMap[command] = handler;
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var CommandStack = {
    commandStack: ['type', CommandStack$1]
  };

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory
   */

  /**
   * Adds change support to the diagram, including
   *
   * <ul>
   *   <li>redrawing shapes and connections on change</li>
   * </ul>
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {ElementRegistry} elementRegistry
   * @param {GraphicsFactory} graphicsFactory
   */
  function ChangeSupport$2(eventBus, canvas, elementRegistry, graphicsFactory) {
    // redraw shapes / connections on change

    eventBus.on('element.changed', function (event) {
      var element = event.element;

      // element might have been deleted and replaced by new element with same ID
      // thus check for parent of element except for root element
      if (element.parent || element === canvas.getRootElement()) {
        event.gfx = elementRegistry.getGraphics(element);
      }

      // shape + gfx may have been deleted
      if (!event.gfx) {
        return;
      }
      eventBus.fire(getType$1(element) + '.changed', event);
    });
    eventBus.on('elements.changed', function (event) {
      var elements = event.elements;
      elements.forEach(function (e) {
        eventBus.fire('element.changed', {
          element: e
        });
      });
      graphicsFactory.updateContainments(elements);
    });
    eventBus.on('shape.changed', function (event) {
      graphicsFactory.update('shape', event.element, event.gfx);
    });
    eventBus.on('connection.changed', function (event) {
      graphicsFactory.update('connection', event.element, event.gfx);
    });
  }
  ChangeSupport$2.$inject = ['eventBus', 'canvas', 'elementRegistry', 'graphicsFactory'];

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramChangeSupport = {
    __init__: ['changeSupport'],
    changeSupport: ['type', ChangeSupport$2]
  };

  var min$1 = Math.min,
    max$1 = Math.max;
  function preventDefault(e) {
    e.preventDefault();
  }
  function stopPropagation$2(e) {
    e.stopPropagation();
  }
  function isTextNode(node) {
    return node.nodeType === Node.TEXT_NODE;
  }
  function toArray(nodeList) {
    return [].slice.call(nodeList);
  }

  /**
   * Initializes a container for a content editable div.
   *
   * Structure:
   *
   * container
   *   parent
   *     content
   *     resize-handle
   *
   * @param {object} options
   * @param {DOMElement} options.container The DOM element to append the contentContainer to
   * @param {Function} options.keyHandler Handler for key events
   * @param {Function} options.resizeHandler Handler for resize events
   */
  function TextBox(options) {
    this.container = options.container;
    this.parent = domify$1('<div class="djs-direct-editing-parent">' + '<div class="djs-direct-editing-content" contenteditable="true"></div>' + '</div>');
    this.content = query('[contenteditable]', this.parent);
    this.keyHandler = options.keyHandler || function () {};
    this.resizeHandler = options.resizeHandler || function () {};
    this.autoResize = bind$3(this.autoResize, this);
    this.handlePaste = bind$3(this.handlePaste, this);
  }

  /**
   * Create a text box with the given position, size, style and text content
   *
   * @param {Object} bounds
   * @param {Number} bounds.x absolute x position
   * @param {Number} bounds.y absolute y position
   * @param {Number} [bounds.width] fixed width value
   * @param {Number} [bounds.height] fixed height value
   * @param {Number} [bounds.maxWidth] maximum width value
   * @param {Number} [bounds.maxHeight] maximum height value
   * @param {Number} [bounds.minWidth] minimum width value
   * @param {Number} [bounds.minHeight] minimum height value
   * @param {Object} [style]
   * @param {String} value text content
   *
   * @return {DOMElement} The created content DOM element
   */
  TextBox.prototype.create = function (bounds, style, value, options) {
    var self = this;
    var parent = this.parent,
      content = this.content,
      container = this.container;
    options = this.options = options || {};
    style = this.style = style || {};
    var parentStyle = pick$1(style, ['width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight', 'left', 'top', 'backgroundColor', 'position', 'overflow', 'border', 'wordWrap', 'textAlign', 'outline', 'transform']);
    assign$4(parent.style, {
      width: bounds.width + 'px',
      height: bounds.height + 'px',
      maxWidth: bounds.maxWidth + 'px',
      maxHeight: bounds.maxHeight + 'px',
      minWidth: bounds.minWidth + 'px',
      minHeight: bounds.minHeight + 'px',
      left: bounds.x + 'px',
      top: bounds.y + 'px',
      backgroundColor: '#ffffff',
      position: 'absolute',
      overflow: 'visible',
      border: '1px solid #ccc',
      boxSizing: 'border-box',
      wordWrap: 'normal',
      textAlign: 'center',
      outline: 'none'
    }, parentStyle);
    var contentStyle = pick$1(style, ['fontFamily', 'fontSize', 'fontWeight', 'lineHeight', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft']);
    assign$4(content.style, {
      boxSizing: 'border-box',
      width: '100%',
      outline: 'none',
      wordWrap: 'break-word'
    }, contentStyle);
    if (options.centerVertically) {
      assign$4(content.style, {
        position: 'absolute',
        top: '50%',
        transform: 'translate(0, -50%)'
      }, contentStyle);
    }
    content.innerText = value;
    event.bind(content, 'keydown', this.keyHandler);
    event.bind(content, 'mousedown', stopPropagation$2);
    event.bind(content, 'paste', self.handlePaste);
    if (options.autoResize) {
      event.bind(content, 'input', this.autoResize);
    }
    if (options.resizable) {
      this.resizable(style);
    }
    container.appendChild(parent);

    // set selection to end of text
    this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);
    return parent;
  };

  /**
   * Intercept paste events to remove formatting from pasted text.
   */
  TextBox.prototype.handlePaste = function (e) {
    var options = this.options,
      style = this.style;
    e.preventDefault();
    var text;
    if (e.clipboardData) {
      // Chrome, Firefox, Safari
      text = e.clipboardData.getData('text/plain');
    } else {
      // Internet Explorer
      text = window.clipboardData.getData('Text');
    }
    this.insertText(text);
    if (options.autoResize) {
      var hasResized = this.autoResize(style);
      if (hasResized) {
        this.resizeHandler(hasResized);
      }
    }
  };
  TextBox.prototype.insertText = function (text) {
    text = normalizeEndOfLineSequences(text);

    // insertText command not supported by Internet Explorer
    var success = document.execCommand('insertText', false, text);
    if (success) {
      return;
    }
    this._insertTextIE(text);
  };
  TextBox.prototype._insertTextIE = function (text) {
    // Internet Explorer
    var range = this.getSelection(),
      startContainer = range.startContainer,
      endContainer = range.endContainer,
      startOffset = range.startOffset,
      endOffset = range.endOffset,
      commonAncestorContainer = range.commonAncestorContainer;
    var childNodesArray = toArray(commonAncestorContainer.childNodes);
    var container, offset;
    if (isTextNode(commonAncestorContainer)) {
      var containerTextContent = startContainer.textContent;
      startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);
      container = startContainer;
      offset = startOffset + text.length;
    } else if (startContainer === this.content && endContainer === this.content) {
      var textNode = document.createTextNode(text);
      this.content.insertBefore(textNode, childNodesArray[startOffset]);
      container = textNode;
      offset = textNode.textContent.length;
    } else {
      var startContainerChildIndex = childNodesArray.indexOf(startContainer),
        endContainerChildIndex = childNodesArray.indexOf(endContainer);
      childNodesArray.forEach(function (childNode, index) {
        if (index === startContainerChildIndex) {
          childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
        } else if (index > startContainerChildIndex && index <= endContainerChildIndex) {
          remove$4(childNode);
        }
      });
      container = startContainer;
      offset = startOffset + text.length;
    }
    if (container && offset !== undefined) {
      // is necessary in Internet Explorer
      setTimeout(function () {
        self.setSelection(container, offset);
      });
    }
  };

  /**
   * Automatically resize element vertically to fit its content.
   */
  TextBox.prototype.autoResize = function () {
    var parent = this.parent,
      content = this.content;
    var fontSize = parseInt(this.style.fontSize) || 12;
    if (content.scrollHeight > parent.offsetHeight || content.scrollHeight < parent.offsetHeight - fontSize) {
      var bounds = parent.getBoundingClientRect();
      var height = content.scrollHeight;
      parent.style.height = height + 'px';
      this.resizeHandler({
        width: bounds.width,
        height: bounds.height,
        dx: 0,
        dy: height - bounds.height
      });
    }
  };

  /**
   * Make an element resizable by adding a resize handle.
   */
  TextBox.prototype.resizable = function () {
    var self = this;
    var parent = this.parent,
      resizeHandle = this.resizeHandle;
    var minWidth = parseInt(this.style.minWidth) || 0,
      minHeight = parseInt(this.style.minHeight) || 0,
      maxWidth = parseInt(this.style.maxWidth) || Infinity,
      maxHeight = parseInt(this.style.maxHeight) || Infinity;
    if (!resizeHandle) {
      resizeHandle = this.resizeHandle = domify$1('<div class="djs-direct-editing-resize-handle"></div>');
      var startX, startY, startWidth, startHeight;
      var onMouseDown = function onMouseDown(e) {
        preventDefault(e);
        stopPropagation$2(e);
        startX = e.clientX;
        startY = e.clientY;
        var bounds = parent.getBoundingClientRect();
        startWidth = bounds.width;
        startHeight = bounds.height;
        event.bind(document, 'mousemove', onMouseMove);
        event.bind(document, 'mouseup', onMouseUp);
      };
      var onMouseMove = function onMouseMove(e) {
        preventDefault(e);
        stopPropagation$2(e);
        var newWidth = min$1(max$1(startWidth + e.clientX - startX, minWidth), maxWidth);
        var newHeight = min$1(max$1(startHeight + e.clientY - startY, minHeight), maxHeight);
        parent.style.width = newWidth + 'px';
        parent.style.height = newHeight + 'px';
        self.resizeHandler({
          width: startWidth,
          height: startHeight,
          dx: e.clientX - startX,
          dy: e.clientY - startY
        });
      };
      var onMouseUp = function onMouseUp(e) {
        preventDefault(e);
        stopPropagation$2(e);
        event.unbind(document, 'mousemove', onMouseMove, false);
        event.unbind(document, 'mouseup', onMouseUp, false);
      };
      event.bind(resizeHandle, 'mousedown', onMouseDown);
    }
    assign$4(resizeHandle.style, {
      position: 'absolute',
      bottom: '0px',
      right: '0px',
      cursor: 'nwse-resize',
      width: '0',
      height: '0',
      borderTop: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent',
      borderRight: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
      borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
      borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent'
    });
    parent.appendChild(resizeHandle);
  };

  /**
   * Clear content and style of the textbox, unbind listeners and
   * reset CSS style.
   */
  TextBox.prototype.destroy = function () {
    var parent = this.parent,
      content = this.content,
      resizeHandle = this.resizeHandle;

    // clear content
    content.innerText = '';

    // clear styles
    parent.removeAttribute('style');
    content.removeAttribute('style');
    event.unbind(content, 'keydown', this.keyHandler);
    event.unbind(content, 'mousedown', stopPropagation$2);
    event.unbind(content, 'input', this.autoResize);
    event.unbind(content, 'paste', this.handlePaste);
    if (resizeHandle) {
      resizeHandle.removeAttribute('style');
      remove$4(resizeHandle);
    }
    remove$4(parent);
  };
  TextBox.prototype.getValue = function () {
    return this.content.innerText.trim();
  };
  TextBox.prototype.getSelection = function () {
    var selection = window.getSelection(),
      range = selection.getRangeAt(0);
    return range;
  };
  TextBox.prototype.setSelection = function (container, offset) {
    var range = document.createRange();
    if (container === null) {
      range.selectNodeContents(this.content);
    } else {
      range.setStart(container, offset);
      range.setEnd(container, offset);
    }
    var selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
  };

  // helpers //////////

  function normalizeEndOfLineSequences(string) {
    return string.replace(/\r\n|\r|\n/g, '\n');
  }

  /**
   * A direct editing component that allows users
   * to edit an elements text directly in the diagram
   *
   * @param {EventBus} eventBus the event bus
   */
  function DirectEditing(eventBus, canvas) {
    this._eventBus = eventBus;
    this._providers = [];
    this._textbox = new TextBox({
      container: canvas.getContainer(),
      keyHandler: bind$3(this._handleKey, this),
      resizeHandler: bind$3(this._handleResize, this)
    });
  }
  DirectEditing.$inject = ['eventBus', 'canvas'];

  /**
   * Register a direct editing provider

   * @param {Object} provider the provider, must expose an #activate(element) method that returns
   *                          an activation context ({ bounds: {x, y, width, height }, text }) if
   *                          direct editing is available for the given element.
   *                          Additionally the provider must expose a #update(element, value) method
   *                          to receive direct editing updates.
   */
  DirectEditing.prototype.registerProvider = function (provider) {
    this._providers.push(provider);
  };

  /**
   * Returns true if direct editing is currently active
   *
   * @param {djs.model.Base} [element]
   *
   * @return {boolean}
   */
  DirectEditing.prototype.isActive = function (element) {
    return !!(this._active && (!element || this._active.element === element));
  };

  /**
   * Cancel direct editing, if it is currently active
   */
  DirectEditing.prototype.cancel = function () {
    if (!this._active) {
      return;
    }
    this._fire('cancel');
    this.close();
  };
  DirectEditing.prototype._fire = function (event, context) {
    this._eventBus.fire('directEditing.' + event, context || {
      active: this._active
    });
  };
  DirectEditing.prototype.close = function () {
    this._textbox.destroy();
    this._fire('deactivate');
    this._active = null;
    this.resizable = undefined;
  };
  DirectEditing.prototype.complete = function () {
    var active = this._active;
    if (!active) {
      return;
    }
    var containerBounds,
      previousBounds = active.context.bounds,
      newBounds = this.$textbox.getBoundingClientRect(),
      newText = this.getValue(),
      previousText = active.context.text;
    if (newText !== previousText || newBounds.height !== previousBounds.height || newBounds.width !== previousBounds.width) {
      containerBounds = this._textbox.container.getBoundingClientRect();
      active.provider.update(active.element, newText, active.context.text, {
        x: newBounds.left - containerBounds.left,
        y: newBounds.top - containerBounds.top,
        width: newBounds.width,
        height: newBounds.height
      });
    }
    this._fire('complete');
    this.close();
  };
  DirectEditing.prototype.getValue = function () {
    return this._textbox.getValue();
  };
  DirectEditing.prototype._handleKey = function (e) {
    // stop bubble
    e.stopPropagation();
    var key = e.keyCode || e.charCode;

    // ESC
    if (key === 27) {
      e.preventDefault();
      return this.cancel();
    }

    // Enter
    if (key === 13 && !e.shiftKey) {
      e.preventDefault();
      return this.complete();
    }
  };
  DirectEditing.prototype._handleResize = function (event) {
    this._fire('resize', event);
  };

  /**
   * Activate direct editing on the given element
   *
   * @param {Object} ElementDescriptor the descriptor for a shape or connection
   * @return {Boolean} true if the activation was possible
   */
  DirectEditing.prototype.activate = function (element) {
    if (this.isActive()) {
      this.cancel();
    }

    // the direct editing context
    var context;
    var provider = find$2(this._providers, function (p) {
      return (context = p.activate(element)) ? p : null;
    });

    // check if activation took place
    if (context) {
      this.$textbox = this._textbox.create(context.bounds, context.style, context.text, context.options);
      this._active = {
        element: element,
        context: context,
        provider: provider
      };
      if (context.options && context.options.resizable) {
        this.resizable = true;
      }
      this._fire('activate');
    }
    return !!context;
  };

  var DiagramDirectEditing = {
    __depends__: [InteractionEventsModule],
    __init__: ['directEditing'],
    directEditing: ['type', DirectEditing]
  };

  function LabelEditingProvider(canvas, directEditing, eventBus, modeling, textRenderer) {
    this._canvas = canvas;
    this._modeling = modeling;
    this._textRenderer = textRenderer;
    directEditing.registerProvider(this);

    // listen to dblclick on non-root elements
    eventBus.on('element.dblclick', function (event) {
      directEditing.activate(event.element);
    });

    // complete on followup canvas operation
    eventBus.on(['autoPlace.start', 'canvas.viewbox.changing', 'drag.init', 'drillDown.click', 'element.mousedown', 'popupMenu.open', 'selection.changed'], function () {
      directEditing.complete();
    });

    // cancel on command stack changes
    eventBus.on(['commandStack.changed'], function () {
      directEditing.cancel();
    });
    eventBus.on('create.end', 500, function (e) {
      var element = e.shape;
      if (is$1(element, 'dmn:Decision') || is$1(element, 'dmn:InputData') || is$1(element, 'dmn:BusinessKnowledgeModel') || is$1(element, 'dmn:KnowledgeSource') || is$1(element, 'dmn:TextAnnotation')) {
        directEditing.activate(element);
      }
    });
    eventBus.on('autoPlace.end', 500, function (event) {
      directEditing.activate(event.shape);
    });
  }
  LabelEditingProvider.$inject = ['canvas', 'directEditing', 'eventBus', 'modeling', 'textRenderer'];

  /**
   * Activate direct editing for drgs and text annotations.
   *
   * @param  {djs.model.Base} element
   *
   * @return {Object} an object with properties bounds (position and size) and text
   */
  LabelEditingProvider.prototype.activate = function (element) {
    var text = getLabel(element);
    if (!isDefined(text)) {
      return;
    }
    var context = {
      text: text
    };
    var editingBBox = this.getEditingBBox(element);
    assign$4(context, editingBBox);
    var options = {};

    // DRG elements
    if (is$1(element, 'dmn:DRGElement')) {
      assign$4(options, {
        centerVertically: true
      });
    }

    // text annotations
    if (is$1(element, 'dmn:TextAnnotation')) {
      assign$4(options, {
        resizable: true
      });
    }
    assign$4(context, {
      options: options
    });
    return context;
  };

  /**
   * Get the editing bounding box based on the element's size and position
   *
   * @param  {djs.model.Base} element
   *
   * @return {Object}
   *         an object containing information about position and
   *         size (fixed or minimum and/or maximum)
   */
  LabelEditingProvider.prototype.getEditingBBox = function (element) {
    var canvas = this._canvas;
    var target = element.label || element;
    var bbox = canvas.getAbsoluteBBox(target);

    // default position
    var bounds = {
      x: bbox.x,
      y: bbox.y
    };
    var zoom = canvas.zoom();
    var defaultStyle = this._textRenderer.getDefaultStyle();

    // take zoom into account
    var defaultFontSize = defaultStyle.fontSize * zoom,
      defaultLineHeight = defaultStyle.lineHeight;
    var style = {
      fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
      fontWeight: this._textRenderer.getDefaultStyle().fontWeight
    };

    // DRG elements
    if (is$1(element, 'dmn:DRGElement')) {
      assign$4(bounds, {
        width: bbox.width,
        height: bbox.height
      });
      assign$4(style, {
        fontSize: defaultFontSize + 'px',
        lineHeight: defaultLineHeight,
        paddingTop: 7 * zoom + 'px',
        paddingBottom: 7 * zoom + 'px',
        paddingLeft: 5 * zoom + 'px',
        paddingRight: 5 * zoom + 'px'
      });
    }

    // text annotations
    if (is$1(element, 'dmn:TextAnnotation')) {
      assign$4(bounds, {
        width: bbox.width,
        height: bbox.height,
        minWidth: 30 * zoom,
        minHeight: 10 * zoom
      });
      assign$4(style, {
        textAlign: 'left',
        paddingTop: 5 * zoom + 'px',
        paddingBottom: 7 * zoom + 'px',
        paddingLeft: 7 * zoom + 'px',
        paddingRight: 5 * zoom + 'px',
        fontSize: defaultFontSize + 'px',
        lineHeight: defaultLineHeight
      });
    }
    return {
      bounds: bounds,
      style: style
    };
  };
  LabelEditingProvider.prototype.update = function (element, newLabel, activeContextText, bounds) {
    var newBounds, bbox;
    if (is$1(element, 'dmn:TextAnnotation')) {
      bbox = this._canvas.getAbsoluteBBox(element);
      newBounds = {
        x: element.x,
        y: element.y,
        width: element.width / bbox.width * bounds.width,
        height: element.height / bbox.height * bounds.height
      };
    }
    if (isEmptyText(newLabel)) {
      newLabel = null;
    }
    this._modeling.updateLabel(element, newLabel, newBounds);
  };

  // helpers //////////

  function isEmptyText(label) {
    return !label || !label.trim();
  }

  var LabelEditingModule = {
    __depends__: [CommandStack, DiagramChangeSupport, DiagramDirectEditing],
    __init__: ['labelEditingProvider'],
    labelEditingProvider: ['type', LabelEditingProvider]
  };

  /**
   * Creates DMN-specific refs for new connection.
   *
   * @param {DrdFactory} drdFactory
   * @param {Injector} injector
   */
  function CreateConnectionBehavior(drdFactory, injector) {
    injector.invoke(CommandInterceptor, this);
    this.preExecute('connection.create', function (context) {
      var connection = context.connection,
        connectionBo = connection.businessObject,
        source = context.source,
        target = context.target,
        elementRef,
        sourceRef,
        targetRef;
      if (is$1(connection, 'dmn:Association')) {
        sourceRef = connectionBo.sourceRef = drdFactory.create('dmn:DMNElementReference', {
          href: '#' + source.id
        });
        sourceRef.$parent = connectionBo;
        targetRef = connectionBo.targetRef = drdFactory.create('dmn:DMNElementReference', {
          href: '#' + target.id
        });
        targetRef.$parent = connectionBo;
      } else {
        elementRef = connectionBo['required' + getRequirementType(source)] = drdFactory.create('dmn:DMNElementReference', {
          href: '#' + source.id
        });
        elementRef.$parent = connectionBo;
      }
    }, true);
  }
  CreateConnectionBehavior.$inject = ['drdFactory', 'injector'];
  e$2(CreateConnectionBehavior, CommandInterceptor);

  // helpers //////////

  function getRequirementType(source) {
    if (is$1(source, 'dmn:BusinessKnowledgeModel')) {
      return 'Knowledge';
    } else if (is$1(source, 'dmn:Decision')) {
      return 'Decision';
    } else if (is$1(source, 'dmn:InputData')) {
      return 'Input';
    } else if (is$1(source, 'dmn:KnowledgeSource')) {
      return 'Authority';
    }
  }

  var LOW_PRIORITY$e = 500;
  function LayoutConnectionBehavior(injector, layouter, modeling, rules) {
    injector.invoke(CommandInterceptor, this);

    // specify connection start and end on connection create
    this.preExecute(['connection.create', 'connection.reconnect'], function (context) {
      var connection = context.connection,
        source = context.newSource || context.source,
        target = context.newTarget || context.target;
      if (is$1(connection, 'dmn:InformationRequirement') && !rules.allowed('connection.connect', {
        connection: connection,
        source: source,
        target: target
      })) {
        return;
      }
      if (!is$1(connection, 'dmn:InformationRequirement')) {
        return;
      }
      var orientation = getOrientation(source, target);
      if (!context.hints) {
        context.hints = {};
      }
      assign$4(context.hints, getConnectionHints(source, target, orientation));
    }, true);

    /**
     * Update incoming information requirements.
     *
     * @param {djs.model.Shape} target
     * @param {Array<djs.model.Connection>} [informationRequirements]
     * @param {string} [orientation]
     */
    function updateInformationRequirements(target, informationRequirements, orientation) {
      // (1) get information requirements
      if (!informationRequirements) {
        informationRequirements = target.incoming.filter(function (incoming) {
          return is$1(incoming, 'dmn:InformationRequirement');
        });
      }
      var incomingInformationRequirementsByOrientation = {};

      // (2) get information requirements per orientation
      if (orientation) {
        incomingInformationRequirementsByOrientation[orientation] = informationRequirements;
      } else {
        incomingInformationRequirementsByOrientation = getInformationRequirementsByOrientation(target, informationRequirements);
      }

      // (3) update information requirements per orientation
      forEach$3(incomingInformationRequirementsByOrientation, function (informationRequirements, orientation) {
        // (3.1) sort information requirements
        informationRequirements = sortInformationRequirements(informationRequirements, orientation);

        // (3.2) get new connection start and end
        var connectionStartEnd = getConnectionsStartEnd(informationRequirements, target, orientation);

        // (3.3) update information requirements
        informationRequirements.forEach(function (informationRequirement, index) {
          var connectionStart = connectionStartEnd[index].start,
            connectionEnd = connectionStartEnd[index].end;
          var waypoints = layouter.layoutConnection(informationRequirement, {
            connectionStart: connectionStart,
            connectionEnd: connectionEnd
          });
          modeling.updateWaypoints(informationRequirement, waypoints);
        });
      });
    }

    // update information requirements on connection create and delete
    // update information requirements of new target on connection reconnect
    this.postExecuted(['connection.create', 'connection.delete', 'connection.reconnect'], function (context) {
      var connection = context.connection,
        source = connection.source || context.source,
        target = connection.target || context.target;
      if (!is$1(connection, 'dmn:InformationRequirement')) {
        return;
      }
      var orientation = getOrientation(source, target);

      // update all information requirements with same orientation
      var informationRequirements = target.incoming.filter(function (incoming) {
        var incomingOrientation = getOrientation(incoming.source, incoming.target);
        return is$1(incoming, 'dmn:InformationRequirement') && isSameOrientation(incomingOrientation, orientation);
      });
      if (!informationRequirements.length) {
        return;
      }
      updateInformationRequirements(target, informationRequirements, orientation);
    }, true);

    // update information requirements of old target on connection reconnect
    this.preExecute('connection.reconnect', function (context) {
      var connection = context.connection,
        source = connection.source,
        target = connection.target;
      if (!is$1(connection, 'dmn:InformationRequirement')) {
        return;
      }
      var orientation = getOrientation(source, target);

      // update all information requirements with same orientation except reconnected
      var informationRequirements = target.incoming.filter(function (incoming) {
        var incomingOrientation = getOrientation(incoming.source, incoming.target);
        return incoming !== connection && is$1(incoming, 'dmn:InformationRequirement') && isSameOrientation(incomingOrientation, orientation);
      });
      if (!informationRequirements.length) {
        return;
      }
      updateInformationRequirements(target, informationRequirements, orientation);
    }, true);

    // update information requirements on elements move
    this.postExecuted('elements.move', LOW_PRIORITY$e, function (context) {
      var shapes = context.shapes,
        closure = context.closure,
        enclosedConnections = closure.enclosedConnections;
      shapes.forEach(function (shape) {
        if (!isAny(shape, ['dmn:Decision', 'dmn:InputData'])) {
          return;
        }

        // (1) update incoming information requirements
        var incomingInformationRequirements = shape.incoming.filter(function (incoming) {
          return is$1(incoming, 'dmn:InformationRequirement') && !enclosedConnections[incoming.id];
        });
        if (incomingInformationRequirements.length) {
          updateInformationRequirements(shape, incomingInformationRequirements);
        }

        // (2) update outgoing information requirements
        shape.outgoing.forEach(function (outgoing) {
          if (!is$1(outgoing, 'dmn:InformationRequirement') || enclosedConnections[outgoing.id]) {
            return;
          }
          updateInformationRequirements(outgoing.target);
        });
      });
    }, true);
  }
  LayoutConnectionBehavior.$inject = ['injector', 'layouter', 'modeling', 'rules'];
  e$2(LayoutConnectionBehavior, CommandInterceptor);

  // helpers //////////

  function getConnectionHints(source, target, orientation) {
    var connectionStart = getMid(source),
      connectionEnd = getMid(target);
    if (orientation.includes('bottom')) {
      connectionStart.y = source.y;
      connectionEnd.y = target.y + target.height;
    } else if (orientation.includes('top')) {
      connectionStart.y = source.y + source.height;
      connectionEnd.y = target.y;
    } else if (orientation.includes('right')) {
      connectionStart.x = source.x;
      connectionEnd.x = target.x + target.width;
    } else {
      connectionStart.x = source.x + source.width;
      connectionEnd.x = target.x;
    }
    return {
      connectionStart: connectionStart,
      connectionEnd: connectionEnd
    };
  }

  /**
   * Get connections start and end based on number of information requirements and
   * orientation.
   *
   * @param {Array<djs.model.Connection>} informationRequirements
   * @param {djs.model.Shape} target
   * @param {string} orientation
   *
   * @returns {Array<Object>}
   */
  function getConnectionsStartEnd(informationRequirements, target, orientation) {
    return informationRequirements.map(function (informationRequirement, index) {
      var source = informationRequirement.source,
        sourceMid = getMid(source),
        sourceTrbl = asTRBL(source),
        targetTrbl = asTRBL(target);
      var length = informationRequirements.length;
      if (orientation.includes('bottom')) {
        return {
          start: {
            x: sourceMid.x,
            y: sourceTrbl.top
          },
          end: {
            x: targetTrbl.left + target.width / (length + 1) * (index + 1),
            y: targetTrbl.bottom
          }
        };
      } else if (orientation.includes('top')) {
        return {
          start: {
            x: sourceMid.x,
            y: sourceTrbl.bottom
          },
          end: {
            x: targetTrbl.left + target.width / (length + 1) * (index + 1),
            y: targetTrbl.top
          }
        };
      } else if (orientation.includes('right')) {
        return {
          start: {
            x: sourceTrbl.left,
            y: sourceMid.y
          },
          end: {
            x: targetTrbl.right,
            y: targetTrbl.top + target.height / (length + 1) * (index + 1)
          }
        };
      } else {
        return {
          start: {
            x: sourceTrbl.right,
            y: sourceMid.y
          },
          end: {
            x: targetTrbl.left,
            y: targetTrbl.top + target.height / (length + 1) * (index + 1)
          }
        };
      }
    });
  }

  /**
   * Get information requirements by orientation.
   *
   * @param {djs.model.shape} target
   * @param {Array<djs.model.Connection>} informationRequirements
   *
   * @returns {Object}
   */
  function getInformationRequirementsByOrientation(target, informationRequirements) {
    var incomingInformationRequirementsByOrientation = {};
    informationRequirements.forEach(function (incoming) {
      var orientation = getOrientation(incoming.source, target).split('-').shift();
      if (!incomingInformationRequirementsByOrientation[orientation]) {
        incomingInformationRequirementsByOrientation[orientation] = [];
      }
      incomingInformationRequirementsByOrientation[orientation].push(incoming);
    });
    return incomingInformationRequirementsByOrientation;
  }
  function isSameOrientation(orientationA, orientationB) {
    return orientationA && orientationB && orientationA.split('-').shift() === orientationB.split('-').shift();
  }
  function sortInformationRequirements(informationRequirements, orientation) {
    var axis;
    if (orientation.includes('top') || orientation.includes('bottom')) {
      axis = 'x';
    } else {
      axis = 'y';
    }
    return informationRequirements.sort(function (a, b) {
      return getMid(a.source)[axis] - getMid(b.source)[axis];
    });
  }

  function ReplaceConnectionBehavior(injector, modeling, rules) {
    injector.invoke(CommandInterceptor, this);
    this.preExecute('connection.reconnect', function (context) {
      var connection = context.connection,
        source = context.newSource || connection.source,
        target = context.newTarget || connection.target,
        waypoints = connection.waypoints.slice();
      var allowed = rules.allowed('connection.reconnect', {
        connection: connection,
        source: source,
        target: target
      });
      if (!allowed || allowed.type === connection.type) {
        return;
      }
      context.connection = modeling.connect(source, target, {
        type: allowed.type,
        waypoints: waypoints
      });
      modeling.removeConnection(connection);
    }, true);
  }
  e$2(ReplaceConnectionBehavior, CommandInterceptor);
  ReplaceConnectionBehavior.$inject = ['injector', 'modeling', 'rules'];

  /**
   * Defines the behaviour of what happens to the elements inside a container
   * that morphs into another DRD element
   */
  function ReplaceElementBehaviour(eventBus, modeling, selection) {
    CommandInterceptor.call(this, eventBus);
    this._modeling = modeling;
    this.postExecuted(['shape.replace'], 1500, function (e) {
      var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape;
      modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
      modeling.updateProperties(newShape, {
        id: oldShape.id
      });
      selection.select(newShape);
    });
  }
  e$2(ReplaceElementBehaviour, CommandInterceptor);
  ReplaceElementBehaviour.$inject = ['eventBus', 'modeling', 'selection'];

  var ID$2 = 'id';
  var IdChangeBehavior = /*#__PURE__*/function (_CommandInterceptor) {
    _inherits$1(IdChangeBehavior, _CommandInterceptor);
    var _super = _createSuper(IdChangeBehavior);
    function IdChangeBehavior(eventBus) {
      var _this;
      _classCallCheck(this, IdChangeBehavior);
      _this = _super.call(this, eventBus);
      _this.executed('element.updateProperties', _this.updateIds.bind(_assertThisInitialized(_this)));
      return _this;
    }
    _createClass(IdChangeBehavior, [{
      key: "updateIds",
      value: function updateIds(_ref) {
        var context = _ref.context;
        var element = context.element,
          oldProperties = context.oldProperties,
          properties = context.properties;
        var bo = getBusinessObject(element);
        if (this.shouldSkipUpdate(bo, oldProperties, properties)) {
          return;
        }
        var definitions = getDefinitions$1(bo);
        var drgElements = definitions.get('drgElement');
        drgElements.forEach(function (drgElement) {
          updateElementReferences(drgElement, oldProperties.id, properties.id);
        });
        var artifacts = definitions.get('artifact');
        artifacts.forEach(function (artifact) {
          updateAssociationReferences(artifact, oldProperties.id, properties.id);
        });
      }
    }, {
      key: "shouldSkipUpdate",
      value: function shouldSkipUpdate(bo, oldProperties, newProperties) {
        return !isIdChange$2(oldProperties, newProperties) || !is$1(bo, 'dmn:DRGElement') && !is$1(bo, 'dmn:TextAnnotation');
      }
    }]);
    return IdChangeBehavior;
  }(CommandInterceptor);
  IdChangeBehavior.$inject = ['eventBus'];

  // helpers //////////////////////

  function isIdChange$2(oldProperties, properties) {
    return ID$2 in oldProperties && ID$2 in properties;
  }

  /**
   * Walk up the tree until at the root to get to dmn:Definitions.
   *
   * @param {ModdleElement} element
   */
  function getDefinitions$1(element) {
    var definitions = element;
    while (!is$1(definitions, 'dmn:Definitions')) {
      definitions = definitions.$parent;
    }
    return definitions;
  }
  function updateElementReferences(element, oldId, id) {
    var handlers = {
      authorityRequirement: function authorityRequirement() {
        element.authorityRequirement.forEach(function (authorityRequirement) {
          var requiredAuthority = authorityRequirement.requiredAuthority,
            requiredDecision = authorityRequirement.requiredDecision,
            requiredInput = authorityRequirement.requiredInput;
          if (requiredAuthority && requiredAuthority.href === "#".concat(oldId)) {
            requiredAuthority.href = "#".concat(id);
          }
          if (requiredDecision && requiredDecision.href === "#".concat(oldId)) {
            requiredDecision.href = "#".concat(id);
          }
          if (requiredInput && requiredInput.href === "#".concat(oldId)) {
            requiredInput.href = "#".concat(id);
          }
        });
      },
      informationRequirement: function informationRequirement() {
        element.informationRequirement.forEach(function (informationRequirement) {
          var requiredDecision = informationRequirement.requiredDecision,
            requiredInput = informationRequirement.requiredInput;
          if (requiredDecision && requiredDecision.href === "#".concat(oldId)) {
            requiredDecision.href = "#".concat(id);
          }
          if (requiredInput && requiredInput.href === "#".concat(oldId)) {
            requiredInput.href = "#".concat(id);
          }
        });
      },
      knowledgeRequirement: function knowledgeRequirement() {
        element.knowledgeRequirement.forEach(function (knowledgeRequirement) {
          var requiredKnowledge = knowledgeRequirement.requiredKnowledge;
          if (requiredKnowledge && requiredKnowledge.href === "#".concat(oldId)) {
            requiredKnowledge.href = "#".concat(id);
          }
        });
      }
    };
    forEach$3(handlers, function (handler, key) {
      if (element[key]) {
        handler();
      }
    });
  }
  function updateAssociationReferences(element, oldId, id) {
    var handlers = {
      sourceRef: function sourceRef() {
        var sourceRef = element.sourceRef;
        if (sourceRef.href === "#".concat(oldId)) {
          sourceRef.href = "#".concat(id);
        }
      },
      targetRef: function targetRef() {
        var targetRef = element.targetRef;
        if (targetRef.href === "#".concat(oldId)) {
          targetRef.href = "#".concat(id);
        }
      }
    };
    forEach$3(handlers, function (handler, key) {
      if (element[key]) {
        handler();
      }
    });
  }

  var ModelingBehavior = {
    __init__: ['createConnectionBehavior', 'idChangeBehavior', 'layoutConnectionBehavior', 'replaceConnectionBehavior', 'replaceElementBehavior'],
    createConnectionBehavior: ['type', CreateConnectionBehavior],
    idChangeBehavior: ['type', IdChangeBehavior],
    layoutConnectionBehavior: ['type', LayoutConnectionBehavior],
    replaceConnectionBehavior: ['type', ReplaceConnectionBehavior],
    replaceElementBehavior: ['type', ReplaceElementBehaviour]
  };

  /**
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  /**
   * A basic provider that may be extended to implement modeling rules.
   *
   * Extensions should implement the init method to actually add their custom
   * modeling checks. Checks may be added via the #addRule(action, fn) method.
   *
   * @class
   *
   * @param {EventBus} eventBus
   */
  function RuleProvider(eventBus) {
    CommandInterceptor.call(this, eventBus);
    this.init();
  }
  RuleProvider.$inject = ['eventBus'];
  e$2(RuleProvider, CommandInterceptor);

  /**
   * Adds a modeling rule for the given action, implemented through
   * a callback function.
   *
   * The callback receives a modeling specific action context
   * to perform its check. It must return `false` to disallow the
   * action from happening or `true` to allow the action. Usually returing
   * `null` denotes that a particular interaction shall be ignored.
   * By returning nothing or `undefined` you pass evaluation to lower
   * priority rules.
   *
   * @example
   *
   * ```javascript
   * ResizableRules.prototype.init = function() {
   *
   *   \/**
   *    * Return `true`, `false` or nothing to denote
   *    * _allowed_, _not allowed_ and _continue evaluating_.
   *    *\/
   *   this.addRule('shape.resize', function(context) {
   *
   *     var shape = context.shape;
   *
   *     if (!context.newBounds) {
   *       // check general resizability
   *       if (!shape.resizable) {
   *         return false;
   *       }
   *
   *       // not returning anything (read: undefined)
   *       // will continue the evaluation of other rules
   *       // (with lower priority)
   *       return;
   *     } else {
   *       // element must have minimum size of 10*10 points
   *       return context.newBounds.width > 10 && context.newBounds.height > 10;
   *     }
   *   });
   * };
   * ```
   *
   * @param {string|string[]} actions the identifier for the modeling action to check
   * @param {number} [priority] the priority at which this rule is being applied
   * @param {(any) => any} fn the callback function that performs the actual check
   */
  RuleProvider.prototype.addRule = function (actions, priority, fn) {
    var self = this;
    if (typeof actions === 'string') {
      actions = [actions];
    }
    actions.forEach(function (action) {
      self.canExecute(action, priority, function (context, action, event) {
        return fn(context);
      }, true);
    });
  };

  /**
   * Implement this method to add new rules during provider initialization.
   */
  RuleProvider.prototype.init = function () {};

  /**
   * DRD modeling rules.
   */
  function DrdRules(injector) {
    injector.invoke(RuleProvider, this);
  }
  e$2(DrdRules, RuleProvider);
  DrdRules.$inject = ['injector'];
  DrdRules.prototype.init = function () {
    this.addRule('connection.create', function (context) {
      var source = context.source,
        target = context.target;
      return canConnect(source, target);
    });
    this.addRule('connection.reconnect', function (context) {
      context.connection;
        var source = context.source,
        target = context.target;
      return canConnect(source, target);
    });
    this.addRule('connection.updateWaypoints', function (context) {
      var connection = context.connection;
      return {
        type: connection.type,
        businessObject: connection.businessObject
      };
    });
    this.addRule('elements.move', function (context) {
      var target = context.target,
        shapes = context.shapes;
        context.position;
      return canMove(shapes, target);
    });
    this.addRule('shape.create', function (context) {
      var shape = context.shape,
        target = context.target;
      return canCreate(shape, target);
    });
    this.addRule('shape.resize', function (context) {
      var shape = context.shape;
      return is$1(shape, 'dmn:TextAnnotation');
    });
  };
  DrdRules.prototype.canConnect = canConnect;
  DrdRules.prototype.canCreate = canCreate;
  DrdRules.prototype.canMove = canMove;
  function canConnect(source, target) {
    if (!source || isLabel(source) || !target || isLabel(target)) {
      return null;
    }
    if (source === target) {
      return false;
    }
    if (is$1(source, 'dmn:BusinessKnowledgeModel') && isAny(target, ['dmn:BusinessKnowledgeModel', 'dmn:Decision'])) {
      return {
        type: 'dmn:KnowledgeRequirement'
      };
    }
    if (is$1(source, 'dmn:Decision')) {
      if (is$1(target, 'dmn:Decision')) {
        return {
          type: 'dmn:InformationRequirement'
        };
      }
      if (is$1(target, 'dmn:KnowledgeSource')) {
        return {
          type: 'dmn:AuthorityRequirement'
        };
      }
    }
    if (is$1(source, 'dmn:Definitions') || is$1(target, 'dmn:Definitions')) {
      return false;
    }
    if (is$1(source, 'dmn:InputData')) {
      if (is$1(target, 'dmn:Decision')) {
        return {
          type: 'dmn:InformationRequirement'
        };
      }
      if (is$1(target, 'dmn:KnowledgeSource')) {
        return {
          type: 'dmn:AuthorityRequirement'
        };
      }
    }
    if (is$1(source, 'dmn:KnowledgeSource') && isAny(target, ['dmn:BusinessKnowledgeModel', 'dmn:Decision', 'dmn:KnowledgeSource'])) {
      return {
        type: 'dmn:AuthorityRequirement'
      };
    }
    if (is$1(source, 'dmn:TextAnnotation') && !is$1(target, 'dmn:TextAnnotation') || !is$1(source, 'dmn:TextAnnotation') && is$1(target, 'dmn:TextAnnotation')) {
      return {
        type: 'dmn:Association'
      };
    }
    return false;
  }
  function canCreate(shape, target) {
    return isAny(shape, ['dmn:BusinessKnowledgeModel', 'dmn:Decision', 'dmn:InputData', 'dmn:KnowledgeSource', 'dmn:TextAnnotation']) && is$1(target, 'dmn:Definitions');
  }
  function canMove(elements, target) {
    if (!isArray$6(elements)) {
      elements = [elements];
    }

    // allow default move check to start move operation
    if (!target) {
      return true;
    }
    if (every(elements, function (element) {
      return isAny(element, ['dmn:BusinessKnowledgeModel', 'dmn:Decision', 'dmn:InputData', 'dmn:KnowledgeSource', 'dmn:TextAnnotation', 'dmn:InformationRequirement', 'dmn:AuthorityRequirement', 'dmn:KnowledgeRequirement', 'dmn:Association']);
    }) && is$1(target, 'dmn:Definitions')) {
      return true;
    }
    return false;
  }
  function isLabel(element) {
    return !!element.labelTarget;
  }

  var Rules$4 = {
    __depends__: [Rules$5],
    __init__: ['drdRules'],
    drdRules: ['type', DrdRules]
  };

  function DrdFactory(moddle) {
    this._model = moddle;
  }
  DrdFactory.$inject = ['moddle'];
  DrdFactory.prototype._needsId = function (element) {
    return isAny(element, ['dmn:Artifact', 'dmn:DMNElement', 'dmn:DRGElement', 'dmndi:DMNDiagram', 'dmndi:DMNDiagramElement']);
  };
  DrdFactory.prototype._ensureId = function (element) {
    var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';
    if (!element.id && this._needsId(element)) {
      element.id = this._model.ids.nextPrefixed(prefix, element);
    }
  };
  DrdFactory.prototype.create = function (type, attrs) {
    var element = this._model.create(type, attrs || {});
    this._ensureId(element);
    return element;
  };
  DrdFactory.prototype.createDiShape = function (semantic, bounds, attrs) {
    return this.create('dmndi:DMNShape', assign$4({
      dmnElementRef: semantic,
      bounds: this.createDiBounds(bounds)
    }, attrs));
  };
  DrdFactory.prototype.createDiBounds = function (bounds) {
    return this.create('dc:Bounds', bounds);
  };
  DrdFactory.prototype.createDiEdge = function (semantic, waypoints, attrs) {
    return this.create('dmndi:DMNEdge', {
      dmnElementRef: semantic,
      waypoint: this.createDiWaypoints(waypoints)
    }, attrs);
  };
  DrdFactory.prototype.createDiWaypoints = function (waypoints) {
    var self = this;
    return waypoints.map(function (waypoint) {
      return self.createDiWaypoint(waypoint);
    });
  };
  DrdFactory.prototype.createDiWaypoint = function (waypoint) {
    return this.create('dc:Point', pick$1(waypoint, ['x', 'y']));
  };
  DrdFactory.prototype.createExtensionElements = function () {
    return this.create('dmn:ExtensionElements', {
      values: []
    });
  };

  /**
   * Update DMN 1.3 information.
   */
  function DrdUpdater(connectionDocking, definitionPropertiesView, drdFactory, drdRules, injector) {
    injector.invoke(CommandInterceptor, this);
    this._definitionPropertiesView = definitionPropertiesView;
    this._drdFactory = drdFactory;
    this._drdRules = drdRules;
    var self = this;
    function cropConnection(context) {
      var connection = context.connection,
        cropped = context.cropped;
      if (!cropped) {
        connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
        context.cropped = true;
      }
    }
    this.executed(['connection.create', 'connection.layout'], cropConnection, true);
    this.reverted(['connection.layout'], function (context) {
      delete context.cropped;
    }, true);
    function updateParent(context) {
      var connection = context.connection,
        parent = context.parent,
        shape = context.shape;
      if (connection && !is$1(connection, 'dmn:Association')) {
        parent = connection.target;
      }
      self.updateParent(shape || connection, parent);
    }
    function reverseUpdateParent(context) {
      var connection = context.connection,
        shape = context.shape;
      var oldParent = context.parent || context.newParent;
      if (connection && !is$1(connection, 'dmn:Association')) {
        oldParent = connection.target;
      }
      self.updateParent(shape || connection, oldParent);
    }
    this.executed(['connection.create', 'connection.delete', 'connection.move', 'shape.create', 'shape.delete'], updateParent, true);
    this.reverted(['connection.create', 'connection.delete', 'connection.move', 'shape.create', 'shape.delete'], reverseUpdateParent, true);
    function updateBounds(context) {
      var shape = context.shape;
      if (!(is$1(shape, 'dmn:DRGElement') || is$1(shape, 'dmn:TextAnnotation'))) {
        return;
      }
      self.updateBounds(shape);
    }
    this.executed(['shape.create', 'shape.move', 'shape.resize'], updateBounds, true);
    this.reverted(['shape.create', 'shape.move', 'shape.resize'], updateBounds, true);
    function updateConnectionWaypoints(context) {
      self.updateConnectionWaypoints(context);
    }
    this.executed(['connection.create', 'connection.layout', 'connection.move', 'connection.updateWaypoints'], updateConnectionWaypoints, true);
    this.reverted(['connection.create', 'connection.layout', 'connection.move', 'connection.updateWaypoints'], updateConnectionWaypoints, true);
    this.executed('connection.create', function (context) {
      var connection = context.connection,
        connectionBo = connection.businessObject,
        target = context.target,
        targetBo = target.businessObject;
      if (is$1(connection, 'dmn:Association')) {
        updateParent(context);
      } else {
        // parent is target
        self.updateSemanticParent(connectionBo, targetBo);
      }
    }, true);
    this.reverted('connection.create', function (context) {
      reverseUpdateParent(context);
    }, true);
    this.executed('connection.reconnect', function (context) {
      var connection = context.connection,
        connectionBo = connection.businessObject,
        newTarget = context.newTarget,
        newTargetBo = newTarget.businessObject;
      if (is$1(connectionBo, 'dmn:Association')) {
        return;
      }
      self.updateSemanticParent(connectionBo, newTargetBo);
    }, true);
    this.reverted('connection.reconnect', function (context) {
      var connection = context.connection,
        connectionBo = connection.businessObject,
        oldTarget = context.oldTarget,
        oldTargetBo = oldTarget.businessObject;
      if (is$1(connectionBo, 'dmn:Association')) {
        return;
      }
      self.updateSemanticParent(connectionBo, oldTargetBo);
    }, true);
    this.executed('element.updateProperties', function (context) {
      definitionPropertiesView.update();
    }, true);
    this.reverted('element.updateProperties', function (context) {
      definitionPropertiesView.update();
    }, true);
  }
  e$2(DrdUpdater, CommandInterceptor);
  DrdUpdater.$inject = ['connectionDocking', 'definitionPropertiesView', 'drdFactory', 'drdRules', 'injector'];
  DrdUpdater.prototype.updateBounds = function (shape) {
    var businessObject = shape.businessObject,
      bounds = businessObject.di.bounds;

    // update bounds
    assign$4(bounds, {
      x: shape.x,
      y: shape.y,
      width: shape.width,
      height: shape.height
    });
  };
  DrdUpdater.prototype.updateConnectionWaypoints = function (context) {
    var drdFactory = this._drdFactory;
    var connection = context.connection,
      businessObject = connection.businessObject,
      edge = businessObject.di;
    edge.waypoint = drdFactory.createDiWaypoints(connection.waypoints).map(function (waypoint) {
      waypoint.$parent = edge;
      return waypoint;
    });
  };
  DrdUpdater.prototype.updateParent = function (element, oldParent) {
    var parent = element.parent;
    if (!is$1(element, 'dmn:DRGElement') && !is$1(element, 'dmn:Artifact')) {
      parent = oldParent;
    }
    var businessObject = element.businessObject,
      parentBo = parent && parent.businessObject;
    this.updateSemanticParent(businessObject, parentBo);
    this.updateDiParent(businessObject.di, parentBo && parentBo.di);
  };
  DrdUpdater.prototype.updateSemanticParent = function (businessObject, parent) {
    var children, containment;
    if (businessObject.$parent === parent) {
      return;
    }
    if (is$1(businessObject, 'dmn:DRGElement')) {
      containment = 'drgElement';
    } else if (is$1(businessObject, 'dmn:Artifact')) {
      containment = 'artifact';
    } else if (is$1(businessObject, 'dmn:InformationRequirement')) {
      containment = 'informationRequirement';
    } else if (is$1(businessObject, 'dmn:AuthorityRequirement')) {
      containment = 'authorityRequirement';
    } else if (is$1(businessObject, 'dmn:KnowledgeRequirement')) {
      containment = 'knowledgeRequirement';
    }
    if (businessObject.$parent) {
      // remove from old parent
      children = businessObject.$parent.get(containment);
      remove$2(children, businessObject);
    }
    if (parent) {
      // add to new parent
      children = parent.get(containment);
      if (children) {
        children.push(businessObject);
        businessObject.$parent = parent;
      }
    } else {
      businessObject.$parent = null;
    }
  };
  DrdUpdater.prototype.updateDiParent = function (di, parentDi) {
    if (di.$parent === parentDi) {
      return;
    }
    if (isAny(di, ['dmndi:DMNEdge', 'dmndi:DMNShape'])) {
      var diagram = parentDi || di;
      while (!is$1(diagram, 'dmndi:DMNDiagram')) {
        diagram = diagram.$parent;
      }
      var diagramElements = diagram.get('diagramElements');
      if (parentDi) {
        di.$parent = diagram;
        add$2(diagramElements, di);
      } else {
        di.$parent = null;
        remove$2(diagramElements, di);
      }
    } else {
      throw new Error('unsupported');
    }
  };

  /**
   * @typedef {import('../../../core/Canvas').default} Canvas
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that align elements in a certain way.
   *
   * @param {Modeling} modeling
   * @param {Canvas} canvas
   */
  function AlignElements(modeling, canvas) {
    this._modeling = modeling;
    this._canvas = canvas;
  }
  AlignElements.$inject = ['modeling', 'canvas'];
  AlignElements.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var elements = context.elements,
      alignment = context.alignment;
    forEach$3(elements, function (element) {
      var delta = {
        x: 0,
        y: 0
      };
      if (isDefined(alignment.left)) {
        delta.x = alignment.left - element.x;
      } else if (isDefined(alignment.right)) {
        delta.x = alignment.right - element.width - element.x;
      } else if (isDefined(alignment.center)) {
        delta.x = alignment.center - Math.round(element.width / 2) - element.x;
      } else if (isDefined(alignment.top)) {
        delta.y = alignment.top - element.y;
      } else if (isDefined(alignment.bottom)) {
        delta.y = alignment.bottom - element.height - element.y;
      } else if (isDefined(alignment.middle)) {
        delta.y = alignment.middle - Math.round(element.height / 2) - element.y;
      }
      modeling.moveElements([element], delta, element.parent);
    });
  };
  AlignElements.prototype.postExecute = function (context) {};

  /**
   * @typedef {import('../../../model/Types').Element} Element
   * @typedef {import('../../../model/Types').Parent} Parent
   * @typedef {import('../../../model/Types').Shape} Shape
   *
   * @typedef {import('../../../util/Types').Point} Point
   *
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that implements reversible appending of shapes
   * to a source shape.
   *
   * @param {Modeling} modeling
   */
  function AppendShapeHandler(modeling) {
    this._modeling = modeling;
  }
  AppendShapeHandler.$inject = ['modeling'];

  // api //////////////////////

  /**
   * Creates a new shape.
   *
   * @param {Object} context
   * @param {Partial<Shape>} context.shape The new shape.
   * @param {Element} context.source The element to which to append the new shape to.
   * @param {Parent} context.parent The parent.
   * @param {Point} context.position The position at which to create the new shape.
   */
  AppendShapeHandler.prototype.preExecute = function (context) {
    var source = context.source;
    if (!source) {
      throw new Error('source required');
    }
    var target = context.target || source.parent,
      shape = context.shape,
      hints = context.hints || {};
    shape = context.shape = this._modeling.createShape(shape, context.position, target, {
      attach: hints.attach
    });
    context.shape = shape;
  };
  AppendShapeHandler.prototype.postExecute = function (context) {
    var hints = context.hints || {};
    if (!existsConnection(context.source, context.shape)) {
      // create connection
      if (hints.connectionTarget === context.source) {
        this._modeling.connect(context.shape, context.source, context.connection);
      } else {
        this._modeling.connect(context.source, context.shape, context.connection);
      }
    }
  };
  function existsConnection(source, target) {
    return some(source.outgoing, function (c) {
      return c.target === target;
    });
  }

  /**
   * @typedef {import('../../../model/Types').Element} Element
   * @typedef {import('../../../model/Types').Shape} Shape
   *
   * @typedef {import('../../../util/Types').Point} Point
   *
   * @typedef {import('../Modeling').ModelingHints} ModelingHints
   *
   * @typedef {import('../../../core/Canvas').default} Canvas
   * @typedef {import('../../../layout/BaseLayouter').default} Layouter
   */

  /**
   * @param {Canvas} canvas
   * @param {Layouter} layouter
   */
  function CreateConnectionHandler(canvas, layouter) {
    this._canvas = canvas;
    this._layouter = layouter;
  }
  CreateConnectionHandler.$inject = ['canvas', 'layouter'];

  // api //////////////////////

  /**
   * Creates a new connection between two elements.
   *
   * @param {Object} context
   * @param {Element} context.source The source.
   * @param {Element} context.target The target.
   * @param {Shape} context.parent The parent.
   * @param {number} [context.parentIndex] The optional index at which to add the
   * connection to the parent's children.
   * @param {ModelingHints} [context.hints] The optional hints.
   */
  CreateConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection,
      source = context.source,
      target = context.target,
      parent = context.parent,
      parentIndex = context.parentIndex,
      hints = context.hints;
    if (!source || !target) {
      throw new Error('source and target required');
    }
    if (!parent) {
      throw new Error('parent required');
    }
    connection.source = source;
    connection.target = target;
    if (!connection.waypoints) {
      connection.waypoints = this._layouter.layoutConnection(connection, hints);
    }

    // add connection
    this._canvas.addConnection(connection, parent, parentIndex);
    return connection;
  };
  CreateConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection;
    this._canvas.removeConnection(connection);
    connection.source = null;
    connection.target = null;
    return connection;
  };

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  var round$2 = Math.round;

  /**
   * @param {Modeling} modeling
   */
  function CreateElementsHandler(modeling) {
    this._modeling = modeling;
  }
  CreateElementsHandler.$inject = ['modeling'];
  CreateElementsHandler.prototype.preExecute = function (context) {
    var elements = context.elements,
      parent = context.parent,
      parentIndex = context.parentIndex,
      position = context.position,
      hints = context.hints;
    var modeling = this._modeling;

    // make sure each element has x and y
    forEach$3(elements, function (element) {
      if (!isNumber$3(element.x)) {
        element.x = 0;
      }
      if (!isNumber$3(element.y)) {
        element.y = 0;
      }
    });
    var visibleElements = filter$2(elements, function (element) {
      return !element.hidden;
    });
    var bbox = getBBox(visibleElements);

    // center elements around position
    forEach$3(elements, function (element) {
      if (isConnection(element)) {
        element.waypoints = map$2(element.waypoints, function (waypoint) {
          return {
            x: round$2(waypoint.x - bbox.x - bbox.width / 2 + position.x),
            y: round$2(waypoint.y - bbox.y - bbox.height / 2 + position.y)
          };
        });
      }
      assign$4(element, {
        x: round$2(element.x - bbox.x - bbox.width / 2 + position.x),
        y: round$2(element.y - bbox.y - bbox.height / 2 + position.y)
      });
    });
    var parents = getParents(elements);
    var cache = {};
    forEach$3(elements, function (element) {
      if (isConnection(element)) {
        cache[element.id] = isNumber$3(parentIndex) ? modeling.createConnection(cache[element.source.id], cache[element.target.id], parentIndex, element, element.parent || parent, hints) : modeling.createConnection(cache[element.source.id], cache[element.target.id], element, element.parent || parent, hints);
        return;
      }
      var createShapeHints = assign$4({}, hints);
      if (parents.indexOf(element) === -1) {
        createShapeHints.autoResize = false;
      }
      if (isLabel$1(element)) {
        createShapeHints = omit(createShapeHints, ['attach']);
      }
      cache[element.id] = isNumber$3(parentIndex) ? modeling.createShape(element, pick$1(element, ['x', 'y', 'width', 'height']), element.parent || parent, parentIndex, createShapeHints) : modeling.createShape(element, pick$1(element, ['x', 'y', 'width', 'height']), element.parent || parent, createShapeHints);
    });
    context.elements = values$1(cache);
  };

  /**
   * @typedef {import('../../../model/Types').Element} Element
   * @typedef {import('../../../util/Types').Point} Point
   *
   * @typedef {import('../../../core/Canvas').default} Canvas
   */

  var round$1 = Math.round;

  /**
   * A handler that implements reversible addition of shapes.
   *
   * @param {Canvas} canvas
   */
  function CreateShapeHandler(canvas) {
    this._canvas = canvas;
  }
  CreateShapeHandler.$inject = ['canvas'];

  // api //////////////////////

  /**
   * Appends a shape to a target shape
   *
   * @param {Object} context
   * @param {Element} context.parent The parent.
   * @param {Point} context.position The position at which to create the new shape.
   * @param {number} [context.parentIndex] The optional index at which to add the
   * shape to the parent's children.
   */
  CreateShapeHandler.prototype.execute = function (context) {
    var shape = context.shape,
      positionOrBounds = context.position,
      parent = context.parent,
      parentIndex = context.parentIndex;
    if (!parent) {
      throw new Error('parent required');
    }
    if (!positionOrBounds) {
      throw new Error('position required');
    }

    // (1) add at event center position _or_ at given bounds
    if (positionOrBounds.width !== undefined) {
      assign$4(shape, positionOrBounds);
    } else {
      assign$4(shape, {
        x: positionOrBounds.x - round$1(shape.width / 2),
        y: positionOrBounds.y - round$1(shape.height / 2)
      });
    }

    // (2) add to canvas
    this._canvas.addShape(shape, parent, parentIndex);
    return shape;
  };

  /**
   * Undo append by removing the shape
   */
  CreateShapeHandler.prototype.revert = function (context) {
    var shape = context.shape;

    // (3) remove form canvas
    this._canvas.removeShape(shape);
    return shape;
  };

  /**
   * @typedef {import('../../../core/Canvas').default} Canvas
   *
   * @typedef {import('../../../model/Types').Element} Element
   * @typedef {import('../../../model/Types').Parent} Parent
   * @typedef {import('../../../model/Types').Shape} Shape
   * @typedef {import('../../../util/Types').Point} Point
   */

  /**
   * A handler that attaches a label to a given target shape.
   *
   * @param {Canvas} canvas
   */
  function CreateLabelHandler(canvas) {
    CreateShapeHandler.call(this, canvas);
  }
  e$2(CreateLabelHandler, CreateShapeHandler);
  CreateLabelHandler.$inject = ['canvas'];

  // api //////////////////////

  var originalExecute = CreateShapeHandler.prototype.execute;

  /**
   * Append label to element.
   *
   * @param { {
   *   parent: Parent;
   *   position: Point;
   *   shape: Shape;
   *   target: Element;
   * } } context
   */
  CreateLabelHandler.prototype.execute = function (context) {
    var label = context.shape;
    ensureValidDimensions(label);
    label.labelTarget = context.labelTarget;
    return originalExecute.call(this, context);
  };
  var originalRevert = CreateShapeHandler.prototype.revert;

  /**
   * Revert appending by removing label.
   */
  CreateLabelHandler.prototype.revert = function (context) {
    context.shape.labelTarget = null;
    return originalRevert.call(this, context);
  };

  // helpers //////////////////////

  function ensureValidDimensions(label) {
    // make sure a label has valid { width, height } dimensions
    ['width', 'height'].forEach(function (prop) {
      if (typeof label[prop] === 'undefined') {
        label[prop] = 0;
      }
    });
  }

  /**
   * Remove from the beginning of a collection until it is empty.
   *
   * This is a null-safe operation that ensures elements
   * are being removed from the given collection until the
   * collection is empty.
   *
   * The implementation deals with the fact that a remove operation
   * may touch, i.e. remove multiple elements in the collection
   * at a time.
   *
   * @param {Object[]} [collection]
   * @param {(element: Object) => void} removeFn
   *
   * @return {Object[]} the cleared collection
   */
  function saveClear(collection, removeFn) {
    if (typeof removeFn !== 'function') {
      throw new Error('removeFn iterator must be a function');
    }
    if (!collection) {
      return;
    }
    var e;
    while (e = collection[0]) {
      removeFn(e);
    }
    return collection;
  }

  /**
   * @typedef {import('../../../core/Canvas').default} Canvas
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that implements reversible deletion of Connections.
   */
  function DeleteConnectionHandler(canvas, modeling) {
    this._canvas = canvas;
    this._modeling = modeling;
  }
  DeleteConnectionHandler.$inject = ['canvas', 'modeling'];

  /**
   * - Remove connections
   */
  DeleteConnectionHandler.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var connection = context.connection;

    // remove connections
    saveClear(connection.incoming, function (connection) {
      // To make sure that the connection isn't removed twice
      // For example if a container is removed
      modeling.removeConnection(connection, {
        nested: true
      });
    });
    saveClear(connection.outgoing, function (connection) {
      modeling.removeConnection(connection, {
        nested: true
      });
    });
  };
  DeleteConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection,
      parent = connection.parent;
    context.parent = parent;

    // remember containment
    context.parentIndex = indexOf(parent.children, connection);
    context.source = connection.source;
    context.target = connection.target;
    this._canvas.removeConnection(connection);
    connection.source = null;
    connection.target = null;
    return connection;
  };

  /**
   * Command revert implementation.
   */
  DeleteConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection,
      parent = context.parent,
      parentIndex = context.parentIndex;
    connection.source = context.source;
    connection.target = context.target;

    // restore containment
    add$2(parent.children, connection, parentIndex);
    this._canvas.addConnection(connection, parent);
    return connection;
  };

  /**
   * @typedef {import('../../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * @param {Modeling} modeling
   * @param {ElementRegistry} elementRegistry
   */
  function DeleteElementsHandler(modeling, elementRegistry) {
    this._modeling = modeling;
    this._elementRegistry = elementRegistry;
  }
  DeleteElementsHandler.$inject = ['modeling', 'elementRegistry'];
  DeleteElementsHandler.prototype.postExecute = function (context) {
    var modeling = this._modeling,
      elementRegistry = this._elementRegistry,
      elements = context.elements;
    forEach$3(elements, function (element) {
      // element may have been removed with previous
      // remove operations already (e.g. in case of nesting)
      if (!elementRegistry.get(element.id)) {
        return;
      }
      if (element.waypoints) {
        modeling.removeConnection(element);
      } else {
        modeling.removeShape(element);
      }
    });
  };

  /**
   * @typedef {import('../../../core/Canvas').default} Canvas
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that implements reversible deletion of shapes.
   *
   * @param {Canvas} canvas
   * @param {Modeling} modeling
   */
  function DeleteShapeHandler(canvas, modeling) {
    this._canvas = canvas;
    this._modeling = modeling;
  }
  DeleteShapeHandler.$inject = ['canvas', 'modeling'];

  /**
   * - Remove connections
   * - Remove all direct children
   */
  DeleteShapeHandler.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var shape = context.shape;

    // remove connections
    saveClear(shape.incoming, function (connection) {
      // To make sure that the connection isn't removed twice
      // For example if a container is removed
      modeling.removeConnection(connection, {
        nested: true
      });
    });
    saveClear(shape.outgoing, function (connection) {
      modeling.removeConnection(connection, {
        nested: true
      });
    });

    // remove child shapes and connections
    saveClear(shape.children, function (child) {
      if (isConnection(child)) {
        modeling.removeConnection(child, {
          nested: true
        });
      } else {
        modeling.removeShape(child, {
          nested: true
        });
      }
    });
  };

  /**
   * Remove shape and remember the parent
   */
  DeleteShapeHandler.prototype.execute = function (context) {
    var canvas = this._canvas;
    var shape = context.shape,
      oldParent = shape.parent;
    context.oldParent = oldParent;

    // remove containment
    context.oldParentIndex = indexOf(oldParent.children, shape);

    // remove shape
    canvas.removeShape(shape);
    return shape;
  };

  /**
   * Command revert implementation
   */
  DeleteShapeHandler.prototype.revert = function (context) {
    var canvas = this._canvas;
    var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex;

    // restore containment
    add$2(oldParent.children, shape, oldParentIndex);
    canvas.addShape(shape, oldParent);
    return shape;
  };

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that distributes elements evenly.
   *
   * @param {Modeling} modeling
   */
  function DistributeElements(modeling) {
    this._modeling = modeling;
  }
  DistributeElements.$inject = ['modeling'];
  var OFF_AXIS = {
    x: 'y',
    y: 'x'
  };
  DistributeElements.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var groups = context.groups,
      axis = context.axis,
      dimension = context.dimension;
    function updateRange(group, element) {
      group.range.min = Math.min(element[axis], group.range.min);
      group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
    }
    function center(element) {
      return element[axis] + element[dimension] / 2;
    }
    function lastIdx(arr) {
      return arr.length - 1;
    }
    function rangeDiff(range) {
      return range.max - range.min;
    }
    function centerElement(refCenter, element) {
      var delta = {
        y: 0
      };
      delta[axis] = refCenter - center(element);
      if (delta[axis]) {
        delta[OFF_AXIS[axis]] = 0;
        modeling.moveElements([element], delta, element.parent);
      }
    }
    var firstGroup = groups[0],
      lastGroupIdx = lastIdx(groups),
      lastGroup = groups[lastGroupIdx];
    var margin,
      spaceInBetween,
      groupsSize = 0; // the size of each range

    forEach$3(groups, function (group, idx) {
      var sortedElements, refElem, refCenter;
      if (group.elements.length < 2) {
        if (idx && idx !== groups.length - 1) {
          updateRange(group, group.elements[0]);
          groupsSize += rangeDiff(group.range);
        }
        return;
      }
      sortedElements = sortBy(group.elements, axis);
      refElem = sortedElements[0];
      if (idx === lastGroupIdx) {
        refElem = sortedElements[lastIdx(sortedElements)];
      }
      refCenter = center(refElem);

      // wanna update the ranges after the shapes have been centered
      group.range = null;
      forEach$3(sortedElements, function (element) {
        centerElement(refCenter, element);
        if (group.range === null) {
          group.range = {
            min: element[axis],
            max: element[axis] + element[dimension]
          };
          return;
        }

        // update group's range after centering the range elements
        updateRange(group, element);
      });
      if (idx && idx !== groups.length - 1) {
        groupsSize += rangeDiff(group.range);
      }
    });
    spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);
    margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));
    if (margin < groups.length - 1) {
      return;
    }
    forEach$3(groups, function (group, groupIdx) {
      var delta = {},
        prevGroup;
      if (group === firstGroup || group === lastGroup) {
        return;
      }
      prevGroup = groups[groupIdx - 1];
      group.range.max = 0;
      forEach$3(group.elements, function (element, idx) {
        delta[OFF_AXIS[axis]] = 0;
        delta[axis] = prevGroup.range.max - element[axis] + margin;
        if (group.range.min !== element[axis]) {
          delta[axis] += element[axis] - group.range.min;
        }
        if (delta[axis]) {
          modeling.moveElements([element], delta, element.parent);
        }
        group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
      });
    });
  };
  DistributeElements.prototype.postExecute = function (context) {};

  /**
   * @typedef {import('../../../core/Canvas').default} Canvas
   * @typedef {import('../../../layout/BaseLayouter').default} Layouter
   */

  /**
   * A handler that implements reversible moving of shapes.
   *
   * @param {Layouter} layouter
   * @param {Canvas} canvas
   */
  function LayoutConnectionHandler(layouter, canvas) {
    this._layouter = layouter;
    this._canvas = canvas;
  }
  LayoutConnectionHandler.$inject = ['layouter', 'canvas'];
  LayoutConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection;
    var oldWaypoints = connection.waypoints;
    assign$4(context, {
      oldWaypoints: oldWaypoints
    });
    connection.waypoints = this._layouter.layoutConnection(connection, context.hints);
    return connection;
  };
  LayoutConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection;
    connection.waypoints = context.oldWaypoints;
    return connection;
  };

  /**
   * A handler that implements reversible moving of connections.
   *
   * The handler differs from the layout connection handler in a sense
   * that it preserves the connection layout.
   */
  function MoveConnectionHandler() {}
  MoveConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection,
      delta = context.delta;
    var newParent = context.newParent || connection.parent,
      newParentIndex = context.newParentIndex,
      oldParent = connection.parent;

    // save old parent in context
    context.oldParent = oldParent;
    context.oldParentIndex = remove$2(oldParent.children, connection);

    // add to new parent at position
    add$2(newParent.children, connection, newParentIndex);

    // update parent
    connection.parent = newParent;

    // update waypoint positions
    forEach$3(connection.waypoints, function (p) {
      p.x += delta.x;
      p.y += delta.y;
      if (p.original) {
        p.original.x += delta.x;
        p.original.y += delta.y;
      }
    });
    return connection;
  };
  MoveConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection,
      newParent = connection.parent,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;

    // remove from newParent
    remove$2(newParent.children, connection);

    // restore previous location in old parent
    add$2(oldParent.children, connection, oldParentIndex);

    // restore parent
    connection.parent = oldParent;

    // revert to old waypoint positions
    forEach$3(connection.waypoints, function (p) {
      p.x -= delta.x;
      p.y -= delta.y;
      if (p.original) {
        p.original.x -= delta.x;
        p.original.y -= delta.y;
      }
    });
    return connection;
  };

  /**
   * @typedef {import('../model/Types').Shape} Shape
   *
   * @typedef {import('../util/Types').Point} Point
   * @typedef {import('../util/Types').Rect} Rect
   */

  /**
   * Calculates the absolute point relative to the new element's position.
   *
   * @param {Point} point [absolute]
   * @param {Rect} oldBounds
   * @param {Rect} newBounds
   *
   * @return {Point} point [absolute]
   */
  function getNewAttachPoint(point, oldBounds, newBounds) {
    var oldCenter = center(oldBounds),
      newCenter = center(newBounds),
      oldDelta = delta(point, oldCenter);
    var newDelta = {
      x: oldDelta.x * (newBounds.width / oldBounds.width),
      y: oldDelta.y * (newBounds.height / oldBounds.height)
    };
    return roundPoint({
      x: newCenter.x + newDelta.x,
      y: newCenter.y + newDelta.y
    });
  }

  /**
   * @typedef {import('../../../../core/Types').ConnectionLike} Connection
   * @typedef {import('../../../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../../../util/Types').Point} Point
   * @typedef {import('../../../../util/Types').Rect} Rect
   */

  /**
   * @param {Connection} connection
   * @param {Shape} shape
   * @param {Rect} oldBounds
   * @return {Point}
   */
  function getResizedSourceAnchor(connection, shape, oldBounds) {
    var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[0];

    // new anchor is the last waypoint enclosed be resized source
    if (waypointsInsideNewBounds.length) {
      return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];
    }
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
  }
  function getResizedTargetAnchor(connection, shape, oldBounds) {
    var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[waypoints.length - 1];

    // new anchor is the first waypoint enclosed be resized target
    if (waypointsInsideNewBounds.length) {
      return waypointsInsideNewBounds[0];
    }
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
  }
  function getMovedSourceAnchor(connection, source, moveDelta) {
    var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(source, moveDelta),
      oldAnchor = waypoints[0];
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);
  }
  function getMovedTargetAnchor(connection, target, moveDelta) {
    var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(target, moveDelta),
      oldAnchor = waypoints[waypoints.length - 1];
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);
  }

  // helpers //////////////////////

  function subtract(bounds, delta) {
    return {
      x: bounds.x - delta.x,
      y: bounds.y - delta.y,
      width: bounds.width,
      height: bounds.height
    };
  }

  /**
   * Return waypoints of given connection; throw if non exists (should not happen!!).
   *
   * @param {Connection} connection
   *
   * @return {Point[]}
   */
  function safeGetWaypoints(connection) {
    var waypoints = connection.waypoints;
    if (!waypoints.length) {
      throw new Error('connection#' + connection.id + ': no waypoints');
    }
    return waypoints;
  }
  function getWaypointsInsideBounds(waypoints, bounds) {
    var originalWaypoints = map$2(waypoints, getOriginal);
    return filter$2(originalWaypoints, function (waypoint) {
      return isInsideBounds(waypoint, bounds);
    });
  }

  /**
   * Checks if point is inside bounds, incl. edges.
   *
   * @param {Point} point
   * @param {Rect} bounds
   */
  function isInsideBounds(point, bounds) {
    return getOrientation(bounds, point, 1) === 'intersect';
  }
  function getOriginal(point) {
    return point.original || point;
  }

  /**
   * @typedef {import('../../../../model/Types').Connection} Connection
   * @typedef {import('../../../../model/Types').Element} Element
   * @typedef {import('../../../../model/Types').Shape} Shape
   */

  function MoveClosure() {
    /**
     * @type {Record<string, Shape>}
     */
    this.allShapes = {};

    /**
     * @type {Record<string, Connection>}
     */
    this.allConnections = {};

    /**
     * @type {Record<string, Element>}
     */
    this.enclosedElements = {};

    /**
     * @type {Record<string, Connection>}
     */
    this.enclosedConnections = {};

    /**
     * @type {Record<string, Element>}
     */
    this.topLevel = {};
  }

  /**
   * @param {Element} element
   * @param {boolean} [isTopLevel]
   *
   * @return {MoveClosure}
   */
  MoveClosure.prototype.add = function (element, isTopLevel) {
    return this.addAll([element], isTopLevel);
  };

  /**
   * @param {Element[]} elements
   * @param {boolean} [isTopLevel]
   *
   * @return {MoveClosure}
   */
  MoveClosure.prototype.addAll = function (elements, isTopLevel) {
    var newClosure = getClosure(elements, !!isTopLevel, this);
    assign$4(this, newClosure);
    return this;
  };

  /**
   * @typedef {import('../../../../core/Types').ElementLike} Element
   * @typedef {import('../../../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../../../util/Types').Point} Point
   *
   * @typedef {import('../../Modeling').default} Modeling
   */

  /**
   * A helper that is able to carry out serialized move
   * operations on multiple elements.
   *
   * @param {Modeling} modeling
   */
  function MoveHelper(modeling) {
    this._modeling = modeling;
  }

  /**
   * Move the specified elements and all children by the given delta.
   *
   * This moves all enclosed connections, too and layouts all affected
   * external connections.
   *
   * @template {Element} T
   *
   * @param {T[]} elements
   * @param {Point} delta
   * @param {Shape} newParent The new parent of all elements that are not nested.
   *
   * @return {T[]}
   */
  MoveHelper.prototype.moveRecursive = function (elements, delta, newParent) {
    if (!elements) {
      return [];
    } else {
      return this.moveClosure(this.getClosure(elements), delta, newParent);
    }
  };

  /**
   * Move the given closure of elmements.
   *
   * @param {Object} closure
   * @param {Point} delta
   * @param {Shape} [newParent]
   * @param {Shape} [newHost]
   */
  MoveHelper.prototype.moveClosure = function (closure, delta, newParent, newHost, primaryShape) {
    var modeling = this._modeling;
    var allShapes = closure.allShapes,
      allConnections = closure.allConnections,
      enclosedConnections = closure.enclosedConnections,
      topLevel = closure.topLevel,
      keepParent = false;
    if (primaryShape && primaryShape.parent === newParent) {
      keepParent = true;
    }

    // move all shapes
    forEach$3(allShapes, function (shape) {
      // move the element according to the given delta
      modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {
        recurse: false,
        layout: false
      });
    });

    // move all child connections / layout external connections
    forEach$3(allConnections, function (c) {
      var sourceMoved = !!allShapes[c.source.id],
        targetMoved = !!allShapes[c.target.id];
      if (enclosedConnections[c.id] && sourceMoved && targetMoved) {
        modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);
      } else {
        modeling.layoutConnection(c, {
          connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),
          connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)
        });
      }
    });
  };

  /**
   * Returns the closure for the selected elements
   *
   * @param {Element[]} elements
   *
   * @return {MoveClosure}
   */
  MoveHelper.prototype.getClosure = function (elements) {
    return new MoveClosure().addAll(elements, true);
  };

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that implements reversible moving of shapes.
   *
   * @param {Modeling} modeling
   */
  function MoveElementsHandler(modeling) {
    this._helper = new MoveHelper(modeling);
  }
  MoveElementsHandler.$inject = ['modeling'];
  MoveElementsHandler.prototype.preExecute = function (context) {
    context.closure = this._helper.getClosure(context.shapes);
  };
  MoveElementsHandler.prototype.postExecute = function (context) {
    var hints = context.hints,
      primaryShape;
    if (hints && hints.primaryShape) {
      primaryShape = hints.primaryShape;
      hints.oldParent = primaryShape.parent;
    }
    this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);
  };

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that implements reversible moving of shapes.
   *
   * @param {Modeling} modeling
   */
  function MoveShapeHandler(modeling) {
    this._modeling = modeling;
    this._helper = new MoveHelper(modeling);
  }
  MoveShapeHandler.$inject = ['modeling'];
  MoveShapeHandler.prototype.execute = function (context) {
    var shape = context.shape,
      delta = context.delta,
      newParent = context.newParent || shape.parent,
      newParentIndex = context.newParentIndex,
      oldParent = shape.parent;
    context.oldBounds = pick$1(shape, ['x', 'y', 'width', 'height']);

    // save old parent in context
    context.oldParent = oldParent;
    context.oldParentIndex = remove$2(oldParent.children, shape);

    // add to new parent at position
    add$2(newParent.children, shape, newParentIndex);

    // update shape parent + position
    assign$4(shape, {
      parent: newParent,
      x: shape.x + delta.x,
      y: shape.y + delta.y
    });
    return shape;
  };
  MoveShapeHandler.prototype.postExecute = function (context) {
    var shape = context.shape,
      delta = context.delta,
      hints = context.hints;
    var modeling = this._modeling;
    if (hints.layout !== false) {
      forEach$3(shape.incoming, function (c) {
        modeling.layoutConnection(c, {
          connectionEnd: getMovedTargetAnchor(c, shape, delta)
        });
      });
      forEach$3(shape.outgoing, function (c) {
        modeling.layoutConnection(c, {
          connectionStart: getMovedSourceAnchor(c, shape, delta)
        });
      });
    }
    if (hints.recurse !== false) {
      this.moveChildren(context);
    }
  };
  MoveShapeHandler.prototype.revert = function (context) {
    var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;

    // restore previous location in old parent
    add$2(oldParent.children, shape, oldParentIndex);

    // revert to old position and parent
    assign$4(shape, {
      parent: oldParent,
      x: shape.x - delta.x,
      y: shape.y - delta.y
    });
    return shape;
  };
  MoveShapeHandler.prototype.moveChildren = function (context) {
    var delta = context.delta,
      shape = context.shape;
    this._helper.moveRecursive(shape.children, delta, null);
  };
  MoveShapeHandler.prototype.getNewParent = function (context) {
    return context.newParent || context.shape.parent;
  };

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * Reconnect connection handler.
   *
   * @param {Modeling} modeling
   */
  function ReconnectConnectionHandler(modeling) {
    this._modeling = modeling;
  }
  ReconnectConnectionHandler.$inject = ['modeling'];
  ReconnectConnectionHandler.prototype.execute = function (context) {
    var newSource = context.newSource,
      newTarget = context.newTarget,
      connection = context.connection,
      dockingOrPoints = context.dockingOrPoints;
    if (!newSource && !newTarget) {
      throw new Error('newSource or newTarget required');
    }
    if (isArray$6(dockingOrPoints)) {
      context.oldWaypoints = connection.waypoints;
      connection.waypoints = dockingOrPoints;
    }
    if (newSource) {
      context.oldSource = connection.source;
      connection.source = newSource;
    }
    if (newTarget) {
      context.oldTarget = connection.target;
      connection.target = newTarget;
    }
    return connection;
  };
  ReconnectConnectionHandler.prototype.postExecute = function (context) {
    var connection = context.connection,
      newSource = context.newSource,
      newTarget = context.newTarget,
      dockingOrPoints = context.dockingOrPoints,
      hints = context.hints || {};
    var layoutConnectionHints = {};
    if (hints.connectionStart) {
      layoutConnectionHints.connectionStart = hints.connectionStart;
    }
    if (hints.connectionEnd) {
      layoutConnectionHints.connectionEnd = hints.connectionEnd;
    }
    if (hints.layoutConnection === false) {
      return;
    }
    if (newSource && (!newTarget || hints.docking === 'source')) {
      layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart || getDocking(isArray$6(dockingOrPoints) ? dockingOrPoints[0] : dockingOrPoints);
    }
    if (newTarget && (!newSource || hints.docking === 'target')) {
      layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd || getDocking(isArray$6(dockingOrPoints) ? dockingOrPoints[dockingOrPoints.length - 1] : dockingOrPoints);
    }
    if (hints.newWaypoints) {
      layoutConnectionHints.waypoints = hints.newWaypoints;
    }
    this._modeling.layoutConnection(connection, layoutConnectionHints);
  };
  ReconnectConnectionHandler.prototype.revert = function (context) {
    var oldSource = context.oldSource,
      oldTarget = context.oldTarget,
      oldWaypoints = context.oldWaypoints,
      connection = context.connection;
    if (oldSource) {
      connection.source = oldSource;
    }
    if (oldTarget) {
      connection.target = oldTarget;
    }
    if (oldWaypoints) {
      connection.waypoints = oldWaypoints;
    }
    return connection;
  };

  // helpers //////////

  function getDocking(point) {
    return point.original || point;
  }

  /**
   * @typedef {import('../../model/Types').Shape} Shape
   *
   * @typedef {import('../Modeling').default} Modeling
   * @typedef {import('../../rules/Rules').default} Rules
   */

  /**
   * Replace shape by adding new shape and removing old shape. Incoming and outgoing connections will
   * be kept if possible.
   *
   * @class
   * @constructor
   *
   * @param {Modeling} modeling
   * @param {Rules} rules
   */
  function ReplaceShapeHandler(modeling, rules) {
    this._modeling = modeling;
    this._rules = rules;
  }
  ReplaceShapeHandler.$inject = ['modeling', 'rules'];

  /**
   * Add new shape.
   *
   * @param {Object} context
   * @param {Shape} context.oldShape
   * @param {Object} context.newData
   * @param {string} context.newData.type
   * @param {number} context.newData.x
   * @param {number} context.newData.y
   * @param {Object} [context.hints]
   */
  ReplaceShapeHandler.prototype.preExecute = function (context) {
    var self = this,
      modeling = this._modeling,
      rules = this._rules;
    var oldShape = context.oldShape,
      newData = context.newData,
      hints = context.hints || {},
      newShape;
    function canReconnect(source, target, connection) {
      return rules.allowed('connection.reconnect', {
        connection: connection,
        source: source,
        target: target
      });
    }

    // (1) add new shape at given position
    var position = {
      x: newData.x,
      y: newData.y
    };
    var oldBounds = {
      x: oldShape.x,
      y: oldShape.y,
      width: oldShape.width,
      height: oldShape.height
    };
    newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent, hints);

    // (2) update host
    if (oldShape.host) {
      modeling.updateAttachment(newShape, oldShape.host);
    }

    // (3) adopt all children from old shape
    var children;
    if (hints.moveChildren !== false) {
      children = oldShape.children.slice();
      modeling.moveElements(children, {
        x: 0,
        y: 0
      }, newShape, hints);
    }

    // (4) reconnect connections to new shape if possible
    var incoming = oldShape.incoming.slice(),
      outgoing = oldShape.outgoing.slice();
    forEach$3(incoming, function (connection) {
      var source = connection.source,
        allowed = canReconnect(source, newShape, connection);
      if (allowed) {
        self.reconnectEnd(connection, newShape, getResizedTargetAnchor(connection, newShape, oldBounds), hints);
      }
    });
    forEach$3(outgoing, function (connection) {
      var target = connection.target,
        allowed = canReconnect(newShape, target, connection);
      if (allowed) {
        self.reconnectStart(connection, newShape, getResizedSourceAnchor(connection, newShape, oldBounds), hints);
      }
    });
  };

  /**
   * Remove old shape.
   */
  ReplaceShapeHandler.prototype.postExecute = function (context) {
    var oldShape = context.oldShape;
    this._modeling.removeShape(oldShape);
  };
  ReplaceShapeHandler.prototype.execute = function (context) {};
  ReplaceShapeHandler.prototype.revert = function (context) {};
  ReplaceShapeHandler.prototype.createShape = function (shape, position, target, hints) {
    return this._modeling.createShape(shape, position, target, hints);
  };
  ReplaceShapeHandler.prototype.reconnectStart = function (connection, newSource, dockingPoint, hints) {
    this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
  };
  ReplaceShapeHandler.prototype.reconnectEnd = function (connection, newTarget, dockingPoint, hints) {
    this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
  };

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that implements reversible resizing of shapes.
   *
   * @param {Modeling} modeling
   */
  function ResizeShapeHandler(modeling) {
    this._modeling = modeling;
  }
  ResizeShapeHandler.$inject = ['modeling'];

  /**
   * {
   *   shape: {....}
   *   newBounds: {
   *     width:  20,
   *     height: 40,
   *     x:       5,
   *     y:      10
   *   }
   *
   * }
   */
  ResizeShapeHandler.prototype.execute = function (context) {
    var shape = context.shape,
      newBounds = context.newBounds,
      minBounds = context.minBounds;
    if (newBounds.x === undefined || newBounds.y === undefined || newBounds.width === undefined || newBounds.height === undefined) {
      throw new Error('newBounds must have {x, y, width, height} properties');
    }
    if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
      throw new Error('width and height cannot be less than minimum height and width');
    } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
      throw new Error('width and height cannot be less than 10px');
    }

    // save old bbox in context
    context.oldBounds = {
      width: shape.width,
      height: shape.height,
      x: shape.x,
      y: shape.y
    };

    // update shape
    assign$4(shape, {
      width: newBounds.width,
      height: newBounds.height,
      x: newBounds.x,
      y: newBounds.y
    });
    return shape;
  };
  ResizeShapeHandler.prototype.postExecute = function (context) {
    var modeling = this._modeling;
    var shape = context.shape,
      oldBounds = context.oldBounds,
      hints = context.hints || {};
    if (hints.layout === false) {
      return;
    }
    forEach$3(shape.incoming, function (c) {
      modeling.layoutConnection(c, {
        connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)
      });
    });
    forEach$3(shape.outgoing, function (c) {
      modeling.layoutConnection(c, {
        connectionStart: getResizedSourceAnchor(c, shape, oldBounds)
      });
    });
  };
  ResizeShapeHandler.prototype.revert = function (context) {
    var shape = context.shape,
      oldBounds = context.oldBounds;

    // restore previous bbox
    assign$4(shape, {
      width: oldBounds.width,
      height: oldBounds.height,
      x: oldBounds.x,
      y: oldBounds.y
    });
    return shape;
  };

  /**
   * @typedef {import('../../core/Types').ConnectionLike} Connection
   * @typedef {import('../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../util/Types').Axis} Axis
   * @typedef {import('../../util/Types').Direction} Direction
   * @typedef {import('../../util/Types').Point} Point
   * @typedef {import('../../util/Types').Rect} Rect
   */


  /**
   * Returns connections whose waypoints are to be updated. Waypoints are to be updated if start
   * or end is to be moved or resized.
   *
   * @param {Array<Shape>} movingShapes
   * @param {Array<Shape>} resizingShapes
   *
   * @return {Array<Connection>}
   */
  function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
    var waypointsUpdatingConnections = [];
    forEach$3(movingShapes.concat(resizingShapes), function (shape) {
      var incoming = shape.incoming,
        outgoing = shape.outgoing;
      forEach$3(incoming.concat(outgoing), function (connection) {
        var source = connection.source,
          target = connection.target;
        if (includes$2(movingShapes, source) || includes$2(movingShapes, target) || includes$2(resizingShapes, source) || includes$2(resizingShapes, target)) {
          if (!includes$2(waypointsUpdatingConnections, connection)) {
            waypointsUpdatingConnections.push(connection);
          }
        }
      });
    });
    return waypointsUpdatingConnections;
  }
  function includes$2(array, item) {
    return array.indexOf(item) !== -1;
  }

  /**
   * Resize bounds.
   *
   * @param {Rect} bounds
   * @param {Direction} direction
   * @param {Point} delta
   *
   * @return {Rect}
   */
  function resizeBounds$1(bounds, direction, delta) {
    var x = bounds.x,
      y = bounds.y,
      width = bounds.width,
      height = bounds.height,
      dx = delta.x,
      dy = delta.y;
    switch (direction) {
      case 'n':
        return {
          x: x,
          y: y + dy,
          width: width,
          height: height - dy
        };
      case 's':
        return {
          x: x,
          y: y,
          width: width,
          height: height + dy
        };
      case 'w':
        return {
          x: x + dx,
          y: y,
          width: width - dx,
          height: height
        };
      case 'e':
        return {
          x: x,
          y: y,
          width: width + dx,
          height: height
        };
      default:
        throw new Error('unknown direction: ' + direction);
    }
  }

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * Add or remove space by moving and resizing shapes and updating connection waypoints.
   *
   * @param {Modeling} modeling
   */
  function SpaceToolHandler(modeling) {
    this._modeling = modeling;
  }
  SpaceToolHandler.$inject = ['modeling'];
  SpaceToolHandler.prototype.preExecute = function (context) {
    var delta = context.delta,
      direction = context.direction,
      movingShapes = context.movingShapes,
      resizingShapes = context.resizingShapes,
      start = context.start,
      oldBounds = {};

    // (1) move shapes
    this.moveShapes(movingShapes, delta);

    // (2a) save old bounds of resized shapes
    forEach$3(resizingShapes, function (shape) {
      oldBounds[shape.id] = getBounds(shape);
    });

    // (2b) resize shapes
    this.resizeShapes(resizingShapes, delta, direction);

    // (3) update connection waypoints
    this.updateConnectionWaypoints(getWaypointsUpdatingConnections(movingShapes, resizingShapes), delta, direction, start, movingShapes, resizingShapes, oldBounds);
  };
  SpaceToolHandler.prototype.execute = function () {};
  SpaceToolHandler.prototype.revert = function () {};
  SpaceToolHandler.prototype.moveShapes = function (shapes, delta) {
    var self = this;
    forEach$3(shapes, function (element) {
      self._modeling.moveShape(element, delta, null, {
        autoResize: false,
        layout: false,
        recurse: false
      });
    });
  };
  SpaceToolHandler.prototype.resizeShapes = function (shapes, delta, direction) {
    var self = this;
    forEach$3(shapes, function (shape) {
      var newBounds = resizeBounds$1(shape, direction, delta);
      self._modeling.resizeShape(shape, newBounds, null, {
        attachSupport: false,
        autoResize: false,
        layout: false
      });
    });
  };

  /**
   * Update connections waypoints according to the rules:
   *   1. Both source and target are moved/resized => move waypoints by the delta
   *   2. Only one of source and target is moved/resized => re-layout connection with moved start/end
   */
  SpaceToolHandler.prototype.updateConnectionWaypoints = function (connections, delta, direction, start, movingShapes, resizingShapes, oldBounds) {
    var self = this,
      affectedShapes = movingShapes.concat(resizingShapes);
    forEach$3(connections, function (connection) {
      var source = connection.source,
        target = connection.target,
        waypoints = copyWaypoints(connection),
        axis = getAxisFromDirection(direction),
        layoutHints = {};
      if (includes$1(affectedShapes, source) && includes$1(affectedShapes, target)) {
        // move waypoints
        waypoints = map$2(waypoints, function (waypoint) {
          if (shouldMoveWaypoint(waypoint, start, direction)) {
            // move waypoint
            waypoint[axis] = waypoint[axis] + delta[axis];
          }
          if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {
            // move waypoint original
            waypoint.original[axis] = waypoint.original[axis] + delta[axis];
          }
          return waypoint;
        });
        self._modeling.updateWaypoints(connection, waypoints, {
          labelBehavior: false
        });
      } else if (includes$1(affectedShapes, source) || includes$1(affectedShapes, target)) {
        // re-layout connection with moved start/end
        if (includes$1(movingShapes, source)) {
          layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta);
        } else if (includes$1(movingShapes, target)) {
          layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta);
        } else if (includes$1(resizingShapes, source)) {
          layoutHints.connectionStart = getResizedSourceAnchor(connection, source, oldBounds[source.id]);
        } else if (includes$1(resizingShapes, target)) {
          layoutHints.connectionEnd = getResizedTargetAnchor(connection, target, oldBounds[target.id]);
        }
        self._modeling.layoutConnection(connection, layoutHints);
      }
    });
  };

  // helpers //////////

  function copyWaypoint(waypoint) {
    return assign$4({}, waypoint);
  }
  function copyWaypoints(connection) {
    return map$2(connection.waypoints, function (waypoint) {
      waypoint = copyWaypoint(waypoint);
      if (waypoint.original) {
        waypoint.original = copyWaypoint(waypoint.original);
      }
      return waypoint;
    });
  }
  function getAxisFromDirection(direction) {
    switch (direction) {
      case 'n':
        return 'y';
      case 'w':
        return 'x';
      case 's':
        return 'y';
      case 'e':
        return 'x';
    }
  }
  function shouldMoveWaypoint(waypoint, start, direction) {
    var relevantAxis = getAxisFromDirection(direction);
    if (/e|s/.test(direction)) {
      return waypoint[relevantAxis] > start;
    } else if (/n|w/.test(direction)) {
      return waypoint[relevantAxis] < start;
    }
  }
  function includes$1(array, item) {
    return array.indexOf(item) !== -1;
  }
  function getBounds(shape) {
    return {
      x: shape.x,
      y: shape.y,
      height: shape.height,
      width: shape.width
    };
  }

  /**
   * @typedef {import('../../model/Types').Shape} Shape
   *
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that toggles the collapsed state of an element
   * and the visibility of all its children.
   *
   * @param {Modeling} modeling
   */
  function ToggleShapeCollapseHandler(modeling) {
    this._modeling = modeling;
  }
  ToggleShapeCollapseHandler.$inject = ['modeling'];
  ToggleShapeCollapseHandler.prototype.execute = function (context) {
    var shape = context.shape,
      children = shape.children;

    // recursively remember previous visibility of children
    context.oldChildrenVisibility = getElementsVisibilityRecursive(children);

    // toggle state
    shape.collapsed = !shape.collapsed;

    // recursively hide/show children
    var result = setHiddenRecursive(children, shape.collapsed);
    return [shape].concat(result);
  };
  ToggleShapeCollapseHandler.prototype.revert = function (context) {
    var shape = context.shape,
      oldChildrenVisibility = context.oldChildrenVisibility;
    var children = shape.children;

    // recursively set old visability of children
    var result = restoreVisibilityRecursive(children, oldChildrenVisibility);

    // retoggle state
    shape.collapsed = !shape.collapsed;
    return [shape].concat(result);
  };

  // helpers //////////////////////

  /**
   * Return a map { elementId -> hiddenState}.
   *
   * @param {Shape[]} elements
   *
   * @return {Object}
   */
  function getElementsVisibilityRecursive(elements) {
    var result = {};
    forEach$3(elements, function (element) {
      result[element.id] = element.hidden;
      if (element.children) {
        result = assign$4({}, result, getElementsVisibilityRecursive(element.children));
      }
    });
    return result;
  }
  function setHiddenRecursive(elements, newHidden) {
    var result = [];
    forEach$3(elements, function (element) {
      element.hidden = newHidden;
      result = result.concat(element);
      if (element.children) {
        result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
      }
    });
    return result;
  }
  function restoreVisibilityRecursive(elements, lastState) {
    var result = [];
    forEach$3(elements, function (element) {
      element.hidden = lastState[element.id];
      result = result.concat(element);
      if (element.children) {
        result = result.concat(restoreVisibilityRecursive(element.children, lastState));
      }
    });
    return result;
  }

  /**
   * @typedef {import('../Modeling').default} Modeling
   */

  /**
   * A handler that implements reversible attaching/detaching of shapes.
   *
   * @param {Modeling} modeling
   */
  function UpdateAttachmentHandler(modeling) {
    this._modeling = modeling;
  }
  UpdateAttachmentHandler.$inject = ['modeling'];
  UpdateAttachmentHandler.prototype.execute = function (context) {
    var shape = context.shape,
      newHost = context.newHost,
      oldHost = shape.host;

    // (0) detach from old host
    context.oldHost = oldHost;
    context.attacherIdx = removeAttacher(oldHost, shape);

    // (1) attach to new host
    addAttacher(newHost, shape);

    // (2) update host
    shape.host = newHost;
    return shape;
  };
  UpdateAttachmentHandler.prototype.revert = function (context) {
    var shape = context.shape,
      newHost = context.newHost,
      oldHost = context.oldHost,
      attacherIdx = context.attacherIdx;

    // (2) update host
    shape.host = oldHost;

    // (1) attach to new host
    removeAttacher(newHost, shape);

    // (0) detach from old host
    addAttacher(oldHost, shape, attacherIdx);
    return shape;
  };
  function removeAttacher(host, attacher) {
    // remove attacher from host
    return remove$2(host && host.attachers, attacher);
  }
  function addAttacher(host, attacher, idx) {
    if (!host) {
      return;
    }
    var attachers = host.attachers;
    if (!attachers) {
      host.attachers = attachers = [];
    }
    add$2(attachers, attacher, idx);
  }

  function UpdateWaypointsHandler() {}
  UpdateWaypointsHandler.prototype.execute = function (context) {
    var connection = context.connection,
      newWaypoints = context.newWaypoints;
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = newWaypoints;
    return connection;
  };
  UpdateWaypointsHandler.prototype.revert = function (context) {
    var connection = context.connection,
      oldWaypoints = context.oldWaypoints;
    connection.waypoints = oldWaypoints;
    return connection;
  };

  /**
   * @typedef {import('../../model/Types').Element} Element
   * @typedef {import('../../model/Types').Connection} Connection
   * @typedef {import('../../model/Types').Parent} Parent
   * @typedef {import('../../model/Types').Shape} Shape
   * @typedef {import('../../model/Types').Label} Label
   *
   * @typedef {import('../../command/CommandStack').default} CommandStack
   * @typedef {import('../../core/ElementFactory').default} ElementFactory
   * @typedef {import('../../core/EventBus').default} EventBus
   *
   * @typedef {import('../../command/CommandStack').CommandHandlerConstructor} CommandHandlerConstructor
   *
   * @typedef {import('../../util/Types').Dimensions} Dimensions
   * @typedef {import('../../util/Types').Direction} Direction
   * @typedef {import('../../util/Types').Point} Point
   * @typedef {import('../../util/Types').Rect} Rect
   *
   * @typedef { 'x' | 'y' } ModelingDistributeAxis
   *
   * @typedef { 'width' | 'height' } ModelingDistributeDimension
   *
   * @typedef { {
   *   bottom?: number;
   *   center?: number;
   *   left?: number;
   *   middle?: number;
   *   right?: number;
   *   top?: number;
   * } } ModelingAlignAlignment
   *
   * @typedef { {
   *   [key: string]: any;
   * } } ModelingHints
   *
   * @typedef { {
   *   attach?: boolean;
   * } & ModelingHints } ModelingMoveElementsHints
   *
   * @typedef { {
   *   attach?: boolean;
   * } & ModelingHints } ModelingCreateShapeHints
   */

  /**
   * @template {Element} U
   *
   * @typedef { {
   *   elements: U[],
   *   range: {
   *     min: number;
   *     max: number;
   *   } }
   * } ModelingDistributeGroup
   */

  /**
   * The basic modeling entry point.
   *
   * @template {Connection} [T=Connection]
   * @template {Element} [U=Element]
   * @template {Label} [V=Label]
   * @template {Parent} [W=Parent]
   * @template {Shape} [X=Shape]
   *
   * @param {EventBus} eventBus
   * @param {ElementFactory} elementFactory
   * @param {CommandStack} commandStack
   */
  function Modeling$4(eventBus, elementFactory, commandStack) {
    this._eventBus = eventBus;
    this._elementFactory = elementFactory;
    this._commandStack = commandStack;
    var self = this;
    eventBus.on('diagram.init', function () {
      // register modeling handlers
      self.registerHandlers(commandStack);
    });
  }
  Modeling$4.$inject = ['eventBus', 'elementFactory', 'commandStack'];

  /**
   * Get a map of all command handlers.
   *
   * @return {Map<string, CommandHandlerConstructor>}
   */
  Modeling$4.prototype.getHandlers = function () {
    return {
      'shape.append': AppendShapeHandler,
      'shape.create': CreateShapeHandler,
      'shape.delete': DeleteShapeHandler,
      'shape.move': MoveShapeHandler,
      'shape.resize': ResizeShapeHandler,
      'shape.replace': ReplaceShapeHandler,
      'shape.toggleCollapse': ToggleShapeCollapseHandler,
      'spaceTool': SpaceToolHandler,
      'label.create': CreateLabelHandler,
      'connection.create': CreateConnectionHandler,
      'connection.delete': DeleteConnectionHandler,
      'connection.move': MoveConnectionHandler,
      'connection.layout': LayoutConnectionHandler,
      'connection.updateWaypoints': UpdateWaypointsHandler,
      'connection.reconnect': ReconnectConnectionHandler,
      'elements.create': CreateElementsHandler,
      'elements.move': MoveElementsHandler,
      'elements.delete': DeleteElementsHandler,
      'elements.distribute': DistributeElements,
      'elements.align': AlignElements,
      'element.updateAttachment': UpdateAttachmentHandler
    };
  };

  /**
   * Register handlers with the command stack
   *
   * @param {CommandStack} commandStack
   */
  Modeling$4.prototype.registerHandlers = function (commandStack) {
    forEach$3(this.getHandlers(), function (handler, id) {
      commandStack.registerHandler(id, handler);
    });
  };

  /**
   * Move a shape by the given delta and optionally to a new parent.
   *
   * @param {X} shape
   * @param {Point} delta
   * @param {W} [newParent]
   * @param {number} [newParentIndex]
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.moveShape = function (shape, delta, newParent, newParentIndex, hints) {
    if (_typeof(newParentIndex) === 'object') {
      hints = newParentIndex;
      newParentIndex = null;
    }
    var context = {
      shape: shape,
      delta: delta,
      newParent: newParent,
      newParentIndex: newParentIndex,
      hints: hints || {}
    };
    this._commandStack.execute('shape.move', context);
  };

  /**
   * Update the attachment of a shape.
   *
   * @param {X} shape
   * @param {X} [newHost=undefined]
   */
  Modeling$4.prototype.updateAttachment = function (shape, newHost) {
    var context = {
      shape: shape,
      newHost: newHost
    };
    this._commandStack.execute('element.updateAttachment', context);
  };

  /**
   * Move elements by a given delta and optionally to a new parent.
   *
   * @param {U[]} shapes
   * @param {Point} delta
   * @param {W} [target]
   * @param {ModelingMoveElementsHints} [hints]
   */
  Modeling$4.prototype.moveElements = function (shapes, delta, target, hints) {
    hints = hints || {};
    var attach = hints.attach;
    var newParent = target,
      newHost;
    if (attach === true) {
      newHost = target;
      newParent = target.parent;
    } else if (attach === false) {
      newHost = null;
    }
    var context = {
      shapes: shapes,
      delta: delta,
      newParent: newParent,
      newHost: newHost,
      hints: hints
    };
    this._commandStack.execute('elements.move', context);
  };

  /**
   * Move a shape by the given delta and optionally to a new parent.
   *
   * @param {T} connection
   * @param {Point} delta
   * @param {W} [newParent]
   * @param {number} [newParentIndex]
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.moveConnection = function (connection, delta, newParent, newParentIndex, hints) {
    if (_typeof(newParentIndex) === 'object') {
      hints = newParentIndex;
      newParentIndex = undefined;
    }
    var context = {
      connection: connection,
      delta: delta,
      newParent: newParent,
      newParentIndex: newParentIndex,
      hints: hints || {}
    };
    this._commandStack.execute('connection.move', context);
  };

  /**
   * Layout a connection.
   *
   * @param {T} connection
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.layoutConnection = function (connection, hints) {
    var context = {
      connection: connection,
      hints: hints || {}
    };
    this._commandStack.execute('connection.layout', context);
  };

  /**
   * Create a connection.
   *
   * @overlord
   *
   * @param {U} source
   * @param {U} target
   * @param {Partial<T>} connection
   * @param {W} parent
   * @param {ModelingHints} [hints]
   *
   * @return {T}
   */

  /**
   * Create a connection.
   *
   * @param {U} source
   * @param {U} target
   * @param {number} parentIndex
   * @param {Partial<T>} connection
   * @param {W} parent
   * @param {ModelingHints} [hints]
   *
   * @return {T}
   */
  Modeling$4.prototype.createConnection = function (source, target, parentIndex, connection, parent, hints) {
    if (_typeof(parentIndex) === 'object') {
      hints = parent;
      parent = connection;
      connection = parentIndex;
      parentIndex = undefined;
    }
    connection = this._create('connection', connection);
    var context = {
      source: source,
      target: target,
      parent: parent,
      parentIndex: parentIndex,
      connection: connection,
      hints: hints
    };
    this._commandStack.execute('connection.create', context);
    return context.connection;
  };

  /**
   * Create a shape.
   *
   * @overlord
   *
   * @param {Partial<X>} shape
   * @param {Point} position
   * @param {W} target
   * @param {ModelingCreateShapeHints} [hints]
   *
   * @return {X}
   */

  /**
   * Create a shape.
   *
   * @param {Partial<X>} shape
   * @param {Point} position
   * @param {W} target
   * @param {number} parentIndex
   * @param {ModelingCreateShapeHints} [hints]
   *
   * @return {X}
   */
  Modeling$4.prototype.createShape = function (shape, position, target, parentIndex, hints) {
    if (typeof parentIndex !== 'number') {
      hints = parentIndex;
      parentIndex = undefined;
    }
    hints = hints || {};
    var attach = hints.attach,
      parent,
      host;
    shape = this._create('shape', shape);
    if (attach) {
      parent = target.parent;
      host = target;
    } else {
      parent = target;
    }
    var context = {
      position: position,
      shape: shape,
      parent: parent,
      parentIndex: parentIndex,
      host: host,
      hints: hints
    };
    this._commandStack.execute('shape.create', context);
    return context.shape;
  };

  /**
   * Create elements.
   *
   * @param {Partial<U>[]} elements
   * @param {Point} position
   * @param {W} parent
   * @param {number} [parentIndex]
   * @param {ModelingHints} [hints]
   *
   * @return {U[]}
   */
  Modeling$4.prototype.createElements = function (elements, position, parent, parentIndex, hints) {
    if (!isArray$6(elements)) {
      elements = [elements];
    }
    if (typeof parentIndex !== 'number') {
      hints = parentIndex;
      parentIndex = undefined;
    }
    hints = hints || {};
    var context = {
      position: position,
      elements: elements,
      parent: parent,
      parentIndex: parentIndex,
      hints: hints
    };
    this._commandStack.execute('elements.create', context);
    return context.elements;
  };

  /**
   * Create a label.
   *
   * @param {U} labelTarget
   * @param {Point} position
   * @param {Partial<V>} label
   * @param {W} [parent]
   *
   * @return {V}
   */
  Modeling$4.prototype.createLabel = function (labelTarget, position, label, parent) {
    label = this._create('label', label);
    var context = {
      labelTarget: labelTarget,
      position: position,
      parent: parent || labelTarget.parent,
      shape: label
    };
    this._commandStack.execute('label.create', context);
    return context.shape;
  };

  /**
   * Create and connect a shape to a source.
   *
   * @param {U} source
   * @param {Partial<X>} shape
   * @param {Point} position
   * @param {W} target
   * @param {ModelingHints} [hints]
   *
   * @return {X}
   */
  Modeling$4.prototype.appendShape = function (source, shape, position, target, hints) {
    hints = hints || {};
    shape = this._create('shape', shape);
    var context = {
      source: source,
      position: position,
      target: target,
      shape: shape,
      connection: hints.connection,
      connectionParent: hints.connectionParent,
      hints: hints
    };
    this._commandStack.execute('shape.append', context);
    return context.shape;
  };

  /**
   * Remove elements.
   *
   * @param {U[]} elements
   */
  Modeling$4.prototype.removeElements = function (elements) {
    var context = {
      elements: elements
    };
    this._commandStack.execute('elements.delete', context);
  };

  /**
   * Distribute elements along a given axis.
   *
   * @param {ModelingDistributeGroup<U>[]} groups
   * @param {ModelingDistributeAxis} axis
   * @param {ModelingDistributeDimension} dimension
   */
  Modeling$4.prototype.distributeElements = function (groups, axis, dimension) {
    var context = {
      groups: groups,
      axis: axis,
      dimension: dimension
    };
    this._commandStack.execute('elements.distribute', context);
  };

  /**
   * Remove a shape.
   *
   * @param {X} shape
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.removeShape = function (shape, hints) {
    var context = {
      shape: shape,
      hints: hints || {}
    };
    this._commandStack.execute('shape.delete', context);
  };

  /**
   * Remove a connection.
   *
   * @param {T} connection
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.removeConnection = function (connection, hints) {
    var context = {
      connection: connection,
      hints: hints || {}
    };
    this._commandStack.execute('connection.delete', context);
  };

  /**
   * Replace a shape.
   *
   * @param {X} oldShape
   * @param {Partial<X>} newShape
   * @param {ModelingHints} [hints]
   *
   * @return {X}
   */
  Modeling$4.prototype.replaceShape = function (oldShape, newShape, hints) {
    var context = {
      oldShape: oldShape,
      newData: newShape,
      hints: hints || {}
    };
    this._commandStack.execute('shape.replace', context);
    return context.newShape;
  };

  /**
   * Align elements.
   *
   * @param {U[]} elements
   * @param {ModelingAlignAlignment} alignment
   */
  Modeling$4.prototype.alignElements = function (elements, alignment) {
    var context = {
      elements: elements,
      alignment: alignment
    };
    this._commandStack.execute('elements.align', context);
  };

  /**
   * Resize a shape.
   *
   * @param {X} shape
   * @param {Rect} newBounds
   * @param {Dimensions} [minBounds]
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.resizeShape = function (shape, newBounds, minBounds, hints) {
    var context = {
      shape: shape,
      newBounds: newBounds,
      minBounds: minBounds,
      hints: hints
    };
    this._commandStack.execute('shape.resize', context);
  };

  /**
   * Create space along an horizontally or vertically.
   *
   * @param {X[]} movingShapes
   * @param {X[]} resizingShapes
   * @param {Point} delta
   * @param {Direction} direction
   * @param {number} start
   */
  Modeling$4.prototype.createSpace = function (movingShapes, resizingShapes, delta, direction, start) {
    var context = {
      delta: delta,
      direction: direction,
      movingShapes: movingShapes,
      resizingShapes: resizingShapes,
      start: start
    };
    this._commandStack.execute('spaceTool', context);
  };

  /**
   * Update a connetions waypoints.
   *
   * @param {T} connection
   * @param {Point[]} newWaypoints
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.updateWaypoints = function (connection, newWaypoints, hints) {
    var context = {
      connection: connection,
      newWaypoints: newWaypoints,
      hints: hints || {}
    };
    this._commandStack.execute('connection.updateWaypoints', context);
  };

  /**
   * Reconnect a connections source and/or target.
   *
   * @param {T} connection
   * @param {U} source
   * @param {U} target
   * @param {Point|Point[]} dockingOrPoints
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.reconnect = function (connection, source, target, dockingOrPoints, hints) {
    var context = {
      connection: connection,
      newSource: source,
      newTarget: target,
      dockingOrPoints: dockingOrPoints,
      hints: hints || {}
    };
    this._commandStack.execute('connection.reconnect', context);
  };

  /**
   * Reconnect a connections source.
   *
   * @param {T} connection
   * @param {U} newSource
   * @param {Point|Point[]} dockingOrPoints
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.reconnectStart = function (connection, newSource, dockingOrPoints, hints) {
    if (!hints) {
      hints = {};
    }
    this.reconnect(connection, newSource, connection.target, dockingOrPoints, assign$4(hints, {
      docking: 'source'
    }));
  };

  /**
   * Reconnect a connections target.
   *
   * @param {T} connection
   * @param {U} newTarget
   * @param {Point|Point[]} dockingOrPoints
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.reconnectEnd = function (connection, newTarget, dockingOrPoints, hints) {
    if (!hints) {
      hints = {};
    }
    this.reconnect(connection, connection.source, newTarget, dockingOrPoints, assign$4(hints, {
      docking: 'target'
    }));
  };

  /**
   * Connect two elements.
   *
   * @param {U} source
   * @param {U} target
   * @param {Partial<T>} [attrs]
   * @param {ModelingHints} [hints]
   *
   * @return {T}
   */
  Modeling$4.prototype.connect = function (source, target, attrs, hints) {
    return this.createConnection(source, target, attrs || {}, source.parent, hints);
  };
  Modeling$4.prototype._create = function (type, attrs) {
    if (isModelElement(attrs)) {
      return attrs;
    } else {
      return this._elementFactory.create(type, attrs);
    }
  };

  /**
   * Collapse or expand a shape.
   *
   * @param {X} shape
   * @param {ModelingHints} [hints]
   */
  Modeling$4.prototype.toggleCollapse = function (shape, hints) {
    var context = {
      shape: shape,
      hints: hints || {}
    };
    this._commandStack.execute('shape.toggleCollapse', context);
  };

  function IdClaimHandler$1(moddle) {
    this._moddle = moddle;
  }
  IdClaimHandler$1.$inject = ['moddle'];
  IdClaimHandler$1.prototype.execute = function (context) {
    var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;
    if (claiming) {
      ids.claim(id, element);
    } else {
      ids.unclaim(id);
    }
  };

  /**
   * Command revert implementation.
   */
  IdClaimHandler$1.prototype.revert = function (context) {
    var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;
    if (claiming) {
      ids.unclaim(id);
    } else {
      ids.claim(id, element);
    }
  };

  /**
   * A handler that updates the name of a DMN element.
   */
  function UpdateLabelHandler() {
    /**
     * Set the label and return the changed elements.
     *
     * Element parameter can be label itself or connection (i.e. sequence flow).
     *
     * @param {djs.model.Base} element
     * @param {string} text
     */
    function setText(element, text) {
      // external label if present
      var label = element.label || element;
      var labelTarget = element.labelTarget || element;
      setLabel(label, text, labelTarget !== label);
      return [label, labelTarget];
    }
    function execute(ctx) {
      ctx.oldLabel = getLabel(ctx.element);
      return setText(ctx.element, ctx.newLabel);
    }
    function revert(ctx) {
      return setText(ctx.element, ctx.oldLabel);
    }

    // API

    this.execute = execute;
    this.revert = revert;
  }

  var NAME = 'name',
    ID$1 = 'id';

  /**
   * A handler that implements a DMN property update.
   *
   * This should be used to set simple properties on elements with
   * an underlying DMN business object.
   *
   * Use respective diagram-js provided handlers if you would
   * like to perform automated modeling.
   */
  function UpdatePropertiesHandler(elementRegistry, moddle) {
    this._elementRegistry = elementRegistry;
    this._moddle = moddle;
  }
  UpdatePropertiesHandler.$inject = ['elementRegistry', 'moddle'];

  /**
   * Updates a DMN element with a list of new properties
   *
   * @param {Object} context
   * @param {djs.model.Base} context.element the element to update
   * @param {Object} context.properties a list of properties to set on the element's
   *                                    businessObject (the DMN model element)
   *
   * @return {Array<djs.model.Base>} the updated element
   */
  UpdatePropertiesHandler.prototype.execute = function (context) {
    var element = context.element,
      changed = [element];
    if (!element) {
      throw new Error('element required');
    }
    var elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;
    var businessObject = element.businessObject,
      properties = context.properties,
      oldProperties = context.oldProperties || getProperties(businessObject, keys(properties));
    if (isIdChange$1(properties, businessObject)) {
      ids.unclaim(businessObject[ID$1]);
      elementRegistry.updateId(element, properties[ID$1]);
      ids.claim(properties[ID$1], businessObject);
    }
    if (NAME in properties && element.label) {
      changed.push(element.label);
    }

    // update properties
    setProperties(businessObject, properties);

    // store old values
    context.oldProperties = oldProperties;
    context.changed = changed;

    // indicate changed on objects affected by the update
    return changed;
  };

  /**
   * Reverts the update on a DMN elements properties.
   *
   * @param  {Object} context
   *
   * @return {djs.model.Base} the updated element
   */
  UpdatePropertiesHandler.prototype.revert = function (context) {
    var element = context.element,
      properties = context.properties,
      oldProperties = context.oldProperties,
      businessObject = element.businessObject,
      elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;

    // update properties
    setProperties(businessObject, oldProperties);
    if (isIdChange$1(properties, businessObject)) {
      ids.unclaim(properties[ID$1]);
      elementRegistry.updateId(element, oldProperties[ID$1]);
      ids.claim(oldProperties[ID$1], businessObject);
    }
    return context.changed;
  };
  function isIdChange$1(properties, businessObject) {
    return ID$1 in properties && properties[ID$1] !== businessObject[ID$1];
  }
  function getProperties(businessObject, propertyNames) {
    return reduce(propertyNames, function (result, key) {
      result[key] = businessObject.get(key);
      return result;
    }, {});
  }
  function setProperties(businessObject, properties) {
    forEach$3(properties, function (value, key) {
      businessObject.set(key, value);
    });
  }

  /**
   * DMN modeling.
   *
   * @param {Canvas} canvas
   * @param {CommandStack} commandStack
   * @param {DrdRules} drdRules
   * @param {ElementFactory} elementFactory
   * @param {EventBus} eventBus
   */
  function Modeling$3(canvas, drdRules, injector) {
    this._canvas = canvas;
    this._drdRules = drdRules;
    injector.invoke(Modeling$4, this);
  }
  e$2(Modeling$3, Modeling$4);
  Modeling$3.$inject = ['canvas', 'drdRules', 'injector'];
  Modeling$3.prototype.claimId = function (id, moddleElement) {
    this._commandStack.execute('id.updateClaim', {
      id: id,
      element: moddleElement,
      claiming: true
    });
  };
  Modeling$3.prototype.connect = function (source, target, attrs, hints) {
    var drdRules = this._drdRules,
      rootElement = this._canvas.getRootElement();
    if (!attrs) {
      attrs = drdRules.canConnect(source, target) || {
        type: 'dmn:Association'
      };
    }
    return this.createConnection(source, target, attrs, rootElement, hints);
  };
  Modeling$3.prototype.getHandlers = function () {
    var handlers = Modeling$4.prototype.getHandlers.call(this);
    handlers['id.updateClaim'] = IdClaimHandler$1;
    handlers['element.updateLabel'] = UpdateLabelHandler;
    handlers['element.updateProperties'] = UpdatePropertiesHandler;
    return handlers;
  };
  Modeling$3.prototype.unclaimId = function (id, moddleElement) {
    this._commandStack.execute('id.updateClaim', {
      id: id,
      element: moddleElement
    });
  };
  Modeling$3.prototype.updateProperties = function (element, properties) {
    this._commandStack.execute('element.updateProperties', {
      element: element,
      properties: properties
    });
  };
  Modeling$3.prototype.updateLabel = function (element, newLabel, newBounds, hints) {
    this._commandStack.execute('element.updateLabel', {
      element: element,
      newLabel: newLabel,
      newBounds: newBounds,
      hints: hints || {}
    });
  };

  /**
   * @typedef {import('../core/Types').ElementLike} Element
   * @typedef {import('../core/Types').ConnectionLike} Connection
   *
   * @typedef {import('../util').Point} Point
   *
   * @typedef { {
   *   connectionStart?: Point;
   *   connectionEnd?: Point;
   *   source?: Element;
   *   target?: Element;
   * } } LayoutConnectionHints
   */


  /**
   * A base connection layouter implementation
   * that layouts the connection by directly connecting
   * mid(source) + mid(target).
   */
  function BaseLayouter() {}

  /**
   * Return the new layouted waypoints for the given connection.
   *
   * The connection passed is still unchanged; you may figure out about
   * the new connection start / end via the layout hints provided.
   *
   * @param {Connection} connection
   * @param {LayoutConnectionHints} [hints]
   *
   * @return {Point[]} The waypoints of the laid out connection.
   */
  BaseLayouter.prototype.layoutConnection = function (connection, hints) {
    hints = hints || {};
    return [hints.connectionStart || getMid(hints.source || connection.source), hints.connectionEnd || getMid(hints.target || connection.target)];
  };

  var ADDITIONAL_WAYPOINT_DISTANCE = 20;
  function DrdLayouter(connectionDocking) {
    this._connectionDocking = connectionDocking;
  }
  e$2(DrdLayouter, BaseLayouter);
  DrdLayouter.$inject = ['connectionDocking'];
  DrdLayouter.prototype.layoutConnection = function (connection, hints) {
    var connectionDocking = this._connectionDocking;
    if (!hints) {
      hints = {};
    }
    var source = hints.source || connection.source,
      target = hints.target || connection.target,
      waypoints = hints.waypoints || connection.waypoints || [],
      connectionStart = hints.connectionStart,
      connectionEnd = hints.connectionEnd,
      orientation = getOrientation(source, target);
    if (!connectionStart) {
      connectionStart = getConnectionDocking(waypoints[0], source);
    }
    if (!connectionEnd) {
      connectionEnd = getConnectionDocking(waypoints[waypoints.length - 1], target);
    }
    if (is$1(connection, 'dmn:InformationRequirement')) {
      waypoints = [connectionStart, connectionEnd];
      var croppedWaypoints = connectionDocking.getCroppedWaypoints(assign$4({}, connection, {
        waypoints: waypoints
      }), source, target);
      connectionEnd = croppedWaypoints.pop();
      var additionalWaypoint = {
        x: connectionEnd.x,
        y: connectionEnd.y
      };
      if (orientation.includes('bottom')) {
        additionalWaypoint.y += ADDITIONAL_WAYPOINT_DISTANCE;
      } else if (orientation.includes('top')) {
        additionalWaypoint.y -= ADDITIONAL_WAYPOINT_DISTANCE;
      } else if (orientation.includes('right')) {
        additionalWaypoint.x += ADDITIONAL_WAYPOINT_DISTANCE;
      } else {
        additionalWaypoint.x -= ADDITIONAL_WAYPOINT_DISTANCE;
      }
      waypoints = croppedWaypoints.concat([additionalWaypoint, connectionEnd]);
      return waypoints;
    }
    return [connectionStart, connectionEnd];
  };
  function getConnectionDocking(point, shape) {
    return point ? point.original || point : getMid(shape);
  }

  /**
   * @typedef {import('../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../core/GraphicsFactory').default} GraphicsFactory
   */

  function dockingToPoint(docking) {
    // use the dockings actual point and
    // retain the original docking
    return assign$4({
      original: docking.point.original || docking.point
    }, docking.actual);
  }

  /**
   * A {@link ConnectionDocking} that crops connection waypoints based on
   * the path(s) of the connection source and target.
   *
   * @param {ElementRegistry} elementRegistry
   * @param {GraphicsFactory} graphicsFactory
   */
  function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
    this._elementRegistry = elementRegistry;
    this._graphicsFactory = graphicsFactory;
  }
  CroppingConnectionDocking.$inject = ['elementRegistry', 'graphicsFactory'];

  /**
   * @inheritDoc ConnectionDocking#getCroppedWaypoints
   */
  CroppingConnectionDocking.prototype.getCroppedWaypoints = function (connection, source, target) {
    source = source || connection.source;
    target = target || connection.target;
    var sourceDocking = this.getDockingPoint(connection, source, true),
      targetDocking = this.getDockingPoint(connection, target);
    var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);
    croppedWaypoints.unshift(dockingToPoint(sourceDocking));
    croppedWaypoints.push(dockingToPoint(targetDocking));
    return croppedWaypoints;
  };

  /**
   * Return the connection docking point on the specified shape
   *
   * @inheritDoc ConnectionDocking#getDockingPoint
   */
  CroppingConnectionDocking.prototype.getDockingPoint = function (connection, shape, dockStart) {
    var waypoints = connection.waypoints,
      dockingIdx,
      dockingPoint,
      croppedPoint;
    dockingIdx = dockStart ? 0 : waypoints.length - 1;
    dockingPoint = waypoints[dockingIdx];
    croppedPoint = this._getIntersection(shape, connection, dockStart);
    return {
      point: dockingPoint,
      actual: croppedPoint || dockingPoint,
      idx: dockingIdx
    };
  };

  // helpers //////////////////////

  CroppingConnectionDocking.prototype._getIntersection = function (shape, connection, takeFirst) {
    var shapePath = this._getShapePath(shape),
      connectionPath = this._getConnectionPath(connection);
    return getElementLineIntersection(shapePath, connectionPath, takeFirst);
  };
  CroppingConnectionDocking.prototype._getConnectionPath = function (connection) {
    return this._graphicsFactory.getConnectionPath(connection);
  };
  CroppingConnectionDocking.prototype._getShapePath = function (shape) {
    return this._graphicsFactory.getShapePath(shape);
  };
  CroppingConnectionDocking.prototype._getGfx = function (element) {
    return this._elementRegistry.getGraphics(element);
  };

  var ModelingModule$1 = {
    __init__: ['modeling', 'drdUpdater'],
    __depends__: [ModelingBehavior, Rules$4, DefinitionPropertiesViewer, CommandStack, SelectionModule, DiagramChangeSupport],
    drdFactory: ['type', DrdFactory],
    drdUpdater: ['type', DrdUpdater],
    elementFactory: ['type', ElementFactory$2],
    modeling: ['type', Modeling$3],
    layouter: ['type', DrdLayouter],
    connectionDocking: ['type', CroppingConnectionDocking]
  };

  /**
   * @typedef {import('../../core/Types').ElementLike} Element
   * @typedef {import('../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   * @typedef {import('../selection/Selection').default} Selection
   */

  var LOW_PRIORITY$d = 500,
    MEDIUM_PRIORITY = 1250,
    HIGH_PRIORITY$6 = 1500;
  var round = Math.round;
  function mid(element) {
    return {
      x: element.x + round(element.width / 2),
      y: element.y + round(element.height / 2)
    };
  }

  /**
   * A plugin that makes shapes draggable / droppable.
   *
   * @param {EventBus} eventBus
   * @param {Dragging} dragging
   * @param {Modeling} modeling
   * @param {Selection} selection
   * @param {Rules} rules
   */
  function MoveEvents(eventBus, dragging, modeling, selection, rules) {
    // rules

    function canMove(shapes, delta, position, target) {
      return rules.allowed('elements.move', {
        shapes: shapes,
        delta: delta,
        position: position,
        target: target
      });
    }

    // move events

    // assign a high priority to this handler to setup the environment
    // others may hook up later, e.g. at default priority and modify
    // the move environment.
    //
    // This sets up the context with
    //
    // * shape: the primary shape being moved
    // * shapes: a list of shapes to be moved
    // * validatedShapes: a list of shapes that are being checked
    //                    against the rules before and during move
    //
    eventBus.on('shape.move.start', HIGH_PRIORITY$6, function (event) {
      var context = event.context,
        shape = event.shape,
        shapes = selection.get().slice();

      // move only single shape if the dragged element
      // is not part of the current selection
      if (shapes.indexOf(shape) === -1) {
        shapes = [shape];
      }

      // ensure we remove nested elements in the collection
      // and add attachers for a proper dragger
      shapes = removeNested(shapes);

      // attach shapes to drag context
      assign$4(context, {
        shapes: shapes,
        validatedShapes: shapes,
        shape: shape
      });
    });

    // assign a high priority to this handler to setup the environment
    // others may hook up later, e.g. at default priority and modify
    // the move environment
    //
    eventBus.on('shape.move.start', MEDIUM_PRIORITY, function (event) {
      var context = event.context,
        validatedShapes = context.validatedShapes,
        canExecute;
      canExecute = context.canExecute = canMove(validatedShapes);

      // check if we can move the elements
      if (!canExecute) {
        return false;
      }
    });

    // assign a low priority to this handler
    // to let others modify the move event before we update
    // the context
    //
    eventBus.on('shape.move.move', LOW_PRIORITY$d, function (event) {
      var context = event.context,
        validatedShapes = context.validatedShapes,
        hover = event.hover,
        delta = {
          x: event.dx,
          y: event.dy
        },
        position = {
          x: event.x,
          y: event.y
        },
        canExecute;

      // check if we can move the elements
      canExecute = canMove(validatedShapes, delta, position, hover);
      context.delta = delta;
      context.canExecute = canExecute;

      // simply ignore move over
      if (canExecute === null) {
        context.target = null;
        return;
      }
      context.target = hover;
    });
    eventBus.on('shape.move.end', function (event) {
      var context = event.context;
      var delta = context.delta,
        canExecute = context.canExecute,
        isAttach = canExecute === 'attach',
        shapes = context.shapes;
      if (canExecute === false) {
        return false;
      }

      // ensure we have actual pixel values deltas
      // (important when zoom level was > 1 during move)
      delta.x = round(delta.x);
      delta.y = round(delta.y);
      if (delta.x === 0 && delta.y === 0) {
        // didn't move
        return;
      }
      modeling.moveElements(shapes, delta, context.target, {
        primaryShape: context.shape,
        attach: isAttach
      });
    });

    // move activation

    eventBus.on('element.mousedown', function (event) {
      if (!isPrimaryButton(event)) {
        return;
      }
      var originalEvent = getOriginal$1(event);
      if (!originalEvent) {
        throw new Error('must supply DOM mousedown event');
      }
      return start(originalEvent, event.element);
    });

    /**
     * Start move.
     *
     * @param {MouseEvent|TouchEvent} event
     * @param {Shape} element
     * @param {boolean} [activate]
     * @param {Object} [context]
     */
    function start(event, element, activate, context) {
      if (isObject$2(activate)) {
        context = activate;
        activate = false;
      }

      // do not move connections or the root element
      if (element.waypoints || !element.parent) {
        return;
      }

      // ignore non-draggable hits
      if (classes(event.target).has('djs-hit-no-move')) {
        return;
      }
      var referencePoint = mid(element);
      dragging.init(event, referencePoint, 'shape.move', {
        cursor: 'grabbing',
        autoActivate: activate,
        data: {
          shape: element,
          context: context || {}
        }
      });

      // we've handled the event
      return true;
    }

    // API

    this.start = start;
  }
  MoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];

  /**
   * Return a filtered list of elements that do not contain
   * those nested into others.
   *
   * @param {Element[]} elements
   *
   * @return {Element[]} filtered
   */
  function removeNested(elements) {
    var ids = groupBy(elements, 'id');
    return filter$2(elements, function (element) {
      while (element = element.parent) {
        // parent in selection
        if (ids[element.id]) {
          return false;
        }
      }
      return true;
    });
  }

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../preview-support/PreviewSupport').default} PreviewSupport
   * @typedef {import('../../draw/Styles').default} Styles
   */

  var LOW_PRIORITY$c = 499;
  var MARKER_DRAGGING = 'djs-dragging',
    MARKER_OK = 'drop-ok',
    MARKER_NOT_OK = 'drop-not-ok',
    MARKER_NEW_PARENT = 'new-parent',
    MARKER_ATTACH = 'attach-ok';

  /**
   * Provides previews for moving shapes when moving.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Styles} styles
   * @param {PreviewSupport} previewSupport
   */
  function MovePreview(eventBus, canvas, styles, previewSupport) {
    function getVisualDragShapes(shapes) {
      var elements = getAllDraggedElements(shapes);
      var filteredElements = removeEdges(elements);
      return filteredElements;
    }
    function getAllDraggedElements(shapes) {
      var allShapes = selfAndAllChildren(shapes, true);
      var allConnections = map$2(allShapes, function (shape) {
        return (shape.incoming || []).concat(shape.outgoing || []);
      });
      return flatten$1(allShapes.concat(allConnections));
    }

    /**
     * Sets drop marker on an element.
     */
    function setMarker(element, marker) {
      [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {
        if (m === marker) {
          canvas.addMarker(element, m);
        } else {
          canvas.removeMarker(element, m);
        }
      });
    }

    /**
     * Make an element draggable.
     *
     * @param {Object} context
     * @param {Element} element
     * @param {boolean} addMarker
     */
    function makeDraggable(context, element, addMarker) {
      previewSupport.addDragger(element, context.dragGroup);
      if (addMarker) {
        canvas.addMarker(element, MARKER_DRAGGING);
      }
      if (context.allDraggedElements) {
        context.allDraggedElements.push(element);
      } else {
        context.allDraggedElements = [element];
      }
    }

    // assign a low priority to this handler
    // to let others modify the move context before
    // we draw things
    eventBus.on('shape.move.start', LOW_PRIORITY$c, function (event) {
      var context = event.context,
        dragShapes = context.shapes,
        allDraggedElements = context.allDraggedElements;
      var visuallyDraggedShapes = getVisualDragShapes(dragShapes);
      if (!context.dragGroup) {
        var dragGroup = create$2('g');
        attr(dragGroup, styles.cls('djs-drag-group', ['no-events']));
        var activeLayer = canvas.getActiveLayer();
        append(activeLayer, dragGroup);
        context.dragGroup = dragGroup;
      }

      // add previews
      visuallyDraggedShapes.forEach(function (shape) {
        previewSupport.addDragger(shape, context.dragGroup);
      });

      // cache all dragged elements / gfx
      // so that we can quickly undo their state changes later
      if (!allDraggedElements) {
        allDraggedElements = getAllDraggedElements(dragShapes);
      } else {
        allDraggedElements = flatten$1([allDraggedElements, getAllDraggedElements(dragShapes)]);
      }

      // add dragging marker
      forEach$3(allDraggedElements, function (e) {
        canvas.addMarker(e, MARKER_DRAGGING);
      });
      context.allDraggedElements = allDraggedElements;

      // determine, if any of the dragged elements have different parents
      context.differentParents = haveDifferentParents(dragShapes);
    });

    // update previews
    eventBus.on('shape.move.move', LOW_PRIORITY$c, function (event) {
      var context = event.context,
        dragGroup = context.dragGroup,
        target = context.target,
        parent = context.shape.parent,
        canExecute = context.canExecute;
      if (target) {
        if (canExecute === 'attach') {
          setMarker(target, MARKER_ATTACH);
        } else if (context.canExecute && target && target.id !== parent.id) {
          setMarker(target, MARKER_NEW_PARENT);
        } else {
          setMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
        }
      }
      translate$1(dragGroup, event.dx, event.dy);
    });
    eventBus.on(['shape.move.out', 'shape.move.cleanup'], function (event) {
      var context = event.context,
        target = context.target;
      if (target) {
        setMarker(target, null);
      }
    });

    // remove previews
    eventBus.on('shape.move.cleanup', function (event) {
      var context = event.context,
        allDraggedElements = context.allDraggedElements,
        dragGroup = context.dragGroup;

      // remove dragging marker
      forEach$3(allDraggedElements, function (e) {
        canvas.removeMarker(e, MARKER_DRAGGING);
      });
      if (dragGroup) {
        remove$3(dragGroup);
      }
    });

    // API //////////////////////

    /**
     * Make an element draggable.
     *
     * @param {Object} context
     * @param {Element} element
     * @param {boolean} addMarker
     */
    this.makeDraggable = makeDraggable;
  }
  MovePreview.$inject = ['eventBus', 'canvas', 'styles', 'previewSupport'];

  // helpers //////////////////////

  /**
   * returns elements minus all connections
   * where source or target is not elements
   */
  function removeEdges(elements) {
    var filteredElements = filter$2(elements, function (element) {
      if (!isConnection(element)) {
        return true;
      } else {
        return find$2(elements, matchPattern({
          id: element.source.id
        })) && find$2(elements, matchPattern({
          id: element.target.id
        }));
      }
    });
    return filteredElements;
  }
  function haveDifferentParents(elements) {
    return size(groupBy(elements, function (e) {
      return e.parent && e.parent.id;
    })) !== 1;
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var MoveModule = {
    __depends__: [InteractionEventsModule, SelectionModule, Outline, Rules$5, DraggingModule, PreviewSupportModule],
    __init__: ['move', 'movePreview'],
    move: ['type', MoveEvents],
    movePreview: ['type', MovePreview]
  };

  function ownKeys$a(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$a(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$a(Object(source), !0).forEach(function (key) {
        _defineProperty$J(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$J(obj, key, value) {
    key = _toPropertyKey$G(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$G(arg) {
    var key = _toPrimitive$G(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$G(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var BUSINESS_KNOWLEDGE_MODEL_OUTLINE_PATH = "\nM2.45221 16.0068L18.7175 1.74436L18.0615 0.996331L18.7175 1.74436C19.2646 1.26455 19.9676 \n1 20.6953 1H140.926C142.583 1 143.926 2.34295 143.926 3.99967L143.93 37.5457C143.93 \n38.3668 143.593 39.152 142.999 39.7183L143.689 40.4424L142.999 39.7183L127.299 \n54.6723C126.741 55.2036 126 55.5 125.23 55.5H4.53787C2.88599 55.5 1.54491 54.1646 1.5379 \n52.5127L1.43066 27.229L1.43065 27.2248L1.4301 18.2626C1.43005 \n17.3986 1.80255 16.5765 2.45221 16.0068Z\n";
  var KNOWLEDGE_SOURCE_OUTLINE_PATH = "\nM1.79494 63.0032L1.2941 63.6423L1.79493 63.0032C1.71778 62.9427 1.6428 62.8741 1.57288 \n62.8L1.01736 63.3241L1.57288 62.8C1.20495 62.41 1 61.8941 1 61.3579V2.65067C1 1.74066 \n1.73867 1.00345 2.64868 1.00526L108.006 1.2145C109.66 1.21778 111 2.55996 111 \n4.21449V21.7015V61.6762C111 63.3188 109.679 64.656 108.037 64.676L107.06 64.6879C106.66 \n64.6927 106.26 64.6165 105.89 64.4652C105.04 64.1176 104.222 63.78 103.43 \n63.4531C93.4866 59.3517 87.6891 56.9603 76.3991 58.1057C71.7035 58.5821 66.8747 60.74 \n61.5721 63.1744C61.3243 63.2881 61.0753 63.4026 60.825 63.5177C55.6712 65.8868 49.9696 \n68.5077 43.2365 70.3468C31.101 73.6617 15.2135 73.5179 1.79494 63.0032Z\n";

  /**
   * @type {Dimensions}
   */
  var BUSINESS_KNOWLEDGE_MODEL_STANDARD_SIZE = {
    width: 135,
    height: 46
  };

  /**
   * @type {Dimensions}
   */
  var KNOWLEDGE_SOURCE_STANDARD_SIZE = {
    width: 100,
    height: 63
  };

  /**
   * Create a path element with given attributes.
   * @param {string} path
   * @param {Object} attrs
   * @param {Object} OUTLINE_STYLE
   * @return {SVGElement}
   */
  function createPath(path, attrs, OUTLINE_STYLE) {
    return create$2('path', _objectSpread$a({
      d: path,
      strokeWidth: 2,
      transform: "translate(".concat(attrs.x, ", ").concat(attrs.y, ")")
    }, OUTLINE_STYLE));
  }

  var DEFAULT_OFFSET = 5;

  /**
   * DMN-specific outline provider.
   *
   * @implements {BaseOutlineProvider}
   *
   * @param {Outline} outline
   * @param {Styles} styles
   */
  function OutlineProvider$1(outline, styles) {
    this._styles = styles;
    outline.registerProvider(this);
  }
  OutlineProvider$1.$inject = ['outline', 'styles'];

  /**
   * Returns outline for a given element.
   *
   * @param {Element} element
   *
   * @return {Outline}
   */
  OutlineProvider$1.prototype.getOutline = function (element) {
    var OUTLINE_STYLE = this._styles.cls('djs-outline', ['no-fill']);
    var outline;
    if (is$1(element, 'dmn:InputData')) {
      outline = create$2('rect');
      attr(outline, assign$4({
        x: -DEFAULT_OFFSET,
        y: -DEFAULT_OFFSET,
        rx: 27,
        width: element.width + DEFAULT_OFFSET * 2,
        height: element.height + DEFAULT_OFFSET * 2
      }, OUTLINE_STYLE));
    } else if (is$1(element, 'dmn:BusinessKnowledgeModel') && isStandardSize(element, 'dmn:BusinessKnowledgeModel')) {
      outline = createPath(BUSINESS_KNOWLEDGE_MODEL_OUTLINE_PATH, {
        x: -6,
        y: -6
      }, OUTLINE_STYLE);
    } else if (is$1(element, 'dmn:KnowledgeSource') && isStandardSize(element, 'dmn:KnowledgeSource')) {
      outline = createPath(KNOWLEDGE_SOURCE_OUTLINE_PATH, {
        x: -6,
        y: -1.5
      }, OUTLINE_STYLE);
    }
    return outline;
  };

  /**
   * Updates the outline for a given element.
   * Returns true if the update for the given element was handled by this provider.
   *
   * @param {Element} element
   * @param {Outline} outline
   * @returns {boolean}
   */
  OutlineProvider$1.prototype.updateOutline = function (element) {
    if (isAny(element, ['dmn:InputData', 'dmn:BusinessKnowledgeModel', 'dmn:KnowledgeSource'])) {
      return true;
    }
    return false;
  };

  // helpers //////////

  function isStandardSize(element, type) {
    var standardSize;
    if (type === 'dmn:BusinessKnowledgeModel') {
      standardSize = BUSINESS_KNOWLEDGE_MODEL_STANDARD_SIZE;
    } else if (type === 'dmn:KnowledgeSource') {
      standardSize = KNOWLEDGE_SOURCE_STANDARD_SIZE;
    }
    return element.width === standardSize.width && element.height === standardSize.height;
  }

  var OutlineProvider = {
    __depends__: [Outline],
    __init__: ['outlineProvider'],
    outlineProvider: ['type', OutlineProvider$1]
  };

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   *
   * @typedef {import('./PaletteProvider').PaletteEntries} PaletteEntries
   * @typedef {import('./PaletteProvider').default} PaletteProvider
   */

  var TOGGLE_SELECTOR = '.djs-palette-toggle',
    ENTRY_SELECTOR = '.entry',
    ELEMENT_SELECTOR$1 = TOGGLE_SELECTOR + ', ' + ENTRY_SELECTOR;
  var PALETTE_PREFIX = 'djs-palette-',
    PALETTE_SHOWN_CLS = 'shown',
    PALETTE_OPEN_CLS = 'open',
    PALETTE_TWO_COLUMN_CLS = 'two-column';
  var DEFAULT_PRIORITY$2 = 1000;

  /**
   * A palette containing modeling elements.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function Palette(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    var self = this;
    eventBus.on('tool-manager.update', function (event) {
      var tool = event.tool;
      self.updateToolHighlight(tool);
    });
    eventBus.on('i18n.changed', function () {
      self._update();
    });
    eventBus.on('diagram.init', function () {
      self._diagramInitialized = true;
      self._rebuild();
    });
  }
  Palette.$inject = ['eventBus', 'canvas'];

  /**
   * @overlord
   *
   * Register a palette provider with default priority. See
   * {@link PaletteProvider} for examples.
   *
   * @param {PaletteProvider} provider
   */

  /**
   * Register a palette provider with the given priority. See
   * {@link PaletteProvider} for examples.
   *
   * @param {number} priority
   * @param {PaletteProvider} provider
   */
  Palette.prototype.registerProvider = function (priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY$2;
    }
    this._eventBus.on('palette.getProviders', priority, function (event) {
      event.providers.push(provider);
    });
    this._rebuild();
  };

  /**
   * Returns the palette entries.
   *
   * @return {PaletteEntries}
   */
  Palette.prototype.getEntries = function () {
    var providers = this._getProviders();
    return providers.reduce(addPaletteEntries, {});
  };
  Palette.prototype._rebuild = function () {
    if (!this._diagramInitialized) {
      return;
    }
    var providers = this._getProviders();
    if (!providers.length) {
      return;
    }
    if (!this._container) {
      this._init();
    }
    this._update();
  };

  /**
   * Initialize palette.
   */
  Palette.prototype._init = function () {
    var self = this;
    var eventBus = this._eventBus;
    var parentContainer = this._getParentContainer();
    var container = this._container = domify$1(Palette.HTML_MARKUP);
    parentContainer.appendChild(container);
    classes$1(parentContainer).add(PALETTE_PREFIX + PALETTE_SHOWN_CLS);
    delegate.bind(container, ELEMENT_SELECTOR$1, 'click', function (event) {
      var target = event.delegateTarget;
      if (matches(target, TOGGLE_SELECTOR)) {
        return self.toggle();
      }
      self.trigger('click', event);
    });

    // prevent drag propagation
    event.bind(container, 'mousedown', function (event) {
      event.stopPropagation();
    });

    // prevent drag propagation
    delegate.bind(container, ENTRY_SELECTOR, 'dragstart', function (event) {
      self.trigger('dragstart', event);
    });
    eventBus.on('canvas.resized', this._layoutChanged, this);
    eventBus.fire('palette.create', {
      container: container
    });
  };
  Palette.prototype._getProviders = function (id) {
    var event = this._eventBus.createEvent({
      type: 'palette.getProviders',
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };

  /**
   * Update palette state.
   *
   * @param { {
   *   open?: boolean;
   *   twoColumn?: boolean;
   * } } [state]
   */
  Palette.prototype._toggleState = function (state) {
    state = state || {};
    var parent = this._getParentContainer(),
      container = this._container;
    var eventBus = this._eventBus;
    var twoColumn;
    var cls = classes$1(container),
      parentCls = classes$1(parent);
    if ('twoColumn' in state) {
      twoColumn = state.twoColumn;
    } else {
      twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
    }

    // always update two column
    cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);
    parentCls.toggle(PALETTE_PREFIX + PALETTE_TWO_COLUMN_CLS, twoColumn);
    if ('open' in state) {
      cls.toggle(PALETTE_OPEN_CLS, state.open);
      parentCls.toggle(PALETTE_PREFIX + PALETTE_OPEN_CLS, state.open);
    }
    eventBus.fire('palette.changed', {
      twoColumn: twoColumn,
      open: this.isOpen()
    });
  };
  Palette.prototype._update = function () {
    var entriesContainer = query('.djs-palette-entries', this._container),
      entries = this._entries = this.getEntries();
    clear$1(entriesContainer);
    forEach$3(entries, function (entry, id) {
      var grouping = entry.group || 'default';
      var container = query('[data-group=' + escapeCSS(grouping) + ']', entriesContainer);
      if (!container) {
        container = domify$1('<div class="group"></div>');
        attr$1(container, 'data-group', grouping);
        entriesContainer.appendChild(container);
      }
      var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');
      var control = domify$1(html);
      container.appendChild(control);
      if (!entry.separator) {
        attr$1(control, 'data-action', id);
        if (entry.title) {
          attr$1(control, 'title', entry.title);
        }
        if (entry.className) {
          addClasses(control, entry.className);
        }
        if (entry.imageUrl) {
          var image = domify$1('<img>');
          attr$1(image, 'src', entry.imageUrl);
          control.appendChild(image);
        }
      }
    });

    // open after update
    this.open();
  };

  /**
   * Trigger an action available on the palette
   *
   * @param {string} action
   * @param {Event} event
   * @param {boolean} [autoActivate=false]
   */
  Palette.prototype.trigger = function (action, event, autoActivate) {
    var entry,
      originalEvent,
      button = event.delegateTarget || event.target;
    if (!button) {
      return event.preventDefault();
    }
    entry = attr$1(button, 'data-action');
    originalEvent = event.originalEvent || event;
    return this.triggerEntry(entry, action, originalEvent, autoActivate);
  };

  /**
   * @param {string} entryId
   * @param {string} action
   * @param {Event} event
   * @param {boolean} [autoActivate=false]
   */
  Palette.prototype.triggerEntry = function (entryId, action, event, autoActivate) {
    var entries = this._entries,
      entry,
      handler;
    entry = entries[entryId];

    // when user clicks on the palette and not on an action
    if (!entry) {
      return;
    }
    handler = entry.action;
    if (this._eventBus.fire('palette.trigger', {
      entry: entry,
      event: event
    }) === false) {
      return;
    }

    // simple action (via callback function)
    if (isFunction$2(handler)) {
      if (action === 'click') {
        return handler(event, autoActivate);
      }
    } else {
      if (handler[action]) {
        return handler[action](event, autoActivate);
      }
    }

    // silence other actions
    event.preventDefault();
  };
  Palette.prototype._layoutChanged = function () {
    this._toggleState({});
  };

  /**
   * Do we need to collapse to two columns?
   *
   * @param {number} availableHeight
   * @param {PaletteEntries} entries
   *
   * @return {boolean}
   */
  Palette.prototype._needsCollapse = function (availableHeight, entries) {
    // top margin + bottom toggle + bottom margin
    // implementors must override this method if they
    // change the palette styles
    var margin = 20 + 10 + 20;
    var entriesHeight = Object.keys(entries).length * 46;
    return availableHeight < entriesHeight + margin;
  };

  /**
   * Close the palette.
   */
  Palette.prototype.close = function () {
    this._toggleState({
      open: false,
      twoColumn: false
    });
  };

  /**
   * Open the palette.
   */
  Palette.prototype.open = function () {
    this._toggleState({
      open: true
    });
  };

  /**
   * Toggle the palette.
   */
  Palette.prototype.toggle = function () {
    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };

  /**
   * @param {string} tool
   *
   * @return {boolean}
   */
  Palette.prototype.isActiveTool = function (tool) {
    return tool && this._activeTool === tool;
  };

  /**
   * @param {string} name
   */
  Palette.prototype.updateToolHighlight = function (name) {
    var entriesContainer, toolsContainer;
    if (!this._toolsContainer) {
      entriesContainer = query('.djs-palette-entries', this._container);
      this._toolsContainer = query('[data-group=tools]', entriesContainer);
    }
    toolsContainer = this._toolsContainer;
    forEach$3(toolsContainer.children, function (tool) {
      var actionName = tool.getAttribute('data-action');
      if (!actionName) {
        return;
      }
      var toolClasses = classes$1(tool);
      actionName = actionName.replace('-tool', '');
      if (toolClasses.contains('entry') && actionName === name) {
        toolClasses.add('highlighted-entry');
      } else {
        toolClasses.remove('highlighted-entry');
      }
    });
  };

  /**
   * Return `true` if the palette is opened.
   *
   * @example
   *
   * ```javascript
   * palette.open();
   *
   * if (palette.isOpen()) {
   *   // yes, we are open
   * }
   * ```
   *
   * @return {boolean}
   */
  Palette.prototype.isOpen = function () {
    return classes$1(this._container).has(PALETTE_OPEN_CLS);
  };

  /**
   * Get parent element of palette.
   *
   * @return {HTMLElement}
   */
  Palette.prototype._getParentContainer = function () {
    return this._canvas.getContainer();
  };

  /* markup definition */

  Palette.HTML_MARKUP = '<div class="djs-palette">' + '<div class="djs-palette-entries"></div>' + '<div class="djs-palette-toggle"></div>' + '</div>';

  // helpers //////////////////////

  function addClasses(element, classNames) {
    var classes = classes$1(element);
    var actualClassNames = isArray$6(classNames) ? classNames : classNames.split(/\s+/g);
    actualClassNames.forEach(function (cls) {
      classes.add(cls);
    });
  }
  function addPaletteEntries(entries, provider) {
    var entriesOrUpdater = provider.getPaletteEntries();
    if (isFunction$2(entriesOrUpdater)) {
      return entriesOrUpdater(entries);
    }
    forEach$3(entriesOrUpdater, function (entry, id) {
      entries[id] = entry;
    });
    return entries;
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramPalette = {
    __init__: ['palette'],
    palette: ['type', Palette]
  };

  /**
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/EventBus').default} EventBus
   *
   * @typedef {import('../../core/EventBus').Event} Event
   */

  var LOW_PRIORITY$b = 250;

  /**
   * The tool manager acts as middle-man between the available tool's and the Palette,
   * it takes care of making sure that the correct active state is set.
   *
   * @param {EventBus} eventBus
   * @param {Dragging} dragging
   */
  function ToolManager(eventBus, dragging) {
    this._eventBus = eventBus;
    this._dragging = dragging;
    this._tools = [];
    this._active = null;
  }
  ToolManager.$inject = ['eventBus', 'dragging'];

  /**
   * Register a tool.
   *
   * @param {string} name
   * @param { {
   *   dragging: string;
   *   tool: string;
   * } } events
   */
  ToolManager.prototype.registerTool = function (name, events) {
    var tools = this._tools;
    if (!events) {
      throw new Error('A tool has to be registered with it\'s "events"');
    }
    tools.push(name);
    this.bindEvents(name, events);
  };
  ToolManager.prototype.isActive = function (tool) {
    return tool && this._active === tool;
  };
  ToolManager.prototype.length = function (tool) {
    return this._tools.length;
  };
  ToolManager.prototype.setActive = function (tool) {
    var eventBus = this._eventBus;
    if (this._active !== tool) {
      this._active = tool;
      eventBus.fire('tool-manager.update', {
        tool: tool
      });
    }
  };
  ToolManager.prototype.bindEvents = function (name, events) {
    var eventBus = this._eventBus,
      dragging = this._dragging;
    var eventsToRegister = [];
    eventBus.on(events.tool + '.init', function (event) {
      var context = event.context;

      // Active tools that want to reactivate themselves must do this explicitly
      if (!context.reactivate && this.isActive(name)) {
        this.setActive(null);
        dragging.cancel();
        return;
      }
      this.setActive(name);
    }, this);

    // TODO: add test cases
    forEach$3(events, function (event) {
      eventsToRegister.push(event + '.ended');
      eventsToRegister.push(event + '.canceled');
    });
    eventBus.on(eventsToRegister, LOW_PRIORITY$b, function (event) {
      // We defer the de-activation of the tool to the .activate phase,
      // so we're able to check if we want to toggle off the current
      // active tool or switch to a new one
      if (!this._active) {
        return;
      }
      if (isPaletteClick(event)) {
        return;
      }
      this.setActive(null);
    }, this);
  };

  // helpers ///////////////

  /**
   * Check if a given event is a palette click event.
   *
   * @param {Event} event
   *
   * @return {boolean}
   */
  function isPaletteClick(event) {
    var target = event.originalEvent && event.originalEvent.target;
    return target && closest(target, '.group[data-group="tools"]');
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var ToolManagerModule = {
    __depends__: [DraggingModule],
    __init__: ['toolManager'],
    toolManager: ['type', ToolManager]
  };

  /**
   * @typedef {import('../../core/EventBus').default} EventBus
   */

  /**
   * @param {EventBus} eventBus
   */
  function Mouse(eventBus) {
    var self = this;
    this._lastMoveEvent = null;
    function setLastMoveEvent(mousemoveEvent) {
      self._lastMoveEvent = mousemoveEvent;
    }
    eventBus.on('canvas.init', function (context) {
      var svg = self._svg = context.svg;
      svg.addEventListener('mousemove', setLastMoveEvent);
    });
    eventBus.on('canvas.destroy', function () {
      self._lastMouseEvent = null;
      self._svg.removeEventListener('mousemove', setLastMoveEvent);
    });
  }
  Mouse.$inject = ['eventBus'];
  Mouse.prototype.getLastMoveEvent = function () {
    return this._lastMoveEvent || createMoveEvent(0, 0);
  };

  // helpers //////////

  function createMoveEvent(x, y) {
    var event = document.createEvent('MouseEvent');
    var screenX = x,
      screenY = y,
      clientX = x,
      clientY = y;
    if (event.initMouseEvent) {
      event.initMouseEvent('mousemove', true, true, window, 0, screenX, screenY, clientX, clientY, false, false, false, false, 0, null);
    }
    return event;
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var MouseModule = {
    __init__: ['mouse'],
    mouse: ['type', Mouse]
  };

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../mouse/Mouse').default} Mouse
   * @typedef {import('../selection/Selection').default} Selection
   * @typedef {import('../tool-manager/ToolManager').default} ToolManager
   */

  var LASSO_TOOL_CURSOR = 'crosshair';

  /**
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Dragging} dragging
   * @param {ElementRegistry} elementRegistry
   * @param {Selection} selection
   * @param {ToolManager} toolManager
   * @param {Mouse} mouse
   */
  function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager, mouse) {
    this._selection = selection;
    this._dragging = dragging;
    this._mouse = mouse;
    var self = this;

    // lasso visuals implementation

    /**
    * A helper that realizes the selection box visual
    */
    var visuals = {
      create: function create(context) {
        var container = canvas.getActiveLayer(),
          frame;
        frame = context.frame = create$2('rect');
        attr(frame, {
          "class": 'djs-lasso-overlay',
          width: 1,
          height: 1,
          x: 0,
          y: 0
        });
        append(container, frame);
      },
      update: function update(context) {
        var frame = context.frame,
          bbox = context.bbox;
        attr(frame, {
          x: bbox.x,
          y: bbox.y,
          width: bbox.width,
          height: bbox.height
        });
      },
      remove: function remove(context) {
        if (context.frame) {
          remove$3(context.frame);
        }
      }
    };
    toolManager.registerTool('lasso', {
      tool: 'lasso.selection',
      dragging: 'lasso'
    });
    eventBus.on('lasso.selection.end', function (event) {
      var target = event.originalEvent.target;

      // only reactive on diagram click
      // on some occasions, event.hover is not set and we have to check if the target is an svg
      if (!event.hover && !(target instanceof SVGElement)) {
        return;
      }
      eventBus.once('lasso.selection.ended', function () {
        self.activateLasso(event.originalEvent, true);
      });
    });

    // lasso interaction implementation

    eventBus.on('lasso.end', function (event) {
      var bbox = toBBox(event);
      var elements = elementRegistry.filter(function (element) {
        return element;
      });
      self.select(elements, bbox);
    });
    eventBus.on('lasso.start', function (event) {
      var context = event.context;
      context.bbox = toBBox(event);
      visuals.create(context);
    });
    eventBus.on('lasso.move', function (event) {
      var context = event.context;
      context.bbox = toBBox(event);
      visuals.update(context);
    });
    eventBus.on('lasso.cleanup', function (event) {
      var context = event.context;
      visuals.remove(context);
    });

    // event integration

    eventBus.on('element.mousedown', 1500, function (event) {
      if (!hasSecondaryModifier(event)) {
        return;
      }
      self.activateLasso(event.originalEvent);

      // we've handled the event
      return true;
    });
  }
  LassoTool.$inject = ['eventBus', 'canvas', 'dragging', 'elementRegistry', 'selection', 'toolManager', 'mouse'];
  LassoTool.prototype.activateLasso = function (event, autoActivate) {
    this._dragging.init(event, 'lasso', {
      autoActivate: autoActivate,
      cursor: LASSO_TOOL_CURSOR,
      data: {
        context: {}
      }
    });
  };
  LassoTool.prototype.activateSelection = function (event, autoActivate) {
    this._dragging.init(event, 'lasso.selection', {
      trapClick: false,
      autoActivate: autoActivate,
      cursor: LASSO_TOOL_CURSOR,
      data: {
        context: {}
      }
    });
  };
  LassoTool.prototype.select = function (elements, bbox) {
    var selectedElements = getEnclosedElements(elements, bbox);
    this._selection.select(values$1(selectedElements));
  };
  LassoTool.prototype.toggle = function () {
    if (this.isActive()) {
      return this._dragging.cancel();
    }
    var mouseEvent = this._mouse.getLastMoveEvent();
    this.activateSelection(mouseEvent, !!mouseEvent);
  };
  LassoTool.prototype.isActive = function () {
    var context = this._dragging.context();
    return context && /^lasso/.test(context.prefix);
  };
  function toBBox(event) {
    var start = {
      x: event.x - event.dx,
      y: event.y - event.dy
    };
    var end = {
      x: event.x,
      y: event.y
    };
    var bbox;
    if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {
      bbox = {
        x: start.x,
        y: start.y,
        width: end.x - start.x,
        height: end.y - start.y
      };
    } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {
      bbox = {
        x: end.x,
        y: start.y,
        width: start.x - end.x,
        height: end.y - start.y
      };
    } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {
      bbox = {
        x: start.x,
        y: end.y,
        width: end.x - start.x,
        height: start.y - end.y
      };
    } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {
      bbox = {
        x: end.x,
        y: end.y,
        width: start.x - end.x,
        height: start.y - end.y
      };
    } else {
      bbox = {
        x: end.x,
        y: end.y,
        width: 0,
        height: 0
      };
    }
    return bbox;
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramLasso = {
    __depends__: [ToolManagerModule, MouseModule],
    __init__: ['lassoTool'],
    lassoTool: ['type', LassoTool]
  };

  /**
   * @typedef {import('didi').Injector} Injector
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../mouse/Mouse').default} Mouse
   * @typedef {import('../tool-manager/ToolManager').default} ToolManager
   */

  var HIGH_PRIORITY$5 = 1500;
  var HAND_CURSOR = 'grab';

  /**
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Dragging} dragging
   * @param {Injector} injector
   * @param {ToolManager} toolManager
   * @param {Mouse} mouse
   */
  function HandTool(eventBus, canvas, dragging, injector, toolManager, mouse) {
    this._dragging = dragging;
    this._mouse = mouse;
    var self = this,
      keyboard = injector.get('keyboard', false);
    toolManager.registerTool('hand', {
      tool: 'hand',
      dragging: 'hand.move'
    });
    eventBus.on('element.mousedown', HIGH_PRIORITY$5, function (event) {
      if (!hasPrimaryModifier(event)) {
        return;
      }
      self.activateMove(event.originalEvent, true);
      return false;
    });
    keyboard && keyboard.addListener(HIGH_PRIORITY$5, function (e) {
      if (!isSpace$1(e.keyEvent) || self.isActive()) {
        return;
      }
      var mouseEvent = self._mouse.getLastMoveEvent();
      self.activateMove(mouseEvent, !!mouseEvent);
    }, 'keyboard.keydown');
    keyboard && keyboard.addListener(HIGH_PRIORITY$5, function (e) {
      if (!isSpace$1(e.keyEvent) || !self.isActive()) {
        return;
      }
      self.toggle();
    }, 'keyboard.keyup');
    eventBus.on('hand.end', function (event) {
      var target = event.originalEvent.target;

      // only reactive on diagram click
      // on some occasions, event.hover is not set and we have to check if the target is an svg
      if (!event.hover && !(target instanceof SVGElement)) {
        return false;
      }
      eventBus.once('hand.ended', function () {
        self.activateMove(event.originalEvent, {
          reactivate: true
        });
      });
    });
    eventBus.on('hand.move.move', function (event) {
      var scale = canvas.viewbox().scale;
      canvas.scroll({
        dx: event.dx * scale,
        dy: event.dy * scale
      });
    });
    eventBus.on('hand.move.end', function (event) {
      var context = event.context,
        reactivate = context.reactivate;

      // Don't reactivate if the user is using the keyboard keybinding
      if (!hasPrimaryModifier(event) && reactivate) {
        eventBus.once('hand.move.ended', function (event) {
          self.activateHand(event.originalEvent, true, true);
        });
      }
      return false;
    });
  }
  HandTool.$inject = ['eventBus', 'canvas', 'dragging', 'injector', 'toolManager', 'mouse'];
  HandTool.prototype.activateMove = function (event, autoActivate, context) {
    if (_typeof(autoActivate) === 'object') {
      context = autoActivate;
      autoActivate = false;
    }
    this._dragging.init(event, 'hand.move', {
      autoActivate: autoActivate,
      cursor: HAND_CURSOR,
      data: {
        context: context || {}
      }
    });
  };
  HandTool.prototype.activateHand = function (event, autoActivate, reactivate) {
    this._dragging.init(event, 'hand', {
      trapClick: false,
      autoActivate: autoActivate,
      cursor: HAND_CURSOR,
      data: {
        context: {
          reactivate: reactivate
        }
      }
    });
  };
  HandTool.prototype.toggle = function () {
    if (this.isActive()) {
      return this._dragging.cancel();
    }
    var mouseEvent = this._mouse.getLastMoveEvent();
    this.activateHand(mouseEvent, !!mouseEvent);
  };
  HandTool.prototype.isActive = function () {
    var context = this._dragging.context();
    if (context) {
      return /^(hand|hand\.move)$/.test(context.prefix);
    }
    return false;
  };

  // helpers //////////

  function isSpace$1(keyEvent) {
    return isKey('Space', keyEvent);
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var DiagramHand = {
    __depends__: [ToolManagerModule, MouseModule],
    __init__: ['handTool'],
    handTool: ['type', HandTool]
  };

  /**
   * A palette provider for DMN elements.
   */
  function PaletteProvider(palette, create, elementFactory, handTool, lassoTool, translate) {
    this._palette = palette;
    this._create = create;
    this._elementFactory = elementFactory;
    this._handTool = handTool;
    this._lassoTool = lassoTool;
    this._translate = translate;
    palette.registerProvider(this);
  }
  PaletteProvider.$inject = ['palette', 'create', 'elementFactory', 'handTool', 'lassoTool', 'translate'];
  PaletteProvider.prototype.getPaletteEntries = function (element) {
    var actions = {},
      create = this._create,
      elementFactory = this._elementFactory,
      handTool = this._handTool,
      lassoTool = this._lassoTool,
      translate = this._translate;
    function createAction(type, group, className, title, options) {
      function createListener(event) {
        var shape = elementFactory.createShape(assign$4({
          type: type
        }, options));
        create.start(event, shape);
      }
      return {
        group: group,
        className: className,
        title: title,
        action: {
          dragstart: createListener,
          click: createListener
        }
      };
    }
    assign$4(actions, {
      'hand-tool': {
        group: 'tools',
        className: 'dmn-icon-hand-tool',
        title: translate('Activate hand tool'),
        action: {
          click: function click(event) {
            handTool.activateHand(event);
          }
        }
      },
      'lasso-tool': {
        group: 'tools',
        className: 'dmn-icon-lasso-tool',
        title: translate('Activate lasso tool'),
        action: {
          click: function click(event) {
            lassoTool.activateSelection(event);
          }
        }
      },
      'tool-separator': {
        group: 'tools',
        separator: true
      },
      'create.decision': createAction('dmn:Decision', 'drd', 'dmn-icon-decision', translate('Create decision')),
      'create.input-data': createAction('dmn:InputData', 'drd', 'dmn-icon-input-data', translate('Create input data')),
      'create.knowledge-source': createAction('dmn:KnowledgeSource', 'drd', 'dmn-icon-knowledge-source', translate('Create knowledge source')),
      'create.business-knowledge-model': createAction('dmn:BusinessKnowledgeModel', 'drd', 'dmn-icon-business-knowledge', translate('Create knowledge model'))
    });
    return actions;
  };

  var PaletteModule = {
    __depends__: [TranslateModule, DiagramPalette, DiagramCreate, DiagramLasso, DiagramHand],
    __init__: ['paletteProvider'],
    paletteProvider: ['type', PaletteProvider]
  };

  var max = Math.max,
    min = Math.min;
  var DEFAULT_CHILD_BOX_PADDING = 20;

  /**
   * Resize the given bounds by the specified delta from a given anchor point.
   *
   * @param {Rect} bounds the bounding box that should be resized
   * @param {Direction} direction in which the element is resized (nw, ne, se, sw)
   * @param {Point} delta of the resize operation
   *
   * @return {Rect} resized bounding box
   */
  function resizeBounds(bounds, direction, delta) {
    var dx = delta.x,
      dy = delta.y;
    var newBounds = {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: bounds.height
    };
    if (direction.indexOf('n') !== -1) {
      newBounds.y = bounds.y + dy;
      newBounds.height = bounds.height - dy;
    } else if (direction.indexOf('s') !== -1) {
      newBounds.height = bounds.height + dy;
    }
    if (direction.indexOf('e') !== -1) {
      newBounds.width = bounds.width + dx;
    } else if (direction.indexOf('w') !== -1) {
      newBounds.x = bounds.x + dx;
      newBounds.width = bounds.width - dx;
    }
    return newBounds;
  }
  function applyConstraints(attr, trbl, resizeConstraints) {
    var value = trbl[attr],
      minValue = resizeConstraints.min && resizeConstraints.min[attr],
      maxValue = resizeConstraints.max && resizeConstraints.max[attr];
    if (isNumber$3(minValue)) {
      value = (/top|left/.test(attr) ? min : max)(value, minValue);
    }
    if (isNumber$3(maxValue)) {
      value = (/top|left/.test(attr) ? max : min)(value, maxValue);
    }
    return value;
  }
  function ensureConstraints(currentBounds, resizeConstraints) {
    if (!resizeConstraints) {
      return currentBounds;
    }
    var currentTrbl = asTRBL(currentBounds);
    return asBounds({
      top: applyConstraints('top', currentTrbl, resizeConstraints),
      right: applyConstraints('right', currentTrbl, resizeConstraints),
      bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),
      left: applyConstraints('left', currentTrbl, resizeConstraints)
    });
  }
  function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {
    var currentBox = asTRBL(currentBounds);
    var minBox = {
      top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
      left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
      bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
      right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
    };
    var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;
    var combinedBox = {
      top: min(minBox.top, childrenBox.top),
      left: min(minBox.left, childrenBox.left),
      bottom: max(minBox.bottom, childrenBox.bottom),
      right: max(minBox.right, childrenBox.right)
    };
    return asBounds(combinedBox);
  }
  function asPadding(mayBePadding, defaultValue) {
    if (typeof mayBePadding !== 'undefined') {
      return mayBePadding;
    } else {
      return DEFAULT_CHILD_BOX_PADDING;
    }
  }
  function addPadding(bbox, padding) {
    var left, right, top, bottom;
    if (_typeof(padding) === 'object') {
      left = asPadding(padding.left);
      right = asPadding(padding.right);
      top = asPadding(padding.top);
      bottom = asPadding(padding.bottom);
    } else {
      left = right = top = bottom = asPadding(padding);
    }
    return {
      x: bbox.x - left,
      y: bbox.y - top,
      width: bbox.width + left + right,
      height: bbox.height + top + bottom
    };
  }

  /**
   * Is the given element part of the resize
   * targets min boundary box?
   *
   * This is the default implementation which excludes
   * connections and labels.
   *
   * @param {Element} element
   */
  function isBBoxChild(element) {
    // exclude connections
    if (element.waypoints) {
      return false;
    }

    // exclude labels
    if (element.type === 'label') {
      return false;
    }
    return true;
  }

  /**
   * Return children bounding computed from a shapes children
   * or a list of prefiltered children.
   *
   * @param {Shape|Shape[]} shapeOrChildren
   * @param {RectTRBL|number} padding
   *
   * @return {Rect}
   */
  function computeChildrenBBox(shapeOrChildren, padding) {
    var elements;

    // compute based on shape
    if (shapeOrChildren.length === undefined) {
      // grab all the children that are part of the
      // parents children box
      elements = filter$2(shapeOrChildren.children, isBBoxChild);
    } else {
      elements = shapeOrChildren;
    }
    if (elements.length) {
      return addPadding(getBBox(elements), padding);
    }
  }

  /**
   * @typedef {import('../../core/Types').ShapeLike} Shape
   *
   * @typedef {import('../../util/Types').Direction} Direction
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../dragging/Dragging').default} Dragging
   * @typedef {import('../modeling/Modeling').default} Modeling
   * @typedef {import('../rules/Rules').default} Rules
   */

  var DEFAULT_MIN_WIDTH = 10;

  /**
   * A component that provides resizing of shapes on the canvas.
   *
   * The following components are part of shape resize:
   *
   *  * adding resize handles,
   *  * creating a visual during resize
   *  * checking resize rules
   *  * committing a change once finished
   *
   *
   * ## Customizing
   *
   * It's possible to customize the resizing behaviour by intercepting 'resize.start'
   * and providing the following parameters through the 'context':
   *
   *   * minDimensions ({ width, height }): minimum shape dimensions
   *
   *   * childrenBoxPadding ({ left, top, bottom, right } || number):
   *     gap between the minimum bounding box and the container
   *
   * f.ex:
   *
   * ```javascript
   * eventBus.on('resize.start', 1500, function(event) {
   *   var context = event.context,
   *
   *  context.minDimensions = { width: 140, height: 120 };
   *
   *  // Passing general padding
   *  context.childrenBoxPadding = 30;
   *
   *  // Passing padding to a specific side
   *  context.childrenBoxPadding.left = 20;
   * });
   * ```
   *
   * @param {EventBus} eventBus
   * @param {Rules} rules
   * @param {Modeling} modeling
   * @param {Dragging} dragging
   */
  function Resize(eventBus, rules, modeling, dragging) {
    this._dragging = dragging;
    this._rules = rules;
    var self = this;

    /**
     * Handle resize move by specified delta.
     *
     * @param {Object} context
     * @param {Point} delta
     */
    function handleMove(context, delta) {
      var shape = context.shape,
        direction = context.direction,
        resizeConstraints = context.resizeConstraints,
        newBounds;
      context.delta = delta;
      newBounds = resizeBounds(shape, direction, delta);

      // ensure constraints during resize
      context.newBounds = ensureConstraints(newBounds, resizeConstraints);

      // update + cache executable state
      context.canExecute = self.canResize(context);
    }

    /**
     * Handle resize start.
     *
     * @param {Object} context
     */
    function handleStart(context) {
      var resizeConstraints = context.resizeConstraints,
        // evaluate minBounds for backwards compatibility
        minBounds = context.minBounds;
      if (resizeConstraints !== undefined) {
        return;
      }
      if (minBounds === undefined) {
        minBounds = self.computeMinResizeBox(context);
      }
      context.resizeConstraints = {
        min: asTRBL(minBounds)
      };
    }

    /**
     * Handle resize end.
     *
     * @param {Object} context
     */
    function handleEnd(context) {
      var shape = context.shape,
        canExecute = context.canExecute,
        newBounds = context.newBounds;
      if (canExecute) {
        // ensure we have actual pixel values for new bounds
        // (important when zoom level was > 1 during move)
        newBounds = roundBounds(newBounds);
        if (!boundsChanged(shape, newBounds)) {
          // no resize necessary
          return;
        }

        // perform the actual resize
        modeling.resizeShape(shape, newBounds);
      }
    }
    eventBus.on('resize.start', function (event) {
      handleStart(event.context);
    });
    eventBus.on('resize.move', function (event) {
      var delta = {
        x: event.dx,
        y: event.dy
      };
      handleMove(event.context, delta);
    });
    eventBus.on('resize.end', function (event) {
      handleEnd(event.context);
    });
  }
  Resize.prototype.canResize = function (context) {
    var rules = this._rules;
    var ctx = pick$1(context, ['newBounds', 'shape', 'delta', 'direction']);
    return rules.allowed('shape.resize', ctx);
  };

  /**
   * Activate a resize operation.
   *
   * You may specify additional contextual information and must specify a
   * resize direction during activation of the resize event.
   *
   * @param {MouseEvent|TouchEvent} event
   * @param {Shape} shape
   * @param {Object|Direction} contextOrDirection
   */
  Resize.prototype.activate = function (event, shape, contextOrDirection) {
    var dragging = this._dragging,
      context,
      direction;
    if (typeof contextOrDirection === 'string') {
      contextOrDirection = {
        direction: contextOrDirection
      };
    }
    context = assign$4({
      shape: shape
    }, contextOrDirection);
    direction = context.direction;
    if (!direction) {
      throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');
    }
    dragging.init(event, getReferencePoint(shape, direction), 'resize', {
      autoActivate: true,
      cursor: getCursor(direction),
      data: {
        shape: shape,
        context: context
      }
    });
  };
  Resize.prototype.computeMinResizeBox = function (context) {
    var shape = context.shape,
      direction = context.direction,
      minDimensions,
      childrenBounds;
    minDimensions = context.minDimensions || {
      width: DEFAULT_MIN_WIDTH,
      height: DEFAULT_MIN_WIDTH
    };

    // get children bounds
    childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);

    // get correct minimum bounds from given resize direction
    // basically ensures that the minBounds is max(childrenBounds, minDimensions)
    return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
  };
  Resize.$inject = ['eventBus', 'rules', 'modeling', 'dragging'];

  // helpers //////////

  function boundsChanged(shape, newBounds) {
    return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;
  }
  function getReferencePoint(shape, direction) {
    var mid = getMid(shape),
      trbl = asTRBL(shape);
    var referencePoint = {
      x: mid.x,
      y: mid.y
    };
    if (direction.indexOf('n') !== -1) {
      referencePoint.y = trbl.top;
    } else if (direction.indexOf('s') !== -1) {
      referencePoint.y = trbl.bottom;
    }
    if (direction.indexOf('e') !== -1) {
      referencePoint.x = trbl.right;
    } else if (direction.indexOf('w') !== -1) {
      referencePoint.x = trbl.left;
    }
    return referencePoint;
  }
  function getCursor(direction) {
    var prefix = 'resize-';
    if (direction === 'n' || direction === 's') {
      return prefix + 'ns';
    } else if (direction === 'e' || direction === 'w') {
      return prefix + 'ew';
    } else if (direction === 'nw' || direction === 'se') {
      return prefix + 'nwse';
    } else {
      return prefix + 'nesw';
    }
  }

  var MARKER_RESIZING = 'djs-resizing',
    MARKER_RESIZE_NOT_OK = 'resize-not-ok';
  var LOW_PRIORITY$a = 500;

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../preview-support/PreviewSupport').default} PreviewSupport
   */

  /**
   * Provides previews for resizing shapes when resizing.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {PreviewSupport} previewSupport
   */
  function ResizePreview(eventBus, canvas, previewSupport) {
    /**
     * Update resizer frame.
     *
     * @param {Object} context
     */
    function updateFrame(context) {
      var shape = context.shape,
        bounds = context.newBounds,
        frame = context.frame;
      if (!frame) {
        frame = context.frame = previewSupport.addFrame(shape, canvas.getActiveLayer());
        canvas.addMarker(shape, MARKER_RESIZING);
      }
      if (bounds.width > 5) {
        attr(frame, {
          x: bounds.x,
          width: bounds.width
        });
      }
      if (bounds.height > 5) {
        attr(frame, {
          y: bounds.y,
          height: bounds.height
        });
      }
      if (context.canExecute) {
        classes(frame).remove(MARKER_RESIZE_NOT_OK);
      } else {
        classes(frame).add(MARKER_RESIZE_NOT_OK);
      }
    }

    /**
     * Remove resizer frame.
     *
     * @param {Object} context
     */
    function removeFrame(context) {
      var shape = context.shape,
        frame = context.frame;
      if (frame) {
        remove$3(context.frame);
      }
      canvas.removeMarker(shape, MARKER_RESIZING);
    }

    // add and update previews
    eventBus.on('resize.move', LOW_PRIORITY$a, function (event) {
      updateFrame(event.context);
    });

    // remove previews
    eventBus.on('resize.cleanup', function (event) {
      removeFrame(event.context);
    });
  }
  ResizePreview.$inject = ['eventBus', 'canvas', 'previewSupport'];

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../core/Canvas').default} Canvas
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('../resize/Resize').default} Resize
   * @typedef {import('../selection/Selection').default} Selection
   */

  var HANDLE_OFFSET = -6,
    HANDLE_SIZE = 8,
    HANDLE_HIT_SIZE = 20;
  var CLS_RESIZER = 'djs-resizer';
  var directions = ['n', 'w', 's', 'e', 'nw', 'ne', 'se', 'sw'];

  /**
   * This component is responsible for adding resize handles.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {Selection} selection
   * @param {Resize} resize
   */
  function ResizeHandles(eventBus, canvas, selection, resize) {
    this._resize = resize;
    this._canvas = canvas;
    var self = this;
    eventBus.on('selection.changed', function (e) {
      var newSelection = e.newSelection;

      // remove old selection markers
      self.removeResizers();

      // add new selection markers ONLY if single selection
      if (newSelection.length === 1) {
        forEach$3(newSelection, bind$3(self.addResizer, self));
      }
    });
    eventBus.on('shape.changed', function (e) {
      var shape = e.element;
      if (selection.isSelected(shape)) {
        self.removeResizers();
        self.addResizer(shape);
      }
    });
  }
  ResizeHandles.prototype.makeDraggable = function (element, gfx, direction) {
    var resize = this._resize;
    function startResize(event) {
      // only trigger on left mouse button
      if (isPrimaryButton(event)) {
        resize.activate(event, element, direction);
      }
    }
    event.bind(gfx, 'mousedown', startResize);
    event.bind(gfx, 'touchstart', startResize);
  };
  ResizeHandles.prototype._createResizer = function (element, x, y, direction) {
    var resizersParent = this._getResizersParent();
    var offset = getHandleOffset(direction);
    var group = create$2('g');
    classes(group).add(CLS_RESIZER);
    classes(group).add(CLS_RESIZER + '-' + element.id);
    classes(group).add(CLS_RESIZER + '-' + direction);
    append(resizersParent, group);
    var visual = create$2('rect');
    attr(visual, {
      x: -HANDLE_SIZE / 2 + offset.x,
      y: -HANDLE_SIZE / 2 + offset.y,
      width: HANDLE_SIZE,
      height: HANDLE_SIZE
    });
    classes(visual).add(CLS_RESIZER + '-visual');
    append(group, visual);
    var hit = create$2('rect');
    attr(hit, {
      x: -HANDLE_HIT_SIZE / 2 + offset.x,
      y: -HANDLE_HIT_SIZE / 2 + offset.y,
      width: HANDLE_HIT_SIZE,
      height: HANDLE_HIT_SIZE
    });
    classes(hit).add(CLS_RESIZER + '-hit');
    append(group, hit);
    transform(group, x, y);
    return group;
  };
  ResizeHandles.prototype.createResizer = function (element, direction) {
    var point = getReferencePoint(element, direction);
    var resizer = this._createResizer(element, point.x, point.y, direction);
    this.makeDraggable(element, resizer, direction);
  };

  // resize handles implementation ///////////////////////////////

  /**
   * Add resizers for a given element.
   *
   * @param {Element} element
   */
  ResizeHandles.prototype.addResizer = function (element) {
    var self = this;
    if (isConnection(element) || !this._resize.canResize({
      shape: element
    })) {
      return;
    }
    forEach$3(directions, function (direction) {
      self.createResizer(element, direction);
    });
  };

  /**
   * Remove all resizers
   */
  ResizeHandles.prototype.removeResizers = function () {
    var resizersParent = this._getResizersParent();
    clear(resizersParent);
  };
  ResizeHandles.prototype._getResizersParent = function () {
    return this._canvas.getLayer('resizers');
  };
  ResizeHandles.$inject = ['eventBus', 'canvas', 'selection', 'resize'];

  // helpers //////////

  function getHandleOffset(direction) {
    var offset = {
      x: 0,
      y: 0
    };
    if (direction.indexOf('e') !== -1) {
      offset.x = -HANDLE_OFFSET;
    } else if (direction.indexOf('w') !== -1) {
      offset.x = HANDLE_OFFSET;
    }
    if (direction.indexOf('s') !== -1) {
      offset.y = -HANDLE_OFFSET;
    } else if (direction.indexOf('n') !== -1) {
      offset.y = HANDLE_OFFSET;
    }
    return offset;
  }

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var ResizeModule = {
    __depends__: [Rules$5, DraggingModule, PreviewSupportModule],
    __init__: ['resize', 'resizePreview', 'resizeHandles'],
    resize: ['type', Resize],
    resizePreview: ['type', ResizePreview],
    resizeHandles: ['type', ResizeHandles]
  };

  var RECONNECT_START = 'reconnectStart',
    RECONNECT_END = 'reconnectEnd';
  var HIGH_PRIORITY$4 = 2000;
  function DrdBendpointSnapping(eventBus) {
    eventBus.on(['bendpoint.move.move', 'bendpoint.move.end'], HIGH_PRIORITY$4, function (event) {
      var context = event.context,
        allowed = context.allowed,
        hover = context.hover,
        source = context.source,
        target = context.target,
        type = context.type;
      if (!context.hints) {
        context.hints = {};
      }
      delete context.hints.connectionStart;
      delete context.hints.connectionEnd;
      if (allowed && allowed.type !== 'dmn:InformationRequirement') {
        return;
      }
      if (!hover || !isAny(hover, ['dmn:Decision', 'dmn:InputData'])) {
        return;
      }
      if (source === target) {
        return;
      }
      var reconnect = type === RECONNECT_START || type === RECONNECT_END;
      var orientation = getOrientation(source, target);
      if (reconnect && hover === source) {
        // (1) snap event to source
        snapToSource(event, orientation);

        // (2) set connection end to target
        context.hints.connectionEnd = getConnectionEnd(target, orientation);
      } else if (reconnect && hover === target) {
        // (1) set connection start to source
        context.hints.connectionStart = getConnectionStart(source, orientation);

        // (2) snap event to target
        snapToTarget(event, orientation);
      }
    });
  }
  DrdBendpointSnapping.$inject = ['eventBus'];

  // helpers //////////

  function getConnectionStart(source, orientation) {
    var sourceTrbl = asTRBL(source);
    var connectionStart = getMid(source);
    if (orientation.includes('bottom')) {
      connectionStart.y = sourceTrbl.top;
    } else if (orientation.includes('top')) {
      connectionStart.y = sourceTrbl.bottom;
    } else if (orientation.includes('right')) {
      connectionStart.x = sourceTrbl.left;
    } else {
      connectionStart.x = sourceTrbl.right;
    }
    return connectionStart;
  }
  function getConnectionEnd(target, orientation) {
    var targetTrbl = asTRBL(target);
    var connectionEnd = getMid(target);
    if (orientation.includes('bottom')) {
      connectionEnd.y = targetTrbl.bottom;
    } else if (orientation.includes('top')) {
      connectionEnd.y = targetTrbl.top;
    } else if (orientation.includes('right')) {
      connectionEnd.x = targetTrbl.right;
    } else {
      connectionEnd.x = targetTrbl.left;
    }
    return connectionEnd;
  }
  function snapToSource(event, orientation) {
    var context = event.context,
      source = context.source;
    var connectionStart = getConnectionStart(source, orientation);
    var dx = event.x - connectionStart.x,
      dy = event.y - connectionStart.y;
    event.x -= dx;
    event.y -= dy;
    event.dx -= dx;
    event.dy -= dy;
  }
  function snapToTarget(event, orientation) {
    var context = event.context,
      target = context.target;
    var connectionEnd = getConnectionEnd(target, orientation);
    var dx = 0,
      dy = 0;
    if (orientation.includes('top') || orientation.includes('bottom')) {
      dy = event.y - connectionEnd.y;
    } else {
      dx = event.x - connectionEnd.x;
    }
    event.x -= dx;
    event.y -= dy;
    event.dx -= dx;
    event.dy -= dy;
  }

  var LOW_PRIORITY$9 = 250;
  function DrdConnectSnapping(eventBus) {
    eventBus.on(['connect.hover', 'connect.move', 'connect.end'], LOW_PRIORITY$9, function (event) {
      var context = event.context,
        canExecute = context.canExecute,
        hover = context.hover,
        source = context.source,
        target = context.target;
      if (canExecute && canExecute.type === 'dmn:InformationRequirement') {
        var orientation = getOrientation(source, target);

        // snap source
        context.connectionStart = getMid(source);

        // snap target
        if (hover === source) {
          context.connectionEnd = getMid(target);
        } else {
          context.connectionEnd = {
            x: event.x,
            y: event.y
          };
        }
        if (orientation.includes('bottom')) {
          context.connectionStart.y = asTRBL(source).top;
          context.connectionEnd.y = asTRBL(target).bottom;
        } else if (orientation.includes('top')) {
          context.connectionStart.y = asTRBL(source).bottom;
          context.connectionEnd.y = asTRBL(target).top;
        } else if (orientation.includes('right')) {
          context.connectionStart.x = asTRBL(source).left;
          context.connectionEnd.x = asTRBL(target).right;
        } else {
          context.connectionStart.x = asTRBL(source).right;
          context.connectionEnd.x = asTRBL(target).left;
        }
      } else {
        delete context.connectionStart;
        delete context.connectionEnd;
      }
    });
  }
  DrdConnectSnapping.$inject = ['eventBus'];

  /**
   * @typedef {import('../../model/Types').Element} Element
   *
   * @typedef {import('../../util/Types').Axis} Axis
   * @typedef {import('../../util/Types').DirectionTRBL} DirectionTRBL
   * @typedef {import('../../util/Types').Point} Point
   *
   * @typedef {DirectionTRBL & 'mid'} SnapLocation
   */

  /**
   * A snap context, containing the (possibly incomplete)
   * mappings of drop targets (to identify the snapping)
   * to computed snap points.
   */
  function SnapContext() {
    /**
     * @type {Record<string, SnapPoints>}
     */
    this._targets = {};

    /**
     * @type {Record<SnapLocation, Point>}
     */
    this._snapOrigins = {};

    /**
     * @type {SnapLocation[]}
     */
    this._snapLocations = [];

    /**
     * @type {Record<SnapLocation, Point[]>}
     */
    this._defaultSnaps = {};
  }

  /**
   * Get the snap origin for a given location.
   *
   * @param {SnapLocation} snapLocation
   *
   * @return {Point}
   */
  SnapContext.prototype.getSnapOrigin = function (snapLocation) {
    return this._snapOrigins[snapLocation];
  };

  /**
   * Set the snap origin for a given location.
   *
   * @param {SnapLocation} snapLocation
   * @param {Point} snapOrigin
   */
  SnapContext.prototype.setSnapOrigin = function (snapLocation, snapOrigin) {
    this._snapOrigins[snapLocation] = snapOrigin;
    if (this._snapLocations.indexOf(snapLocation) === -1) {
      this._snapLocations.push(snapLocation);
    }
  };

  /**
   * Add a default snap point.
   *
   * @param {SnapLocation} snapLocation
   * @param {Point} point
   */
  SnapContext.prototype.addDefaultSnap = function (snapLocation, point) {
    var snapValues = this._defaultSnaps[snapLocation];
    if (!snapValues) {
      snapValues = this._defaultSnaps[snapLocation] = [];
    }
    snapValues.push(point);
  };

  /**
   * Get the snap locations for this context.
   *
   * @return {SnapLocation[]}
   */
  SnapContext.prototype.getSnapLocations = function () {
    return this._snapLocations;
  };

  /**
   * Set the snap locations for this context.
   *
   * The order of locations determines precedence.
   *
   * @param {SnapLocation[]} snapLocations
   */
  SnapContext.prototype.setSnapLocations = function (snapLocations) {
    this._snapLocations = snapLocations;
  };

  /**
   * Get snap points for the given target.
   *
   * @param {Element|string} target
   *
   * @return {SnapPoints}
   */
  SnapContext.prototype.pointsForTarget = function (target) {
    var targetId = target.id || target;
    var snapPoints = this._targets[targetId];
    if (!snapPoints) {
      snapPoints = this._targets[targetId] = new SnapPoints();
      snapPoints.initDefaults(this._defaultSnaps);
    }
    return snapPoints;
  };

  /**
   * Add points to snap to.
   */
  function SnapPoints() {
    /**
     * Example:
     *
     * ```javascript
     * {
     *   'top-right': {
     *     x: [ 100, 200, 300 ]
     *     y: [ 100, 200, 300 ]
     *   }
     * }
     * ```
     *
     * @type {Record<string, Record<Axis, number[]>>}
     */
    this._snapValues = {};
  }

  /**
   * Add a snap point.
   *
   * @param {SnapLocation} snapLocation
   * @param {Point} point
   */
  SnapPoints.prototype.add = function (snapLocation, point) {
    var snapValues = this._snapValues[snapLocation];
    if (!snapValues) {
      snapValues = this._snapValues[snapLocation] = {
        x: [],
        y: []
      };
    }
    if (snapValues.x.indexOf(point.x) === -1) {
      snapValues.x.push(point.x);
    }
    if (snapValues.y.indexOf(point.y) === -1) {
      snapValues.y.push(point.y);
    }
  };

  /**
   * Snap a point's x or y value.
   *
   * @param {Point} point
   * @param {SnapLocation} snapLocation
   * @param {Axis} axis
   * @param {number} tolerance
   *
   * @return {number}
   */
  SnapPoints.prototype.snap = function (point, snapLocation, axis, tolerance) {
    var snappingValues = this._snapValues[snapLocation];
    return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
  };

  /**
   * Initialize default snap points.
   *
   * @param {Record<SnapLocation, Point[]>} defaultSnaps
   */
  SnapPoints.prototype.initDefaults = function (defaultSnaps) {
    var self = this;
    forEach$3(defaultSnaps || {}, function (snapPoints, snapLocation) {
      forEach$3(snapPoints, function (point) {
        self.add(snapLocation, point);
      });
    });
  };

  /**
   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('./Snapping').default} Snapping
   */

  var HIGHER_PRIORITY$2 = 1250;

  /**
   * Snap during create and move.
   *
   * @param {ElementRegistry} elementRegistry
   * @param {EventBus} eventBus
   * @param {Snapping} snapping
   */
  function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
    var self = this;
    this._elementRegistry = elementRegistry;
    eventBus.on(['create.start', 'shape.move.start'], function (event) {
      self.initSnap(event);
    });
    eventBus.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], HIGHER_PRIORITY$2, function (event) {
      var context = event.context,
        shape = context.shape,
        snapContext = context.snapContext,
        target = context.target;
      if (event.originalEvent && isCmd$5(event.originalEvent)) {
        return;
      }
      if (isSnapped(event) || !target) {
        return;
      }
      var snapPoints = snapContext.pointsForTarget(target);
      if (!snapPoints.initialized) {
        snapPoints = self.addSnapTargetPoints(snapPoints, shape, target);
        snapPoints.initialized = true;
      }
      snapping.snap(event, snapPoints);
    });
    eventBus.on(['create.cleanup', 'shape.move.cleanup'], function () {
      snapping.hide();
    });
  }
  CreateMoveSnapping.$inject = ['elementRegistry', 'eventBus', 'snapping'];
  CreateMoveSnapping.prototype.initSnap = function (event) {
    var elementRegistry = this._elementRegistry;
    var context = event.context,
      shape = context.shape,
      snapContext = context.snapContext;
    if (!snapContext) {
      snapContext = context.snapContext = new SnapContext();
    }
    var shapeMid;
    if (elementRegistry.get(shape.id)) {
      // move
      shapeMid = mid$1(shape, event);
    } else {
      // create
      shapeMid = {
        x: event.x + mid$1(shape).x,
        y: event.y + mid$1(shape).y
      };
    }
    var shapeTopLeft = {
        x: shapeMid.x - shape.width / 2,
        y: shapeMid.y - shape.height / 2
      },
      shapeBottomRight = {
        x: shapeMid.x + shape.width / 2,
        y: shapeMid.y + shape.height / 2
      };
    snapContext.setSnapOrigin('mid', {
      x: shapeMid.x - event.x,
      y: shapeMid.y - event.y
    });

    // snap labels to mid only
    if (isLabel$1(shape)) {
      return snapContext;
    }
    snapContext.setSnapOrigin('top-left', {
      x: shapeTopLeft.x - event.x,
      y: shapeTopLeft.y - event.y
    });
    snapContext.setSnapOrigin('bottom-right', {
      x: shapeBottomRight.x - event.x,
      y: shapeBottomRight.y - event.y
    });
    return snapContext;
  };
  CreateMoveSnapping.prototype.addSnapTargetPoints = function (snapPoints, shape, target) {
    var snapTargets = this.getSnapTargets(shape, target);
    forEach$3(snapTargets, function (snapTarget) {
      // handle labels
      if (isLabel$1(snapTarget)) {
        if (isLabel$1(shape)) {
          snapPoints.add('mid', mid$1(snapTarget));
        }
        return;
      }

      // handle connections
      if (isConnection(snapTarget)) {
        // ignore single segment connections
        if (snapTarget.waypoints.length < 3) {
          return;
        }

        // ignore first and last waypoint
        var waypoints = snapTarget.waypoints.slice(1, -1);
        forEach$3(waypoints, function (waypoint) {
          snapPoints.add('mid', waypoint);
        });
        return;
      }

      // handle shapes
      snapPoints.add('mid', mid$1(snapTarget));
    });
    if (!isNumber$3(shape.x) || !isNumber$3(shape.y)) {
      return snapPoints;
    }

    // snap to original position when moving
    if (this._elementRegistry.get(shape.id)) {
      snapPoints.add('mid', mid$1(shape));
    }
    return snapPoints;
  };
  CreateMoveSnapping.prototype.getSnapTargets = function (shape, target) {
    return getChildren(target).filter(function (child) {
      return !isHidden$1(child);
    });
  };

  // helpers //////////

  function isHidden$1(element) {
    return !!element.hidden;
  }

  /**
   * @typedef {import('../../core/EventBus').default} EventBus
   * @typedef {import('./Snapping').default} Snapping
   */

  var HIGHER_PRIORITY$1 = 1250;

  /**
   * Snap during resize.
   *
   * @param {EventBus} eventBus
   * @param {Snapping} snapping
   */
  function ResizeSnapping(eventBus, snapping) {
    var self = this;
    eventBus.on(['resize.start'], function (event) {
      self.initSnap(event);
    });
    eventBus.on(['resize.move', 'resize.end'], HIGHER_PRIORITY$1, function (event) {
      var context = event.context,
        shape = context.shape,
        parent = shape.parent,
        direction = context.direction,
        snapContext = context.snapContext;
      if (event.originalEvent && isCmd$5(event.originalEvent)) {
        return;
      }
      if (isSnapped(event)) {
        return;
      }
      var snapPoints = snapContext.pointsForTarget(parent);
      if (!snapPoints.initialized) {
        snapPoints = self.addSnapTargetPoints(snapPoints, shape, parent, direction);
        snapPoints.initialized = true;
      }
      if (isHorizontal(direction)) {
        setSnapped(event, 'x', event.x);
      }
      if (isVertical(direction)) {
        setSnapped(event, 'y', event.y);
      }
      snapping.snap(event, snapPoints);
    });
    eventBus.on(['resize.cleanup'], function () {
      snapping.hide();
    });
  }
  ResizeSnapping.prototype.initSnap = function (event) {
    var context = event.context,
      shape = context.shape,
      direction = context.direction,
      snapContext = context.snapContext;
    if (!snapContext) {
      snapContext = context.snapContext = new SnapContext();
    }
    var snapOrigin = getSnapOrigin(shape, direction);
    snapContext.setSnapOrigin('corner', {
      x: snapOrigin.x - event.x,
      y: snapOrigin.y - event.y
    });
    return snapContext;
  };
  ResizeSnapping.prototype.addSnapTargetPoints = function (snapPoints, shape, target, direction) {
    var snapTargets = this.getSnapTargets(shape, target);
    forEach$3(snapTargets, function (snapTarget) {
      snapPoints.add('corner', bottomRight(snapTarget));
      snapPoints.add('corner', topLeft(snapTarget));
    });
    snapPoints.add('corner', getSnapOrigin(shape, direction));
    return snapPoints;
  };
  ResizeSnapping.$inject = ['eventBus', 'snapping'];
  ResizeSnapping.prototype.getSnapTargets = function (shape, target) {
    return getChildren(target).filter(function (child) {
      return !isAttached(child, shape) && !isConnection(child) && !isHidden(child) && !isLabel$1(child);
    });
  };

  // helpers //////////

  function getSnapOrigin(shape, direction) {
    var mid = getMid(shape),
      trbl = asTRBL(shape);
    var snapOrigin = {
      x: mid.x,
      y: mid.y
    };
    if (direction.indexOf('n') !== -1) {
      snapOrigin.y = trbl.top;
    } else if (direction.indexOf('s') !== -1) {
      snapOrigin.y = trbl.bottom;
    }
    if (direction.indexOf('e') !== -1) {
      snapOrigin.x = trbl.right;
    } else if (direction.indexOf('w') !== -1) {
      snapOrigin.x = trbl.left;
    }
    return snapOrigin;
  }
  function isAttached(element, host) {
    return element.host === host;
  }
  function isHidden(element) {
    return !!element.hidden;
  }
  function isHorizontal(direction) {
    return direction === 'n' || direction === 's';
  }
  function isVertical(direction) {
    return direction === 'e' || direction === 'w';
  }

  /**
   * @typedef {import('../../core/Canvas').default} Canvas
   *
   * @typedef {import('../../core/EventBus').Event} Event
   *
   * @typedef {import('./SnapContext').SnapPoints} SnapPoints
   */

  var SNAP_TOLERANCE = 7;
  var SNAP_LINE_HIDE_DELAY = 1000;

  /**
   * Generic snapping feature.
   *
   * @param {Canvas} canvas
   */
  function Snapping(canvas) {
    this._canvas = canvas;

    // delay hide by 1000 seconds since last snap
    this._asyncHide = debounce(bind$3(this.hide, this), SNAP_LINE_HIDE_DELAY);
  }
  Snapping.$inject = ['canvas'];

  /**
   * Snap an event to given snap points.
   *
   * @param {Event} event
   * @param {SnapPoints} snapPoints
   */
  Snapping.prototype.snap = function (event, snapPoints) {
    var context = event.context,
      snapContext = context.snapContext,
      snapLocations = snapContext.getSnapLocations();
    var snapping = {
      x: isSnapped(event, 'x'),
      y: isSnapped(event, 'y')
    };
    forEach$3(snapLocations, function (location) {
      var snapOrigin = snapContext.getSnapOrigin(location);
      var snapCurrent = {
        x: event.x + snapOrigin.x,
        y: event.y + snapOrigin.y
      };

      // snap both axis if not snapped already
      forEach$3(['x', 'y'], function (axis) {
        var locationSnapping;
        if (!snapping[axis]) {
          locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);
          if (locationSnapping !== undefined) {
            snapping[axis] = {
              value: locationSnapping,
              originValue: locationSnapping - snapOrigin[axis]
            };
          }
        }
      });

      // no need to continue snapping
      if (snapping.x && snapping.y) {
        return false;
      }
    });

    // show snap lines
    this.showSnapLine('vertical', snapping.x && snapping.x.value);
    this.showSnapLine('horizontal', snapping.y && snapping.y.value);

    // snap event
    forEach$3(['x', 'y'], function (axis) {
      var axisSnapping = snapping[axis];
      if (isObject$2(axisSnapping)) {
        setSnapped(event, axis, axisSnapping.originValue);
      }
    });
  };
  Snapping.prototype._createLine = function (orientation) {
    var root = this._canvas.getLayer('snap');
    var line = create$2('path');
    attr(line, {
      d: 'M0,0 L0,0'
    });
    classes(line).add('djs-snap-line');
    append(root, line);
    return {
      update: function update(position) {
        if (!isNumber$3(position)) {
          attr(line, {
            display: 'none'
          });
        } else {
          if (orientation === 'horizontal') {
            attr(line, {
              d: 'M-100000,' + position + ' L+100000,' + position,
              display: ''
            });
          } else {
            attr(line, {
              d: 'M ' + position + ',-100000 L ' + position + ', +100000',
              display: ''
            });
          }
        }
      }
    };
  };
  Snapping.prototype._createSnapLines = function () {
    this._snapLines = {
      horizontal: this._createLine('horizontal'),
      vertical: this._createLine('vertical')
    };
  };
  Snapping.prototype.showSnapLine = function (orientation, position) {
    var line = this.getSnapLine(orientation);
    if (line) {
      line.update(position);
    }
    this._asyncHide();
  };
  Snapping.prototype.getSnapLine = function (orientation) {
    if (!this._snapLines) {
      this._createSnapLines();
    }
    return this._snapLines[orientation];
  };
  Snapping.prototype.hide = function () {
    forEach$3(this._snapLines, function (snapLine) {
      snapLine.update();
    });
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var SnappingModule$1 = {
    __init__: ['createMoveSnapping', 'resizeSnapping', 'snapping'],
    createMoveSnapping: ['type', CreateMoveSnapping],
    resizeSnapping: ['type', ResizeSnapping],
    snapping: ['type', Snapping]
  };

  var SnappingModule = {
    __depends__: [SnappingModule$1],
    __init__: ['bendpointSnapping', 'connectSnapping'],
    bendpointSnapping: ['type', DrdBendpointSnapping],
    connectSnapping: ['type', DrdConnectSnapping]
  };

  /**
   * A modeler for DMN tables.
   *
   *
   * ## Extending the Modeler
   *
   * In order to extend the viewer pass extension modules to bootstrap via the
   * `additionalModules` option. An extension module is an object that exposes
   * named services.
   *
   * The following example depicts the integration of a simple
   * logging component that integrates with interaction events:
   *
   *
   * ```javascript
   *
   * // logging component
   * function InteractionLogger(eventBus) {
   *   eventBus.on('element.hover', function(event) {
   *     console.log()
   *   })
   * }
   *
   * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
   *
   * // extension module
   * var extensionModule = {
   *   __init__: [ 'interactionLogger' ],
   *   interactionLogger: [ 'type', InteractionLogger ]
   * };
   *
   * // extend the viewer
   * var dmnModeler = new Modeler({ additionalModules: [ extensionModule ] });
   * dmnModeler.importXML(...);
   * ```
   *
   *
   * ## Customizing / Replacing Components
   *
   * You can replace individual table components by redefining them in override modules.
   * This works for all components, including those defined in the core.
   *
   * Pass in override modules via the `options.additionalModules` flag like this:
   *
   * ```javascript
   * function CustomContextPadProvider(contextPad) {
   *
   *   contextPad.registerProvider(this);
   *
   *   this.getContextPadEntries = function(element) {
   *     // no entries, effectively disable the context pad
   *     return {};
   *   };
   * }
   *
   * CustomContextPadProvider.$inject = [ 'contextPad' ];
   *
   * var overrideModule = {
   *   contextPadProvider: [ 'type', CustomContextPadProvider ]
   * };
   *
   * var dmnModeler = new Modeler({ additionalModules: [ overrideModule ]});
   * ```
   *
   * @param {Object} [options] configuration options to pass to the viewer
   * @param {DOMElement} [options.container]
   *        the container to render the viewer in, defaults to body.
   * @param {string|number} [options.width] the width of the viewer
   * @param {string|number} [options.height] the height of the viewer
   * @param {Object} [options.moddleExtensions]
   *        extension packages to provide
   * @param {Array<didi.Module>} [options.modules]
   *        a list of modules to override the default modules
   * @param {Array<didi.Module>} [options.additionalModules]
   *        a list of modules to use with the default modules
   */
  function Modeler$1(options) {
    NavigatedViewer.call(this, options);
  }
  e$2(Modeler$1, NavigatedViewer);

  // modules the modeler is composed of
  //
  // - viewer + navigation modules
  // - modeling modules

  Modeler$1.prototype._modelingModules = [
  // modeling components
  AlignElementsModule, AutoPlaceModule, AutoScrollModule, BendpointsModule, ContextPadModule, ConnectPreviewModule, DefinitionPropertiesModule, DistributeElementsModule, EditorActionsModule, GenerateDiModule, GridSnappingModule, KeyboardModule$1, KeyboardMoveModule, KeyboardMoveSelectionModule, LabelEditingModule, ModelingModule$1, MoveModule, OutlineProvider, PaletteModule, ResizeModule, SnappingModule];
  Modeler$1.prototype._modules = [].concat(Modeler$1.prototype._modules, Modeler$1.prototype._modelingModules);

  /** @typedef {import('./VariableResolver').Variable} Variable */

  /**
   * @typedef Context
   * @property {Variable[]} variables
   * @property {*} rootElement
   */

  /**
   * Resolve variables available to a DMN element.
   * @param {*} moddleElement
   * @returns {Variable[]}
   */
  function resolveVariables(moddleElement) {
    var context = {
      variables: [],
      rootElement: getRootElement(moddleElement)
    };
    for (var current = moddleElement; current; current = current.$parent) {
      handle(current, context);
    }
    return context.variables;
  }
  function handle(element, context) {
    if (is(element, 'dmn:Decision')) {
      handleDecision(element, context);
    }
  }
  function handleDecision(decision, context) {
    var _iterator = _createForOfIteratorHelper(decision.get('informationRequirement')),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var informationRequirement = _step.value;
        handleInformationRequirement(informationRequirement, context);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper(decision.get('knowledgeRequirement')),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var knowledgeRequirement = _step2.value;
        handleKnowledgeRequirement(knowledgeRequirement, context);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  function handleInformationRequirement(informationRequirement, context) {
    var requiredInput = informationRequirement.get('requiredInput');
    if (requiredInput) {
      handleRequiredInput(requiredInput, context);
    }
    var requiredDecision = informationRequirement.get('requiredDecision');
    if (requiredDecision) {
      handleRequiredDecision(requiredDecision, context);
    }
  }
  function handleRequiredInput(reference, context) {
    var input = getReferencedElement(reference, context.rootElement);
    if (!input) {
      return;
    }
    var name = input.get('name');

    // prevent invalid variables in suggestions
    if (!name) {
      return;
    }
    context.variables.push({
      name: name,
      origin: input
    });
  }
  function handleRequiredDecision(reference, context) {
    var decision = getReferencedElement(reference, context.rootElement);
    if (!decision) {
      return;
    }
    var name = decision.get('name');

    // prevent invalid variables in suggestions
    if (!name) {
      return;
    }

    /** @type Variable */
    var variable = {
      name: name,
      origin: decision
    };
    var decisionLogic = decision.get('decisionLogic');
    if (decisionLogic) {
      handleDecisionLogic(decisionLogic, variable);
    }
    context.variables.push(variable);
  }

  /**
   *
   * @param {*} decisionLogic
   * @param {Variable} currentVariable
   * @param {Context} context
   */
  function handleDecisionLogic(decisionLogic, currentVariable, context) {
    if (is(decisionLogic, 'dmn:DecisionTable')) {
      var outputs = decisionLogic.get('output');
      handleOutputs(outputs, currentVariable);
    }
  }

  /**
   *
   * @param {Array<any>} outputs
   * @param {Variable} currentVariable
   * @param {Context} context
   */
  function handleOutputs(outputs, currentVariable, context) {
    // for single output name is ignored
    if (outputs.length === 1) {
      var outputVariable = _objectSpread2(_objectSpread2({}, handleOutput(outputs[0])), {}, {
        name: currentVariable.name
      });
      Object.assign(currentVariable, outputVariable);
      return;
    }

    // in type it's schema but it's not handled in feel editor
    var outputsVariables = outputs.map(handleOutput);
    currentVariable.entries = outputsVariables.filter(function (variable) {
      return !!variable.name;
    });
  }
  function handleOutput(output) {
    // unnamed output is OK for a single-output table
    var variable = {
      name: output.name
    };
    if (output.typeRef) {
      variable.detail = output.typeRef;
    }
    return variable;
  }
  function handleKnowledgeRequirement(knowledgeRequirement, context) {
    var requiredKnowledge = knowledgeRequirement.get('requiredKnowledge');
    if (requiredKnowledge) {
      handleRequiredKnowledge(requiredKnowledge, context);
    }
  }
  function handleRequiredKnowledge(reference, context) {
    var invocable = getReferencedElement(reference, context.rootElement);
    if (!invocable) {
      return;
    }
    if (is(invocable, 'dmn:BusinessKnowledgeModel')) {
      handleBusinessKnowledgeModel(invocable, context);
    }
  }
  function handleBusinessKnowledgeModel(bkm, context) {
    var name = bkm.get('name');

    // prevent invalid variables in suggestions
    if (!name) {
      return;
    }

    /** @type Variable */
    var variable = {
      name: name,
      origin: bkm
    };
    context.variables.push(variable);
  }

  // helpers //////////////////////
  function getRootElement(element) {
    var rootElement = element;
    while (rootElement.$parent) {
      rootElement = rootElement.$parent;
    }
    return rootElement;
  }
  function getReferencedElement(reference, rootElement) {
    var href = reference.get('href');
    if (!href || !href.startsWith('#')) {
      return;
    }
    var id = href.slice(1);
    var drgElements = rootElement.get('drgElement');
    return drgElements.find(function (drgElement) {
      return drgElement.get('id') === id;
    });
  }
  function is(moddleElement, type) {
    return moddleElement.$instanceOf(type);
  }

  var DmnVariableProvider = /*#__PURE__*/function () {
    /**
     * @param {import('./VariableResolver').VariableResolver} variableResolver
     */
    function DmnVariableProvider(variableResolver) {
      _classCallCheck(this, DmnVariableProvider);
      variableResolver.registerProvider(this);
    }
    _createClass(DmnVariableProvider, [{
      key: "getVariables",
      value: function getVariables(variables, element) {
        return variables.concat(resolveVariables(element));
      }
    }]);
    return DmnVariableProvider;
  }();
  DmnVariableProvider.$inject = ['variableResolver'];

  /**
   * @typedef {import('@bpmn-io/feel-editor').Variable} Variable
  */

  /**
   * @typedef VariableProvider
   * @property {(variables: Variable[], element) => Variable[]} getVariables
   */

  var VariableResolver = /*#__PURE__*/function () {
    function VariableResolver() {
      _classCallCheck(this, VariableResolver);
      this._providers = [];
    }

    /**
     * @param {VariableProvider} provider
     */
    _createClass(VariableResolver, [{
      key: "registerProvider",
      value: function registerProvider(provider) {
        this._providers.push(provider);
      }
    }, {
      key: "getVariables",
      value: function getVariables(element) {
        return this._providers.reduce(function (variables, provider) {
          return provider.getVariables(variables, element);
        }, []);
      }
    }]);
    return VariableResolver;
  }();

  var DmnVariableResolverModule = {
    __init__: ['dmnVariableProvider'],
    dmnVariableProvider: ['type', DmnVariableProvider],
    variableResolver: ['type', VariableResolver]
  };

  var Base = /*#__PURE__*/_createClass(function Base(attrs) {
    _classCallCheck(this, Base);
    assign$4(this, attrs);
    /**
     * The object that backs up the shape
     *
     * @name Base#businessObject
     * @type Object
     */

    defineProperty(this, 'businessObject', {
      writable: true
    });
  });
  var Root = /*#__PURE__*/function (_Base) {
    _inherits$1(Root, _Base);
    var _super = _createSuper(Root);
    function Root(attrs) {
      var _this;
      _classCallCheck(this, Root);
      _this = _super.call(this, attrs);
      /**
       * The tables rows
       *
       * @name Root#rows
       * @type Row
       */

      defineProperty(_assertThisInitialized(_this), 'rows', {
        enumerable: true,
        value: _this.rows || []
      });
      /**
       * The tables columns
       *
       * @name Root#cols
       * @type Col
       */

      defineProperty(_assertThisInitialized(_this), 'cols', {
        enumerable: true,
        value: _this.cols || []
      });
      return _this;
    }
    return _createClass(Root);
  }(Base);
  var Row = /*#__PURE__*/function (_Base2) {
    _inherits$1(Row, _Base2);
    var _super2 = _createSuper(Row);
    function Row(attrs) {
      var _this2;
      _classCallCheck(this, Row);
      _this2 = _super2.call(this, attrs);
      /**
       * Reference to the table
       *
       * @name Row#root
       * @type Root
       */

      defineProperty(_assertThisInitialized(_this2), 'root', {
        writable: true
      });
      /**
       * Reference to contained cells
       *
       * @name Row#cells
       * @type Cell
       */

      defineProperty(_assertThisInitialized(_this2), 'cells', {
        enumerable: true,
        value: _this2.cells || []
      });
      return _this2;
    }
    return _createClass(Row);
  }(Base);
  var Col = /*#__PURE__*/function (_Base3) {
    _inherits$1(Col, _Base3);
    var _super3 = _createSuper(Col);
    function Col(attrs) {
      var _this3;
      _classCallCheck(this, Col);
      _this3 = _super3.call(this, attrs);
      /**
       * Reference to the table
       *
       * @name Col#table
       * @type Root
       */

      defineProperty(_assertThisInitialized(_this3), 'root', {
        writable: true
      });
      /**
       * Reference to contained cells
       *
       * @name Row#cells
       * @type Cell
       */

      defineProperty(_assertThisInitialized(_this3), 'cells', {
        enumerable: true,
        value: _this3.cells || []
      });
      return _this3;
    }
    return _createClass(Col);
  }(Base);
  var Cell = /*#__PURE__*/function (_Base4) {
    _inherits$1(Cell, _Base4);
    var _super4 = _createSuper(Cell);
    function Cell(attrs) {
      var _this4;
      _classCallCheck(this, Cell);
      _this4 = _super4.call(this, attrs);
      /**
       * Reference to the row
       *
       * @name Cell#row
       * @type Row
       */

      defineProperty(_assertThisInitialized(_this4), 'row', {
        writable: true
      });
      /**
       * Reference to the col
       *
       * @name Cell#col
       * @type Col
       */

      defineProperty(_assertThisInitialized(_this4), 'col', {
        writable: true
      });
      return _this4;
    }
    return _createClass(Cell);
  }(Base);
  var TYPES = {
    root: Root,
    row: Row,
    col: Col,
    cell: Cell
  };
  function create(type, attrs) {
    var Type = TYPES[type];
    if (!Type) {
      throw new Error('unknown type ' + type);
    }
    return new Type(attrs);
  } // helpers /////////////

  function defineProperty(el, prop, options) {
    Object.defineProperty(el, prop, options);
  }

  var ElementFactory$1 = /*#__PURE__*/function () {
    function ElementFactory() {
      _classCallCheck(this, ElementFactory);
      this._uid = 12;
    }
    _createClass(ElementFactory, [{
      key: "create",
      value: function create$1(type) {
        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!attrs.id) {
          attrs.id = type + '_' + this._uid++;
        }
        return create(type, attrs);
      }
    }, {
      key: "createRoot",
      value: function createRoot(attrs) {
        return this.create('root', attrs);
      }
    }, {
      key: "createRow",
      value: function createRow(attrs) {
        return this.create('row', attrs);
      }
    }, {
      key: "createCol",
      value: function createCol(attrs) {
        return this.create('col', attrs);
      }
    }, {
      key: "createCell",
      value: function createCell(attrs) {
        return this.create('cell', attrs);
      }
    }]);
    return ElementFactory;
  }();

  var ElementRegistry$1 = /*#__PURE__*/function () {
    function ElementRegistry(eventBus) {
      _classCallCheck(this, ElementRegistry);
      this._eventBus = eventBus;
      this._elements = {};
      eventBus.on('table.clear', this.clear.bind(this));
    }
    _createClass(ElementRegistry, [{
      key: "add",
      value: function add(element, type) {
        var id = element.id;
        this._elements[id] = element;
      }
    }, {
      key: "remove",
      value: function remove(element) {
        var id = element.id || element;
        delete this._elements[id];
      }
    }, {
      key: "get",
      value: function get(id) {
        return this._elements[id];
      }
    }, {
      key: "getAll",
      value: function getAll() {
        return values(this._elements);
      }
    }, {
      key: "forEach",
      value: function forEach(fn) {
        values(this._elements).forEach(function (element) {
          return fn(element);
        });
      }
    }, {
      key: "filter",
      value: function filter(fn) {
        return values(this._elements).filter(function (element) {
          return fn(element);
        });
      }
    }, {
      key: "clear",
      value: function clear() {
        this._elements = {};
      }
    }, {
      key: "updateId",
      value: function updateId(element, newId) {
        this._validateId(newId);
        if (typeof element === 'string') {
          element = this.get(element);
        }
        this._eventBus.fire('element.updateId', {
          element: element,
          newId: newId
        });
        this.remove(element);
        element.id = newId;
        this.add(element);
      }
      /**
      * Validate the suitability of the given id and signals a problem
      * with an exception.
      *
      * @param {String} id
      *
      * @throws {Error} if id is empty or already assigned
      */
    }, {
      key: "_validateId",
      value: function _validateId(id) {
        if (!id) {
          throw new Error('element must have an id');
        }
        if (this._elements[id]) {
          throw new Error('element with id ' + id + ' already added');
        }
      }
    }]);
    return ElementRegistry;
  }();
  ElementRegistry$1.$inject = ['eventBus']; // helpers

  function values(obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  }

  var ChangeSupport$1 = /*#__PURE__*/function () {
    function ChangeSupport(eventBus) {
      var _this = this;
      _classCallCheck(this, ChangeSupport);
      this._listeners = {};
      eventBus.on('elements.changed', function (_ref) {
        var elements = _ref.elements;
        _this.elementsChanged(elements);
      });
      eventBus.on('root.remove', function (context) {
        var oldRootId = context.root.id;
        if (_this._listeners[oldRootId]) {
          eventBus.once('root.add', function (context) {
            var newRootId = context.root.id;
            _this.updateId(oldRootId, newRootId);
          });
        }
      });
      eventBus.on('element.updateId', function (_ref2) {
        var element = _ref2.element,
          newId = _ref2.newId;
        _this.updateId(element.id, newId);
      });
    }
    _createClass(ChangeSupport, [{
      key: "elementsChanged",
      value: function elementsChanged(elements) {
        var invoked = {};
        var elementsLength = elements.length;
        for (var i = 0; i < elementsLength; i++) {
          var id = elements[i].id;
          if (invoked[id]) {
            return;
          }
          invoked[id] = true;
          var listenersLength = this._listeners[id] && this._listeners[id].length;
          if (listenersLength) {
            for (var j = 0; j < listenersLength; j++) {
              // listeners might remove themselves before they get called
              this._listeners[id][j] && this._listeners[id][j]();
            }
          }
        }
      }
    }, {
      key: "onElementsChanged",
      value: function onElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          this._listeners[id] = [];
        } // avoid push for better performance

        this._listeners[id][this._listeners[id].length] = listener;
      }
    }, {
      key: "offElementsChanged",
      value: function offElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          return;
        }
        if (listener) {
          var idx = this._listeners[id].indexOf(listener);
          if (idx !== -1) {
            this._listeners[id].splice(idx, 1);
          }
        } else {
          this._listeners[id].length = 0;
        }
      }
    }, {
      key: "updateId",
      value: function updateId(oldId, newId) {
        if (this._listeners[oldId]) {
          this._listeners[newId] = this._listeners[oldId];
          delete this._listeners[oldId];
        }
      }
    }]);
    return ChangeSupport;
  }();
  ChangeSupport$1.$inject = ['eventBus'];

  var DEFAULT_PRIORITY$1 = 1000;
  var Components$1 = /*#__PURE__*/function () {
    function Components() {
      _classCallCheck(this, Components);
      this._listeners = {};
    }
    _createClass(Components, [{
      key: "getComponent",
      value: function getComponent(type, context) {
        var listeners = this._listeners[type];
        if (!listeners) {
          return;
        }
        var component;
        for (var i = 0; i < listeners.length; i++) {
          component = listeners[i].callback(context);
          if (component) {
            break;
          }
        }
        return component;
      }
    }, {
      key: "getComponents",
      value: function getComponents(type, context) {
        var listeners = this._listeners[type];
        var components = [];
        if (!listeners) {
          return components;
        }
        for (var i = 0; i < listeners.length; i++) {
          var component = listeners[i].callback(context);
          if (component) {
            components.push(component);
          }
        }
        if (!components.length) {
          return components;
        }
        return components;
      }
    }, {
      key: "onGetComponent",
      value: function onGetComponent(type, priority, callback) {
        if (isFunction$2(priority)) {
          callback = priority;
          priority = DEFAULT_PRIORITY$1;
        }
        if (!isNumber$3(priority)) {
          throw new Error('priority must be a number');
        }
        var listeners = this._getListeners(type);
        var existingListener, idx;
        var newListener = {
          priority: priority,
          callback: callback
        };
        for (idx = 0; existingListener = listeners[idx]; idx++) {
          if (existingListener.priority < priority) {
            // prepend newListener at before existingListener
            listeners.splice(idx, 0, newListener);
            return;
          }
        }
        listeners.push(newListener);
      }
    }, {
      key: "offGetComponent",
      value: function offGetComponent(type, callback) {
        var listeners = this._getListeners(type);
        var listener, listenerCallback, idx;
        if (callback) {
          // move through listeners from back to front
          // and remove matching listeners
          for (idx = listeners.length - 1; listener = listeners[idx]; idx--) {
            listenerCallback = listener.callback;
            if (listenerCallback === callback) {
              listeners.splice(idx, 1);
            }
          }
        } else {
          // clear listeners
          listeners.length = 0;
        }
      }
    }, {
      key: "_getListeners",
      value: function _getListeners(type) {
        var listeners = this._listeners[type];
        if (!listeners) {
          this._listeners[type] = listeners = [];
        }
        return listeners;
      }
    }]);
    return Components;
  }();

  var NO_OP = '$NO_OP';
  var ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';
  var isBrowser = !!(typeof window !== 'undefined' && window.document);
  var isArray = Array.isArray;
  function isStringOrNumber(o) {
    var type = _typeof(o);
    return type === 'string' || type === 'number';
  }
  function isNullOrUndef(o) {
    return isUndefined(o) || isNull$2(o);
  }
  function isInvalid(o) {
    return isNull$2(o) || o === false || isTrue(o) || isUndefined(o);
  }
  function isFunction(o) {
    return typeof o === 'function';
  }
  function isString(o) {
    return typeof o === 'string';
  }
  function isNumber$2(o) {
    return typeof o === 'number';
  }
  function isNull$2(o) {
    return o === null;
  }
  function isTrue(o) {
    return o === true;
  }
  function isUndefined(o) {
    return o === void 0;
  }
  function isObject(o) {
    return _typeof(o) === 'object';
  }
  function throwError(message) {
    if (!message) {
      message = ERROR_MSG;
    }
    throw new Error("Inferno Error: " + message);
  }
  function warning(message) {
    // tslint:disable-next-line:no-console
    console.error(message);
  }
  function combineFrom(first, second) {
    var out = {};
    if (first) {
      for (var key in first) {
        out[key] = first[key];
      }
    }
    if (second) {
      for (var key$1 in second) {
        out[key$1] = second[key$1];
      }
    }
    return out;
  }
  function getTagName(input) {
    var tagName;
    if (isArray(input)) {
      var arrayText = input.length > 3 ? input.slice(0, 3).toString() + ',...' : input.toString();
      tagName = 'Array(' + arrayText + ')';
    } else if (isStringOrNumber(input)) {
      tagName = 'Text(' + input + ')';
    } else if (isInvalid(input)) {
      tagName = 'InvalidVNode(' + input + ')';
    } else {
      var flags = input.flags;
      if (flags & 481 /* Element */) {
        tagName = "<" + input.type + (input.className ? ' class="' + input.className + '"' : '') + ">";
      } else if (flags & 16 /* Text */) {
        tagName = "Text(" + input.children + ")";
      } else if (flags & 1024 /* Portal */) {
        tagName = "Portal*";
      } else {
        var type = input.type;
        // Fallback for IE
        var componentName = type.name || type.displayName || type.constructor.name || (type.toString().match(/^function\s*([^\s(]+)/) || [])[1];
        tagName = "<" + componentName + " />";
      }
    }
    return '>> ' + tagName + '\n';
  }
  function DEV_ValidateKeys(vNodeTree, forceKeyed) {
    var foundKeys = {};
    for (var i = 0, len = vNodeTree.length; i < len; i++) {
      var childNode = vNodeTree[i];
      if (isArray(childNode)) {
        return 'Encountered ARRAY in mount, array must be flattened, or normalize used. Location: \n' + getTagName(childNode);
      }
      if (isInvalid(childNode)) {
        if (forceKeyed) {
          return 'Encountered invalid node when preparing to keyed algorithm. Location: \n' + getTagName(childNode);
        } else if (Object.keys(foundKeys).length !== 0) {
          return 'Encountered invalid node with mixed keys. Location: \n' + getTagName(childNode);
        }
        continue;
      }
      if (_typeof(childNode) === 'object') {
        childNode.isValidated = true;
      }
      // Key can be undefined, null too. But typescript complains for no real reason
      var key = childNode.key;
      if (!isNullOrUndef(key) && !isStringOrNumber(key)) {
        return 'Encountered child vNode where key property is not string or number. Location: \n' + getTagName(childNode);
      }
      var children = childNode.children;
      var childFlags = childNode.childFlags;
      if (!isInvalid(children)) {
        var val = void 0;
        if (childFlags & 12 /* MultipleChildren */) {
          val = DEV_ValidateKeys(children, childNode.childFlags & 8 /* HasKeyedChildren */);
        } else if (childFlags === 2 /* HasVNodeChildren */) {
          val = DEV_ValidateKeys([children], childNode.childFlags & 8 /* HasKeyedChildren */);
        }

        if (val) {
          val += getTagName(childNode);
          return val;
        }
      }
      if (forceKeyed && isNullOrUndef(key)) {
        return 'Encountered child without key during keyed algorithm. If this error points to Array make sure children is flat list. Location: \n' + getTagName(childNode);
      } else if (!forceKeyed && isNullOrUndef(key)) {
        if (Object.keys(foundKeys).length !== 0) {
          return 'Encountered children with key missing. Location: \n' + getTagName(childNode);
        }
        continue;
      }
      if (foundKeys[key]) {
        return 'Encountered two children with same key: {' + key + '}. Location: \n' + getTagName(childNode);
      }
      foundKeys[key] = true;
    }
  }
  function validateVNodeElementChildren(vNode) {
    {
      if (vNode.childFlags & 1 /* HasInvalidChildren */) {
        return;
      }
      if (vNode.flags & 64 /* InputElement */) {
        throwError("input elements can't have children.");
      }
      if (vNode.flags & 128 /* TextareaElement */) {
        throwError("textarea elements can't have children.");
      }
      if (vNode.flags & 481 /* Element */) {
        var voidTypes = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];
        var tag = vNode.type.toLowerCase();
        if (tag === 'media') {
          throwError("media elements can't have children.");
        }
        var idx = voidTypes.indexOf(tag);
        if (idx !== -1) {
          throwError(voidTypes[idx] + " elements can't have children.");
        }
      }
    }
  }
  function validateKeys(vNode) {
    {
      // Checks if there is any key missing or duplicate keys
      if (vNode.isValidated === false && vNode.children && vNode.flags & 481 /* Element */) {
        var error = DEV_ValidateKeys(Array.isArray(vNode.children) ? vNode.children : [vNode.children], (vNode.childFlags & 8 /* HasKeyedChildren */) > 0);
        if (error) {
          throwError(error + getTagName(vNode));
        }
      }
      vNode.isValidated = true;
    }
  }
  var keyPrefix = '$';
  function getVNode(childFlags, children, className, flags, key, props, ref, type) {
    {
      return {
        childFlags: childFlags,
        children: children,
        className: className,
        dom: null,
        flags: flags,
        isValidated: false,
        key: key === void 0 ? null : key,
        parentVNode: null,
        props: props === void 0 ? null : props,
        ref: ref === void 0 ? null : ref,
        type: type
      };
    }
  }
  function createVNode(flags, type, className, children, childFlags, props, key, ref) {
    {
      if (flags & 14 /* Component */) {
        throwError('Creating Component vNodes using createVNode is not allowed. Use Inferno.createComponentVNode method.');
      }
    }
    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
    var vNode = getVNode(childFlag, children, className, flags, key, props, ref, type);
    if (childFlag === 0 /* UnknownChildren */) {
      normalizeChildren(vNode, vNode.children);
    }
    {
      validateVNodeElementChildren(vNode);
    }
    return vNode;
  }
  function createComponentVNode(flags, type, props, key, ref) {
    {
      if (flags & 1 /* HtmlElement */) {
        throwError('Creating element vNodes using createComponentVNode is not allowed. Use Inferno.createVNode method.');
      }
    }
    if ((flags & 2 /* ComponentUnknown */) > 0) {
      flags = type.prototype && isFunction(type.prototype.render) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;
    }
    // set default props
    var defaultProps = type.defaultProps;
    if (!isNullOrUndef(defaultProps)) {
      if (!props) {
        props = {}; // Props can be referenced and modified at application level so always create new object
      }

      for (var prop in defaultProps) {
        if (isUndefined(props[prop])) {
          props[prop] = defaultProps[prop];
        }
      }
    }
    if ((flags & 8 /* ComponentFunction */) > 0) {
      var defaultHooks = type.defaultHooks;
      if (!isNullOrUndef(defaultHooks)) {
        if (!ref) {
          // As ref cannot be referenced from application level, we can use the same refs object
          ref = defaultHooks;
        } else {
          for (var prop$1 in defaultHooks) {
            if (isUndefined(ref[prop$1])) {
              ref[prop$1] = defaultHooks[prop$1];
            }
          }
        }
      }
    }
    var vNode = getVNode(1 /* HasInvalidChildren */, null, null, flags, key, props, ref, type);
    var optsVNode = options$1.createVNode;
    if (isFunction(optsVNode)) {
      optsVNode(vNode);
    }
    return vNode;
  }
  function createTextVNode(text, key) {
    return getVNode(1 /* HasInvalidChildren */, isNullOrUndef(text) ? '' : text, null, 16 /* Text */, key, null, null, null);
  }
  function normalizeProps(vNode) {
    var props = vNode.props;
    if (props) {
      var flags = vNode.flags;
      if (flags & 481 /* Element */) {
        if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
          normalizeChildren(vNode, props.children);
        }
        if (props.className !== void 0) {
          vNode.className = props.className || null;
          props.className = undefined;
        }
      }
      if (props.key !== void 0) {
        vNode.key = props.key;
        props.key = undefined;
      }
      if (props.ref !== void 0) {
        if (flags & 8 /* ComponentFunction */) {
          vNode.ref = combineFrom(vNode.ref, props.ref);
        } else {
          vNode.ref = props.ref;
        }
        props.ref = undefined;
      }
    }
    return vNode;
  }
  function directClone(vNodeToClone) {
    var newVNode;
    var flags = vNodeToClone.flags;
    if (flags & 14 /* Component */) {
      var props;
      var propsToClone = vNodeToClone.props;
      if (!isNull$2(propsToClone)) {
        props = {};
        for (var key in propsToClone) {
          props[key] = propsToClone[key];
        }
      }
      newVNode = createComponentVNode(flags, vNodeToClone.type, props, vNodeToClone.key, vNodeToClone.ref);
    } else if (flags & 481 /* Element */) {
      newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, vNodeToClone.children, vNodeToClone.childFlags, vNodeToClone.props, vNodeToClone.key, vNodeToClone.ref);
    } else if (flags & 16 /* Text */) {
      newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);
    } else if (flags & 1024 /* Portal */) {
      newVNode = vNodeToClone;
    }
    return newVNode;
  }
  function createVoidVNode() {
    return createTextVNode('', null);
  }
  function _normalizeVNodes(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
      var n = nodes[index];
      if (!isInvalid(n)) {
        var newKey = currentKey + keyPrefix + index;
        if (isArray(n)) {
          _normalizeVNodes(n, result, 0, newKey);
        } else {
          if (isStringOrNumber(n)) {
            n = createTextVNode(n, newKey);
          } else {
            var oldKey = n.key;
            var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;
            if (!isNull$2(n.dom) || isPrefixedKey) {
              n = directClone(n);
            }
            if (isNull$2(oldKey) || isPrefixedKey) {
              n.key = newKey;
            } else {
              n.key = currentKey + oldKey;
            }
          }
          result.push(n);
        }
      }
    }
  }

  function normalizeChildren(vNode, children) {
    var newChildren;
    var newChildFlags = 1 /* HasInvalidChildren */;
    // Don't change children to match strict equal (===) true in patching
    if (isInvalid(children)) {
      newChildren = children;
    } else if (isString(children)) {
      newChildFlags = 2 /* HasVNodeChildren */;
      newChildren = createTextVNode(children);
    } else if (isNumber$2(children)) {
      newChildFlags = 2 /* HasVNodeChildren */;
      newChildren = createTextVNode(children + '');
    } else if (isArray(children)) {
      var len = children.length;
      if (len === 0) {
        newChildren = null;
        newChildFlags = 1 /* HasInvalidChildren */;
      } else {
        // we assign $ which basically means we've flagged this array for future note
        // if it comes back again, we need to clone it, as people are using it
        // in an immutable way
        // tslint:disable-next-line
        if (Object.isFrozen(children) || children['$'] === true) {
          children = children.slice();
        }
        newChildFlags = 8 /* HasKeyedChildren */;
        for (var i = 0; i < len; i++) {
          var n = children[i];
          if (isInvalid(n) || isArray(n)) {
            newChildren = newChildren || children.slice(0, i);
            _normalizeVNodes(children, newChildren, i, '');
            break;
          } else if (isStringOrNumber(n)) {
            newChildren = newChildren || children.slice(0, i);
            newChildren.push(createTextVNode(n, keyPrefix + i));
          } else {
            var key = n.key;
            var isNullDom = isNull$2(n.dom);
            var isNullKey = isNull$2(key);
            var isPrefixed = !isNullKey && isString(key) && key[0] === keyPrefix;
            if (!isNullDom || isNullKey || isPrefixed) {
              newChildren = newChildren || children.slice(0, i);
              if (!isNullDom || isPrefixed) {
                n = directClone(n);
              }
              if (isNullKey || isPrefixed) {
                n.key = keyPrefix + i;
              }
              newChildren.push(n);
            } else if (newChildren) {
              newChildren.push(n);
            }
          }
        }
        newChildren = newChildren || children;
        newChildren.$ = true;
      }
    } else {
      newChildren = children;
      if (!isNull$2(children.dom)) {
        newChildren = directClone(children);
      }
      newChildFlags = 2 /* HasVNodeChildren */;
    }

    vNode.children = newChildren;
    vNode.childFlags = newChildFlags;
    {
      validateVNodeElementChildren(vNode);
    }
    return vNode;
  }
  var options$1 = {
    afterRender: null,
    beforeRender: null,
    createVNode: null,
    renderComplete: null
  };

  var xlinkNS = 'http://www.w3.org/1999/xlink';
  var xmlNS = 'http://www.w3.org/XML/1998/namespace';
  var svgNS = 'http://www.w3.org/2000/svg';
  var namespaces = {
    'xlink:actuate': xlinkNS,
    'xlink:arcrole': xlinkNS,
    'xlink:href': xlinkNS,
    'xlink:role': xlinkNS,
    'xlink:show': xlinkNS,
    'xlink:title': xlinkNS,
    'xlink:type': xlinkNS,
    'xml:base': xmlNS,
    'xml:lang': xmlNS,
    'xml:space': xmlNS
  };

  // We need EMPTY_OBJ defined in one place.
  // Its used for comparison so we cant inline it into shared
  var EMPTY_OBJ = {};
  var LIFECYCLE = [];
  {
    Object.freeze(EMPTY_OBJ);
  }
  function appendChild(parentDom, dom) {
    parentDom.appendChild(dom);
  }
  function insertOrAppend(parentDom, newNode, nextNode) {
    if (isNullOrUndef(nextNode)) {
      appendChild(parentDom, newNode);
    } else {
      parentDom.insertBefore(newNode, nextNode);
    }
  }
  function documentCreateElement(tag, isSVG) {
    if (isSVG) {
      return document.createElementNS(svgNS, tag);
    }
    return document.createElement(tag);
  }
  function replaceChild(parentDom, newDom, lastDom) {
    parentDom.replaceChild(newDom, lastDom);
  }
  function removeChild(parentDom, dom) {
    parentDom.removeChild(dom);
  }
  function callAll(arrayFn) {
    var listener;
    while ((listener = arrayFn.shift()) !== undefined) {
      listener();
    }
  }
  var attachedEventCounts = {};
  var attachedEvents = {};
  function handleEvent(name, nextEvent, dom) {
    var eventsLeft = attachedEventCounts[name];
    var eventsObject = dom.$EV;
    if (nextEvent) {
      if (!eventsLeft) {
        attachedEvents[name] = attachEventToDocument(name);
        attachedEventCounts[name] = 0;
      }
      if (!eventsObject) {
        eventsObject = dom.$EV = {};
      }
      if (!eventsObject[name]) {
        attachedEventCounts[name]++;
      }
      eventsObject[name] = nextEvent;
    } else if (eventsObject && eventsObject[name]) {
      attachedEventCounts[name]--;
      if (eventsLeft === 1) {
        document.removeEventListener(normalizeEventName(name), attachedEvents[name]);
        attachedEvents[name] = null;
      }
      eventsObject[name] = nextEvent;
    }
  }
  function dispatchEvents(event, target, isClick, name, eventData) {
    var dom = target;
    while (!isNull$2(dom)) {
      // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
      // because the event listener is on document.body
      // Don't process clicks on disabled elements
      if (isClick && dom.disabled) {
        return;
      }
      var eventsObject = dom.$EV;
      if (eventsObject) {
        var currentEvent = eventsObject[name];
        if (currentEvent) {
          // linkEvent object
          eventData.dom = dom;
          if (currentEvent.event) {
            currentEvent.event(currentEvent.data, event);
          } else {
            currentEvent(event);
          }
          if (event.cancelBubble) {
            return;
          }
        }
      }
      dom = dom.parentNode;
    }
  }
  function normalizeEventName(name) {
    return name.substr(2).toLowerCase();
  }
  function stopPropagation$1() {
    this.cancelBubble = true;
    if (!this.immediatePropagationStopped) {
      this.stopImmediatePropagation();
    }
  }
  function attachEventToDocument(name) {
    var docEvent = function docEvent(event) {
      var type = event.type;
      var isClick = type === 'click' || type === 'dblclick';
      if (isClick && event.button !== 0) {
        // Firefox incorrectly triggers click event for mid/right mouse buttons.
        // This bug has been active for 12 years.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=184051
        event.stopPropagation();
        return false;
      }
      event.stopPropagation = stopPropagation$1;
      // Event data needs to be object to save reference to currentTarget getter
      var eventData = {
        dom: document
      };
      Object.defineProperty(event, 'currentTarget', {
        configurable: true,
        get: function get() {
          return eventData.dom;
        }
      });
      dispatchEvents(event, event.target, isClick, name, eventData);
      return;
    };
    document.addEventListener(normalizeEventName(name), docEvent);
    return docEvent;
  }
  function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
  }
  function isSamePropsInnerHTML(dom, props) {
    return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML(dom, props.dangerouslySetInnerHTML.__html));
  }
  function triggerEventListener(props, methodName, e) {
    if (props[methodName]) {
      var listener = props[methodName];
      if (listener.event) {
        listener.event(listener.data, e);
      } else {
        listener(e);
      }
    } else {
      var nativeListenerName = methodName.toLowerCase();
      if (props[nativeListenerName]) {
        props[nativeListenerName](e);
      }
    }
  }
  function createWrappedFunction(methodName, applyValue) {
    var fnMethod = function fnMethod(e) {
      e.stopPropagation();
      var vNode = this.$V;
      // If vNode is gone by the time event fires, no-op
      if (!vNode) {
        return;
      }
      var props = vNode.props || EMPTY_OBJ;
      var dom = vNode.dom;
      if (isString(methodName)) {
        triggerEventListener(props, methodName, e);
      } else {
        for (var i = 0; i < methodName.length; i++) {
          triggerEventListener(props, methodName[i], e);
        }
      }
      if (isFunction(applyValue)) {
        var newVNode = this.$V;
        var newProps = newVNode.props || EMPTY_OBJ;
        applyValue(newProps, dom, false, newVNode);
      }
    };
    Object.defineProperty(fnMethod, 'wrapped', {
      configurable: false,
      enumerable: false,
      value: true,
      writable: false
    });
    return fnMethod;
  }
  function isCheckedType(type) {
    return type === 'checkbox' || type === 'radio';
  }
  var onTextInputChange = createWrappedFunction('onInput', applyValueInput);
  var wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);
  /* tslint:disable-next-line:no-empty */
  function emptywrapper(event) {
    event.stopPropagation();
  }
  emptywrapper.wrapped = true;
  function inputEvents(dom, nextPropsOrEmpty) {
    if (isCheckedType(nextPropsOrEmpty.type)) {
      dom.onchange = wrappedOnChange;
      dom.onclick = emptywrapper;
    } else {
      dom.oninput = onTextInputChange;
    }
  }
  function applyValueInput(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef(value);
    if (type && type !== dom.type) {
      dom.setAttribute('type', type);
    }
    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
      dom.multiple = multiple;
    }
    if (!isNullOrUndef(defaultValue) && !hasValue) {
      dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType(type)) {
      if (hasValue) {
        dom.value = value;
      }
      if (!isNullOrUndef(checked)) {
        dom.checked = checked;
      }
    } else {
      if (hasValue && dom.value !== value) {
        dom.defaultValue = value;
        dom.value = value;
      } else if (!isNullOrUndef(checked)) {
        dom.checked = checked;
      }
    }
  }
  function updateChildOptionGroup(vNode, value) {
    var type = vNode.type;
    if (type === 'optgroup') {
      var children = vNode.children;
      var childFlags = vNode.childFlags;
      if (childFlags & 12 /* MultipleChildren */) {
        for (var i = 0, len = children.length; i < len; i++) {
          updateChildOption(children[i], value);
        }
      } else if (childFlags === 2 /* HasVNodeChildren */) {
        updateChildOption(children, value);
      }
    } else {
      updateChildOption(vNode, value);
    }
  }
  function updateChildOption(vNode, value) {
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (isArray(value) && value.indexOf(props.value) !== -1 || props.value === value) {
      dom.selected = true;
    } else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {
      dom.selected = props.selected || false;
    }
  }
  var onSelectChange = createWrappedFunction('onChange', applyValueSelect);
  function selectEvents(dom) {
    dom.onchange = onSelectChange;
  }
  function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
      dom.multiple = multiplePropInBoolean;
    }
    var childFlags = vNode.childFlags;
    if ((childFlags & 1 /* HasInvalidChildren */) === 0) {
      var children = vNode.children;
      var value = nextPropsOrEmpty.value;
      if (mounting && isNullOrUndef(value)) {
        value = nextPropsOrEmpty.defaultValue;
      }
      if (childFlags & 12 /* MultipleChildren */) {
        for (var i = 0, len = children.length; i < len; i++) {
          updateChildOptionGroup(children[i], value);
        }
      } else if (childFlags === 2 /* HasVNodeChildren */) {
        updateChildOptionGroup(children, value);
      }
    }
  }
  var onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);
  var wrappedOnChange$1 = createWrappedFunction('onChange');
  function textAreaEvents(dom, nextPropsOrEmpty) {
    dom.oninput = onTextareaInputChange;
    if (nextPropsOrEmpty.onChange) {
      dom.onchange = wrappedOnChange$1;
    }
  }
  function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef(value)) {
      if (mounting) {
        var defaultValue = nextPropsOrEmpty.defaultValue;
        if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
          dom.defaultValue = defaultValue;
          dom.value = defaultValue;
        }
      }
    } else if (domValue !== value) {
      /* There is value so keep it controlled */
      dom.defaultValue = value;
      dom.value = value;
    }
  }

  /**
   * There is currently no support for switching same input between controlled and nonControlled
   * If that ever becomes a real issue, then re design controlled elements
   * Currently user must choose either controlled or non-controlled and stick with that
   */
  function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    if (flags & 64 /* InputElement */) {
      applyValueInput(nextPropsOrEmpty, dom);
    } else if (flags & 256 /* SelectElement */) {
      applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
    } else if (flags & 128 /* TextareaElement */) {
      applyValueTextArea(nextPropsOrEmpty, dom, mounting);
    }
    if (isControlled) {
      dom.$V = vNode;
    }
  }
  function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
    if (flags & 64 /* InputElement */) {
      inputEvents(dom, nextPropsOrEmpty);
    } else if (flags & 256 /* SelectElement */) {
      selectEvents(dom);
    } else if (flags & 128 /* TextareaElement */) {
      textAreaEvents(dom, nextPropsOrEmpty);
    }
  }
  function isControlledFormElement(nextPropsOrEmpty) {
    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
  }
  function remove$1(vNode, parentDom) {
    unmount(vNode);
    if (parentDom && vNode.dom) {
      removeChild(parentDom, vNode.dom);
      // Let carbage collector free memory
      vNode.dom = null;
    }
  }
  function unmount(vNode) {
    var flags = vNode.flags;
    if (flags & 481 /* Element */) {
      var ref = vNode.ref;
      var props = vNode.props;
      if (isFunction(ref)) {
        ref(null);
      }
      var children = vNode.children;
      var childFlags = vNode.childFlags;
      if (childFlags & 12 /* MultipleChildren */) {
        unmountAllChildren(children);
      } else if (childFlags === 2 /* HasVNodeChildren */) {
        unmount(children);
      }
      if (!isNull$2(props)) {
        for (var name in props) {
          switch (name) {
            case 'onClick':
            case 'onDblClick':
            case 'onFocusIn':
            case 'onFocusOut':
            case 'onKeyDown':
            case 'onKeyPress':
            case 'onKeyUp':
            case 'onMouseDown':
            case 'onMouseMove':
            case 'onMouseUp':
            case 'onSubmit':
            case 'onTouchEnd':
            case 'onTouchMove':
            case 'onTouchStart':
              handleEvent(name, null, vNode.dom);
              break;
          }
        }
      }
    } else {
      var children$1 = vNode.children;
      // Safe guard for crashed VNode
      if (children$1) {
        if (flags & 14 /* Component */) {
          var ref$1 = vNode.ref;
          if (flags & 4 /* ComponentClass */) {
            if (isFunction(children$1.componentWillUnmount)) {
              children$1.componentWillUnmount();
            }
            if (isFunction(ref$1)) {
              ref$1(null);
            }
            children$1.$UN = true;
            if (children$1.$LI) {
              unmount(children$1.$LI);
            }
          } else {
            if (!isNullOrUndef(ref$1) && isFunction(ref$1.onComponentWillUnmount)) {
              ref$1.onComponentWillUnmount(vNode.dom, vNode.props || EMPTY_OBJ);
            }
            unmount(children$1);
          }
        } else if (flags & 1024 /* Portal */) {
          remove$1(children$1, vNode.type);
        }
      }
    }
  }
  function unmountAllChildren(children) {
    for (var i = 0, len = children.length; i < len; i++) {
      unmount(children[i]);
    }
  }
  function removeAllChildren(dom, children) {
    unmountAllChildren(children);
    dom.textContent = '';
  }
  function createLinkEvent(linkEvent, nextValue) {
    return function (e) {
      linkEvent(nextValue.data, e);
    };
  }
  function patchEvent(name, nextValue, dom) {
    var nameLowerCase = name.toLowerCase();
    if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {
      var linkEvent = nextValue.event;
      if (linkEvent && isFunction(linkEvent)) {
        dom[nameLowerCase] = createLinkEvent(linkEvent, nextValue);
      } else {
        // Development warning
        {
          throwError("an event on a VNode \"" + name + "\". was not a function or a valid linkEvent.");
        }
      }
    } else {
      var domEvent = dom[nameLowerCase];
      // if the function is wrapped, that means it's been controlled by a wrapper
      if (!domEvent || !domEvent.wrapped) {
        dom[nameLowerCase] = nextValue;
      }
    }
  }
  function getNumberStyleValue(style, value) {
    switch (style) {
      case 'animationIterationCount':
      case 'borderImageOutset':
      case 'borderImageSlice':
      case 'borderImageWidth':
      case 'boxFlex':
      case 'boxFlexGroup':
      case 'boxOrdinalGroup':
      case 'columnCount':
      case 'fillOpacity':
      case 'flex':
      case 'flexGrow':
      case 'flexNegative':
      case 'flexOrder':
      case 'flexPositive':
      case 'flexShrink':
      case 'floodOpacity':
      case 'fontWeight':
      case 'gridColumn':
      case 'gridRow':
      case 'lineClamp':
      case 'lineHeight':
      case 'opacity':
      case 'order':
      case 'orphans':
      case 'stopOpacity':
      case 'strokeDasharray':
      case 'strokeDashoffset':
      case 'strokeMiterlimit':
      case 'strokeOpacity':
      case 'strokeWidth':
      case 'tabSize':
      case 'widows':
      case 'zIndex':
      case 'zoom':
        return value;
      default:
        return value + 'px';
    }
  }
  // We are assuming here that we come from patchProp routine
  // -nextAttrValue cannot be null or undefined
  function patchStyle(lastAttrValue, nextAttrValue, dom) {
    var domStyle = dom.style;
    var style;
    var value;
    if (isString(nextAttrValue)) {
      domStyle.cssText = nextAttrValue;
      return;
    }
    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {
      for (style in nextAttrValue) {
        // do not add a hasOwnProperty check here, it affects performance
        value = nextAttrValue[style];
        if (value !== lastAttrValue[style]) {
          domStyle[style] = isNumber$2(value) ? getNumberStyleValue(style, value) : value;
        }
      }
      for (style in lastAttrValue) {
        if (isNullOrUndef(nextAttrValue[style])) {
          domStyle[style] = '';
        }
      }
    } else {
      for (style in nextAttrValue) {
        value = nextAttrValue[style];
        domStyle[style] = isNumber$2(value) ? getNumberStyleValue(style, value) : value;
      }
    }
  }
  function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
    switch (prop) {
      case 'onClick':
      case 'onDblClick':
      case 'onFocusIn':
      case 'onFocusOut':
      case 'onKeyDown':
      case 'onKeyPress':
      case 'onKeyUp':
      case 'onMouseDown':
      case 'onMouseMove':
      case 'onMouseUp':
      case 'onSubmit':
      case 'onTouchEnd':
      case 'onTouchMove':
      case 'onTouchStart':
        handleEvent(prop, nextValue, dom);
        break;
      case 'children':
      case 'childrenType':
      case 'className':
      case 'defaultValue':
      case 'key':
      case 'multiple':
      case 'ref':
        break;
      case 'autoFocus':
        dom.autofocus = !!nextValue;
        break;
      case 'allowfullscreen':
      case 'autoplay':
      case 'capture':
      case 'checked':
      case 'controls':
      case 'default':
      case 'disabled':
      case 'hidden':
      case 'indeterminate':
      case 'loop':
      case 'muted':
      case 'novalidate':
      case 'open':
      case 'readOnly':
      case 'required':
      case 'reversed':
      case 'scoped':
      case 'seamless':
      case 'selected':
        dom[prop] = !!nextValue;
        break;
      case 'defaultChecked':
      case 'value':
      case 'volume':
        if (hasControlledValue && prop === 'value') {
          return;
        }
        var value = isNullOrUndef(nextValue) ? '' : nextValue;
        if (dom[prop] !== value) {
          dom[prop] = value;
        }
        break;
      case 'dangerouslySetInnerHTML':
        var lastHtml = lastValue && lastValue.__html || '';
        var nextHtml = nextValue && nextValue.__html || '';
        if (lastHtml !== nextHtml) {
          if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
            if (!isNull$2(lastVNode)) {
              if (lastVNode.childFlags & 12 /* MultipleChildren */) {
                unmountAllChildren(lastVNode.children);
              } else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {
                unmount(lastVNode.children);
              }
              lastVNode.children = null;
              lastVNode.childFlags = 1 /* HasInvalidChildren */;
            }

            dom.innerHTML = nextHtml;
          }
        }
        break;
      default:
        if (prop[0] === 'o' && prop[1] === 'n') {
          patchEvent(prop, nextValue, dom);
        } else if (isNullOrUndef(nextValue)) {
          dom.removeAttribute(prop);
        } else if (prop === 'style') {
          patchStyle(lastValue, nextValue, dom);
        } else if (isSVG && namespaces[prop]) {
          // We optimize for isSVG being false
          // If we end up in this path we can read property again
          dom.setAttributeNS(namespaces[prop], prop, nextValue);
        } else {
          dom.setAttribute(prop, nextValue);
        }
        break;
    }
  }
  function mountProps(vNode, flags, props, dom, isSVG) {
    var hasControlledValue = false;
    var isFormElement = (flags & 448 /* FormElement */) > 0;
    if (isFormElement) {
      hasControlledValue = isControlledFormElement(props);
      if (hasControlledValue) {
        addFormElementEventHandlers(flags, dom, props);
      }
    }
    for (var prop in props) {
      // do not add a hasOwnProperty check here, it affects performance
      patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
    }
    if (isFormElement) {
      processElement(flags, vNode, dom, props, true, hasControlledValue);
    }
  }
  function createClassComponentInstance(vNode, Component, props, context) {
    var instance = new Component(props, context);
    vNode.children = instance;
    instance.$V = vNode;
    instance.$BS = false;
    instance.context = context;
    if (instance.props === EMPTY_OBJ) {
      instance.props = props;
    }
    instance.$UN = false;
    if (isFunction(instance.componentWillMount)) {
      instance.$BR = true;
      instance.componentWillMount();
      if (instance.$PSS) {
        var state = instance.state;
        var pending = instance.$PS;
        if (isNull$2(state)) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }
        instance.$PSS = false;
        instance.$PS = null;
      }
      instance.$BR = false;
    }
    if (isFunction(options$1.beforeRender)) {
      options$1.beforeRender(instance);
    }
    var input = handleComponentInput(instance.render(props, instance.state, context), vNode);
    var childContext;
    if (isFunction(instance.getChildContext)) {
      childContext = instance.getChildContext();
    }
    if (isNullOrUndef(childContext)) {
      instance.$CX = context;
    } else {
      instance.$CX = combineFrom(context, childContext);
    }
    if (isFunction(options$1.afterRender)) {
      options$1.afterRender(instance);
    }
    instance.$LI = input;
    return instance;
  }
  function handleComponentInput(input, componentVNode) {
    // Development validation
    {
      if (isArray(input)) {
        throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');
      }
    }
    if (isInvalid(input)) {
      input = createVoidVNode();
    } else if (isStringOrNumber(input)) {
      input = createTextVNode(input, null);
    } else {
      if (input.dom) {
        input = directClone(input);
      }
      if (input.flags & 14 /* Component */) {
        // if we have an input that is also a component, we run into a tricky situation
        // where the root vNode needs to always have the correct DOM entry
        // we can optimise this in the future, but this gets us out of a lot of issues
        input.parentVNode = componentVNode;
      }
    }
    return input;
  }
  function mount(vNode, parentDom, context, isSVG) {
    var flags = vNode.flags;
    if (flags & 481 /* Element */) {
      return mountElement(vNode, parentDom, context, isSVG);
    }
    if (flags & 14 /* Component */) {
      return mountComponent(vNode, parentDom, context, isSVG, (flags & 4 /* ComponentClass */) > 0);
    }
    if (flags & 512 /* Void */ || flags & 16 /* Text */) {
      return mountText(vNode, parentDom);
    }
    if (flags & 1024 /* Portal */) {
      mount(vNode.children, vNode.type, context, false);
      return vNode.dom = mountText(createVoidVNode(), parentDom);
    }
    // Development validation, in production we don't need to throw because it crashes anyway
    {
      if (_typeof(vNode) === 'object') {
        throwError("mount() received an object that's not a valid VNode, you should stringify it first, fix createVNode flags or call normalizeChildren. Object: \"" + JSON.stringify(vNode) + "\".");
      } else {
        throwError("mount() expects a valid VNode, instead it received an object with the type \"" + _typeof(vNode) + "\".");
      }
    }
  }
  function mountText(vNode, parentDom) {
    var dom = vNode.dom = document.createTextNode(vNode.children);
    if (!isNull$2(parentDom)) {
      appendChild(parentDom, dom);
    }
    return dom;
  }
  function mountElement(vNode, parentDom, context, isSVG) {
    var flags = vNode.flags;
    var children = vNode.children;
    var props = vNode.props;
    var className = vNode.className;
    var ref = vNode.ref;
    var childFlags = vNode.childFlags;
    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;
    var dom = documentCreateElement(vNode.type, isSVG);
    vNode.dom = dom;
    if (!isNullOrUndef(className) && className !== '') {
      if (isSVG) {
        dom.setAttribute('class', className);
      } else {
        dom.className = className;
      }
    }
    {
      validateKeys(vNode);
    }
    if (!isNull$2(parentDom)) {
      appendChild(parentDom, dom);
    }
    if ((childFlags & 1 /* HasInvalidChildren */) === 0) {
      var childrenIsSVG = isSVG === true && vNode.type !== 'foreignObject';
      if (childFlags === 2 /* HasVNodeChildren */) {
        mount(children, dom, context, childrenIsSVG);
      } else if (childFlags & 12 /* MultipleChildren */) {
        mountArrayChildren(children, dom, context, childrenIsSVG);
      }
    }
    if (!isNull$2(props)) {
      mountProps(vNode, flags, props, dom, isSVG);
    }
    {
      if (isString(ref)) {
        throwError('string "refs" are not supported in Inferno 1.0. Use callback "refs" instead.');
      }
    }
    if (isFunction(ref)) {
      mountRef(dom, ref);
    }
    return dom;
  }
  function mountArrayChildren(children, dom, context, isSVG) {
    for (var i = 0, len = children.length; i < len; i++) {
      var child = children[i];
      if (!isNull$2(child.dom)) {
        children[i] = child = directClone(child);
      }
      mount(child, dom, context, isSVG);
    }
  }
  function mountComponent(vNode, parentDom, context, isSVG, isClass) {
    var dom;
    var type = vNode.type;
    var props = vNode.props || EMPTY_OBJ;
    var ref = vNode.ref;
    if (isClass) {
      var instance = createClassComponentInstance(vNode, type, props, context);
      vNode.dom = dom = mount(instance.$LI, null, instance.$CX, isSVG);
      mountClassComponentCallbacks(vNode, ref, instance);
      instance.$UPD = false;
    } else {
      var input = handleComponentInput(type(props, context), vNode);
      vNode.children = input;
      vNode.dom = dom = mount(input, null, context, isSVG);
      mountFunctionalComponentCallbacks(props, ref, dom);
    }
    if (!isNull$2(parentDom)) {
      appendChild(parentDom, dom);
    }
    return dom;
  }
  function createClassMountCallback(instance) {
    return function () {
      instance.$UPD = true;
      instance.componentDidMount();
      instance.$UPD = false;
    };
  }
  function mountClassComponentCallbacks(vNode, ref, instance) {
    if (isFunction(ref)) {
      ref(instance);
    } else {
      {
        if (isStringOrNumber(ref)) {
          throwError('string "refs" are not supported in Inferno 1.0. Use callback "refs" instead.');
        } else if (!isNullOrUndef(ref) && isObject(ref) && vNode.flags & 4 /* ComponentClass */) {
          throwError('functional component lifecycle events are not supported on ES2015 class components.');
        }
      }
    }
    if (isFunction(instance.componentDidMount)) {
      LIFECYCLE.push(createClassMountCallback(instance));
    }
  }
  function createOnMountCallback(ref, dom, props) {
    return function () {
      return ref.onComponentDidMount(dom, props);
    };
  }
  function mountFunctionalComponentCallbacks(props, ref, dom) {
    if (!isNullOrUndef(ref)) {
      if (isFunction(ref.onComponentWillMount)) {
        ref.onComponentWillMount(props);
      }
      if (isFunction(ref.onComponentDidMount)) {
        LIFECYCLE.push(createOnMountCallback(ref, dom, props));
      }
    }
  }
  function mountRef(dom, value) {
    LIFECYCLE.push(function () {
      return value(dom);
    });
  }
  function hydrateComponent(vNode, dom, context, isSVG, isClass) {
    var type = vNode.type;
    var ref = vNode.ref;
    var props = vNode.props || EMPTY_OBJ;
    if (isClass) {
      var instance = createClassComponentInstance(vNode, type, props, context);
      var input = instance.$LI;
      hydrateVNode(input, dom, instance.$CX, isSVG);
      vNode.dom = input.dom;
      mountClassComponentCallbacks(vNode, ref, instance);
      instance.$UPD = false; // Mount finished allow going sync
    } else {
      var input$1 = handleComponentInput(type(props, context), vNode);
      hydrateVNode(input$1, dom, context, isSVG);
      vNode.children = input$1;
      vNode.dom = input$1.dom;
      mountFunctionalComponentCallbacks(props, ref, dom);
    }
  }
  function hydrateElement(vNode, dom, context, isSVG) {
    var children = vNode.children;
    var props = vNode.props;
    var className = vNode.className;
    var flags = vNode.flags;
    var ref = vNode.ref;
    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;
    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {
      {
        warning("Inferno hydration: Server-side markup doesn't match client-side markup or Initial render target is not empty");
      }
      var newDom = mountElement(vNode, null, context, isSVG);
      vNode.dom = newDom;
      replaceChild(dom.parentNode, newDom, dom);
    } else {
      vNode.dom = dom;
      var childNode = dom.firstChild;
      var childFlags = vNode.childFlags;
      if ((childFlags & 1 /* HasInvalidChildren */) === 0) {
        var nextSibling = null;
        while (childNode) {
          nextSibling = childNode.nextSibling;
          if (childNode.nodeType === 8) {
            if (childNode.data === '!') {
              dom.replaceChild(document.createTextNode(''), childNode);
            } else {
              dom.removeChild(childNode);
            }
          }
          childNode = nextSibling;
        }
        childNode = dom.firstChild;
        if (childFlags === 2 /* HasVNodeChildren */) {
          if (isNull$2(childNode)) {
            mount(children, dom, context, isSVG);
          } else {
            nextSibling = childNode.nextSibling;
            hydrateVNode(children, childNode, context, isSVG);
            childNode = nextSibling;
          }
        } else if (childFlags & 12 /* MultipleChildren */) {
          for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            if (isNull$2(childNode)) {
              mount(child, dom, context, isSVG);
            } else {
              nextSibling = childNode.nextSibling;
              hydrateVNode(child, childNode, context, isSVG);
              childNode = nextSibling;
            }
          }
        }
        // clear any other DOM nodes, there should be only a single entry for the root
        while (childNode) {
          nextSibling = childNode.nextSibling;
          dom.removeChild(childNode);
          childNode = nextSibling;
        }
      } else if (!isNull$2(dom.firstChild) && !isSamePropsInnerHTML(dom, props)) {
        dom.textContent = ''; // dom has content, but VNode has no children remove everything from DOM
        if (flags & 448 /* FormElement */) {
          // If element is form element, we need to clear defaultValue also
          dom.defaultValue = '';
        }
      }
      if (!isNull$2(props)) {
        mountProps(vNode, flags, props, dom, isSVG);
      }
      if (isNullOrUndef(className)) {
        if (dom.className !== '') {
          dom.removeAttribute('class');
        }
      } else if (isSVG) {
        dom.setAttribute('class', className);
      } else {
        dom.className = className;
      }
      if (isFunction(ref)) {
        mountRef(dom, ref);
      } else {
        {
          if (isString(ref)) {
            throwError('string "refs" are not supported in Inferno 1.0. Use callback "refs" instead.');
          }
        }
      }
    }
  }
  function hydrateText(vNode, dom) {
    if (dom.nodeType !== 3) {
      var newDom = mountText(vNode, null);
      vNode.dom = newDom;
      replaceChild(dom.parentNode, newDom, dom);
    } else {
      var text = vNode.children;
      if (dom.nodeValue !== text) {
        dom.nodeValue = text;
      }
      vNode.dom = dom;
    }
  }
  function hydrateVNode(vNode, dom, context, isSVG) {
    var flags = vNode.flags;
    if (flags & 14 /* Component */) {
      hydrateComponent(vNode, dom, context, isSVG, (flags & 4 /* ComponentClass */) > 0);
    } else if (flags & 481 /* Element */) {
      hydrateElement(vNode, dom, context, isSVG);
    } else if (flags & 16 /* Text */) {
      hydrateText(vNode, dom);
    } else if (flags & 512 /* Void */) {
      vNode.dom = dom;
    } else {
      {
        throwError("hydrate() expects a valid VNode, instead it received an object with the type \"" + _typeof(vNode) + "\".");
      }
      throwError();
    }
  }
  function hydrate(input, parentDom, callback) {
    var dom = parentDom.firstChild;
    if (!isNull$2(dom)) {
      if (!isInvalid(input)) {
        hydrateVNode(input, dom, EMPTY_OBJ, false);
      }
      dom = parentDom.firstChild;
      // clear any other DOM nodes, there should be only a single entry for the root
      while (dom = dom.nextSibling) {
        parentDom.removeChild(dom);
      }
    }
    if (LIFECYCLE.length > 0) {
      callAll(LIFECYCLE);
    }
    parentDom.$V = input;
    if (isFunction(callback)) {
      callback();
    }
  }
  function replaceWithNewNode(lastNode, nextNode, parentDom, context, isSVG) {
    unmount(lastNode);
    replaceChild(parentDom, mount(nextNode, null, context, isSVG), lastNode.dom);
  }
  function patch(lastVNode, nextVNode, parentDom, context, isSVG) {
    var nextFlags = nextVNode.flags | 0;
    if (lastVNode.flags !== nextFlags || nextFlags & 2048 /* ReCreate */) {
      replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);
    } else if (nextFlags & 481 /* Element */) {
      patchElement(lastVNode, nextVNode, parentDom, context, isSVG, nextFlags);
    } else if (nextFlags & 14 /* Component */) {
      patchComponent(lastVNode, nextVNode, parentDom, context, isSVG, (nextFlags & 4 /* ComponentClass */) > 0);
    } else if (nextFlags & 16 /* Text */) {
      patchText(lastVNode, nextVNode);
    } else if (nextFlags & 512 /* Void */) {
      nextVNode.dom = lastVNode.dom;
    } else {
      patchPortal(lastVNode, nextVNode, context);
    }
  }
  function patchContentEditableChildren(dom, nextVNode) {
    if (dom.textContent !== nextVNode.children) {
      dom.textContent = nextVNode.children;
    }
  }
  function patchPortal(lastVNode, nextVNode, context) {
    var lastContainer = lastVNode.type;
    var nextContainer = nextVNode.type;
    var nextChildren = nextVNode.children;
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false);
    nextVNode.dom = lastVNode.dom;
    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
      var node = nextChildren.dom;
      lastContainer.removeChild(node);
      nextContainer.appendChild(node);
    }
  }
  function patchElement(lastVNode, nextVNode, parentDom, context, isSVG, nextFlags) {
    var nextTag = nextVNode.type;
    if (lastVNode.type !== nextTag) {
      replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);
    } else {
      var dom = lastVNode.dom;
      var lastProps = lastVNode.props;
      var nextProps = nextVNode.props;
      var isFormElement = false;
      var hasControlledValue = false;
      var nextPropsOrEmpty;
      nextVNode.dom = dom;
      isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;
      // inlined patchProps  -- starts --
      if (lastProps !== nextProps) {
        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
        nextPropsOrEmpty = nextProps || EMPTY_OBJ;
        if (nextPropsOrEmpty !== EMPTY_OBJ) {
          isFormElement = (nextFlags & 448 /* FormElement */) > 0;
          if (isFormElement) {
            hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
          }
          for (var prop in nextPropsOrEmpty) {
            var lastValue = lastPropsOrEmpty[prop];
            var nextValue = nextPropsOrEmpty[prop];
            if (lastValue !== nextValue) {
              patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
            }
          }
        }
        if (lastPropsOrEmpty !== EMPTY_OBJ) {
          for (var prop$1 in lastPropsOrEmpty) {
            if (!nextPropsOrEmpty.hasOwnProperty(prop$1) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
              patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
            }
          }
        }
      }
      var lastChildren = lastVNode.children;
      var nextChildren = nextVNode.children;
      var nextRef = nextVNode.ref;
      var lastClassName = lastVNode.className;
      var nextClassName = nextVNode.className;
      {
        validateKeys(nextVNode);
      }
      if (nextFlags & 4096 /* ContentEditable */) {
        patchContentEditableChildren(dom, nextChildren);
      } else {
        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastChildren, nextChildren, dom, context, isSVG && nextTag !== 'foreignObject');
      }
      if (isFormElement) {
        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
      }
      // inlined patchProps  -- ends --
      if (lastClassName !== nextClassName) {
        if (isNullOrUndef(nextClassName)) {
          dom.removeAttribute('class');
        } else if (isSVG) {
          dom.setAttribute('class', nextClassName);
        } else {
          dom.className = nextClassName;
        }
      }
      if (isFunction(nextRef) && lastVNode.ref !== nextRef) {
        mountRef(dom, nextRef);
      } else {
        {
          if (isString(nextRef)) {
            throwError('string "refs" are not supported in Inferno 1.0. Use callback "refs" instead.');
          }
        }
      }
    }
  }
  function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG) {
    switch (lastChildFlags) {
      case 2 /* HasVNodeChildren */:
        switch (nextChildFlags) {
          case 2 /* HasVNodeChildren */:
            patch(lastChildren, nextChildren, parentDOM, context, isSVG);
            break;
          case 1 /* HasInvalidChildren */:
            remove$1(lastChildren, parentDOM);
            break;
          default:
            remove$1(lastChildren, parentDOM);
            mountArrayChildren(nextChildren, parentDOM, context, isSVG);
            break;
        }
        break;
      case 1 /* HasInvalidChildren */:
        switch (nextChildFlags) {
          case 2 /* HasVNodeChildren */:
            mount(nextChildren, parentDOM, context, isSVG);
            break;
          case 1 /* HasInvalidChildren */:
            break;
          default:
            mountArrayChildren(nextChildren, parentDOM, context, isSVG);
            break;
        }
        break;
      default:
        if (nextChildFlags & 12 /* MultipleChildren */) {
          var lastLength = lastChildren.length;
          var nextLength = nextChildren.length;
          // Fast path's for both algorithms
          if (lastLength === 0) {
            if (nextLength > 0) {
              mountArrayChildren(nextChildren, parentDOM, context, isSVG);
            }
          } else if (nextLength === 0) {
            removeAllChildren(parentDOM, lastChildren);
          } else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {
            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength);
          } else {
            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength);
          }
        } else if (nextChildFlags === 1 /* HasInvalidChildren */) {
          removeAllChildren(parentDOM, lastChildren);
        } else if (nextChildFlags === 2 /* HasVNodeChildren */) {
          removeAllChildren(parentDOM, lastChildren);
          mount(nextChildren, parentDOM, context, isSVG);
        }
        break;
    }
  }
  function updateClassComponent(instance, nextState, nextVNode, nextProps, parentDom, context, isSVG, force, fromSetState) {
    var lastState = instance.state;
    var lastProps = instance.props;
    nextVNode.children = instance;
    var renderOutput;
    if (instance.$UN) {
      {
        warning('Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.');
      }
      return;
    }
    if (lastProps !== nextProps || nextProps === EMPTY_OBJ) {
      if (!fromSetState && isFunction(instance.componentWillReceiveProps)) {
        instance.$BR = true;
        instance.componentWillReceiveProps(nextProps, context);
        // If instance component was removed during its own update do nothing.
        if (instance.$UN) {
          return;
        }
        instance.$BR = false;
      }
      if (instance.$PSS) {
        nextState = combineFrom(nextState, instance.$PS);
        instance.$PSS = false;
        instance.$PS = null;
      }
    }
    /* Update if scu is not defined, or it returns truthy value or force */
    var hasSCU = Boolean(instance.shouldComponentUpdate);
    if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context)) {
      if (isFunction(instance.componentWillUpdate)) {
        instance.$BS = true;
        instance.componentWillUpdate(nextProps, nextState, context);
        instance.$BS = false;
      }
      instance.props = nextProps;
      instance.state = nextState;
      instance.context = context;
      if (isFunction(options$1.beforeRender)) {
        options$1.beforeRender(instance);
      }
      renderOutput = instance.render(nextProps, nextState, context);
      if (isFunction(options$1.afterRender)) {
        options$1.afterRender(instance);
      }
      var didUpdate = renderOutput !== NO_OP;
      var childContext;
      if (isFunction(instance.getChildContext)) {
        childContext = instance.getChildContext();
      }
      if (isNullOrUndef(childContext)) {
        childContext = context;
      } else {
        childContext = combineFrom(context, childContext);
      }
      instance.$CX = childContext;
      if (didUpdate) {
        var lastInput = instance.$LI;
        var nextInput = handleComponentInput(renderOutput, nextVNode);
        patch(lastInput, nextInput, parentDom, childContext, isSVG);
        instance.$LI = nextInput;
        if (isFunction(instance.componentDidUpdate)) {
          instance.componentDidUpdate(lastProps, lastState);
        }
      }
    } else {
      instance.props = nextProps;
      instance.state = nextState;
      instance.context = context;
    }
    nextVNode.dom = instance.$LI.dom;
  }
  function patchComponent(lastVNode, nextVNode, parentDom, context, isSVG, isClass) {
    var nextType = nextVNode.type;
    var lastKey = lastVNode.key;
    var nextKey = nextVNode.key;
    if (lastVNode.type !== nextType || lastKey !== nextKey) {
      replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);
    } else {
      var nextProps = nextVNode.props || EMPTY_OBJ;
      if (isClass) {
        var instance = lastVNode.children;
        instance.$UPD = true;
        instance.$V = nextVNode;
        updateClassComponent(instance, instance.state, nextVNode, nextProps, parentDom, context, isSVG, false, false);
        instance.$UPD = false;
      } else {
        var shouldUpdate = true;
        var lastProps = lastVNode.props;
        var nextHooks = nextVNode.ref;
        var nextHooksDefined = !isNullOrUndef(nextHooks);
        var lastInput = lastVNode.children;
        nextVNode.dom = lastVNode.dom;
        nextVNode.children = lastInput;
        if (nextHooksDefined && isFunction(nextHooks.onComponentShouldUpdate)) {
          shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps, nextProps);
        }
        if (shouldUpdate !== false) {
          if (nextHooksDefined && isFunction(nextHooks.onComponentWillUpdate)) {
            nextHooks.onComponentWillUpdate(lastProps, nextProps);
          }
          var nextInput = nextType(nextProps, context);
          if (nextInput !== NO_OP) {
            nextInput = handleComponentInput(nextInput, nextVNode);
            patch(lastInput, nextInput, parentDom, context, isSVG);
            nextVNode.children = nextInput;
            nextVNode.dom = nextInput.dom;
            if (nextHooksDefined && isFunction(nextHooks.onComponentDidUpdate)) {
              nextHooks.onComponentDidUpdate(lastProps, nextProps);
            }
          }
        } else if (lastInput.flags & 14 /* Component */) {
          lastInput.parentVNode = nextVNode;
        }
      }
    }
  }
  function patchText(lastVNode, nextVNode) {
    var nextText = nextVNode.children;
    var dom = lastVNode.dom;
    if (nextText !== lastVNode.children) {
      dom.nodeValue = nextText;
    }
    nextVNode.dom = dom;
  }
  function patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength) {
    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
    var i = 0;
    var nextChild;
    var lastChild;
    for (; i < commonLength; i++) {
      nextChild = nextChildren[i];
      lastChild = lastChildren[i];
      if (nextChild.dom) {
        nextChild = nextChildren[i] = directClone(nextChild);
      }
      patch(lastChild, nextChild, dom, context, isSVG);
      lastChildren[i] = nextChild;
    }
    if (lastChildrenLength < nextChildrenLength) {
      for (i = commonLength; i < nextChildrenLength; i++) {
        nextChild = nextChildren[i];
        if (nextChild.dom) {
          nextChild = nextChildren[i] = directClone(nextChild);
        }
        mount(nextChild, dom, context, isSVG);
      }
    } else if (lastChildrenLength > nextChildrenLength) {
      for (i = commonLength; i < lastChildrenLength; i++) {
        remove$1(lastChildren[i], dom);
      }
    }
  }
  function patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var i;
    var j = 0;
    var aNode = a[j];
    var bNode = b[j];
    var nextPos;
    // Step 1
    // tslint:disable-next-line
    outer: {
      // Sync nodes with the same key at the beginning.
      while (aNode.key === bNode.key) {
        if (bNode.dom) {
          b[j] = bNode = directClone(bNode);
        }
        patch(aNode, bNode, dom, context, isSVG);
        a[j] = bNode;
        j++;
        if (j > aEnd || j > bEnd) {
          break outer;
        }
        aNode = a[j];
        bNode = b[j];
      }
      aNode = a[aEnd];
      bNode = b[bEnd];
      // Sync nodes with the same key at the end.
      while (aNode.key === bNode.key) {
        if (bNode.dom) {
          b[bEnd] = bNode = directClone(bNode);
        }
        patch(aNode, bNode, dom, context, isSVG);
        a[aEnd] = bNode;
        aEnd--;
        bEnd--;
        if (j > aEnd || j > bEnd) {
          break outer;
        }
        aNode = a[aEnd];
        bNode = b[bEnd];
      }
    }
    if (j > aEnd) {
      if (j <= bEnd) {
        nextPos = bEnd + 1;
        var nextNode = nextPos < bLength ? b[nextPos].dom : null;
        while (j <= bEnd) {
          bNode = b[j];
          if (bNode.dom) {
            b[j] = bNode = directClone(bNode);
          }
          j++;
          insertOrAppend(dom, mount(bNode, null, context, isSVG), nextNode);
        }
      }
    } else if (j > bEnd) {
      while (j <= aEnd) {
        remove$1(a[j++], dom);
      }
    } else {
      var aStart = j;
      var bStart = j;
      var aLeft = aEnd - j + 1;
      var bLeft = bEnd - j + 1;
      var sources = [];
      for (i = 0; i < bLeft; i++) {
        sources.push(0);
      }
      // Keep track if its possible to remove whole DOM using textContent = '';
      var canRemoveWholeContent = aLeft === aLength;
      var moved = false;
      var pos = 0;
      var patched = 0;
      // When sizes are small, just loop them through
      if (bLength < 4 || (aLeft | bLeft) < 32) {
        for (i = aStart; i <= aEnd; i++) {
          aNode = a[i];
          if (patched < bLeft) {
            for (j = bStart; j <= bEnd; j++) {
              bNode = b[j];
              if (aNode.key === bNode.key) {
                sources[j - bStart] = i + 1;
                if (canRemoveWholeContent) {
                  canRemoveWholeContent = false;
                  while (i > aStart) {
                    remove$1(a[aStart++], dom);
                  }
                }
                if (pos > j) {
                  moved = true;
                } else {
                  pos = j;
                }
                if (bNode.dom) {
                  b[j] = bNode = directClone(bNode);
                }
                patch(aNode, bNode, dom, context, isSVG);
                patched++;
                break;
              }
            }
            if (!canRemoveWholeContent && j > bEnd) {
              remove$1(aNode, dom);
            }
          } else if (!canRemoveWholeContent) {
            remove$1(aNode, dom);
          }
        }
      } else {
        var keyIndex = {};
        // Map keys by their index
        for (i = bStart; i <= bEnd; i++) {
          keyIndex[b[i].key] = i;
        }
        // Try to patch same keys
        for (i = aStart; i <= aEnd; i++) {
          aNode = a[i];
          if (patched < bLeft) {
            j = keyIndex[aNode.key];
            if (j !== void 0) {
              if (canRemoveWholeContent) {
                canRemoveWholeContent = false;
                while (i > aStart) {
                  remove$1(a[aStart++], dom);
                }
              }
              bNode = b[j];
              sources[j - bStart] = i + 1;
              if (pos > j) {
                moved = true;
              } else {
                pos = j;
              }
              if (bNode.dom) {
                b[j] = bNode = directClone(bNode);
              }
              patch(aNode, bNode, dom, context, isSVG);
              patched++;
            } else if (!canRemoveWholeContent) {
              remove$1(aNode, dom);
            }
          } else if (!canRemoveWholeContent) {
            remove$1(aNode, dom);
          }
        }
      }
      // fast-path: if nothing patched remove all old and add all new
      if (canRemoveWholeContent) {
        removeAllChildren(dom, a);
        mountArrayChildren(b, dom, context, isSVG);
      } else {
        if (moved) {
          var seq = lis_algorithm(sources);
          j = seq.length - 1;
          for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
              pos = i + bStart;
              bNode = b[pos];
              if (bNode.dom) {
                b[pos] = bNode = directClone(bNode);
              }
              nextPos = pos + 1;
              insertOrAppend(dom, mount(bNode, null, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);
            } else if (j < 0 || i !== seq[j]) {
              pos = i + bStart;
              bNode = b[pos];
              nextPos = pos + 1;
              insertOrAppend(dom, bNode.dom, nextPos < bLength ? b[nextPos].dom : null);
            } else {
              j--;
            }
          }
        } else if (patched !== bLeft) {
          // when patched count doesn't match b length we need to insert those new ones
          // loop backwards so we can use insertBefore
          for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
              pos = i + bStart;
              bNode = b[pos];
              if (bNode.dom) {
                b[pos] = bNode = directClone(bNode);
              }
              nextPos = pos + 1;
              insertOrAppend(dom, mount(bNode, null, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);
            }
          }
        }
      }
    }
  }
  // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
  function lis_algorithm(arr) {
    var p = arr.slice();
    var result = [0];
    var i;
    var j;
    var u;
    var v;
    var c;
    var len = arr.length;
    for (i = 0; i < len; i++) {
      var arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = (u + v) / 2 | 0;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p[v];
    }
    return result;
  }
  {
    if (isBrowser && document.body === null) {
      warning('Inferno warning: you cannot initialize inferno without "document.body". Wait on "DOMContentLoaded" event, add script to bottom of body, or use async/defer attributes on script tag.');
    }
  }
  var documentBody = isBrowser ? document.body : null;
  function render(input, parentDom, callback) {
    // Development warning
    {
      if (documentBody === parentDom) {
        throwError('you cannot render() to the "document.body". Use an empty element as a container instead.');
      }
    }
    if (input === NO_OP) {
      return;
    }
    var rootInput = parentDom.$V;
    if (isNullOrUndef(rootInput)) {
      if (!isInvalid(input)) {
        if (input.dom) {
          input = directClone(input);
        }
        if (isNull$2(parentDom.firstChild)) {
          mount(input, parentDom, EMPTY_OBJ, false);
          parentDom.$V = input;
        } else {
          hydrate(input, parentDom);
        }
        rootInput = input;
      }
    } else {
      if (isNullOrUndef(input)) {
        remove$1(rootInput, parentDom);
        parentDom.$V = null;
      } else {
        if (input.dom) {
          input = directClone(input);
        }
        patch(rootInput, input, parentDom, EMPTY_OBJ, false);
        rootInput = parentDom.$V = input;
      }
    }
    if (LIFECYCLE.length > 0) {
      callAll(LIFECYCLE);
    }
    if (isFunction(callback)) {
      callback();
    }
    if (isFunction(options$1.renderComplete)) {
      options$1.renderComplete(rootInput);
    }
    if (rootInput && rootInput.flags & 14 /* Component */) {
      return rootInput.children;
    }
  }
  function createPortal(children, container) {
    return createVNode(1024 /* Portal */, container, null, children, 0 /* UnknownChildren */, null, isInvalid(children) ? null : children.key, null);
  }
  var resolvedPromise = typeof Promise === 'undefined' ? null : Promise.resolve();
  // raf.bind(window) is needed to work around bug in IE10-IE11 strict mode (TypeError: Invalid calling object)
  var fallbackMethod = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame.bind(window);
  function nextTick(fn) {
    if (resolvedPromise) {
      return resolvedPromise.then(fn);
    }
    return fallbackMethod(fn);
  }
  function queueStateChanges(component, newState, callback, force) {
    if (isFunction(newState)) {
      newState = newState(component.state, component.props, component.context);
    }
    var pending = component.$PS;
    if (isNullOrUndef(pending)) {
      component.$PS = newState;
    } else {
      for (var stateKey in newState) {
        pending[stateKey] = newState[stateKey];
      }
    }
    if (!component.$PSS && !component.$BR) {
      if (!component.$UPD) {
        component.$PSS = true;
        component.$UPD = true;
        applyState(component, force, callback);
        component.$UPD = false;
      } else {
        // Async
        var queue = component.$QU;
        if (isNull$2(queue)) {
          queue = component.$QU = [];
          nextTick(promiseCallback(component, queue));
        }
        if (isFunction(callback)) {
          queue.push(callback);
        }
      }
    } else {
      component.$PSS = true;
      if (component.$BR && isFunction(callback)) {
        LIFECYCLE.push(callback.bind(component));
      }
    }
  }
  function promiseCallback(component, queue) {
    return function () {
      component.$QU = null;
      component.$UPD = true;
      applyState(component, false, function () {
        for (var i = 0, len = queue.length; i < len; i++) {
          queue[i].call(component);
        }
      });
      component.$UPD = false;
    };
  }
  function applyState(component, force, callback) {
    if (component.$UN) {
      return;
    }
    if (force || !component.$BR) {
      component.$PSS = false;
      var pendingState = component.$PS;
      var prevState = component.state;
      var nextState = combineFrom(prevState, pendingState);
      var props = component.props;
      var context = component.context;
      component.$PS = null;
      var vNode = component.$V;
      var lastInput = component.$LI;
      var parentDom = lastInput.dom && lastInput.dom.parentNode;
      updateClassComponent(component, nextState, vNode, props, parentDom, context, (vNode.flags & 32 /* SvgElement */) > 0, force, true);
      if (component.$UN) {
        return;
      }
      if ((component.$LI.flags & 1024 /* Portal */) === 0) {
        var dom = component.$LI.dom;
        while (!isNull$2(vNode = vNode.parentVNode)) {
          if ((vNode.flags & 14 /* Component */) > 0) {
            vNode.dom = dom;
          }
        }
      }
      if (LIFECYCLE.length > 0) {
        callAll(LIFECYCLE);
      }
    } else {
      component.state = component.$PS;
      component.$PS = null;
    }
    if (isFunction(callback)) {
      callback.call(component);
    }
  }
  var Component = function Component(props, context) {
    this.state = null;
    // Internal properties
    this.$BR = false; // BLOCK RENDER
    this.$BS = true; // BLOCK STATE
    this.$PSS = false; // PENDING SET STATE
    this.$PS = null; // PENDING STATE (PARTIAL or FULL)
    this.$LI = null; // LAST INPUT
    this.$V = null; // VNODE
    this.$UN = false; // UNMOUNTED
    this.$CX = null; // CHILDCONTEXT
    this.$UPD = true; // UPDATING
    this.$QU = null; // QUEUE
    /** @type {object} */
    this.props = props || EMPTY_OBJ;
    /** @type {object} */
    this.context = context || EMPTY_OBJ; // context should not be mutable
  };

  Component.prototype.forceUpdate = function forceUpdate(callback) {
    if (this.$UN) {
      return;
    }
    // Do not allow double render during force update
    queueStateChanges(this, {}, callback, true);
  };
  Component.prototype.setState = function setState(newState, callback) {
    if (this.$UN) {
      return;
    }
    if (!this.$BS) {
      queueStateChanges(this, newState, callback, false);
    } else {
      // Development warning
      {
        throwError('cannot update state via setState() in componentWillUpdate() or constructor.');
      }
      return;
    }
  };
  // tslint:disable-next-line:no-empty
  Component.prototype.render = function render(_nextProps, _nextState, _nextContext) {};
  {
    /* tslint:disable-next-line:no-empty */
    var testFunc = function testFn() {};
    /* tslint:disable-next-line*/
    console.info('Inferno is in development mode.');
    if ((testFunc.name || testFunc.toString()).indexOf('testFn') === -1) {
      warning("It looks like you're using a minified copy of the development build " + 'of Inferno. When deploying Inferno apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See http://infernojs.org for more details.');
    }
  }

  var TableComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(TableComponent, _Component);
    var _super = _createSuper(TableComponent);
    function TableComponent(props) {
      var _this;
      _classCallCheck(this, TableComponent);
      _this = _super.call(this, props);
      var injector = _this._injector = props.injector;
      _this._sheet = injector.get('sheet');
      _this._changeSupport = injector.get('changeSupport');
      _this._components = injector.get('components');
      _this._eventBus = injector.get('eventBus');
      var throttle = injector.get('throttle');
      _this.onElementsChanged = _this.onElementsChanged.bind(_assertThisInitialized(_this));
      _this.onScroll = throttle(_this.onScroll.bind(_assertThisInitialized(_this)));
      return _this;
    }
    _createClass(TableComponent, [{
      key: "onElementsChanged",
      value: function onElementsChanged() {
        this.forceUpdate();
      }
    }, {
      key: "onScroll",
      value: function onScroll() {
        this._eventBus.fire('sheet.scroll');
      }
    }, {
      key: "getChildContext",
      value: function getChildContext() {
        return {
          changeSupport: this._changeSupport,
          components: this._components,
          injector: this._injector
        };
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        var _this$_sheet$getRoot = this._sheet.getRoot(),
          id = _this$_sheet$getRoot.id;
        this._changeSupport.onElementsChanged(id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var _this$_sheet$getRoot2 = this._sheet.getRoot(),
          id = _this$_sheet$getRoot2.id;
        this._changeSupport.offElementsChanged(id, this.onElementsChanged);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$_sheet$getRoot3 = this._sheet.getRoot(),
          rows = _this$_sheet$getRoot3.rows,
          cols = _this$_sheet$getRoot3.cols;
        var beforeTableComponents = this._components.getComponents('table.before');
        var afterTableComponents = this._components.getComponents('table.after');
        var Head = this._components.getComponent('table.head');
        var Body = this._components.getComponent('table.body');
        var Foot = this._components.getComponent('table.foot');
        return createVNode(1, "div", "tjs-container", [beforeTableComponents && beforeTableComponents.map(function (Component, index) {
          return createComponentVNode(2, Component, null, index);
        }), createVNode(1, "div", "tjs-table-container", createVNode(1, "table", "tjs-table", [Head && createComponentVNode(2, Head, {
          "rows": rows,
          "cols": cols
        }), Body && createComponentVNode(2, Body, {
          "rows": rows,
          "cols": cols
        }), Foot && createComponentVNode(2, Foot, {
          "rows": rows,
          "cols": cols
        })], 0), 2, {
          "onScroll": this.onScroll
        }), afterTableComponents && afterTableComponents.map(function (Component, index) {
          return createComponentVNode(2, Component, null, index);
        })], 0);
      }
    }]);
    return TableComponent;
  }(Component);

  var Renderer$1 = /*#__PURE__*/function () {
    function Renderer(changeSupport, components, config, eventBus, injector) {
      _classCallCheck(this, Renderer);
      var container = config.container;
      this._container = container;
      eventBus.on('root.added', function () {
        render(createComponentVNode(2, TableComponent, {
          "injector": injector
        }), container);
      });
      eventBus.on('root.remove', function () {
        render(null, container);
      });
    }
    _createClass(Renderer, [{
      key: "getContainer",
      value: function getContainer() {
        return this._container;
      }
    }]);
    return Renderer;
  }();
  Renderer$1.$inject = ['changeSupport', 'components', 'config.renderer', 'eventBus', 'injector'];

  var renderModule = {
    __init__: ['changeSupport', 'components', 'renderer'],
    changeSupport: ['type', ChangeSupport$1],
    components: ['type', Components$1],
    renderer: ['type', Renderer$1]
  };

  var Sheet = /*#__PURE__*/function () {
    function Sheet(elementRegistry, eventBus) {
      var _this = this;
      _classCallCheck(this, Sheet);
      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;
      this._root = null;
      eventBus.on('table.clear', function () {
        _this.setRoot(null);
      });
    }
    _createClass(Sheet, [{
      key: "setRoot",
      value: function setRoot(root) {
        if (this._root) {
          var oldRoot = this._root;
          this._eventBus.fire('root.remove', {
            root: oldRoot
          });
          this._root = null;
          this._eventBus.fire('root.removed', {
            root: oldRoot
          });
        }
        if (root) {
          this._eventBus.fire('root.add', {
            root: root
          });
        }
        this._root = root;
        if (root) {
          this._eventBus.fire('root.added', {
            root: root
          });
        }
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        if (!this._root) {
          this.setRoot({
            id: '__implicitroot',
            rows: [],
            cols: []
          });
        }
        return this._root;
      }
      /**
       * Add row to sheet.
       *
       * @param {Object} row - Row.
       */
    }, {
      key: "addRow",
      value: function addRow(row, index) {
        var _this2 = this;
        var root = this.getRoot();
        if (root.cols.length != row.cells.length) {
          throw new Error('number of cells is not equal to number of cols');
        }
        if (typeof index === 'undefined') {
          index = root.rows.length;
        }
        addAtIndex(index, root.rows, row);
        row.root = root;
        this._elementRegistry.add(row);
        row.cells.forEach(function (cell, idx) {
          _this2._elementRegistry.add(cell);
          cell.row = row;
          cell.col = root.cols[idx];
          addAtIndex(index, root.cols[idx].cells, cell);
        });
        this._eventBus.fire('row.add', {
          row: row
        });
        return row;
      }
      /**
       * Remove row from sheet.
       *
       * @param {Object|string} row - Row or row ID.
       */
    }, {
      key: "removeRow",
      value: function removeRow(row) {
        var _this3 = this;
        var root = this.getRoot();
        if (typeof row === 'string') {
          row = this._elementRegistry.get(row);
        }
        var index = root.rows.indexOf(row);
        if (index === -1) {
          return;
        }
        removeAtIndex(index, root.rows);
        row.root = undefined;
        this._elementRegistry.remove(row);
        row.cells.forEach(function (cell, idx) {
          _this3._elementRegistry.remove(cell);
          cell.col = undefined;
          removeAtIndex(index, root.cols[idx].cells);
        });
        this._eventBus.fire('row.remove', {
          row: row
        });
      }
      /**
       * Add col to sheet.
       *
       * @param {Object} col
       * @param {Number} [index]
       */
    }, {
      key: "addCol",
      value: function addCol(col, index) {
        var _this4 = this;
        var root = this.getRoot();
        this._elementRegistry.add(col);
        if (root.rows.length != col.cells.length) {
          throw new Error('number of cells is not equal to number of rows');
        }
        if (typeof index === 'undefined') {
          index = root.cols.length;
        }
        addAtIndex(index, root.cols, col);
        col.root = root;
        col.cells.forEach(function (cell, idx) {
          _this4._elementRegistry.add(cell);
          cell.col = col;
          cell.row = root.rows[idx];
          addAtIndex(index, root.rows[idx].cells, cell);
        });
        this._eventBus.fire('col.add', {
          col: col
        });
        return col;
      }
      /**
       * Remove col from sheet.
       *
       * @param {Object|string} col - Col or col ID.
       */
    }, {
      key: "removeCol",
      value: function removeCol(col) {
        var _this5 = this;
        var root = this.getRoot();
        if (typeof col === 'string') {
          col = this._elementRegistry.get(col);
        }
        var index = root.cols.indexOf(col);
        if (index === -1) {
          return;
        }
        removeAtIndex(index, root.cols);
        col.root = undefined;
        this._elementRegistry.remove(col);
        col.cells.forEach(function (cell, idx) {
          _this5._elementRegistry.remove(cell);
          cell.row = undefined;
          removeAtIndex(index, root.rows[idx].cells);
        });
        this._eventBus.fire('col.remove', {
          col: col
        });
      }
    }, {
      key: "resized",
      value: function resized() {
        this._eventBus.fire('sheet.resized');
      }
    }]);
    return Sheet;
  }();
  Sheet.$inject = ['elementRegistry', 'eventBus']; // helpers /////////////

  /**
   * Insert value
   *
   * @param {number} index - Index to insert value at.
   * @param {Array} array - Array to insert value into.
   * @param {*} value - Value to insert.
   */

  function addAtIndex(index, array, value) {
    return array.splice(index, 0, value);
  }
  /**
   *
   * @param {number} index - Index to remove.
   * @param {Array} array - Array to remove from.
   */

  function removeAtIndex(index, array) {
    return array.splice(index, 1);
  }

  /**
   * A factory to create a configurable throttler.
   *
   * @param {number|boolean} [config=true]
   */

  function ThrottleFactory() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var timeout = typeof config === 'number' ? config : config ? 300 : 0;
    if (timeout) {
      return function (fn) {
        return throttle(fn, timeout);
      };
    } else {
      return function (fn) {
        return fn;
      };
    }
  }
  ThrottleFactory.$inject = ['config.throttle'];

  var core$1 = {
    __depends__: [renderModule],
    __init__: ['elementFactory', 'sheet'],
    elementFactory: ['type', ElementFactory$1],
    elementRegistry: ['type', ElementRegistry$1],
    eventBus: ['type', EventBus],
    sheet: ['type', Sheet],
    throttle: ['factory', ThrottleFactory]
  };

  var _excluded$7 = ["modules"];
  var Table = /*#__PURE__*/function () {
    function Table() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Table);
      var injector = options.injector;
      if (!injector) {
        var _this$_init = this._init(options),
          modules = _this$_init.modules,
          config = _this$_init.config;
        injector = createInjector$1(config, modules);
      }
      this.get = injector.get;
      this.invoke = injector.invoke;
      this.get('eventBus').fire('table.init');
      this.get('eventBus').fire('diagram.init');
    }
    /**
     * Intialize table and return modules and config used for creation.
     *
     * @param  {Object} options
     *
     * @return {Object} { modules=[], config }
     */
    _createClass(Table, [{
      key: "_init",
      value: function _init(options) {
        var modules = options.modules,
          config = _objectWithoutProperties$7(options, _excluded$7);
        return {
          modules: modules,
          config: config
        };
      }
      /**
       * Destroys the table. This results in removing the attachment from the container.
       */
    }, {
      key: "destroy",
      value: function destroy() {
        var eventBus = this.get('eventBus');
        eventBus.fire('table.destroy');
        eventBus.fire('diagram.destroy');
      }
      /**
       * Clears the table. Should be used to reset the state of any stateful services.
       */
    }, {
      key: "clear",
      value: function clear() {
        var eventBus = this.get('eventBus');
        eventBus.fire('table.clear');
        eventBus.fire('diagram.clear');
      }
    }]);
    return Table;
  }();
  function createInjector$1(config, modules) {
    var bootstrapModules = [{
      config: ['value', config]
    }, core$1].concat(modules || []);
    var injector = new Injector(bootstrapModules);
    injector.init();
    return injector;
  }

  function elementToString(element) {
    if (!element) {
      return '<null>';
    }
    var id = element.id ? " id=\"".concat(element.id, "\"") : '';
    return "<".concat(element.$type).concat(id, " />");
  }

  function TableTreeWalker(handler, options) {
    function visit(element, ctx, definitions) {
      var gfx = element.gfx;

      // avoid multiple rendering of elements
      if (gfx) {
        throw new Error("already rendered ".concat(elementToString(element)));
      }

      // call handler
      return handler.element(element, ctx, definitions);
    }
    function visitTable(element) {
      return handler.table(element);
    }

    // Semantic handling //////////////////////

    function handleDecision(decision) {
      if (!decision.id) {
        decision.id = 'decision';
      }
      var table = decision.decisionLogic;
      if (table) {
        if (!table.output) {
          throw new Error("missing output for ".concat(elementToString(table)));
        }
        var ctx = visitTable(table);
        if (table.input) {
          handleClauses(table.input, ctx, table);
        }
        handleClauses(table.output, ctx, table);

        // if any input or output clauses (columns) were added
        // make sure that for each rule the according input/output entry is created
        handleRules(table.rule, ctx, table);
      } else {
        throw new Error("no table for ".concat(elementToString(decision)));
      }
    }
    function handleClauses(clauses, context, definitions) {
      forEach$3(clauses, function (e) {
        visit(e, context, definitions);
      });
    }
    function handleRules(rules, context, definitions) {
      forEach$3(rules, function (e) {
        visit(e, context, definitions);
        handleEntry(e.inputEntry, e);
        handleEntry(e.outputEntry, e);
      });
    }
    function handleEntry(entry, context, definitions) {
      forEach$3(entry, function (e) {
        visit(e, context, definitions);
      });
    }

    // API //////////////////////

    return {
      handleDecision: handleDecision
    };
  }

  /**
   * Import the decision table into a table.
   *
   * Errors and warnings are reported through the specified callback.
   *
   * @param  {decisionTable} decisionTable instance of DecisionTable
   * @param  {ModdleElement} decision moddle element
   * @param  {Function} done
   *         the callback, invoked with (err, [ warning ]) once the import is done
   */
  function importDecision(decisionTable, decision, done) {
    var importer = decisionTable.get('tableImporter'),
      eventBus = decisionTable.get('eventBus'),
      sheet = decisionTable.get('sheet');
    decisionTable.get('modeling', false);
    var error,
      warnings = [];
    function render(decision) {
      var visitor = {
        create: function create(type, parent, clause, rule) {
          return importer.create(type, parent, clause, rule);
        },
        table: function table(element) {
          return importer.add(element);
        },
        element: function element(_element, parentShape, definitions) {
          return importer.add(_element, parentShape, definitions);
        },
        error: function error(message, context) {
          warnings.push({
            message: message,
            context: context
          });
        }
      };
      var walker = new TableTreeWalker(visitor);

      // import
      walker.handleDecision(decision);
    }
    eventBus.fire('import.render.start', {
      decision: decision
    });
    try {
      render(decision);
    } catch (e) {
      error = e;
    }
    eventBus.fire('import.render.complete', {
      error: error,
      warnings: warnings
    });
    eventBus.fire('elements.changed', {
      elements: [sheet.getRoot()]
    });
    done(error, warnings);
  }

  function newSet() {
    return {
      elements: [],
      index: {}
    };
  }
  function add$1(set, element) {
    var elements = set.elements,
      index = set.index;
    if (index[element]) {
      return set;
    } else {
      return {
        elements: [].concat(_toConsumableArray(elements), [element]),
        index: _objectSpread2(_objectSpread2({}, index), {}, _defineProperty$M({}, element, true))
      };
    }
  }
  function join(set, separator) {
    return set.elements.join(separator);
  }
  function classNames() {
    var set = newSet();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    args.forEach(function (item) {
      var type = _typeof(item);
      if (type === 'string' && item.length > 0) {
        set = add$1(set, item);
      } else if (type === 'object' && item !== null) {
        Object.keys(item).forEach(function (key) {
          var value = item[key];
          if (value) {
            set = add$1(set, key);
          }
        });
      }
    });
    return join(set, ' ');
  }

  function inject(component) {
    var Type = component.constructor;
    return injectType(Type, component);
  }
  function injectType(Type, component) {
    var annotation = Type.$inject;
    if (!annotation) {
      return;
    }
    var injector = component.context.injector;
    var setupFn = [].concat(_toConsumableArray(annotation), [function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      for (var idx in args) {
        var name = annotation[idx];
        var value = args[idx];
        component[name] = value;
      }
    }]);
    injector.invoke(setupFn);
  }

  /**
   * Composes a number of functions.
   *
   * All receive the the same arguments; the chain is interruped as soon
   * as one function returns a value.
   *
   * @param  {Object}    self
   * @param  {...Function} fns
   *
   * @return {Object}
   */
  function compose(self) {
    for (var _len = arguments.length, fns = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      fns[_key - 1] = arguments[_key];
    }
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var result;
      fns.forEach(function (fn) {
        result = fn.call.apply(fn, [self].concat(args));
        if (typeof result !== 'undefined') {
          return false;
        }
      });
      return result;
    }.bind(self);
  }

  /**
   * A Component and injection aware mixin mechanism.
   *
   * @param {Component} component
   * @param {Object|Function} mixinDef
   */

  function mixin(component, mixinDef) {
    Object.keys(mixinDef).forEach(function (key) {
      if (key === '$inject' || key === '__init') {
        return;
      }
      var mixinFn = mixinDef[key];
      if (key === 'constructor') {
        mixinFn.call(component, component.props, component.context);
      }
      var componentFn = component[key];
      if (typeof componentFn !== 'undefined') {
        if (typeof componentFn !== 'function') {
          throw new Error("failed to mixin <".concat(key, ">: cannot combine with non-fn component value"));
        }
        component[key] = compose(component, componentFn, mixinFn);
      } else {
        component[key] = mixinFn.bind(component);
      }
    });
    if ('$inject' in mixinDef) {
      injectType(mixinDef, component);
    } // call initializer

    if ('__init' in mixinDef) {
      mixinDef.__init.call(component, component.props, component.context);
    }
  }

  /**
   * A mixin to make an element _selection aware_.
   */

  var SelectionAware = {
    getSelectionClasses: function getSelectionClasses() {
      var _this$state = this.state,
        selected = _this$state.selected,
        selectedSecondary = _this$state.selectedSecondary,
        focussed = _this$state.focussed;
      return classNames({
        'selected': selected,
        'selected-secondary': selectedSecondary,
        'focussed': focussed
      });
    },
    selectionChanged: function selectionChanged(newSelection) {
      // newSelection = { selected, selectedSecondary, focussed }
      this.setState(newSelection);
    },
    componentWillUpdate: function componentWillUpdate(newProps) {
      if (newProps.elementId !== this.props.elementId) {
        this.updateSelectionSubscription(false);
      }
    },
    componentDidUpdate: function componentDidUpdate(oldProps) {
      if (oldProps.elementId !== this.props.elementId) {
        this.updateSelectionSubscription(true);
      }
    },
    componentDidMount: function componentDidMount() {
      this.updateSelectionSubscription(true);
    },
    componentWillUnmount: function componentWillUnmount() {
      this.updateSelectionSubscription(false);
    },
    updateSelectionSubscription: function updateSelectionSubscription(enable) {
      var elementId = this.props.elementId;
      if (!elementId) {
        return;
      }
      if (elementId) {
        this.eventBus[enable ? 'on' : 'off']("selection.".concat(elementId, ".changed"), this.selectionChanged);
      }
    }
  };
  var SelectionAware$1 = SelectionAware;
  SelectionAware.$inject = ['eventBus'];

  var _excluded$6 = ["className", "elementId", "coords"];
  var BaseCell = /*#__PURE__*/function (_Component) {
    _inherits$1(BaseCell, _Component);
    var _super = _createSuper(BaseCell);
    function BaseCell(props, context) {
      var _this;
      _classCallCheck(this, BaseCell);
      _this = _super.call(this, props, context);
      mixin(_assertThisInitialized(_this), SelectionAware$1);
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(BaseCell, [{
      key: "getRenderProps",
      value: function getRenderProps() {
        var _this$props = this.props,
          className = _this$props.className,
          elementId = _this$props.elementId,
          coords = _this$props.coords,
          props = _objectWithoutProperties$7(_this$props, _excluded$6);
        for (var _len = arguments.length, cls = new Array(_len), _key = 0; _key < _len; _key++) {
          cls[_key] = arguments[_key];
        }
        var baseProps = {
          className: classNames.apply(void 0, cls.concat([this.getSelectionClasses(), className]))
        };
        if (elementId) {
          baseProps['data-element-id'] = elementId;
        }
        if (coords) {
          baseProps['data-coords'] = coords;
        }
        return _objectSpread2(_objectSpread2({}, baseProps), props);
      }
    }]);
    return BaseCell;
  }(Component);

  var HeaderCell = /*#__PURE__*/function (_BaseCell) {
    _inherits$1(HeaderCell, _BaseCell);
    var _super = _createSuper(HeaderCell);
    function HeaderCell(props, context) {
      var _this;
      _classCallCheck(this, HeaderCell);
      _this = _super.call(this, props, context);
      _this.state = {};
      return _this;
    }
    _createClass(HeaderCell, [{
      key: "render",
      value: function render() {
        var children = this.props.children;
        var props = this.getRenderProps('cell');
        return normalizeProps(createVNode(1, "td", null, children, 0, _objectSpread2({}, props)));
      }
    }]);
    return HeaderCell;
  }(BaseCell);

  var _excluded$5 = ["type", "context"],
    _excluded2 = ["type", "context"];
  function ownKeys$9(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$9(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) {
        _defineProperty$I(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$I(obj, key, value) {
    key = _toPropertyKey$F(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$F(arg) {
    var key = _toPrimitive$F(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$F(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _objectWithoutProperties$5(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$5(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$5(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  /**
   * A simple slot extension, built upon the components service.
   *
   * @type {Object}
   */
  var ComponentWithSlots = {
    slotFill: function slotFill(slotProps, DefaultFill) {
      var type = slotProps.type,
        context = slotProps.context,
        props = _objectWithoutProperties$5(slotProps, _excluded$5);
      var Fill = this.components.getComponent(type, context) || DefaultFill;
      if (Fill) {
        return normalizeProps(createComponentVNode(2, Fill, _objectSpread$9(_objectSpread$9({}, context), props)));
      }
      return null;
    },
    slotFills: function slotFills(slotProps) {
      var type = slotProps.type,
        context = slotProps.context,
        props = _objectWithoutProperties$5(slotProps, _excluded2);
      var fills = this.components.getComponents(type, context);
      return fills.map(function (Fill) {
        return normalizeProps(createComponentVNode(2, Fill, _objectSpread$9(_objectSpread$9({}, context), props)));
      });
    }
  };
  ComponentWithSlots.$inject = ['components'];

  function _defineProperty$H(obj, key, value) {
    key = _toPropertyKey$E(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$E(arg) {
    var key = _toPrimitive$E(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$E(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var MIN_WIDTH = 400;
  var AnnotationHeader = /*#__PURE__*/function (_Component) {
    _inherits$1(AnnotationHeader, _Component);
    var _super = _createSuper(AnnotationHeader);
    function AnnotationHeader(props, context) {
      var _this;
      _classCallCheck(this, AnnotationHeader);
      _this = _super.call(this, props, context);
      _defineProperty$H(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      mixin(_assertThisInitialized(_this), ComponentWithSlots);
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(AnnotationHeader, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.changeSupport.onElementsChanged(this.getRoot(), this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.changeSupport.offElementsChanged(this.getRoot(), this.onElementsChanged);
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this.sheet.getRoot();
      }
    }, {
      key: "render",
      value: function render() {
        var decisionTable = this.getRoot();
        var annotationsWidth = decisionTable.businessObject.get('annotationsWidth');
        var width = (annotationsWidth || MIN_WIDTH) + 'px';
        return createVNode(1, "th", "annotation header", [this.slotFills({
          type: 'cell-inner',
          context: {
            cellType: 'annotations',
            col: this.sheet.getRoot(),
            minWidth: MIN_WIDTH
          }
        }), this.translate('Annotations')], 0, {
          "style": {
            width: width
          }
        });
      }
    }]);
    return AnnotationHeader;
  }(Component);
  AnnotationHeader.$inject = ['changeSupport', 'sheet', 'translate'];

  function AnnotationCell(props) {
    var row = props.row;
    var _row$businessObject = row.businessObject,
      id = _row$businessObject.id,
      description = _row$businessObject.description;
    return createComponentVNode(2, HeaderCell, {
      "className": "annotation",
      "elementId": id,
      children: description || '-'
    });
  }

  function AnnotationsProvider(components) {
    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;
      if (cellType === 'after-label-cells') {
        return AnnotationHeader;
      } else if (cellType === 'after-rule-cells') {
        return AnnotationCell;
      }
    });
  }
  AnnotationsProvider.$inject = ['components'];

  var annotationsModule = {
    __init__: ['annotationsProvider'],
    annotationsProvider: ['type', AnnotationsProvider]
  };

  function elementData(semantic, attrs) {
    return assign$4({
      id: semantic.id,
      type: semantic.$type,
      businessObject: semantic
    }, attrs);
  }
  var TableImporter = /*#__PURE__*/function () {
    function TableImporter(elementFactory, eventBus, sheet) {
      _classCallCheck(this, TableImporter);
      this._elementFactory = elementFactory;
      this._eventBus = eventBus;
      this._sheet = sheet;
    }

    /**
     * Add DMN element.
     */
    _createClass(TableImporter, [{
      key: "add",
      value: function add(semantic) {
        var _this = this;
        var element;

        // decision table
        if (is$1(semantic, 'dmn:DecisionTable')) {
          element = this._elementFactory.createRoot(elementData(semantic));
          this._sheet.setRoot(element);
        }

        // input clause
        else if (is$1(semantic, 'dmn:InputClause')) {
          element = this._elementFactory.createCol(elementData(semantic));
          this._sheet.addCol(element);
        }

        // output clause
        else if (is$1(semantic, 'dmn:OutputClause')) {
          element = this._elementFactory.createCol(elementData(semantic));
          this._sheet.addCol(element);
        }

        // rule
        else if (is$1(semantic, 'dmn:DecisionRule')) {
          if (!semantic.inputEntry) {
            semantic.inputEntry = [];
          }
          if (!semantic.outputEntry) {
            semantic.outputEntry = [];
          }
          var cells = [].concat(_toConsumableArray(semantic.inputEntry), _toConsumableArray(semantic.outputEntry)).map(function (entry) {
            return _this._elementFactory.createCell(elementData(entry));
          });
          element = this._elementFactory.createRow(assign$4(elementData(semantic), {
            cells: cells
          }));
          this._sheet.addRow(element);
        }
        this._eventBus.fire('dmnElement.added', {
          element: element
        });
        return element;
      }
    }]);
    return TableImporter;
  }();
  TableImporter.$inject = ['elementFactory', 'eventBus', 'sheet'];

  var importModule = {
    __depends__: [TranslateModule],
    tableImporter: ['type', TableImporter]
  };

  var coreModule = {
    __depends__: [importModule, renderModule]
  };

  function _defineProperty$G(obj, key, value) {
    key = _toPropertyKey$D(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$D(arg) {
    var key = _toPrimitive$D(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$D(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var DecisionTableHead = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionTableHead, _Component);
    var _super = _createSuper(DecisionTableHead);
    function DecisionTableHead(props, context) {
      var _this;
      _classCallCheck(this, DecisionTableHead);
      _this = _super.call(this, props, context);
      _defineProperty$G(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      mixin(_assertThisInitialized(_this), ComponentWithSlots);
      _this._sheet = context.injector.get('sheet');
      _this._changeSupport = context.changeSupport;
      return _this;
    }
    _createClass(DecisionTableHead, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var root = this._sheet.getRoot();
        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var root = this._sheet.getRoot();
        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var root = this._sheet.getRoot();
        if (!is$1(root, 'dmn:DMNElement')) {
          return null;
        }
        var businessObject = getBusinessObject(root);
        var inputs = businessObject.input,
          outputs = businessObject.output;
        return createVNode(1, "thead", null, createVNode(1, "tr", null, [createVNode(1, "th", "index-column"), this.slotFills({
          type: 'cell',
          context: {
            cellType: 'before-label-cells'
          }
        }), inputs && inputs.map(function (input, index) {
          var width = input.width || '192px';
          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'input-header',
              input: input,
              index: index,
              inputsLength: inputs.length,
              width: width
            },
            key: input.id
          }, DefaultInputHeaderCell);
        }), outputs.map(function (output, index) {
          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'output-header',
              output: output,
              index: index,
              outputsLength: outputs.length
            },
            key: output.id
          }, DefaultOutputHeaderCell);
        }), this.slotFills({
          type: 'cell',
          context: {
            cellType: 'after-label-cells'
          }
        })], 0), 2);
      }
    }]);
    return DecisionTableHead;
  }(Component); // default components ///////////////////////
  function DefaultInputHeaderCell(props, context) {
    var input = props.input,
      className = props.className,
      index = props.index;
    var label = input.label,
      inputExpression = input.inputExpression,
      inputValues = input.inputValues;
    var translate = context.injector.get('translate');
    var actualClassName = (className || '') + ' input-cell';
    return createVNode(1, "th", actualClassName, [createVNode(1, "div", "clause", index === 0 ? translate('When') : translate('And'), 0), label ? createVNode(1, "div", "input-label", label, 0, {
      "title": translate('Input label: ') + label
    }) : createVNode(1, "div", "input-expression", inputExpression.text, 0, {
      "title": translate('Input expression: ') + inputExpression.text
    }), createVNode(1, "div", "input-variable", inputValues && inputValues.text || inputExpression.typeRef, 0, {
      "title": inputValues && inputValues.text ? translate('Input values') : translate('Input type')
    })], 0, {
      "data-col-id": input.id
    }, input.id);
  }
  function DefaultOutputHeaderCell(props, context) {
    var output = props.output,
      className = props.className,
      index = props.index;
    var label = output.label,
      name = output.name,
      outputValues = output.outputValues,
      typeRef = output.typeRef;
    var translate = context.injector.get('translate');
    var actualClassName = (className || '') + ' output-cell';
    return createVNode(1, "th", actualClassName, [createVNode(1, "div", "clause", index === 0 ? translate('Then') : translate('And'), 0), label ? createVNode(1, "div", "output-label", label, 0, {
      "title": translate('Output label')
    }) : createVNode(1, "div", "output-name", name, 0, {
      "title": translate('Output name')
    }), createVNode(1, "div", "output-variable", outputValues && outputValues.text || typeRef, 0, {
      "title": outputValues && outputValues.text ? translate('Output values') : translate('Output type')
    })], 0, null, output.id);
  }

  function DecisionTableHeadProvider(components) {
    components.onGetComponent('table.head', function () {
      return DecisionTableHead;
    });
  }
  DecisionTableHeadProvider.$inject = ['components'];

  var decisionTableHeadModule = {
    __init__: ['decisionTableHeadProvider'],
    decisionTableHeadProvider: ['type', DecisionTableHeadProvider]
  };

  var DecisionTablePropertiesComponent$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionTablePropertiesComponent, _Component);
    var _super = _createSuper(DecisionTablePropertiesComponent);
    function DecisionTablePropertiesComponent(props, context) {
      var _this;
      _classCallCheck(this, DecisionTablePropertiesComponent);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(DecisionTablePropertiesComponent, [{
      key: "render",
      value: function render() {
        var root = this.sheet.getRoot();
        if (!is$1(root, 'dmn:DMNElement')) {
          return null;
        }
        var name = root.businessObject.$parent.name;
        var HitPolicy = this.components.getComponent('hit-policy') || NullComponent$1;
        return createVNode(1, "div", "decision-table-properties", [createVNode(1, "div", "decision-table-name", name, 0, {
          "title": this._translate('Decision name: ') + name
        }), createVNode(1, "div", "decision-table-header-separator"), createComponentVNode(2, HitPolicy)], 4);
      }
    }]);
    return DecisionTablePropertiesComponent;
  }(Component);
  DecisionTablePropertiesComponent$1.$inject = ['sheet', 'components'];
  function NullComponent$1() {
    return null;
  }

  var LOW_PRIORITY$8 = 500;
  var DecisionTableProperties$1 = /*#__PURE__*/_createClass(function DecisionTableProperties(components) {
    _classCallCheck(this, DecisionTableProperties);
    components.onGetComponent('table.before', LOW_PRIORITY$8, function () {
      return DecisionTablePropertiesComponent$1;
    });
  });
  DecisionTableProperties$1.$inject = ['components'];

  var decisionTablePropertiesModule = {
    __init__: ['decisionTableProperties'],
    decisionTableProperties: ['type', DecisionTableProperties$1]
  };

  var DecisionRulesIndexCellComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionRulesIndexCellComponent, _Component);
    var _super = _createSuper(DecisionRulesIndexCellComponent);
    function DecisionRulesIndexCellComponent() {
      _classCallCheck(this, DecisionRulesIndexCellComponent);
      return _super.apply(this, arguments);
    }
    _createClass(DecisionRulesIndexCellComponent, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
          row = _this$props.row,
          rowIndex = _this$props.rowIndex;
        var components = this.context.components;
        var innerComponents = components.getComponents('cell-inner', {
          cellType: 'rule-index',
          row: row,
          rowIndex: rowIndex
        });
        return createVNode(1, "td", "rule-index", [innerComponents && innerComponents.map(function (InnerComponent) {
          return createComponentVNode(2, InnerComponent, {
            "row": row,
            "rowIndex": rowIndex
          });
        }), rowIndex + 1], 0, {
          "data-element-id": row.id,
          "data-row-id": row.id
        });
      }
    }]);
    return DecisionRulesIndexCellComponent;
  }(Component);

  var DecisionRuleIndices = /*#__PURE__*/_createClass(function DecisionRuleIndices(components) {
    _classCallCheck(this, DecisionRuleIndices);
    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;
      if (cellType === 'before-rule-cells') {
        return DecisionRulesIndexCellComponent;
      }
    });
  });
  DecisionRuleIndices.$inject = ['components'];

  var decisionRuleIndicesModule = {
    __init__: ['decisionRuleIndices'],
    decisionRuleIndices: ['type', DecisionRuleIndices]
  };

  var EXPRESSION_LANGUAGE_OPTIONS = [{
    label: 'FEEL',
    value: 'feel'
  }];

  /**
   * @typedef ExpressionLanguageDescriptor
   * @property {string} value - value inserted into XML
   * @property {string} label - human-readable label
   */

  /**
   * Provide options and defaults of expression languages via config.
   *
   * @example
   *
   * // there will be two languages available with FEEL as default
   * const editor = new DmnJS({
   *   common: {
   *     expressionLanguages: {
   *       options: [{
   *         value: 'feel',
   *         label: 'FEEL'
   *       }, {
   *         value: 'juel',
   *         label: 'JUEL'
   *       }],
   *       defaults: {
   *         editor: 'feel'
   *       }
   *     }
   *   }
   * })
   */
  var ExpressionLanguages = /*#__PURE__*/function () {
    function ExpressionLanguages(injector) {
      _classCallCheck(this, ExpressionLanguages);
      this._injector = injector;
      var config = injector.get('config.expressionLanguages') || {};
      this._config = {
        options: EXPRESSION_LANGUAGE_OPTIONS,
        defaults: {
          editor: 'feel'
        }
      };

      // first assign the list of languages as it might be required for the legacy defaults
      if (config.options) {
        this._config.options = config.options;
      }
      var legacyDefaults = this._getLegacyDefaults();
      assign$4(this._config.defaults, legacyDefaults, config.defaults);
    }

    /**
     * Get default expression language for a component or the editor if `componentName`
     * is not provided.
     *
     * @param {string} [componentName]
     * @returns {ExpressionLanguageDescriptor}
     */
    _createClass(ExpressionLanguages, [{
      key: "getDefault",
      value: function getDefault(componentName) {
        var defaults = this._config.defaults;
        var defaultFromConfig = defaults[componentName] || defaults.editor;
        return this._getLanguageByValue(defaultFromConfig) || this.getAll()[0];
      }

      /**
       * Get label for provided expression language.
       *
       * @param {string} expressionLanguageValue - value from XML
       * @returns {string}
       */
    }, {
      key: "getLabel",
      value: function getLabel(expressionLanguageValue) {
        var langauge = this._getLanguageByValue(expressionLanguageValue);
        return langauge ? langauge.label : expressionLanguageValue;
      }

      /**
       * Get list of configured expression languages.
       *
       * @returns {ExpressionLanguageDescriptor[]}
       */
    }, {
      key: "getAll",
      value: function getAll() {
        return this._config.options;
      }
    }, {
      key: "_getLegacyDefaults",
      value: function _getLegacyDefaults() {
        var defaults = {},
          injector = this._injector;
        var inputCellValue = injector.get('config.defaultInputExpressionLanguage');
        var outputCellValue = injector.get('config.defaultOutputExpressionLanguage');
        if (inputCellValue) {
          defaults.inputCell = inputCellValue;
        }
        if (outputCellValue) {
          defaults.outputCell = outputCellValue;
        }
        return defaults;
      }
    }, {
      key: "_getLanguageByValue",
      value: function _getLanguageByValue(value) {
        return find$2(this.getAll(), function (language) {
          return value === language.value;
        });
      }
    }]);
    return ExpressionLanguages;
  }();
  ExpressionLanguages.$inject = ['injector'];

  var ExpressionLanguagesModule = {
    __init__: ['expressionLanguages'],
    expressionLanguages: ['type', ExpressionLanguages]
  };

  var DecisionRulesBodyComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionRulesBodyComponent, _Component);
    var _super = _createSuper(DecisionRulesBodyComponent);
    function DecisionRulesBodyComponent() {
      _classCallCheck(this, DecisionRulesBodyComponent);
      return _super.apply(this, arguments);
    }
    _createClass(DecisionRulesBodyComponent, [{
      key: "render",
      value: function render(_ref) {
        var rows = _ref.rows,
          cols = _ref.cols;
        var components = this.context.components;
        return createVNode(1, "tbody", null, rows.map(function (row, rowIndex) {
          var RowComponent = components.getComponent('row', {
            rowType: 'rule'
          });
          return RowComponent && createComponentVNode(2, RowComponent, {
            "row": row,
            "rowIndex": rowIndex,
            "cols": cols
          }, row.id);
        }), 0);
      }
    }]);
    return DecisionRulesBodyComponent;
  }(Component);

  var DecisionRulesRowComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionRulesRowComponent, _Component);
    var _super = _createSuper(DecisionRulesRowComponent);
    function DecisionRulesRowComponent(props, context) {
      var _this;
      _classCallCheck(this, DecisionRulesRowComponent);
      _this = _super.call(this, props, context);
      mixin(_assertThisInitialized(_this), ComponentWithSlots);
      return _this;
    }
    _createClass(DecisionRulesRowComponent, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$props = this.props,
          row = _this$props.row,
          rowIndex = _this$props.rowIndex,
          cols = _this$props.cols;
        var cells = row.cells;
        return createVNode(1, "tr", null, [this.slotFills({
          type: 'cell',
          context: {
            cellType: 'before-rule-cells',
            row: row,
            rowIndex: rowIndex
          }
        }), cells.map(function (cell, colIndex) {
          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'rule',
              cell: cell,
              rowIndex: rowIndex,
              colIndex: colIndex
            },
            key: cell.id,
            row: row,
            col: cols[colIndex]
          });
        }), this.slotFills({
          type: 'cell',
          context: {
            cellType: 'after-rule-cells',
            row: row,
            rowIndex: rowIndex
          }
        })], 0);
      }
    }]);
    return DecisionRulesRowComponent;
  }(Component);

  var DecisionRulesCellComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionRulesCellComponent, _Component);
    var _super = _createSuper(DecisionRulesCellComponent);
    function DecisionRulesCellComponent() {
      _classCallCheck(this, DecisionRulesCellComponent);
      return _super.apply(this, arguments);
    }
    _createClass(DecisionRulesCellComponent, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
          cell = _this$props.cell,
          row = _this$props.row,
          col = _this$props.col;
        if (is$1(cell, 'dmn:UnaryTests')) {
          return createComponentVNode(2, HeaderCell, {
            "className": "input-cell",
            "elementId": cell.id,
            "data-row-id": row.id,
            "data-col-id": col.id,
            children: cell.businessObject.text
          });
        } else {
          return createComponentVNode(2, HeaderCell, {
            "className": "output-cell",
            "elementId": cell.id,
            "data-row-id": row.id,
            "data-col-id": col.id,
            children: cell.businessObject.text
          });
        }
      }
    }]);
    return DecisionRulesCellComponent;
  }(Component);

  var Rules$3 = /*#__PURE__*/_createClass(function Rules(components) {
    _classCallCheck(this, Rules);
    components.onGetComponent('table.body', function () {
      return DecisionRulesBodyComponent;
    });
    components.onGetComponent('row', function (_ref) {
      var rowType = _ref.rowType;
      if (rowType === 'rule') {
        return DecisionRulesRowComponent;
      }
    });
    components.onGetComponent('cell', function (_ref2) {
      var cellType = _ref2.cellType;
      if (cellType === 'rule') {
        return DecisionRulesCellComponent;
      }
    });
  });
  Rules$3.$inject = ['components'];

  var Rules$2 = {
    __depends__: [ExpressionLanguagesModule],
    __init__: ['decisionRules'],
    decisionRules: ['type', Rules$3]
  };

  /* eslint max-len: 0 */
  var HIT_POLICIES = [{
    label: 'Unique',
    value: {
      hitPolicy: 'UNIQUE',
      aggregation: undefined
    },
    explanation: 'No overlap is possible and all rules are disjoint. Only a single rule can be matched'
  }, {
    label: 'First',
    value: {
      hitPolicy: 'FIRST',
      aggregation: undefined
    },
    explanation: 'Rules may overlap. The first matching rule will be chosen'
  }, {
    label: 'Priority',
    value: {
      hitPolicy: 'PRIORITY',
      aggregation: undefined
    },
    explanation: 'Rules may overlap. The one with the highest priority will be chosen'
  }, {
    label: 'Any',
    value: {
      hitPolicy: 'ANY',
      aggregation: undefined
    },
    explanation: 'Rules may overlap. Their output have to match'
  }, {
    label: 'Collect',
    value: {
      hitPolicy: 'COLLECT',
      aggregation: undefined
    },
    explanation: 'Collects the values of all matching rules'
  }, {
    label: 'Collect (Sum)',
    value: {
      hitPolicy: 'COLLECT',
      aggregation: 'SUM'
    },
    explanation: 'Collects the values of all matching rules and sums up to a single value'
  }, {
    label: 'Collect (Min)',
    value: {
      hitPolicy: 'COLLECT',
      aggregation: 'MIN'
    },
    explanation: 'Collects the values of all matching rules and uses the lowest value'
  }, {
    label: 'Collect (Max)',
    value: {
      hitPolicy: 'COLLECT',
      aggregation: 'MAX'
    },
    explanation: 'Collects the values of all matching rules and uses the highest value'
  }, {
    label: 'Collect (Count)',
    value: {
      hitPolicy: 'COLLECT',
      aggregation: 'COUNT'
    },
    explanation: 'Collects the values of all matching rules and counts the number of them'
  }, {
    label: 'Rule order',
    value: {
      hitPolicy: 'RULE ORDER',
      aggregation: undefined
    },
    explanation: 'Collects the values of all matching rules in rule order'
  }, {
    label: 'Output order',
    value: {
      hitPolicy: 'OUTPUT ORDER',
      aggregation: undefined
    },
    explanation: 'Collects the values of all matching rules in decreasing output priority order'
  }];

  var HitPolicy = /*#__PURE__*/function (_Component) {
    _inherits$1(HitPolicy, _Component);
    var _super = _createSuper(HitPolicy);
    function HitPolicy(props, context) {
      var _this;
      _classCallCheck(this, HitPolicy);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(HitPolicy, [{
      key: "getRoot",
      value: function getRoot() {
        return this.sheet.getRoot();
      }
    }, {
      key: "render",
      value: function render() {
        var root = this.getRoot(),
          businessObject = root.businessObject;
        var aggregation = businessObject.aggregation,
          hitPolicy = businessObject.hitPolicy;
        var hitPolicyEntry = find$2(HIT_POLICIES, function (entry) {
          return isEqualHitPolicy$1(entry.value, {
            aggregation: aggregation,
            hitPolicy: hitPolicy
          });
        });
        return createVNode(1, "div", "hit-policy header", [createVNode(1, "label", "dms-label", this._translate('Hit policy:'), 0), createVNode(1, "span", "hit-policy-value", this._translate(hitPolicyEntry.label), 0)], 4, {
          "title": this._translate(hitPolicyEntry.explanation)
        });
      }
    }]);
    return HitPolicy;
  }(Component);
  HitPolicy.$inject = ['sheet'];

  // helpers //////////////////////
  function isEqualHitPolicy$1(a, b) {
    return a.hitPolicy === b.hitPolicy && a.aggregation === b.aggregation;
  }

  function HitPolicyProvider(components) {
    components.onGetComponent('hit-policy', function () {
      return HitPolicy;
    });
  }
  HitPolicyProvider.$inject = ['components'];

  var hitPolicyModule = {
    __init__: ['hitPolicyProvider'],
    hitPolicyProvider: ['type', HitPolicyProvider]
  };

  function _defineProperty$F(obj, key, value) {
    key = _toPropertyKey$C(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$C(arg) {
    var key = _toPrimitive$C(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$C(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ViewDrdComponent$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(ViewDrdComponent, _Component);
    var _super = _createSuper(ViewDrdComponent);
    function ViewDrdComponent(props, context) {
      var _this;
      _classCallCheck(this, ViewDrdComponent);
      _this = _super.call(this, props, context);
      _defineProperty$F(_assertThisInitialized(_this), "onClick", function () {
        _this._eventBus.fire('showDrd');
      });
      var injector = context.injector;
      _this._translate = injector.get('translate');
      _this._eventBus = injector.get('eventBus');
      return _this;
    }
    _createClass(ViewDrdComponent, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        return createVNode(1, "div", "view-drd", createVNode(1, "button", "view-drd-button", this._translate('View DRD'), 0, {
          "type": "button",
          "onClick": this.onClick
        }), 2, null, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);
    return ViewDrdComponent;
  }(Component);

  var ViewDrd$1 = /*#__PURE__*/function () {
    function ViewDrd(components, eventBus, injector, sheet) {
      var _this = this;
      _classCallCheck(this, ViewDrd);
      this._injector = injector;
      this._sheet = sheet;
      components.onGetComponent('table.before', function () {
        if (_this.canViewDrd()) {
          return ViewDrdComponent$1;
        }
      });
      eventBus.on('showDrd', function () {
        var parent = injector.get('_parent', false);
        var root = sheet.getRoot();
        var definitions = getDefinitions(root);
        if (!definitions) {
          return;
        }

        // open definitions
        var view = parent.getView(definitions);
        parent.open(view);
      });
    }
    _createClass(ViewDrd, [{
      key: "canViewDrd",
      value: function canViewDrd() {
        var parent = this._injector.get('_parent', false);
        if (!parent) {
          return false;
        }
        var root = this._sheet.getRoot();
        var definitions = getDefinitions(root);
        return !!parent.getView(definitions);
      }
    }]);
    return ViewDrd;
  }();
  ViewDrd$1.$inject = ['components', 'eventBus', 'injector', 'sheet'];

  // helpers //////////////////////

  function getDefinitions(root) {
    var businessObject = root.businessObject;

    // root might not have business object
    if (!businessObject) {
      return;
    }
    var decision = businessObject.$parent;
    var definitions = decision.$parent;
    return definitions;
  }

  var viewDrdModule = {
    __init__: ['viewDrd'],
    viewDrd: ['type', ViewDrd$1]
  };

  function Logo() {
    return createVNode(32, "svg", null, [createVNode(1, "path", null, null, 1, {
      "fill": "#000000",
      "d": 'M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z'
    }), createVNode(1, "path", null, null, 1, {
      "fill": "#000000",
      "d": "M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"
    })], 4, {
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 14.02 5.57",
      "width": "53",
      "height": "21",
      "style": "vertical-align:middle"
    });
  }

  function _defineProperty$E(obj, key, value) {
    key = _toPropertyKey$B(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$B(arg) {
    var key = _toPrimitive$B(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$B(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var PoweredByLogoComponent$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(PoweredByLogoComponent, _Component);
    var _super = _createSuper(PoweredByLogoComponent);
    function PoweredByLogoComponent(props, context) {
      var _this;
      _classCallCheck(this, PoweredByLogoComponent);
      _this = _super.call(this, props, context);
      _defineProperty$E(_assertThisInitialized(_this), "onClick", function () {
        _this._eventBus.fire('poweredBy.show');
      });
      var injector = context.injector;
      _this._eventBus = injector.get('eventBus');
      return _this;
    }
    _createClass(PoweredByLogoComponent, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        return createVNode(1, "div", "powered-by", createVNode(1, "div", "powered-by__logo", createComponentVNode(2, Logo), 2, {
          "title": "Powered by bpmn.io",
          "onClick": this.onClick
        }, null, function (node) {
          return _this2.node = node;
        }), 2);
      }
    }]);
    return PoweredByLogoComponent;
  }(Component);

  var PoweredByOverlayComponent$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(PoweredByOverlayComponent, _Component);
    var _super = _createSuper(PoweredByOverlayComponent);
    function PoweredByOverlayComponent(props) {
      var _this;
      _classCallCheck(this, PoweredByOverlayComponent);
      _this = _super.call(this, props);
      _this.state = {
        show: false
      };
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      _this.onShow = _this.onShow.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(PoweredByOverlayComponent, [{
      key: "onClick",
      value: function onClick() {
        this.setState({
          show: false
        });
      }
    }, {
      key: "onShow",
      value: function onShow() {
        this.setState({
          show: true
        });
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        var eventBus = this._eventBus = this.context.injector.get('eventBus');
        eventBus.on('poweredBy.show', this.onShow);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._eventBus.off('poweredBy.show', this.onShow);
      }
    }, {
      key: "render",
      value: function render() {
        var show = this.state.show;
        return show && createVNode(1, "div", "powered-by-overlay", createVNode(1, "div", "powered-by-overlay-content", [createVNode(1, "a", "logo", createComponentVNode(2, Logo), 2, {
          "href": "https://bpmn.io",
          "target": "_blank",
          "rel": "noopener"
        }), createVNode(1, "span", null, [createTextVNode("Web-based tooling for BPMN, DMN and CMMN diagrams powered by "), createVNode(1, "a", null, createTextVNode("bpmn.io"), 2, {
          "href": "http://bpmn.io",
          "target": "_blank"
        }), createTextVNode(".")], 4)], 4, {
          "onClick": function onClick(e) {
            return e.stopPropagation();
          }
        }), 2, {
          "onClick": this.onClick
        });
      }
    }]);
    return PoweredByOverlayComponent;
  }(Component);

  var PoweredBy$1 = /*#__PURE__*/_createClass(function PoweredBy(components, eventBus) {
    _classCallCheck(this, PoweredBy);
    components.onGetComponent('table.before', function () {
      return PoweredByLogoComponent$1;
    });
    components.onGetComponent('table.before', function () {
      return PoweredByOverlayComponent$1;
    });
  });
  PoweredBy$1.$inject = ['components', 'eventBus'];

  var PoweredByModule$1 = {
    __init__: ['poweredBy'],
    poweredBy: ['type', PoweredBy$1]
  };

  var _excluded$4 = ["modules", "additionalModules"];
  function _objectWithoutProperties$4(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$4(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$4(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  /**
   * @typedef {import('dmn-js-shared/lib/base/View).OpenResult} OpenResult
   */

  /**
   * @typedef {import('dmn-js-shared/lib/base/View).OpenError} OpenError
   */
  var Viewer$2 = /*#__PURE__*/function (_Table) {
    _inherits$1(Viewer, _Table);
    var _super = _createSuper(Viewer);
    function Viewer() {
      var _this;
      _classCallCheck(this, Viewer);
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var container = Viewer._createContainer();
      _this = _super.call(this, assign$4(options, {
        renderer: {
          container: container
        }
      }));
      _this._container = container;
      return _this;
    }

    /**
     * Open diagram element.
     *
     * @param  {ModdleElement} decision
     * @returns {Promise} Resolves with {OpenResult} when successful
     * or rejects with {OpenError}
     */
    _createClass(Viewer, [{
      key: "open",
      value: function open(decision) {
        var self = this;
        return new Promise(function (resolve, reject) {
          var err;

          // use try/catch to not swallow synchronous exceptions
          // that may be raised during model parsing
          try {
            if (self._decision) {
              // clear existing rendered diagram
              self.clear();
            }

            // update decision
            self._decision = decision;

            // perform import
            return importDecision(self, decision, function (err, warnings) {
              if (err) {
                err.warnings = warnings || [];
                reject(err);
              } else {
                resolve({
                  warnings: warnings || []
                });
              }
            });
          } catch (e) {
            err = e;
          }

          // handle synchronously thrown exception
          if (err) {
            err.warnings = err.warnings || [];
            reject(err);
          } else {
            resolve({
              warnings: []
            });
          }
        });
      }

      /**
       * Initialize the table, returning { modules: [], config }.
       *
       * @param  {Object} options
       *
       * @return {Object} init config
       */
    }, {
      key: "_init",
      value: function _init(options) {
        var modules = options.modules,
          additionalModules = options.additionalModules,
          config = _objectWithoutProperties$4(options, _excluded$4);
        var baseModules = modules || this.getModules();
        var extraModules = additionalModules || [];
        var staticModules = [{
          decisionTable: ['value', this]
        }];
        var allModules = [PoweredByModule$1].concat(_toConsumableArray(baseModules), _toConsumableArray(extraModules), staticModules);
        return {
          modules: allModules,
          config: config
        };
      }

      /**
       * Register an event listener
       *
       * Remove a previously added listener via {@link #off(event, callback)}.
       *
       * @param {string} event
       * @param {number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */
    }, {
      key: "on",
      value: function on(event, priority, callback, target) {
        return this.get('eventBus').on(event, priority, callback, target);
      }

      /**
       * De-register an event listener
       *
       * @param {string} event
       * @param {Function} callback
       */
    }, {
      key: "off",
      value: function off(event, callback) {
        this.get('eventBus').off(event, callback);
      }

      /**
       * Emit an event on the underlying {@link EventBus}
       *
       * @param  {string} type
       * @param  {Object} event
       *
       * @return {Object} event processing result (if any)
       */
    }, {
      key: "_emit",
      value: function _emit(type, event) {
        return this.get('eventBus').fire(type, event);
      }

      /**
       * Attach viewer to given parent node.
       *
       * @param  {Element} parentNode
       */
    }, {
      key: "attachTo",
      value: function attachTo(parentNode) {
        if (!parentNode) {
          throw new Error('parentNode required');
        }

        // ensure we detach from the
        // previous, old parent
        this.detach();
        var container = this._container;
        parentNode.appendChild(container);
        this._emit('attach', {});
      }

      /**
       * Detach viewer from parent node, if attached.
       */
    }, {
      key: "detach",
      value: function detach() {
        var container = this._container,
          parentNode = container.parentNode;
        if (!parentNode) {
          return;
        }
        this._emit('detach', {});
        remove$4(container);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(Viewer.prototype), "destroy", this).call(this);
        this.detach();
      }
    }, {
      key: "getModules",
      value: function getModules() {
        return Viewer._getModules();
      }
    }], [{
      key: "_getModules",
      value: function _getModules() {
        return [annotationsModule, coreModule, TranslateModule, decisionTableHeadModule, decisionTablePropertiesModule, decisionRuleIndicesModule, Rules$2, hitPolicyModule, viewDrdModule];
      }
    }, {
      key: "_createContainer",
      value: function _createContainer() {
        return domify$1('<div class="dmn-decision-table-container"></div>');
      }
    }]);
    return Viewer;
  }(Table);

  function _defineProperty$D(obj, key, value) {
    key = _toPropertyKey$A(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$A(arg) {
    var key = _toPrimitive$A(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$A(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var AddRuleFootComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(AddRuleFootComponent, _Component);
    var _super = _createSuper(AddRuleFootComponent);
    function AddRuleFootComponent(props, context) {
      var _this;
      _classCallCheck(this, AddRuleFootComponent);
      _this = _super.call(this, props, context);
      _defineProperty$D(_assertThisInitialized(_this), "handleClick", function (e) {
        e.stopPropagation();
        _this.addRule(e.target.dataset.colIndex);
      });
      inject(_assertThisInitialized(_this));
      _this.addRule = _this.addRule.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(AddRuleFootComponent, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this._eventBus = this.context.injector.get('eventBus');
      }
    }, {
      key: "addRule",
      value: function addRule(colIndex) {
        this._eventBus.fire('addRule', {
          colIndex: colIndex
        });
      }
    }, {
      key: "render",
      value: function render() {
        var cols = this.props.cols;
        var cells = [createVNode(1, "td", "add-rule-add", createVNode(1, "span", "dmn-icon-plus action-icon", null, 1, {
          "title": this.translate('Add rule')
        }), 2)];
        var _this$sheet$getRoot = this.sheet.getRoot(),
          businessObject = _this$sheet$getRoot.businessObject;
        if (!businessObject.input || !businessObject.input.length) {
          cells.push(createVNode(1, "td", "input-cell", createTextVNode("-"), 2));
        }
        for (var i = 0; i < cols.length + 1; i++) {
          var className = 'add-rule';
          var _businessObject = cols[i] && cols[i].businessObject;
          var placeholder = '';
          if (_businessObject) {
            if (_businessObject.$instanceOf('dmn:InputClause')) {
              className += ' input-cell';
              placeholder = '-';
            }
            if (_businessObject.$instanceOf('dmn:OutputClause')) {
              className += ' output-cell';
            }
          } else {
            className += ' annotation';
          }
          cells.push(createVNode(1, "td", className, placeholder, 0, {
            "data-col-index": i
          }));
        }
        return createVNode(1, "tfoot", "actionable add-rule", createVNode(1, "tr", null, cells, 0), 2, {
          "onClick": this.handleClick
        });
      }
    }]);
    return AddRuleFootComponent;
  }(Component);
  AddRuleFootComponent.$inject = ['sheet', 'translate'];

  var AddRule = /*#__PURE__*/_createClass(function AddRule(components, editorActions, eventBus, selection) {
    _classCallCheck(this, AddRule);
    components.onGetComponent('table.foot', function () {
      return AddRuleFootComponent;
    });
    eventBus.on('addRule', function (e, context) {
      var rule = editorActions.trigger('addRule');
      var colIndex = context.colIndex;
      if (rule.cells[colIndex]) {
        selection.select(rule.cells[colIndex]);
      } else {
        selection.select(rule.cells[0]);
      }
    });
  });
  AddRule.$inject = ['components', 'editorActions', 'eventBus', 'selection'];

  /**
   * Allows selecting a table cell. Selected cell will be highlighted.
   */
  var Selection = /*#__PURE__*/function () {
    function Selection(elementRegistry, eventBus, renderer) {
      var _this = this;
      _classCallCheck(this, Selection);
      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;
      this._renderer = renderer;
      this._selection = undefined;
      eventBus.on('diagram.clear', function () {
        _this._selection = undefined;
      });
    }
    /**
     * Select a table cell.
     *
     * @param {Object|String} element - Element or element ID.
     */
    _createClass(Selection, [{
      key: "select",
      value: function select(element) {
        if (isString$4(element)) {
          element = this._elementRegistry.get(element);
        }
        var oldSelection = this._selection; // don't re-select already selected *Ggg*

        if (oldSelection === element) {
          return;
        }
        this._selection = element;
        this._eventBus.fire('selection.changed', {
          oldSelection: oldSelection,
          selection: element
        });
      }
      /**
       * Deselect a table cell.
       */
    }, {
      key: "deselect",
      value: function deselect() {
        var oldSelection = this._selection;
        this._selection = undefined;
        this._eventBus.fire('selection.changed', {
          oldSelection: oldSelection,
          selection: this._selection
        });
      }
      /**
       * Get the selected cell.
       */
    }, {
      key: "get",
      value: function get() {
        return this._selection;
      }
      /**
       * Check if a cell is selected.
       */
    }, {
      key: "hasSelection",
      value: function hasSelection() {
        return !!this._selection;
      }
    }]);
    return Selection;
  }();
  Selection.$inject = ['elementRegistry', 'eventBus', 'renderer'];

  /**
   * Selects table cells on on left & right click.
   */
  var SelectionBehavior = /*#__PURE__*/_createClass(function SelectionBehavior(elementRegistry, eventBus, renderer, selection) {
    _classCallCheck(this, SelectionBehavior);
    this._elementRegistry = elementRegistry;
    this._renderer = renderer;
    this._selection = selection;
    eventBus.on(['cell.click', 'cell.contextmenu'], function (_ref) {
      var id = _ref.id;
      var element = elementRegistry.get(id);
      if (!element) {
        return;
      }
      selection.select(element);
    });
    eventBus.on('row.remove', function (_ref2) {
      var row = _ref2.row;
      var currentSelection = selection.get();
      if (!currentSelection) {
        return;
      }
      if (row === currentSelection.row) {
        selection.deselect();
      }
    });
    eventBus.on('col.remove', function (_ref3) {
      var col = _ref3.col;
      var currentSelection = selection.get();
      if (!currentSelection) {
        return;
      }
      if (col === currentSelection.col) {
        selection.deselect();
      }
    });
  });
  SelectionBehavior.$inject = ['elementRegistry', 'eventBus', 'renderer', 'selection'];

  var selectionModule = {
    __init__: ['selection', 'selectionBehavior'],
    selection: ['type', Selection],
    selectionBehavior: ['type', SelectionBehavior]
  };

  function _defineProperty$C(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var EVENTS = ['click', 'dblclick', 'contextmenu', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mouseout', 'mouseover', 'mousemove', 'focusin', 'focusout', 'drag', 'dragstart', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop'];
  /**
   * Provides interaction events on the table.
   *
   * @param {RenderConfig} config
   * @param {EventBus} eventBus
   */
  var InteractionEvents = /*#__PURE__*/function () {
    function InteractionEvents(config, eventBus) {
      var _this = this;
      _classCallCheck(this, InteractionEvents);
      _defineProperty$C(this, "_handleEvent", function (event) {
        var target = event.target,
          type = event.type;
        var node = findClosestCell(target);
        if (!node) {
          return;
        }
        var elementId = node.getAttribute('data-element-id');
        if (elementId) {
          var e = _this._eventBus.createEvent({
            id: elementId,
            event: event,
            node: node,
            target: node
          });
          _this._eventBus.fire("cell.".concat(type), e);
          if (e.defaultPrevented) {
            event.preventDefault();
          }
          if (e.cancelBubble) {
            event.stopPropagation();
          }
        }
      });
      this._eventBus = eventBus;
      this._container = config.container;
      eventBus.on('table.init', function () {
        _this._addEventListeners(EVENTS);
      });
      eventBus.on('table.destroy', function () {
        _this._removeEventListeners(EVENTS);
      });
    }
    _createClass(InteractionEvents, [{
      key: "_addEventListeners",
      value: function _addEventListeners(events) {
        var _this2 = this;
        var container = this._container;
        events.forEach(function (event) {
          container.addEventListener(event, _this2._handleEvent);
        });
      }
    }, {
      key: "_removeEventListeners",
      value: function _removeEventListeners(events) {
        var _this3 = this;
        var container = this._container;
        events.forEach(function (event) {
          container.removeEventListener(event, _this3._handleEvent);
        });
      }
    }]);
    return InteractionEvents;
  }();
  InteractionEvents.$inject = ['config.renderer', 'eventBus']; // helpers /////////////

  function findClosestCell(element) {
    return closest(element, '[data-element-id]', true);
  }

  var interactionEventsModule = {
    __init__: ['interactionEvents'],
    interactionEvents: ['type', InteractionEvents]
  };

  var css_escape = {exports: {}};

  /*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
  (function (module, exports) {
    (function (root, factory) {
      // https://github.com/umdjs/umd/blob/master/returnExports.js
      {
        // For Node.js.
        module.exports = factory(root);
      }
    })(typeof commonjsGlobal != 'undefined' ? commonjsGlobal : commonjsGlobal, function (root) {
      if (root.CSS && root.CSS.escape) {
        return root.CSS.escape;
      }

      // https://drafts.csswg.org/cssom/#serialize-an-identifier
      var cssEscape = function cssEscape(value) {
        if (arguments.length == 0) {
          throw new TypeError('`CSS.escape` requires an argument.');
        }
        var string = String(value);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = '';
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length) {
          codeUnit = string.charCodeAt(index);
          // Note: theres no need to special-case astral symbols, surrogate
          // pairs, or lone surrogates.

          // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
          // (U+FFFD).
          if (codeUnit == 0x0000) {
            result += "\uFFFD";
            continue;
          }
          if (
          // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
          // U+007F, []
          codeUnit >= 0x0001 && codeUnit <= 0x001F || codeUnit == 0x007F ||
          // If the character is the first character and is in the range [0-9]
          // (U+0030 to U+0039), []
          index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
          // If the character is the second character and is in the range [0-9]
          // (U+0030 to U+0039) and the first character is a `-` (U+002D), []

          index == 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit == 0x002D) {
            // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
            result += '\\' + codeUnit.toString(16) + ' ';
            continue;
          }
          if (
          // If the character is the first character and is a `-` (U+002D), and
          // there is no second character, []
          index == 0 && length == 1 && codeUnit == 0x002D) {
            result += '\\' + string.charAt(index);
            continue;
          }

          // If the character is not handled by one of the above rules and is
          // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
          // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
          // U+005A), or [a-z] (U+0061 to U+007A), []
          if (codeUnit >= 0x0080 || codeUnit == 0x002D || codeUnit == 0x005F || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005A || codeUnit >= 0x0061 && codeUnit <= 0x007A) {
            // the character itself
            result += string.charAt(index);
            continue;
          }

          // Otherwise, the escaped character.
          // https://drafts.csswg.org/cssom/#escape-a-character
          result += '\\' + string.charAt(index);
        }
        return result;
      };
      if (!root.CSS) {
        root.CSS = {};
      }
      root.CSS.escape = cssEscape;
      return cssEscape;
    });
  })(css_escape);
  var css_escapeExports = css_escape.exports;
  var cssEscape = /*@__PURE__*/getDefaultExportFromCjs(css_escapeExports);

  /**
   * Expose `xor`
   */

  var componentXor = xor;

  /**
   * XOR utility
   *
   * T T F
   * T F T
   * F T T
   * F F F
   *
   * @param {Boolean} a
   * @param {Boolean} b
   * @return {Boolean}
   */

  function xor(a, b) {
    return a ^ b;
  }

  /**
   * Global Names
   */

  var globals = /\b(Array|Date|Object|Math|JSON)\b/g;

  /**
   * Return immediate identifiers parsed from `str`.
   *
   * @param {String} str
   * @param {String|Function} map function or prefix
   * @return {Array}
   * @api public
   */

  var componentProps = function componentProps(str, fn) {
    var p = unique(props(str));
    if (fn && 'string' == typeof fn) fn = prefixed(fn);
    if (fn) return map(str, p, fn);
    return p;
  };

  /**
   * Return immediate identifiers in `str`.
   *
   * @param {String} str
   * @return {Array}
   * @api private
   */

  function props(str) {
    return str.replace(/\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\//g, '').replace(globals, '').match(/[a-zA-Z_]\w*/g) || [];
  }

  /**
   * Return `str` with `props` mapped with `fn`.
   *
   * @param {String} str
   * @param {Array} props
   * @param {Function} fn
   * @return {String}
   * @api private
   */

  function map(str, props, fn) {
    var re = /\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\/|[a-zA-Z_]\w*/g;
    return str.replace(re, function (_) {
      if ('(' == _[_.length - 1]) return fn(_);
      if (!~props.indexOf(_)) return _;
      return fn(_);
    });
  }

  /**
   * Return unique array.
   *
   * @param {Array} arr
   * @return {Array}
   * @api private
   */

  function unique(arr) {
    var ret = [];
    for (var i = 0; i < arr.length; i++) {
      if (~ret.indexOf(arr[i])) continue;
      ret.push(arr[i]);
    }
    return ret;
  }

  /**
   * Map with prefix `str`.
   */

  function prefixed(str) {
    return function (_) {
      return str + _;
    };
  }

  /**
   * Module Dependencies
   */

  /**
   * Export `Iterator`
   */

  var domIterator = Iterator;

  /**
   * Initialize `Iterator`
   *
   * @param {Node} node
   * @param {Node} root
   * @return {Iterator} self
   * @api public
   */

  function Iterator(node, root) {
    if (!(this instanceof Iterator)) return new Iterator(node, root);
    this.node = this.start = this.peeked = node;
    this.root = root;
    this.closingTag = false;
    this._revisit = true;
    this._selects = [];
    this._rejects = [];
    if (node && this.higher(node)) {
      throw new Error('root must be a parent or ancestor to node');
    }
  }

  /**
   * Reset the Iterator
   *
   * @param {Node} node (optional)
   * @return {Iterator} self
   * @api public
   */

  Iterator.prototype.reset = function (node) {
    this.node = node || this.start;
    return this;
  };

  /**
   * Revisit element nodes. Defaults to `true`
   */

  Iterator.prototype.revisit = function (revisit) {
    this._revisit = undefined == revisit ? true : revisit;
    return this;
  };

  /**
   * Jump to the opening tag
   */

  Iterator.prototype.opening = function () {
    if (1 == this.node.nodeType) this.closingTag = false;
    return this;
  };

  /**
   * Jump to the closing tag
   */

  Iterator.prototype.atOpening = function () {
    return !this.closingTag;
  };

  /**
   * Jump to the closing tag
   */

  Iterator.prototype.closing = function () {
    if (1 == this.node.nodeType) this.closingTag = true;
    return this;
  };

  /**
   * Jump to the closing tag
   */

  Iterator.prototype.atClosing = function () {
    return this.closingTag;
  };

  /**
   * Next node
   *
   * @param {Number} type
   * @return {Node|null}
   * @api public
   */

  Iterator.prototype.next = traverse('nextSibling', 'firstChild');

  /**
   * Previous node
   *
   * @param {Number} type
   * @return {Node|null}
   * @api public
   */

  Iterator.prototype.previous = Iterator.prototype.prev = traverse('previousSibling', 'lastChild');

  /**
   * Make traverse function
   *
   * @param {String} dir
   * @param {String} child
   * @return {Function}
   * @api private
   */

  function traverse(dir, child) {
    var next = dir == 'nextSibling';
    return function walk(expr, n, peek) {
      expr = this.compile(expr);
      n = n && n > 0 ? n : 1;
      var node = this.node;
      var closing = this.closingTag;
      var revisit = this._revisit;
      while (node) {
        if (componentXor(next, closing) && node[child]) {
          // element with children: <em>...</em>
          node = node[child];
          closing = !next;
        } else if (1 == node.nodeType && !node[child] && componentXor(next, closing)) {
          // empty element tag: <em></em>
          closing = next;
          if (!revisit) continue;
        } else if (node[dir]) {
          // element has a neighbor: ...<em></em>...
          node = node[dir];
          closing = !next;
        } else {
          // done with current layer, move up.
          node = node.parentNode;
          closing = next;
          if (!revisit) continue;
        }
        if (!node || this.higher(node, this.root)) break;
        if (expr(node) && this.selects(node, peek) && this.rejects(node, peek)) {
          if (--n) continue;
          if (!peek) this.node = node;
          this.closingTag = closing;
          return node;
        }
      }
      return null;
    };
  }

  /**
   * Select nodes that cause `expr(node)`
   * to be truthy
   *
   * @param {Number|String|Function} expr
   * @return {Iterator} self
   * @api public
   */

  Iterator.prototype.select = function (expr) {
    expr = this.compile(expr);
    this._selects.push(expr);
    return this;
  };

  /**
   * Run through the selects ORing each
   *
   * @param {Node} node
   * @param {Boolean} peek
   * @return {Boolean}
   * @api private
   */

  Iterator.prototype.selects = function (node, peek) {
    var exprs = this._selects;
    var len = exprs.length;
    if (!len) return true;
    for (var i = 0; i < len; i++) {
      if (exprs[i].call(this, node, peek)) return true;
    }
    return false;
  };

  /**
   * Select nodes that cause `expr(node)`
   * to be falsy
   *
   * @param {Number|String|Function} expr
   * @return {Iterator} self
   * @api public
   */

  Iterator.prototype.reject = function (expr) {
    expr = this.compile(expr);
    this._rejects.push(expr);
    return this;
  };

  /**
   * Run through the reject expressions ANDing each
   *
   * @param {Node} node
   * @param {Boolean} peek
   * @return {Boolean}
   * @api private
   */

  Iterator.prototype.rejects = function (node, peek) {
    var exprs = this._rejects;
    var len = exprs.length;
    if (!len) return true;
    for (var i = 0; i < len; i++) {
      if (exprs[i].call(this, node, peek)) return false;
    }
    return true;
  };

  /**
   * Check if node is higher
   * than root.
   *
   * @param {Node} node
   * @param {Node} root
   * @return {Boolean}
   * @api private
   */

  Iterator.prototype.higher = function (node) {
    var root = this.root;
    if (!root) return false;
    node = node.parentNode;
    while (node && node != root) node = node.parentNode;
    return node != root;
  };

  /**
   * Compile an expression
   *
   * @param {String|Function|Number} expr
   * @return {Function}
   */

  Iterator.prototype.compile = function (expr) {
    switch (_typeof(expr)) {
      case 'number':
        return function (node) {
          return expr == node.nodeType;
        };
      case 'string':
        return new Function('node', 'return ' + componentProps(expr, 'node.'));
      case 'function':
        return expr;
      default:
        return function () {
          return true;
        };
    }
  };

  /**
   * Peek in either direction
   * `n` nodes. Peek backwards
   * using negative numbers.
   *
   * @param {Number} n (optional)
   * @return {Node|null}
   * @api public
   */

  Iterator.prototype.peak = Iterator.prototype.peek = function (expr, n) {
    if (arguments.length == 1) n = expr, expr = true;
    n = undefined == n ? 1 : n;
    if (!n) return this.node;else if (n > 0) return this.next(expr, n, true);else return this.prev(expr, Math.abs(n), true);
  };

  /**
   * Add a plugin
   *
   * @param {Function} fn
   * @return {Iterator}
   * @api public
   */

  Iterator.prototype.use = function (fn) {
    fn(this);
    return this;
  };
  var selection = window.getSelection();

  /**
   * Add selection / insert cursor.
   *
   * @param {Range} range
   */
  function applyRange(range) {
    selection.removeAllRanges();
    selection.addRange(range);
  }

  /**
   * Get current document selection.
   *
   * @return {Selection}
   */
  function getWindowSelection() {
    return selection;
  }

  /**
   * Return true if element is part of window selection.
   *
   * @param  {Element}  el
   * @return {Boolean}
   */
  function isSelected(el) {
    if (!selection.rangeCount) {
      return null;
    }
    var focusNode = selection.focusNode;

    // IE supports Node#contains for elements only
    // thus we ensure we check against an actual Element node
    if (isText(focusNode)) {
      focusNode = focusNode.parentNode;
    }
    return el == focusNode || el.contains(focusNode);
  }

  /**
   * Set cursor or selection position.
   *
   * @param {Element} el
   * @param {SelectionRange} selection
   */
  function setRange(el, selection) {
    var range = createRange(el, selection);
    applyRange(range);
  }

  /**
   * Get cursor or selection position.
   *
   * @param {Element} el
   */
  function getRange(el) {
    if (!isSelected(el)) {
      return null;
    }
    var range = selection.getRangeAt(0);
    var startContainer = range.startContainer;
    var endContainer = range.endContainer;
    var startOffset = range.startOffset;
    var endOffset = range.endOffset;
    var i = domIterator(el.firstChild, el);
    var next = i.node;
    var last;
    var isClosing = false;
    var selectionStart;
    var count = 0;
    function isBeforeEnd(node, referenceNode) {
      if (arguments.length === 1) {
        referenceNode = node;
      }
      return node.parentNode === endContainer && referenceNode == endContainer.childNodes[endOffset];
    }
    function isBeforeStart(node, referenceNode) {
      if (arguments.length === 1) {
        referenceNode = node;
      }
      return node.parentNode === startContainer && referenceNode == startContainer.childNodes[startOffset];
    }
    while (next) {
      // start before node
      if (isBeforeStart(next)) {
        selectionStart = count;
      }

      // end before node
      if (isBeforeEnd(next)) {
        break;
      }
      if (!isClosing) {
        if (isBr(next) || last && last.nextSibling == next && (isDiv(next) || isParagraph(next))) {
          count++;
        }
      }
      if (isText(next)) {
        // #text node
        if (startContainer === next) {
          selectionStart = count + startOffset;
        }
        if (endContainer === next) {
          count += endOffset;
          break;
        }
        count += next.textContent.length;
      }
      if (isText(next) || isClosing) {
        // start before node
        if (isBeforeStart(next, next.nextSibling)) {
          selectionStart = count;
        }

        // end before node
        if (isBeforeEnd(next, next.nextSibling)) {
          break;
        }
      }
      last = next;
      next = i.next();
      isClosing = i.closingTag;
    }

    // selection until end of text
    return {
      start: typeof selectionStart === 'undefined' ? count : selectionStart,
      end: count
    };
  }

  // helpers ///////////////////////////

  function createRange(el, selection) {
    var start = selection.start;
    var end = selection.end;
    var range = document.createRange();
    var i = domIterator(el.firstChild, el);
    var next = i.node;
    var isClosing = false;
    var count = 0;
    var length;
    while (next) {
      if (count === start) {
        if (isClosing) {
          range.setStartAfter(next);
        } else {
          range.setStartBefore(next);
        }
      }
      if (count === end) {
        if (isClosing) {
          range.setEndAfter(next);
        } else {
          range.setEndBefore(next);
        }
        return range;
      }
      if (!isClosing) {
        if (isBr(next) || next.previousSibling && (isDiv(next) || isParagraph(next))) {
          count++;
        }
      }
      if (isText(next)) {
        length = next.textContent.length;
        if (count <= start && count + length > start) {
          range.setStart(next, start - count);
        }
        if (count + length > end) {
          range.setEnd(next, end - count);
          return range;
        }
        count += length;
      }
      next = i.next();
      isClosing = i.closingTag;
    }

    // out of range
    if (count <= start) {
      if (el.lastChild) {
        range.setStartAfter(el.lastChild);
      } else {
        range.setStart(el, 0);
      }
    }
    if (el.lastChild) {
      range.setEndAfter(el.lastChild);
    } else {
      range.setEnd(el, 0);
    }
    return range;
  }
  function isText(node) {
    return node.nodeType === 3;
  }
  function isBr(node) {
    return node.nodeType === 1 && node.nodeName === 'BR';
  }
  function isDiv(node) {
    return node.nodeType === 1 && node.nodeName === 'DIV';
  }
  function isParagraph(node) {
    return node.nodeType === 1 && node.nodeName === 'P';
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s,
        _e,
        _x,
        _r,
        _arr = [],
        _n = !0,
        _d = !1;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i) return;
          _n = !1;
        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  var SELECTABLE_SELECTOR = '[contenteditable]';
  var ELEMENT_SELECTOR = '[data-element-id]';
  function getElementId(node) {
    return node.getAttribute('data-element-id');
  }
  function getElementCoords(node) {
    var coordsAttr = node.getAttribute('data-coords');
    if (!coordsAttr) {
      return null;
    }
    var _coordsAttr$split = coordsAttr.split(':'),
      _coordsAttr$split2 = _slicedToArray(_coordsAttr$split, 2),
      row = _coordsAttr$split2[0],
      col = _coordsAttr$split2[1];
    return {
      row: row,
      col: col
    };
  }
  function getNodeByCoords(elementCoords, container) {
    var coordsAttr = "".concat(elementCoords.row, ":").concat(elementCoords.col);
    return query("[data-coords=\"".concat(cssEscape(coordsAttr), "\"]"), container);
  }
  function getNodeById(elementId, container) {
    return query("[data-element-id=\"".concat(cssEscape(elementId), "\"]"), container);
  }
  function isUnselectableNode(node) {
    return closest(node, '.no-deselect', true);
  }

  /**
   * Find semantically _selectable_ element in the nodes ancestors.
   *
   * @param {Element} node
   *
   * @return {Element} node
   */
  function findSelectableAncestor(node) {
    return closest(node, ELEMENT_SELECTOR, true);
  }

  /**
   * Return focusable node in selectable el.
   *
   * @param  {Element} el
   *
   * @return {Element}
   */
  function getFocusableNode(el) {
    var selector = SELECTABLE_SELECTOR;
    return matches(el, selector) ? el : query(selector, el);
  }

  /**
   * Ensure element or element childNode has the proper focus.
   *
   * @param {Element} el
   */
  function ensureFocus$1(el) {
    var focusEl = getFocusableNode(el);
    if (!focusEl) {
      return;
    }

    // QUIRK: otherwise range and focus related actions may
    // yield errors in older browsers (PhantomJS / IE)
    if (!document.body.contains(focusEl)) {
      return;
    }

    // nothing to do, if element already has focus
    if (document.activeElement === focusEl) {
      return;
    }

    // (1) focus
    focusEl.focus();

    // (2) set cursor to element end
    var range = getRange(focusEl);
    if (!range || range.end === 0) {
      window.getSelection().setPosition(focusEl.firstChild, focusEl.firstChild.length);
    }
  }

  var LOW_PRIORITY$7 = 500;
  var VALID_DIRECTIONS = {
    above: true,
    below: true,
    right: true,
    left: true
  };

  /**
   * A cell selection utlity; allows selection of elements, independent from
   * whether they are backed by a business object or not.
   *
   * Works together with the {@link SelectionAware} trait.
   *
   * @param {RenderConfig} config
   * @param {EventBus} eventBus
   * @param {Sheet} sheet
   * @param {Selection} selection
   * @param {ElementRegistry} elementRegistry
   */
  function CellSelection(config, eventBus, sheet, selection, elementRegistry) {
    var container = config.container;
    var lastSelection = null;
    function emit(elementId, newSelection) {
      eventBus.fire('selection.' + elementId + '.changed', newSelection);
      eventBus.fire('cellSelection.changed', {
        elementId: elementId,
        selection: newSelection
      });
    }
    function click(event) {
      var target = event.target;
      if (isUnselectableNode(target)) {
        return;
      }
      var selectableNode = findSelectableAncestor(target);
      var elementId = selectableNode && getElementId(selectableNode);
      var focussed = !event.defaultPrevented;
      realSelect(elementId, focussed);
    }
    function focus(event) {
      var elementId = getElementId(event.target);
      var focussed = !event.defaultPrevented;
      event.stopPropagation();
      return realSelect(elementId, focussed);
    }
    function unfocus(event) {
      var elementId = getElementId(event.target);
      emit(elementId, {
        focussed: false
      });
    }
    function realSelect(elementId) {
      var focussed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (lastSelection !== elementId) {
        emit(lastSelection, {
          selected: false,
          focussed: false
        });
      }
      lastSelection = elementId;
      if (elementId) {
        emit(elementId, {
          selected: true,
          focussed: focussed
        });
      }
      if (elementId) {
        selection.select(elementId);
      } else {
        selection.deselect();
      }
    }
    eventBus.on('cell.click', LOW_PRIORITY$7, click);
    eventBus.on('cell.focusin', LOW_PRIORITY$7, focus);
    eventBus.on('cell.focusout', LOW_PRIORITY$7, unfocus);
    eventBus.on('cellSelection.changed', function (event) {
      var elementId = event.elementId,
        selection = event.selection;
      var actualElement = getNodeById(elementId, container);
      if (selection.focussed && actualElement) {
        ensureFocus$1(actualElement);
      }
    });
    eventBus.on('selection.changed', function (event) {
      var selection = event.selection,
        oldSelection = event.oldSelection;
      var elementId = selection && selection.id;
      var oldElementId = oldSelection && oldSelection.id;

      // select new element
      if (elementId && elementId !== lastSelection) {
        realSelect(selection.id);
      } else
        // deselect old element
        if (oldElementId && oldElementId === lastSelection) {
          realSelect();
        }
    });

    // API //////////////////////

    /**
     * Return true if a cell is currently selected.
     *
     * @return {boolean}
     */
    this.isCellSelected = function () {
      return !!lastSelection;
    };

    /**
     * Get the currently active cellSelection.
     *
     * @return {string} selection
     */
    this.getCellSelection = function () {
      return lastSelection;
    };

    /**
     * Select next cell in given direction.
     *
     * Returns true on success; false on fail (i.e. if no next selection
     * in direction could be found).
     *
     * @param {string} direction
     *
     * @return {boolean}
     */
    this.selectCell = function (direction) {
      if (!lastSelection) {
        return;
      }
      if (!(direction in VALID_DIRECTIONS)) {
        throw new Error('direction must be any of { above, below, left, right }');
      }
      var selectionEl = getNodeById(lastSelection, container);
      var coords = getElementCoords(selectionEl);
      if (!coords) {
        return false;
      }
      var nextCoords = getNextCoords(coords, direction);
      var nextNode = getNodeByCoords(nextCoords, container);
      if (!nextNode) {
        return false;
      }
      var nextElId = getElementId(nextNode);
      if (nextElId) {
        realSelect(nextElId, {
          focussed: true,
          selected: true
        });
      }
      return true;
    };
    eventBus.on('contextMenu.close', function () {
      if (lastSelection) {
        return realSelect(lastSelection);
      }
    });
  }
  CellSelection.$inject = ['config.renderer', 'eventBus', 'sheet', 'selection', 'elementRegistry'];

  // helpers ////////////////

  function getNextCoords(coords, direction) {
    var row = coords.row,
      col = coords.col;
    if (direction === 'above' || direction === 'below') {
      var rowIndex = parseInt(row, 10);
      if (isNaN(rowIndex)) {
        return coords;
      }
      var nextRowIndex = direction === 'above' ? rowIndex - 1 : rowIndex + 1;
      return {
        col: col,
        row: nextRowIndex
      };
    }
    if (direction === 'left' || direction === 'right') {
      var colIndex = parseInt(col, 10);
      if (isNaN(colIndex)) {
        return coords;
      }
      var nextColIndex = direction === 'left' ? colIndex - 1 : colIndex + 1;
      return {
        row: row,
        col: nextColIndex
      };
    }
    throw new Error('invalid direction <' + direction + '>');
  }

  var cellSelectionModule = {
    __depends__: [interactionEventsModule, selectionModule],
    __init__: ['cellSelection'],
    cellSelection: ['type', CellSelection]
  };

  /**
   * A clip board stub
   */
  function Clipboard() {}
  Clipboard.prototype.get = function () {
    return this._data;
  };
  Clipboard.prototype.set = function (data) {
    this._data = data;
  };
  Clipboard.prototype.clear = function () {
    var data = this._data;
    delete this._data;
    return data;
  };
  Clipboard.prototype.isEmpty = function () {
    return !this._data;
  };

  /**
   * @type { import('didi').ModuleDeclaration }
   */
  var ClipboardModule = {
    clipboard: ['type', Clipboard]
  };

  var HIGH_PRIORITY$3 = 2000;
  var DecisionTableModelingRules = /*#__PURE__*/function (_RuleProvider) {
    _inherits$1(DecisionTableModelingRules, _RuleProvider);
    var _super = _createSuper(DecisionTableModelingRules);
    function DecisionTableModelingRules(eventBus, sheet) {
      var _this;
      _classCallCheck(this, DecisionTableModelingRules);
      _this = _super.call(this, eventBus);
      _this._sheet = sheet;
      return _this;
    }
    _createClass(DecisionTableModelingRules, [{
      key: "init",
      value: function init() {
        var _this2 = this;
        this.addRule('col.move', HIGH_PRIORITY$3, function (_ref) {
          var col = _ref.col,
            index = _ref.index;
          var _this$_sheet$getRoot = _this2._sheet.getRoot(),
            businessObject = _this$_sheet$getRoot.businessObject,
            input = businessObject.input;
          if (isInput$1(col)) {
            return index < input.length;
          } else {
            return index >= input.length;
          }
        });
        this.addRule('col.remove', HIGH_PRIORITY$3, function (_ref2) {
          var col = _ref2.col;
          var _this$_sheet$getRoot2 = _this2._sheet.getRoot(),
            cols = _this$_sheet$getRoot2.cols;
          if (isOutput(col)) {
            return cols.filter(function (c) {
              return isOutput(c);
            }).length > 1;
          }
          return true;
        });

        // a rule that is aware of the data structure coming from copy and paste
        this.addRule('paste', HIGH_PRIORITY$3, function (_ref3) {
          var data = _ref3.data,
            target = _ref3.target;
          if (!data || !target) {
            return false;
          }
          var root = data.root;
          if (target instanceof Row) {
            return _this2.canPasteRows(root);
          }
          if (target instanceof Col) {
            return _this2.canPasteCols(root, target);
          }
          return false;
        });
      }
    }, {
      key: "canPasteRows",
      value: function canPasteRows(root) {
        var _this$_sheet$getRoot3 = this._sheet.getRoot(),
          cols = _this$_sheet$getRoot3.cols;
        return every(root, function (descriptor) {
          if (descriptor.type !== 'row') {
            return false;
          }
          if (descriptor.cells.length !== cols.length) {
            return false;
          }
          return every(descriptor.cells, function (cellDescriptor, index) {
            if (isInput$1(cols[index])) {
              return cellDescriptor.businessObject.$type === 'dmn:UnaryTests';
            } else {
              return cellDescriptor.businessObject.$type === 'dmn:LiteralExpression';
            }
          });
        });
      }
    }, {
      key: "canPasteCols",
      value: function canPasteCols(root, targetCol) {
        var _this$_sheet$getRoot4 = this._sheet.getRoot(),
          rows = _this$_sheet$getRoot4.rows;
        return every(root, function (descriptor) {
          if (descriptor.type !== 'col') {
            return false;
          }
          if (descriptor.cells.length !== rows.length) {
            return false;
          }
          if (isInput$1(targetCol)) {
            return descriptor.businessObject.$type === 'dmn:InputClause';
          } else {
            return descriptor.businessObject.$type === 'dmn:OutputClause';
          }
        });
      }
    }]);
    return DecisionTableModelingRules;
  }(RuleProvider);
  DecisionTableModelingRules.$inject = ['eventBus', 'sheet'];

  var Rules$1 = {
    __depends__: [Rules$5]
  };

  var Rules = {
    __depends__: [Rules$1],
    __init__: ['decisionTableModelingRules'],
    decisionTableModelingRules: ['type', DecisionTableModelingRules]
  };

  /**
   * A handler that implements cutting a row or col.
   * Cutting of cells doesn't make sense.
   */
  var CutHandler = /*#__PURE__*/function () {
    function CutHandler(clipboard, modeling, sheet) {
      _classCallCheck(this, CutHandler);
      this._clipboard = clipboard;
      this._modeling = modeling;
      this._sheet = sheet;
    }

    /**
     * <do>
     */
    _createClass(CutHandler, [{
      key: "execute",
      value: function execute(context) {
        var data = context.data;
        context.oldData = this._clipboard.get();
        this._clipboard.set(data);
        return this._sheet.getRoot();
      }
    }, {
      key: "postExecute",
      value: function postExecute(context) {
        var _this = this;
        var elements = context.elements;
        elements.forEach(function (element) {
          if (element instanceof Row) {
            _this._modeling.removeRow(element);
          } else if (element instanceof Col) {
            _this._modeling.removeCol(element);
          }
        });
      }

      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var oldData = context.oldData;
        this._clipboard.set(oldData);
        return this._sheet.getRoot();
      }
    }]);
    return CutHandler;
  }();
  CutHandler.$inject = ['clipboard', 'modeling', 'sheet'];

  function ownKeys$8(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$8(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$8(Object(source), !0).forEach(function (key) {
        _defineProperty$B(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$B(obj, key, value) {
    key = _toPropertyKey$z(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$z(arg) {
    var key = _toPrimitive$z(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$z(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  // creating descriptors //////////

  var createHooks = [copyTableProperties, copyBusinessObjectProperties];
  var reviveHooks = [reviveBusinessObject, reviveTableElement];

  /**
   * Return a serializable snapshot of the given elements.
   *
   * @param {Array<Base>} elements list of table elements
   *
   * @return {Tree} descriptor tree
   */
  function createDescriptor(element, cache, hooks) {
    hooks = hooks || createHooks;
    cache = cache || {};
    if (isArray$6(element)) {
      return createDescriptors0(element, cache, hooks);
    } else {
      return createDescriptor0(element, cache, hooks);
    }
  }

  /**
   * Create descriptors of elements, returning { descriptors: [], descriptorCache }.
   *
   * @param {Array<Base>} elements list of table elements
   * @param {Object} cache the create cache
   *
   * @return {Object} new descriptors + updated cache
   */
  function createDescriptors0(elements, cache, hooks) {
    return reduce(elements, function (result, element) {
      var currentCache = result.descriptorCache,
        currentDescriptors = result.root;
      var _createDescriptor = createDescriptor0(element, currentCache, hooks),
        root = _createDescriptor.root,
        descriptorCache = _createDescriptor.descriptorCache;
      return {
        root: [].concat(_toConsumableArray(currentDescriptors), [root]),
        descriptorCache: _objectSpread$8(_objectSpread$8({}, currentCache), descriptorCache)
      };
    }, {
      root: [],
      descriptorCache: cache
    });
  }
  function createDescriptor0(element, cache, hooks) {
    var id = element.id;
    var descriptor = {
      id: id
    };
    var elements = cache.elements || {};
    var existingDescriptor = elements[id];

    // element already created; nothing to do
    if (existingDescriptor) {
      return {
        root: existingDescriptor,
        descriptorCache: cache
      };
    }

    // we're new; need to initialize element via hooks
    // we assume we're not handling recursive data structures
    // here. Otherwise we'd need to pre-populate the cache
    // with the given element
    var element0 = evaluateHooks(element, descriptor, hooks, _objectSpread$8(_objectSpread$8({}, cache), {}, {
      elements: elements
    }));
    return {
      root: element0.root,
      descriptorCache: _objectSpread$8(_objectSpread$8({}, element0.descriptorCache), {}, {
        elements: _objectSpread$8(_objectSpread$8({}, element0.descriptorCache.elements), {}, _defineProperty$M({}, id, element0.root))
      })
    };
  }
  function evaluateHooks(element, descriptor, hooks, cache) {
    function create(element, descriptorCache) {
      return createDescriptor(element, descriptorCache, hooks);
    }
    return reduce(hooks, function (result, hook) {
      return hook(element, result.root, result.descriptorCache, create);
    }, {
      root: descriptor,
      descriptorCache: cache
    });
  }
  function copyTableProperties(element, descriptor, cache, create) {
    var descriptorCache = cache;
    var newDesc = _objectSpread$8(_objectSpread$8({}, descriptor), {}, {
      type: getType(element)
    });
    if (element instanceof Row || element instanceof Col) {
      var cells0 = create(element.cells, descriptorCache);
      newDesc.cells = cells0.root;
      descriptorCache = cells0.descriptorCache;
    }
    return {
      root: newDesc,
      descriptorCache: descriptorCache
    };
  }
  function copyBusinessObjectProperties(element, descriptor, cache) {
    var businessObject = element.businessObject;
    if (!businessObject) {
      return {
        root: descriptor,
        descriptorCache: cache
      };
    }

    // need to clone businessObject
    var bo0 = createBoDescriptor(businessObject, cache);
    return {
      root: _objectSpread$8(_objectSpread$8({}, descriptor), {}, {
        businessObject: bo0.root
      }),
      descriptorCache: bo0.descriptorCache
    };
  }
  function getType(element) {
    if (element instanceof Row) {
      return 'row';
    }
    if (element instanceof Col) {
      return 'col';
    }
    if (element instanceof Cell) {
      return 'cell';
    }
    throw new Error('cannot deduce element type: #' + element.id);
  }
  function createBoDescriptor(bo, cache) {
    var boCache, existingBoDesc;
    var id = bo.id;
    if (id) {
      boCache = cache.boCache || {};
      existingBoDesc = boCache[id];

      // businessObject already created; nothing to do
      if (existingBoDesc) {
        return {
          root: existingBoDesc,
          descriptorCache: cache
        };
      }
    }
    var descriptor = {
      $type: bo.$type
    };
    if (id) {
      descriptor.id = id;
      boCache = _objectSpread$8(_objectSpread$8({}, boCache), {}, _defineProperty$M({}, id, descriptor));
      cache = _objectSpread$8(_objectSpread$8({}, cache), {}, {
        boCache: boCache
      });
    }

    // TODO(nikku): distinguish relations and containment
    // Need to build up the whole tree and revive relations afterwards

    // ITERATE OVER ALL SET PROPERTIES
    // (Object.keys(bo) or via bo.$descriptor....)

    bo.$descriptor.properties.forEach(function (property) {
      var value = bo[property.name];

      // const propertyDescriptor = bo.$model.getPropertyDescriptor(bo, property.name),
      //       isId = propertyDescriptor.isId,
      //       isReference = propertyDescriptor.isReference;

      // not set
      if (!value) {
        return;
      }

      // arrays of moddle elements
      if (isArray$6(value)) {
        value = value.map(function (b) {
          var value0 = createBoDescriptor(b, cache);
          cache = value0.descriptorCache;
          return value0.root;
        });
      }

      // moddle elements
      if (value.$type) {
        var value0 = createBoDescriptor(value, cache);
        cache = value0.descriptorCache;
        value = value0.root;
      }

      // other values
      descriptor[property.name] = value;
    });
    return {
      root: descriptor,
      descriptorCache: cache
    };
  }

  // reviving //////////

  function reviveDescriptor(entry, reviveCache, hooks) {
    hooks = hooks || reviveHooks;
    reviveCache = reviveCache || {};
    if (isArray$6(entry.root)) {
      return reviveDescriptors0(entry, reviveCache, hooks);
    } else {
      return reviveDescriptor0(entry, reviveCache, hooks);
    }
  }

  /**
   * TBD: document this!
   *
   * @param  {[type]} entry       [description]
   * @param  {[type]} reviveCache [description]
   * @param  {[type]} hooks       [description]
   * @return {[type]}             [description]
   */
  function reviveDescriptors0(entry, reviveCache, hooks) {
    var descriptors = entry.root;
    var descriptorCache = entry.descriptorCache;
    return reduce(descriptors, function (result, element) {
      var currentCache = result.reviveCache,
        currentDescriptors = result.root;
      var _reviveDescriptor = reviveDescriptor0({
          root: element,
          descriptorCache: descriptorCache
        }, currentCache, hooks),
        root = _reviveDescriptor.root,
        reviveCache = _reviveDescriptor.reviveCache;
      return {
        root: [].concat(_toConsumableArray(currentDescriptors), [root]),
        reviveCache: reviveCache
      };
    }, {
      root: [],
      reviveCache: reviveCache
    });
  }

  /**
   * TBD: document this!
   *
   * @param  {[type]} entry [description]
   * @param  {[type]} cache [description]
   * @param  {[type]} hooks [description]
   * @return {[type]}       [description]
   */
  function reviveDescriptor0(entry, reviveCache, hooks) {
    var descriptor = entry.root;
    var id = descriptor.id;
    var elements = reviveCache.elements || {};
    var existingElement = elements[id];

    // element already created; nothing to do
    if (existingElement) {
      return {
        root: existingElement,
        reviveCache: reviveCache
      };
    }

    // start with a fake element; haha <3
    var element = {
      id: id
    };

    // we're new; need to initialize element via hooks
    var element0 = evaluateReviveHooks(entry, element, hooks, _objectSpread$8(_objectSpread$8({}, reviveCache), {}, {
      elements: elements
    }));
    return {
      root: element0.root,
      reviveCache: _objectSpread$8(_objectSpread$8({}, element0.reviveCache), {}, {
        elements: _objectSpread$8(_objectSpread$8({}, element0.reviveCache.elements), {}, _defineProperty$M({}, id, element0.root))
      })
    };
  }

  // entry = { root, descriptorCache }
  // element = { id: foo }
  // hooks = [ ... ]
  // reviveCache = { ... }
  function evaluateReviveHooks(entry, element, hooks, reviveCache) {
    function revive(entry, reviveCache) {
      return reviveDescriptor(entry, reviveCache, hooks);
    }
    return reduce(hooks, function (result, hook) {
      return hook(entry, result.root, result.reviveCache, revive);
    }, {
      root: element,
      reviveCache: reviveCache
    });
  }
  function reviveTableElement(entry, element, reviveCache, revive) {
    var descriptor = entry.root;
    var createCache = entry.descriptorCache;
    var elementAttrs = _objectSpread$8({}, element);

    // make sure table element ID is same as moddle element ID
    if (element.businessObject && element.businessObject.id) {
      elementAttrs.id = element.businessObject.id;
    }
    if (descriptor.type === 'row' || descriptor.type === 'col') {
      var cells0 = revive({
        root: descriptor.cells,
        descriptorCache: createCache
      }, reviveCache);
      elementAttrs.cells = cells0.root;
      reviveCache = cells0.reviveCache;
    }
    var Constructor = getConstructor(descriptor);
    var newElement = new Constructor(elementAttrs);

    // set parent row or col
    if (newElement instanceof Row) {
      newElement.cells.forEach(function (cell) {
        cell.row = newElement;
      });
    } else if (newElement instanceof Col) {
      newElement.cells.forEach(function (cell) {
        cell.col = newElement;
      });
    }
    return {
      root: newElement,
      reviveCache: reviveCache
    };
  }
  function reviveBusinessObject(entry, element, reviveCache) {
    var businessObject = entry.root.businessObject;
    if (!businessObject) {
      return {
        root: element,
        reviveCache: reviveCache
      };
    }

    // need to clone businessObject
    var bo0 = createBo({
      root: businessObject,
      descriptorCache: entry.descriptorCache
    }, reviveCache);
    return {
      root: _objectSpread$8(_objectSpread$8({}, element), {}, {
        businessObject: bo0.root
      }),
      reviveCache: bo0.reviveCache
    };
  }
  function getConstructor(descriptor) {
    switch (descriptor.type) {
      case 'row':
        return Row;
      case 'cell':
        return Cell;
      case 'col':
        return Col;
      default:
        throw new Error('unknown element type: #' + descriptor.type);
    }
  }
  function createBo(entry, reviveCache) {
    var boDescriptor = entry.root;
    var id = boDescriptor.id;
    var boCache, existingBo;
    if (id) {
      boCache = reviveCache.boCache || {};
      existingBo = boCache[id];

      // businessObject already created; nothing to do
      if (existingBo) {
        return {
          root: existingBo,
          reviveCache: reviveCache
        };
      }
    }
    var newBoAttrs = {};

    // set attrs for new business object (might include creating other business objects)
    keys(boDescriptor).forEach(function (key) {
      var val, val0;
      if (boDescriptor[key].$type) {
        val0 = createBo({
          root: boDescriptor[key]
        }, reviveCache);
        val = val0.root;
        reviveCache = val0.reviveCache;
        boCache = reviveCache.boCache || {};
      } else if (isArray$6(boDescriptor[key])) {
        val = boDescriptor[key].map(function (b) {
          val0 = createBo({
            root: b
          }, reviveCache);
          reviveCache = val0.reviveCache;
          boCache = reviveCache.boCache || {};
          return val0.root;
        });
      } else {
        val = boDescriptor[key];
      }
      newBoAttrs[key] = val;
    });
    var type = newBoAttrs.$type;
    delete newBoAttrs.$type;

    // generate new ID if not supposed to be kept or already assigned
    if (!reviveCache._keepIds || reviveCache._model.ids.assigned(newBoAttrs.id)) {
      delete newBoAttrs.id;
    }
    var newBo = reviveCache._dmnFactory.create(type, newBoAttrs);

    // set up $parent relationships for moddle elements
    forEach$3(newBoAttrs, function (newBoAttr) {
      if (newBoAttr.$type) {
        newBoAttr.$parent = newBo;
      }
      if (isArray$6(newBoAttr)) {
        newBoAttr.forEach(function (a) {
          return a.$parent = newBo;
        });
      }
    });
    if (id) {
      boCache = _objectSpread$8(_objectSpread$8({}, boCache), {}, _defineProperty$M({}, id, newBo));
      reviveCache = _objectSpread$8(_objectSpread$8({}, reviveCache), {}, {
        boCache: boCache
      });
    }
    return {
      root: newBo,
      reviveCache: reviveCache
    };
  }

  /**
   * A handler that implements pasting elements.
   */
  var PasteHandler = /*#__PURE__*/function () {
    function PasteHandler(clipboard, dmnFactory, elementFactory, elementRegistry, eventBus, moddle, modeling, sheet) {
      _classCallCheck(this, PasteHandler);
      this._clipboard = clipboard;
      this._dmnFactory = dmnFactory;
      this._elementFactory = elementFactory;
      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;
      this._model = moddle;
      this._modeling = modeling;
      this._sheet = sheet;
    }

    /**
     * <do>
     */
    _createClass(PasteHandler, [{
      key: "postExecute",
      value: function postExecute(context) {
        var _this = this;
        var element = context.element,
          after = context.after;
        var data = this._clipboard.get();
        if (!data) {
          throw new Error('missing clipboard data');
        }
        var root = this._sheet.getRoot();

        // (1) create elements from descriptors
        var elements = reviveDescriptor(data.elements, {
          _dmnFactory: this._dmnFactory,
          _keepIds: data.keepIds,
          _model: this._model
        }).root;

        // (2) add elements to sheet
        if (element instanceof Row) {
          var index = root.rows.indexOf(element);
          if (index === -1) {
            return;
          }
          elements.forEach(function (element) {
            if (after) {
              index++;
            }
            _this._modeling.addRow(element, index);
          });
        } else if (element instanceof Col) {
          var _index = root.cols.indexOf(element);
          if (_index === -1) {
            return;
          }
          elements.forEach(function (element) {
            if (after) {
              _index++;
            }
            _this._modeling.addCol(element, _index);
          });
        }
        context.oldElements = this._clipboard.get();
        return this._sheet.getRoot();
      }

      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {}
    }]);
    return PasteHandler;
  }();
  PasteHandler.$inject = ['clipboard', 'dmnFactory', 'elementFactory', 'elementRegistry', 'eventBus', 'moddle', 'modeling', 'sheet'];

  function ownKeys$7(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$7(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) {
        _defineProperty$A(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$A(obj, key, value) {
    key = _toPropertyKey$y(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$y(arg) {
    var key = _toPrimitive$y(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$y(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var CutPaste = /*#__PURE__*/function () {
    function CutPaste(clipboard, commandStack, eventBus, modeling, sheet, rules) {
      _classCallCheck(this, CutPaste);
      this._clipboard = clipboard;
      this._commandStack = commandStack;
      this._eventBus = eventBus;
      this._modeling = modeling;
      this._sheet = sheet;
      this._rules = rules;
      commandStack.registerHandler('cut', CutHandler);
      commandStack.registerHandler('paste', PasteHandler);
    }

    /**
     * Copy elements.
     *
     * @param {Array} elements - Elements to be copied.
     */
    _createClass(CutPaste, [{
      key: "copy",
      value: function copy(elements) {
        if (!isArray$6(elements)) {
          elements = [elements];
        }
        var data = {
          elements: createDescriptor(elements)
        };
        this._eventBus.fire('copyCutPaste.copy', {
          data: data
        });
        this._clipboard.set(data);
      }

      /**
       * Cut elements thereby removing them temporarily.
       *
       * @param {Array} elements - Elements to be cut.
       */
    }, {
      key: "cut",
      value: function cut(elements) {
        if (!isArray$6(elements)) {
          elements = [elements];
        }
        var data = {
          elements: createDescriptor(elements),
          keepIds: true
        };
        var context = {
          elements: elements,
          data: data
        };
        this._eventBus.fire('copyCutPaste.cut', {
          data: data
        });
        this._commandStack.execute('cut', context);
      }

      /**
       * Paste rows or cols before row or col.
       *
       * @param {Row|Col} element - Row or col to paste elements before.
       */
    }, {
      key: "pasteBefore",
      value: function pasteBefore(element) {
        return this._paste(element, {
          before: true
        });
      }

      /**
       * Paste rows or cols after row or col.
       *
       * @param {Row|Col} element - Row or col to paste elements after.
       */
    }, {
      key: "pasteAfter",
      value: function pasteAfter(element) {
        return this._paste(element, {
          after: true
        });
      }

      /**
       * Basic paste onto given target element.
       */
    }, {
      key: "_paste",
      value: function _paste(target, position) {
        var clipboardData = this._clipboard.get();
        if (!clipboardData) {
          return undefined;
        }
        var allowed = this._rules.allowed('paste', {
          data: clipboardData.elements,
          target: target
        });
        if (!allowed) {
          return false;
        }
        this._commandStack.execute('paste', _objectSpread$7({
          element: target
        }, position));

        // @bpmn-io: Clear clipboard to work around
        // https://github.com/camunda/camunda-modeler/issues/1246 which breaks native copy &
        // paste when row or column is copied or cut
        this._clipboard.clear();

        // Return true to stop propagation and prevent native paste
        return true;
      }

      /**
       * Paste elements at.
       */
    }, {
      key: "pasteAt",
      value: function pasteAt(element) {

        // TODO: implement for pasting cells
      }
    }]);
    return CutPaste;
  }();
  CutPaste.$inject = ['clipboard', 'commandStack', 'eventBus', 'modeling', 'sheet', 'rules'];

  var copyCutPasteModule = {
    __depends__: [ClipboardModule, Rules],
    __init__: ['copyCutPaste'],
    copyCutPaste: ['type', CutPaste]
  };

  var DecisionTableEditorActions = /*#__PURE__*/_createClass(function DecisionTableEditorActions(copyCutPaste, editorActions, modeling, selection, cellSelection, sheet) {
    _classCallCheck(this, DecisionTableEditorActions);
    var actions = {
      addRule: function addRule() {
        return modeling.addRow({
          type: 'dmn:DecisionRule'
        });
      },
      addRuleAbove: function addRuleAbove(context) {
        var rule = context && context.rule;
        if (!rule && !selection.hasSelection()) {
          return;
        }
        rule = rule || selection.get().row;
        var root = sheet.getRoot(),
          index = root.rows.indexOf(rule);
        if (index === -1) {
          return;
        }
        return modeling.addRow({
          type: 'dmn:DecisionRule'
        }, index);
      },
      addRuleBelow: function addRuleBelow(context) {
        var rule = context && context.rule;
        if (!rule && !selection.hasSelection()) {
          return;
        }
        rule = rule || selection.get().row;
        var root = sheet.getRoot(),
          index = root.rows.indexOf(rule);
        if (index === -1) {
          return;
        }
        return modeling.addRow({
          type: 'dmn:DecisionRule'
        }, index + 1);
      },
      removeRule: function removeRule(context) {
        var rule = context && context.rule;
        if (!rule && !selection.hasSelection()) {
          return;
        }
        rule = rule || selection.get().row;
        modeling.removeRow(rule);
      },
      addInput: function addInput() {
        var root = sheet.getRoot(),
          businessObject = root.businessObject;
        var input = businessObject.input;
        return modeling.addCol({
          type: 'dmn:InputClause'
        }, input ? input.length : 0);
      },
      addInputLeft: function addInputLeft(context) {
        var input = context && context.input;
        if (!input && !selection.hasSelection()) {
          return;
        }
        input = input || selection.get().col;
        var root = sheet.getRoot(),
          index = root.cols.indexOf(input);
        if (index === -1) {
          return;
        }
        return modeling.addCol({
          type: 'dmn:InputClause'
        }, index);
      },
      addInputRight: function addInputRight(context) {
        var input = context && context.input;
        if (!input && !selection.hasSelection()) {
          return;
        }
        input = input || selection.get().col;
        var root = sheet.getRoot(),
          index = root.cols.indexOf(input);
        if (index === -1) {
          return;
        }
        return modeling.addCol({
          type: 'dmn:InputClause'
        }, index + 1);
      },
      removeInput: function removeInput(context) {
        var input = context && context.input;
        if (!input && !selection.hasSelection()) {
          return;
        }
        input = input || selection.get().col;
        modeling.removeCol(input);
      },
      addOutput: function addOutput() {
        var root = sheet.getRoot(),
          businessObject = root.businessObject;
        var input = businessObject.get('input'),
          output = businessObject.get('output');
        return modeling.addCol({
          type: 'dmn:OutputClause'
        }, input.length + output.length);
      },
      addOutputLeft: function addOutputLeft(context) {
        var output = context && context.output;
        if (!output && !selection.hasSelection()) {
          return;
        }
        output = output || selection.get().col;
        var root = sheet.getRoot(),
          index = root.cols.indexOf(output);
        if (index === -1) {
          return;
        }
        return modeling.addCol({
          type: 'dmn:OutputClause'
        }, index);
      },
      addOutputRight: function addOutputRight(context) {
        var output = context && context.output;
        if (!output && !selection.hasSelection()) {
          return;
        }
        output = output || selection.get().col;
        var root = sheet.getRoot(),
          index = root.cols.indexOf(output);
        if (index === -1) {
          return;
        }
        return modeling.addCol({
          type: 'dmn:OutputClause'
        }, index + 1);
      },
      removeOutput: function removeOutput(context) {
        var output = context && context.output;
        if (!output && !selection.hasSelection()) {
          return;
        }
        output = output || selection.get().col;
        modeling.removeCol(output);
      },
      addClause: function addClause() {
        if (!selection.hasSelection()) {
          return;
        }
        var clause = selection.get().col;
        if (is$1(clause, 'dmn:InputClause')) {
          return actions.addInput({
            input: clause
          });
        } else if (is$1(clause, 'dmn:OutputClause')) {
          return actions.addOutput({
            output: clause
          });
        }
      },
      addClauseLeft: function addClauseLeft() {
        if (!selection.hasSelection()) {
          return;
        }
        var clause = selection.get().col;
        if (is$1(clause, 'dmn:InputClause')) {
          return actions.addInputLeft({
            input: clause
          });
        } else if (is$1(clause, 'dmn:OutputClause')) {
          return actions.addOutputLeft({
            output: clause
          });
        }
      },
      addClauseRight: function addClauseRight() {
        if (!selection.hasSelection()) {
          return;
        }
        var clause = selection.get().col;
        if (is$1(clause, 'dmn:InputClause')) {
          return actions.addInputRight({
            input: clause
          });
        } else if (is$1(clause, 'dmn:OutputClause')) {
          return actions.addOutputRight({
            output: clause
          });
        }
      },
      removeClause: function removeClause() {
        if (!selection.hasSelection()) {
          return;
        }
        var clause = selection.get().col;
        if (is$1(clause, 'dmn:InputClause')) {
          return actions.removeInput({
            input: clause
          });
        } else if (is$1(clause, 'dmn:OutputClause')) {
          return actions.removeOutput({
            output: clause
          });
        }
      },
      selectCellAbove: function selectCellAbove() {
        return cellSelection.selectCell('above');
      },
      selectCellBelow: function selectCellBelow() {
        return cellSelection.selectCell('below');
      },
      copy: function copy(_ref) {
        var element = _ref.element;
        copyCutPaste.copy(element);
      },
      cut: function cut(_ref2) {
        var element = _ref2.element;
        copyCutPaste.cut(element);
      },
      pasteBefore: function pasteBefore(_ref3) {
        var element = _ref3.element;
        return copyCutPaste.pasteBefore(element);
      },
      pasteAfter: function pasteAfter(_ref4) {
        var element = _ref4.element;
        return copyCutPaste.pasteAfter(element);
      }
    };
    editorActions.register(actions);
  });
  DecisionTableEditorActions.$inject = ['copyCutPaste', 'editorActions', 'modeling', 'selection', 'cellSelection', 'sheet'];

  var NOT_REGISTERED_ERROR$1 = 'is not a registered action',
    IS_REGISTERED_ERROR$1 = 'is already registered';
  /**
   * An interface that provides access to modeling actions by decoupling
   * the one who requests the action to be triggered and the trigger itself.
   *
   * It's possible to add new actions by registering them with registerAction and likewise
   * unregister existing ones with unregisterAction.
   *
   */
  var EditorActions$2 = /*#__PURE__*/function () {
    function EditorActions(commandStack, eventBus, modeling, selection) {
      _classCallCheck(this, EditorActions);
      this._actions = {
        undo: function undo() {
          commandStack.undo();
        },
        redo: function redo() {
          commandStack.redo();
        },
        select: function select(_ref) {
          var cell = _ref.cell;
          selection.select(cell);
        },
        deselect: function deselect() {
          selection.deselect();
        },
        addRow: function addRow(_ref2) {
          var attrs = _ref2.attrs,
            index = _ref2.index;
          modeling.addRow(attrs, index);
        },
        removeRow: function removeRow(_ref3) {
          var row = _ref3.row;
          modeling.removeRow(row);
        },
        moveRow: function moveRow(_ref4) {
          var row = _ref4.row,
            index = _ref4.index;
          modeling.moveRow(row, index);
        },
        addCol: function addCol(_ref5) {
          var attrs = _ref5.attrs,
            index = _ref5.index;
          modeling.addCol(attrs, index);
        },
        removeCol: function removeCol(_ref6) {
          var col = _ref6.col;
          modeling.removeCol(col);
        },
        moveCol: function moveCol(_ref7) {
          var col = _ref7.col,
            index = _ref7.index;
          modeling.moveCol(col, index);
        }
      };
    }
    /**
     * Triggers a registered action
     *
     * @param  {String} action
     * @param  {Object} opts
     *
     * @return {Unknown} Returns what the registered listener returns
     */
    _createClass(EditorActions, [{
      key: "trigger",
      value: function trigger(action, opts) {
        if (!this._actions[action]) {
          throw error$1(action, NOT_REGISTERED_ERROR$1);
        }
        return this._actions[action](opts);
      }
      /**
       * Registers a collections of actions.
       * The key of the object will be the name of the action.
       *
       * @param  {Object} actions
       */
    }, {
      key: "register",
      value: function register(actions, listener) {
        var _this = this;
        if (typeof actions === 'string') {
          return this._registerAction(actions, listener);
        }
        forEach$3(actions, function (listener, action) {
          _this._registerAction(action, listener);
        });
      }
      /**
       * Registers a listener to an action key
       *
       * @param  {String} action
       * @param  {Function} listener
       */
    }, {
      key: "_registerAction",
      value: function _registerAction(action, listener) {
        if (this.isRegistered(action)) {
          throw error$1(action, IS_REGISTERED_ERROR$1);
        }
        this._actions[action] = listener;
      }
      /**
       * Unregister an existing action
       *
       * @param {String} action
       */
    }, {
      key: "unregister",
      value: function unregister(action) {
        if (!this.isRegistered(action)) {
          throw error$1(action, NOT_REGISTERED_ERROR$1);
        }
        this._actions[action] = undefined;
      }
      /**
       * Checks wether the given action is registered
       *
       * @param {String} action
       *
       * @return {Boolean}
       */
    }, {
      key: "isRegistered",
      value: function isRegistered(action) {
        return !!this._actions[action];
      }
    }]);
    return EditorActions;
  }();
  EditorActions$2.$inject = ['commandStack', 'eventBus', 'modeling', 'selection']; // helpers /////////////

  function error$1(action, message) {
    return new Error(action + ' ' + message);
  }

  var editorActionsModule = {
    __depends__: [selectionModule],
    __init__: ['editorActions'],
    editorActions: ['type', EditorActions$2]
  };

  var decisionTableEditorActionsModule = {
    __depends__: [cellSelectionModule, copyCutPasteModule, editorActionsModule, selectionModule],
    __init__: ['decisionTableEditorActions'],
    decisionTableEditorActions: ['type', DecisionTableEditorActions]
  };

  var addRuleModule = {
    __depends__: [decisionTableEditorActionsModule],
    __init__: ['addRule'],
    addRule: ['type', AddRule]
  };

  /*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   */

  /**
   * Module variables.
   * @private
   */

  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Module exports.
   * @public
   */

  var escapeHtml_1 = escapeHtml;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#39;';
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  var escapeHtml$1 = /*@__PURE__*/getDefaultExportFromCjs(escapeHtml_1);

  var selectionUpdate$1 = {exports: {}};

  /**
   * Calculate the selection update for the given
   * current and new input values.
   *
   * @param {Object} currentSelection as {start, end}
   * @param {String} currentValue
   * @param {String} newValue
   *
   * @return {Object} newSelection as {start, end}
   */
  function calculateUpdate(currentSelection, currentValue, newValue) {
    var currentCursor = currentSelection.start,
      newCursor = currentCursor,
      diff = newValue.length - currentValue.length;
    newValue.length - currentValue.length;
    var currentTail = currentValue.substring(currentCursor);

    // check if we can remove common ending from the equation
    // to be able to properly detect a selection change for
    // the following scenarios:
    //
    //  * (AAATTT|TF) => (AAAT|TF)
    //  * (AAAT|TF) =>  (AAATTT|TF)
    //
    if (newValue.lastIndexOf(currentTail) === newValue.length - currentTail.length) {
      currentValue = currentValue.substring(0, currentValue.length - currentTail.length);
      newValue = newValue.substring(0, newValue.length - currentTail.length);
    }

    // diff
    var diff = createDiff(currentValue, newValue);
    if (diff) {
      if (diff.type === 'remove') {
        newCursor = diff.newStart;
      } else {
        newCursor = diff.newEnd;
      }
    }
    return range(newCursor);
  }
  selectionUpdate$1.exports = calculateUpdate;
  function createDiff(currentValue, newValue) {
    var insert;
    var l_str,
      l_char,
      l_idx = 0,
      s_str,
      s_char,
      s_idx = 0;
    if (newValue.length > currentValue.length) {
      l_str = newValue;
      s_str = currentValue;
    } else {
      l_str = currentValue;
      s_str = newValue;
    }

    // assume there will be only one insert / remove and
    // detect that _first_ edit operation only
    while (l_idx < l_str.length) {
      l_char = l_str.charAt(l_idx);
      s_char = s_str.charAt(s_idx);

      // chars no not equal
      if (l_char !== s_char) {
        if (!insert) {
          insert = {
            l_start: l_idx,
            s_start: s_idx
          };
        }
        l_idx++;
      }

      // chars equal (again?)
      else {
        if (insert && !insert.complete) {
          insert.l_end = l_idx;
          insert.s_end = s_idx;
          insert.complete = true;
        }
        s_idx++;
        l_idx++;
      }
    }
    if (insert && !insert.complete) {
      insert.complete = true;
      insert.s_end = s_str.length;
      insert.l_end = l_str.length;
    }

    // no diff
    if (!insert) {
      return;
    }
    if (newValue.length > currentValue.length) {
      return {
        newStart: insert.l_start,
        newEnd: insert.l_end,
        type: 'add'
      };
    } else {
      return {
        newStart: insert.s_start,
        newEnd: insert.s_end,
        type: newValue.length < currentValue.length ? 'remove' : 'replace'
      };
    }
  }

  /**
   * Utility method for creating a new selection range {start, end} object.
   *
   * @param {Number} start
   * @param {Number} [end]
   *
   * @return {Object} selection range as {start, end}
   */
  function range(start, end) {
    return {
      start: start,
      end: end === undefined ? start : end
    };
  }
  selectionUpdate$1.exports.range = range;
  var selectionUpdateExports = selectionUpdate$1.exports;
  var selectionUpdate = /*@__PURE__*/getDefaultExportFromCjs(selectionUpdateExports);

  function _defineProperty$z(obj, key, value) {
    key = _toPropertyKey$x(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$x(arg) {
    var key = _toPrimitive$x(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$x(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * A content ediable that performs proper selection updates on
   * editable changes. It normalizes editor operations by allowing
   * only <br/> and plain text to be inserted.
   *
   * The callback `onInput(text)` recieves text (including line breaks)
   * only. Updating the value via props will update the selection
   * if needed, too.
   *
   * @example
   *
   * class SomeComponent extends Component {
   *
   *   render() {
   *     return (
   *       <ContentEditable
   *         className="some classes"
   *         value={ this.state.text }
   *         onInput={ this.handleInput }
   *         onFocus={ ... }
   *         onBlur={ ... } />
   *     );
   *   }
   *
   * }
   *
   */
  var ContentEditable = /*#__PURE__*/function (_Component) {
    _inherits$1(ContentEditable, _Component);
    var _super = _createSuper(ContentEditable);
    function ContentEditable(props, context) {
      var _this;
      _classCallCheck(this, ContentEditable);
      _this = _super.call(this, props, context);
      _defineProperty$z(_assertThisInitialized(_this), "onFocus", function (event) {
        var propsFocus = _this.props.onFocus;
        _this.setState({
          focussed: true
        });
        if (typeof propsFocus === 'function') {
          propsFocus(event);
        }
      });
      _defineProperty$z(_assertThisInitialized(_this), "onBlur", function (event) {
        var propsBlur = _this.props.onBlur;
        _this.setState({
          focussed: false
        });
        if (typeof propsBlur === 'function') {
          propsBlur(event);
        }
      });
      _defineProperty$z(_assertThisInitialized(_this), "onKeydown", function (event) {
        // enter
        if (event.which === 13) {
          // prevent default action (<br/> insert)
          event.preventDefault();
          if (_this.props.ctrlForNewline && !isCmd$4(event)) {
            return;
          }
          if (_this.props.singleLine) {
            return;
          }
          event.stopPropagation();
          insertLineBreak();
          _this.onInput(event);
        }
      });
      _defineProperty$z(_assertThisInitialized(_this), "onInput", function (event) {
        var propsInput = _this.props.onInput;
        if (typeof propsInput !== 'function') {
          return;
        }
        var text = innerText(_this.node);
        propsInput(text);
      });
      _defineProperty$z(_assertThisInitialized(_this), "onKeyPress", function (event) {
        if (_this.onInputIEPolyfill) {
          _this.onInputIEPolyfill(event);
        }
      });
      _defineProperty$z(_assertThisInitialized(_this), "onPaste", function (event) {
        // TODO(barmac): remove once we drop IE 11 support
        if (_this.onInputIEPolyfill) {
          _this.onInputIEPolyfill(event);
        }
        if (_this.props.singleLine) {
          var text = (event.clipboardData || window.clipboardData).getData('text');

          // replace newline with space
          document.execCommand('insertText', false, text.replace(/\n/g, ' '));
          event.preventDefault();
        }
      });
      _this.state = {};

      // TODO(nikku): remove once we drop IE 11 support
      if (isIE()) {
        // onInput shim for IE <= 11
        _this.onInputIEPolyfill = function (event) {
          var oldText = _this.node.innerHTML;
          setTimeout(function () {
            var text = _this.node.innerHTML;
            if (oldText !== text) {
              _this.onInput(event);
            }
          }, 0);
        };
      }
      return _this;
    }
    _createClass(ContentEditable, [{
      key: "componentWillUpdate",
      value: function componentWillUpdate(newProps, newState) {
        // save old selection + text for later
        var node = this.node;
        var range = newState.focussed && getRange(node);
        this.selected = range && {
          range: range,
          text: innerText(node)
        };
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var selected = this.selected;
        if (!selected) {
          return;
        }

        // compute and restore selection based on
        // (possibly new) text

        var range = selected.range;
        var text = selected.text;
        var node = this.node;
        var newText = innerText(node);
        var newRange = newText !== text ? selectionUpdate(range, text, newText) : range;
        setRange(node, newRange);
      }
    }, {
      key: "getClassName",
      value: function getClassName() {
        var _this$props = this.props,
          className = _this$props.className,
          placeholder = _this$props.placeholder,
          value = _this$props.value;
        return [className || '', 'content-editable', !value && placeholder ? 'content-editable--with-placeholder' : ''].join(' ');
      }
    }, {
      key: "render",
      value: function render(props) {
        var _this2 = this;
        var value = props.value,
          placeholder = props.placeholder;

        // QUIRK: must add trailing <br/> for line
        // breaks to properly work
        value = escapeHtml$1(value).replace(/\r?\n/g, '<br/>') + '<br/>';
        return createVNode(1, "div", this.getClassName(), null, 1, {
          "contentEditable": "true",
          "spellcheck": "false",
          "data-placeholder": placeholder || '',
          "onInput": this.onInput,
          "onKeypress": this.onKeypress,
          "onPaste": this.onPaste,
          "onFocus": this.onFocus,
          "onBlur": this.onBlur,
          "onKeydown": this.onKeydown,
          "dangerouslySetInnerHTML": {
            __html: value
          }
        }, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);
    return ContentEditable;
  }(Component);
  function brTag() {
    return document.createElement('br');
  }
  function innerText(node) {
    // QUIRK: we must remove the last trailing <br/>, if any
    return node.innerText.replace(/\n$/, '');
  }
  function insertLineBreak() {
    // insert line break at current insertation
    // point; this assumes that the correct element, i.e.
    // a <ContentEditable /> is currently focussed
    var selection = getWindowSelection();
    var range = selection.getRangeAt(0);
    if (!range) {
      return;
    }
    var newRange = range.cloneRange();
    var br = brTag();
    newRange.deleteContents();
    newRange.insertNode(br);
    newRange.setStartAfter(br);
    newRange.setEndAfter(br);
    applyRange(newRange);
  }
  function isIE() {
    var ua = window.navigator.userAgent;
    return (
      // IE 10 or older
      ua.indexOf('MSIE ') > 0 ||
      // IE 11
      ua.indexOf('Trident/') > 0
    );
  }
  function isCmd$4(event) {
    return event.metaKey || event.ctrlKey;
  }

  function _defineProperty$y(obj, key, value) {
    key = _toPropertyKey$w(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$w(arg) {
    var key = _toPrimitive$w(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$w(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * A base component for interactivity.
   *
   * @example
   *
   * class Foo extends EditableComponent {
   *
   *   render() {
   *     return (
   *       <div>{ this.getEditor() }</div>
   *     );
   *   }
   * }
   *
   * And in use:
   *
   * <Foo value={ blub }
   *      onChange={ (newValue) => { ... }
   *      onFocus={ () => { ... } }
   *      onBlur={ () => { ... } }
   *      validate={ (newValue) => { return 'some-error'; } }
   *      className="..." } />
   *
   * Special classes added:
   *
   * * focused
   * * invalid
   *
   */
  var EditableComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(EditableComponent, _Component);
    var _super = _createSuper(EditableComponent);
    function EditableComponent(props, context) {
      var _this;
      _classCallCheck(this, EditableComponent);
      _this = _super.call(this, props, context);
      _defineProperty$y(_assertThisInitialized(_this), "onFocus", function (event) {
        _this.setState({
          focussed: true
        });
        var onFocus = _this.props.onFocus;
        if (typeof onFocus === 'function') {
          onFocus(event);
        }
      });
      _defineProperty$y(_assertThisInitialized(_this), "onBlur", function (event) {
        _this.setState({
          focussed: false
        });
        var invalid = _this.state.invalid;
        if (invalid) {
          _this.setState({
            changing: false,
            invalid: false
          });
        }
        var onBlur = _this.props.onBlur;
        if (typeof onBlur === 'function') {
          onBlur(event);
        }
      });
      _this.state = {
        changing: false,
        focussed: false
      };
      var injector = context.injector;
      var debounceInput = injector.get('debounceInput');
      _this.inputChanged = debounceInput(function (value) {
        var onChange = _this.props.onChange;
        if (typeof onChange === 'function') {
          onChange(value);
        }

        // only unset changed if user input and
        // committed changed value equal. This prevents the
        // input jumping back to the saved, good value.
        var currentValue = _this.state.changing;
        _this.setState({
          changing: currentValue === value ? false : currentValue
        });
      });
      _this.onInput = function (value) {
        var validate = _this.props.validate || function () {};
        var invalid = validate(value);
        _this.setState({
          changing: value,
          invalid: invalid
        });
        if (!invalid) {
          _this.inputChanged(value);
        }
      };
      return _this;
    }
    _createClass(EditableComponent, [{
      key: "getClassName",
      value: function getClassName() {
        var _this$props = this.props,
          className = _this$props.className,
          value = _this$props.value;
        var _this$state = this.state,
          changing = _this$state.changing,
          focussed = _this$state.focussed,
          invalid = _this$state.invalid;
        className += ' editable';
        if (focussed) {
          className += ' focussed';
        }
        if (invalid) {
          className += ' invalid';
        }
        if (!value && !changing) {
          className += ' empty';
        }
        return className;
      }
    }, {
      key: "getDisplayValue",
      value: function getDisplayValue() {
        var _this$props2 = this.props,
          value = _this$props2.value,
          placeholder = _this$props2.placeholder;
        var _this$state2 = this.state,
          focussed = _this$state2.focussed,
          changing = _this$state2.changing;
        if (typeof changing === 'string') {
          value = changing;
        }
        if (!value) {
          value = focussed ? '' : placeholder || '';
        }
        return value;
      }
    }, {
      key: "getEditor",
      value: function getEditor() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return createComponentVNode(2, ContentEditable, {
          "className": props.className,
          "ctrlForNewline": this.props.ctrlForNewline,
          "onFocus": this.onFocus,
          "onBlur": this.onBlur,
          "onInput": this.onInput,
          "value": this.getDisplayValue()
        });
      }
    }]);
    return EditableComponent;
  }(Component);

  function _defineProperty$x(obj, key, value) {
    key = _toPropertyKey$v(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$v(arg) {
    var key = _toPrimitive$v(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$v(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var EditableAnnotationCell = /*#__PURE__*/function (_Component) {
    _inherits$1(EditableAnnotationCell, _Component);
    var _super = _createSuper(EditableAnnotationCell);
    function EditableAnnotationCell(props, context) {
      var _this;
      _classCallCheck(this, EditableAnnotationCell);
      _this = _super.call(this, props, context);
      _defineProperty$x(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$x(_assertThisInitialized(_this), "setAnnotationValue", function (text) {
        var row = _this.props.row;
        _this.modeling.editAnnotation(row.businessObject, text);
      });
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(EditableAnnotationCell, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var row = this.props.row;
        this.changeSupport.onElementsChanged(row.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var row = this.props.row;
        this.changeSupport.offElementsChanged(row.id, this.onElementsChanged);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          row = _this$props.row,
          rowIndex = _this$props.rowIndex;
        var _row$businessObject = row.businessObject,
          description = _row$businessObject.description,
          id = _row$businessObject.id;
        return createComponentVNode(2, HeaderCell, {
          "className": "annotation",
          "onChange": this.setAnnotationValue,
          "coords": "".concat(rowIndex, ":annotation"),
          "value": description,
          "elementId": id,
          "data-row-id": row.id,
          children: createComponentVNode(2, AnnotationEditor, {
            "ctrlForNewline": true,
            "className": "annotation-editor",
            "onChange": this.setAnnotationValue,
            "value": description
          })
        });
      }
    }]);
    return EditableAnnotationCell;
  }(Component);
  EditableAnnotationCell.$inject = ['changeSupport', 'modeling'];
  var AnnotationEditor = /*#__PURE__*/function (_EditableComponent) {
    _inherits$1(AnnotationEditor, _EditableComponent);
    var _super2 = _createSuper(AnnotationEditor);
    function AnnotationEditor() {
      _classCallCheck(this, AnnotationEditor);
      return _super2.apply(this, arguments);
    }
    _createClass(AnnotationEditor, [{
      key: "render",
      value: function render() {
        return createVNode(1, "div", this.getClassName(), this.getEditor(), 0);
      }
    }]);
    return AnnotationEditor;
  }(EditableComponent);

  function AnnotationsEditingProvider(components) {
    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;
      if (cellType === 'after-label-cells') {
        return AnnotationHeader;
      } else if (cellType === 'after-rule-cells') {
        return EditableAnnotationCell;
      }
    });
  }
  AnnotationsEditingProvider.$inject = ['components'];

  var DEFAULT_DEBOUNCE_TIME = 300;
  function debounceInput(shouldDebounce) {
    return function _debounceInput(fn) {
      if (shouldDebounce !== false) {
        var debounceTime = isNumber$3(shouldDebounce) ? shouldDebounce : DEFAULT_DEBOUNCE_TIME;
        return debounce(fn, debounceTime);
      } else {
        return fn;
      }
    };
  }
  debounceInput.$inject = ['config.debounceInput'];

  var DebounceInput = {
    debounceInput: ['factory', debounceInput]
  };

  var annotationsEditorModule = {
    __depends__: [DebounceInput],
    __init__: ['annotationsProvider'],
    annotationsProvider: ['type', AnnotationsEditingProvider]
  };

  function _defineProperty$w(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DEFAULT_STYLE = {
    position: 'absolute'
  };
  /**
   * @typedef ContextMenuPosition
   * @property {number} x
   * @property {number} y
   * @property {number} [width=0]
   * @property {number} [height=0]
   * @property {'bottom-left'|'bottom-right'|'top-left'|'top-right'} [align]
   */
  var ContextMenuComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(ContextMenuComponent, _Component);
    var _super = _createSuper(ContextMenuComponent);
    function ContextMenuComponent(props, _context) {
      var _this;
      _classCallCheck(this, ContextMenuComponent);
      _this = _super.call(this, props, _context);
      _defineProperty$w(_assertThisInitialized(_this), "open", function (_ref) {
        var position = _ref.position,
          context = _ref.context;
        // always close first
        _this.close();
        _this.setState({
          isOpen: true,
          position: position || {
            x: 0,
            y: 0
          },
          context: context || {}
        });
      });
      _defineProperty$w(_assertThisInitialized(_this), "close", function () {
        if (_this.state.isOpen) {
          _this.setState({
            context: undefined,
            isOpen: false,
            position: {
              x: 0,
              y: 0
            }
          });
        }
      });
      _defineProperty$w(_assertThisInitialized(_this), "triggerClose", function () {
        _this.eventBus.fire('contextMenu.close');
      });
      _this.state = {
        isOpen: false,
        position: {
          x: 0,
          y: 0
        }
      };
      inject(_assertThisInitialized(_this));
      return _this;
    }
    /**
     * Open the context menu with given position and context.
     *
     * The menu itself will figure out the best position, taking the optional
     * positioning parameter into account. Position can also contain indicator
     * in which direction to open context menu.
     *
     * @param {ContextMenuPosition} position
     * @param {Object} [context]
     */
    _createClass(ContextMenuComponent, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.eventBus.on('contextMenu.open', this.open);
        this.eventBus.on('contextMenu.close', this.close);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.eventBus.off('contextMenu.open', this.open);
        this.eventBus.off('contextMenu.close', this.close);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state = this.state,
          isOpen = _this$state.isOpen,
          context = _this$state.context,
          position = _this$state.position;
        if (!isOpen) {
          return null;
        }
        var components = this.components.getComponents('context-menu', context);
        if (!components.length) {
          return null;
        }
        return createComponentVNode(2, ContextMenu$2, {
          "className": "context-menu no-deselect",
          "context": context,
          "position": position,
          "offset": context.offset || {
            x: 0,
            y: 0
          },
          "autoFocus": context.autoFocus !== false,
          "autoClose": context.autoClose !== false,
          "components": components,
          "onClose": this.triggerClose
        });
      }
    }]);
    return ContextMenuComponent;
  }(Component);
  ContextMenuComponent.$inject = ['eventBus', 'components'];
  /**
   * Low-level, stateless context menu holder.
   */
  var ContextMenu$2 = /*#__PURE__*/function (_Component2) {
    _inherits$1(ContextMenu, _Component2);
    var _super2 = _createSuper(ContextMenu);
    function ContextMenu(props, context) {
      var _this2;
      _classCallCheck(this, ContextMenu);
      _this2 = _super2.call(this, props, context);
      _defineProperty$w(_assertThisInitialized(_this2), "onGlobalMouseDown", function (event) {
        _this2.checkClose(event.target);
      });
      _defineProperty$w(_assertThisInitialized(_this2), "onGlobalKey", function (event) {
        var keyCode = event.which; // ENTER or ESC

        if (keyCode === 13 || keyCode === 27) {
          event.stopPropagation();
          event.preventDefault();
          _this2.close();
        }
      });
      _defineProperty$w(_assertThisInitialized(_this2), "onFocusChanged", function (event) {
        _this2.checkClose(event.target);
      });
      _defineProperty$w(_assertThisInitialized(_this2), "setNode", function (node) {
        _this2.node = node;
        var autoFocus = _this2.props.autoFocus;
        if (node) {
          _this2.updatePosition();
          if (autoFocus) {
            ensureFocus(node);
          }
        }
      });
      inject(_assertThisInitialized(_this2));
      return _this2;
    }
    _createClass(ContextMenu, [{
      key: "close",
      value: function close() {
        var onClose = this.props.onClose;
        if (isFunction$2(onClose)) {
          onClose();
        }
      }
      /**
       * Check whether closing the context menu is necessary
       * after selecting the given element.
       */
    }, {
      key: "checkClose",
      value: function checkClose(focusTarget) {
        var autoClose = this.props.autoClose;
        if (!autoClose) {
          return;
        }
        var node = this.node;
        if (!node) {
          return;
        }
        if (node === focusTarget) {
          return;
        }
        if (node.contains(focusTarget)) {
          return;
        }
        this.close();
      }
      /**
       * Handle global (window) mousedown event.
       */
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        document.addEventListener('focusin', this.onFocusChanged);
        document.addEventListener('keydown', this.onGlobalKey);
        document.addEventListener('mousedown', this.onGlobalMouseDown);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        document.removeEventListener('focusin', this.onFocusChanged);
        document.removeEventListener('keydown', this.onGlobalKey);
        document.removeEventListener('mousedown', this.onGlobalMouseDown);
      }

      /**
       * Find best context menu position and re-layout accordingly.
       */
    }, {
      key: "updatePosition",
      value: function updatePosition() {
        var _this$props = this.props,
          position = _this$props.position,
          offset = _this$props.offset;
        var node = this.node;
        var bounds = node.getBoundingClientRect();
        if (!position.width) {
          position.width = 0;
        }
        if (!position.height) {
          position.height = 0;
        }
        var container = this.renderer.getContainer(),
          containerBounds = container.getBoundingClientRect();
        if (containerBounds.width > containerBounds.height) {
          this.node.classList.add('horizontal');
          this.node.classList.remove('vertical');
        } else {
          this.node.classList.add('vertical');
          this.node.classList.remove('horizontal');
        }
        var _getTableContainerScr = getTableContainerScroll$1(node),
          scrollLeft = _getTableContainerScr.scrollLeft,
          scrollTop = _getTableContainerScr.scrollTop;
        var style = {};
        var alignment;
        if (position.align) {
          alignment = position.align.split('-');
        }
        var left, top;
        var horizontalAlignment = alignment && alignment[1] || (position.x + position.width / 2 > containerBounds.width / 2 ? 'left' : 'right');
        if (horizontalAlignment === 'left') {
          left = position.x - containerBounds.left - bounds.width + offset.x + scrollLeft;
          node.classList.remove('right');
          node.classList.add('left');
        } else {
          left = -containerBounds.left + position.x + position.width - offset.x + scrollLeft;
          node.classList.remove('left');
          node.classList.add('right');
        }
        left = alignment ? left : clampNumber(left, 0 + scrollLeft, containerBounds.width - bounds.width + scrollLeft);
        style.left = left + 'px';
        var verticalAlignment = alignment && alignment[0] || (position.y + position.height / 2 > containerBounds.height / 2 ? 'top' : 'bottom');
        if (verticalAlignment === 'top') {
          top = position.y - containerBounds.top - bounds.height + offset.y + scrollTop;
          node.classList.remove('bottom');
          node.classList.add('top');
        } else {
          top = -containerBounds.top + position.y - offset.y + scrollTop;
          node.classList.remove('top');
          node.classList.add('bottom');
        }
        top = alignment ? top : clampNumber(top, 0 + scrollTop, containerBounds.height - bounds.height + scrollTop);
        style.top = top + 'px'; // ensure context menu will always be accessible

        style.overflowY = 'auto';
        style.maxHeight = containerBounds.height - top + scrollTop + 'px';
        assign$4(this.node.style, DEFAULT_STYLE, style);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
          context = _this$props2.context,
          components = _this$props2.components,
          className = _this$props2.className;
        return createVNode(1, "div", className, components.map(function (Component, idx) {
          return createComponentVNode(2, Component, {
            "context": context
          }, idx);
        }), 0, {
          "onContextMenu": function onContextMenu(e) {
            return e.preventDefault();
          }
        }, null, this.setNode);
      }
    }]);
    return ContextMenu;
  }(Component);
  ContextMenu$2.$inject = ['renderer']; // helpers /////////////

  function clampNumber(number, min, max) {
    return Math.max(min, Math.min(max, number));
  }
  var SELECTABLE_ELEMENTS = "\n  input[type=text],\n  input[type=number],\n  input[type=button],\n  input[type=submit],\n  [contenteditable],\n  [tabindex],\n  a[href],\n  textarea,\n  button\n";
  function ensureFocus(el) {
    var focusEl = query(SELECTABLE_ELEMENTS, el);
    if (focusEl) {
      focusEl.focus(); // inputs

      if (focusEl.selectionStart && focusEl.type === 'text') {
        focusEl.selectionStart = 100000;
      } // content editable elements
      else if ('contentEditable' in focusEl) {
        setRange(focusEl, {
          start: 100000,
          end: 100000
        });
      }
    }
  }
  function getTableContainerScroll$1(node) {
    var tableContainer = closest(node, '.tjs-container');
    if (!tableContainer) {
      return {
        scrollTop: 0,
        scrollLeft: 0
      };
    }
    var scrollLeft = tableContainer.scrollLeft,
      scrollTop = tableContainer.scrollTop;
    return {
      scrollTop: scrollTop,
      scrollLeft: scrollLeft
    };
  }

  var ContextMenu$1 = /*#__PURE__*/function () {
    function ContextMenu(components, eventBus, renderer) {
      _classCallCheck(this, ContextMenu);
      this._eventBus = eventBus;
      components.onGetComponent('table.before', function () {
        return ContextMenuComponent;
      });
    }
    _createClass(ContextMenu, [{
      key: "open",
      value: function open(position, context) {
        this._eventBus.fire('contextMenu.open', {
          position: position,
          context: context
        });
      }
    }, {
      key: "close",
      value: function close() {
        this._eventBus.fire('contextMenu.close');
      }
    }]);
    return ContextMenu;
  }();
  ContextMenu$1.$inject = ['components', 'eventBus', 'renderer'];

  var contextMenuModule = {
    __init__: ['contextMenu'],
    contextMenu: ['type', ContextMenu$1]
  };

  function isCmd$3(modifiers) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (modifiers.altKey) {
      return false;
    }
    return modifiers.ctrlKey || modifiers.metaKey;
  }
  function isShift$1(modifiers) {
    return modifiers.shiftKey;
  }

  function _defineProperty$v(obj, key, value) {
    key = _toPropertyKey$u(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$u(arg) {
    var key = _toPrimitive$u(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$u(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * Keybindings for Copy + Paste
   */
  var CopyPasteKeyBindings = /*#__PURE__*/function () {
    function CopyPasteKeyBindings(injector, eventBus, clipboard, cellSelection, elementRegistry, editorActions, renderer) {
      var _this = this;
      _classCallCheck(this, CopyPasteKeyBindings);
      _defineProperty$v(this, "_clearClipboard", function () {
        _this._clipboard.clear();
      });
      _defineProperty$v(this, "_registerBindings", function () {
        // copy
        // CTRL/CMD + C
        var copy = function copy(key, modifiers) {
          if (isCmd$3(modifiers) && key === 67) {
            var cell = _this._getSelectedCell();
            if (!cell) {
              return;
            }
            if (isShift$1(modifiers)) {
              _this._editorActions.trigger('copy', {
                element: cell.col
              });
            } else {
              _this._editorActions.trigger('copy', {
                element: cell.row
              });
            }
            return true;
          }
        };

        // cut
        // CTRL/CMD + X
        var cut = function cut(key, modifiers) {
          if (isCmd$3(modifiers) && key === 88) {
            var cell = _this._getSelectedCell();
            if (!cell) {
              return;
            }
            if (isShift$1(modifiers)) {
              _this._editorActions.trigger('cut', {
                element: cell.col
              });
            } else {
              _this._editorActions.trigger('cut', {
                element: cell.row
              });
            }
            return true;
          }
        };

        // paste
        // CTRL/CMD + V
        var paste = function paste(key, modifiers) {
          var pasted;
          if (isCmd$3(modifiers) && key === 86) {
            var cell = _this._getSelectedCell();
            if (!cell) {
              return;
            }
            if (isShift$1(modifiers)) {
              pasted = _this._editorActions.trigger('pasteAfter', {
                element: cell.col
              });
              if (pasted) {
                _this._cellSelection.selectCell('right');
              }
            } else {
              pasted = _this._editorActions.trigger('pasteAfter', {
                element: cell.row
              });
              if (pasted) {
                _this._cellSelection.selectCell('below');
              }
            }
          }

          // indicate, whether we could paste
          return typeof pasted !== 'undefined';
        };

        // register listeners
        [copy, cut, paste].forEach(function (l) {
          _this._keyboard.addListener(l);
        });
      });
      this._clipboard = clipboard;
      this._cellSelection = cellSelection;
      this._elementRegistry = elementRegistry;
      this._editorActions = editorActions;
      this._keyboard = injector.get('keyboard', false);
      this._renderer = renderer;
      if (!this._keyboard) {
        return;
      }
      eventBus.on('keyboard.init', this._registerBindings);
      eventBus.on('keyboard.bind', function () {
        event.bind(document, 'copy', _this._clearClipboard, true);
        event.bind(document, 'cut', _this._clearClipboard, true);
      });
      eventBus.on('keyboard.unbind', function () {
        event.unbind(document, 'copy', _this._clearClipboard, true);
        event.unbind(document, 'cut', _this._clearClipboard, true);
      });
    }
    /**
     * Return the selected cell within the decision table.
     *
     * This verifies that a cell ready for copy-or-paste is
     * actual selected by the user, in the Browser UI.
     *
     * @return {Cell}
     */
    _createClass(CopyPasteKeyBindings, [{
      key: "_getSelectedCell",
      value: function _getSelectedCell() {
        var elementId = this._cellSelection.getCellSelection();

        // we may have no selection
        if (!elementId) {
          return;
        }
        var cell = this._elementRegistry.get(elementId);

        // selection may not be a cell
        if (!cell) {
          return;
        }
        var container = this._renderer.getContainer();
        var node = getNodeById(elementId, container);
        var focusableNode = getFocusableNode(node);

        // focusable element in selection may not be actual
        // browser focus, i.e. when a menu is open
        if (document.activeElement !== focusableNode) {
          return;
        }
        var range = getRange(node);

        // user may attempt native copy-paste operation right now
        // don't interfere with normal text copying
        if (range && range.start !== range.end) {
          return;
        }
        return cell;
      }
    }]);
    return CopyPasteKeyBindings;
  }();
  CopyPasteKeyBindings.$inject = ['injector', 'eventBus', 'clipboard', 'cellSelection', 'elementRegistry', 'editorActions', 'renderer'];

  var copyCutPasteKeybindingsModule = {
    __depends__: [ClipboardModule, cellSelectionModule],
    __init__: ['copyCutPasteKeyBindings'],
    copyCutPasteKeyBindings: ['type', CopyPasteKeyBindings]
  };

  function _defineProperty$u(obj, key, value) {
    key = _toPropertyKey$t(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$t(arg) {
    var key = _toPrimitive$t(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$t(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var CreateInputsHeaderCell = /*#__PURE__*/function (_Component) {
    _inherits$1(CreateInputsHeaderCell, _Component);
    var _super = _createSuper(CreateInputsHeaderCell);
    function CreateInputsHeaderCell(props, context) {
      var _this;
      _classCallCheck(this, CreateInputsHeaderCell);
      _this = _super.call(this, props, context);
      _defineProperty$u(_assertThisInitialized(_this), "onClick", function (event) {
        _this.editorActions.trigger('addInput');
      });
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(CreateInputsHeaderCell, [{
      key: "render",
      value: function render() {
        return createVNode(1, "th", "input-cell create-inputs header actionable", [this.translate('Input'), createTextVNode(" "), createVNode(1, "span", "add-input dmn-icon-plus action-icon", null, 1, {
          "title": this.translate('Add input')
        })], 0, {
          "onClick": this.onClick,
          "title": this.translate('Add input')
        });
      }
    }]);
    return CreateInputsHeaderCell;
  }(Component);
  CreateInputsHeaderCell.$inject = ['editorActions', 'translate'];

  function _defineProperty$t(obj, key, value) {
    key = _toPropertyKey$s(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$s(arg) {
    var key = _toPrimitive$s(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$s(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var CreateInputsCell = /*#__PURE__*/function (_Component) {
    _inherits$1(CreateInputsCell, _Component);
    var _super = _createSuper(CreateInputsCell);
    function CreateInputsCell(props, context) {
      var _this;
      _classCallCheck(this, CreateInputsCell);
      _this = _super.call(this, props, context);
      _defineProperty$t(_assertThisInitialized(_this), "onClick", function (event) {
        _this.editorActions.trigger('addInput');
      });
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(CreateInputsCell, [{
      key: "render",
      value: function render() {
        return createVNode(1, "td", "input-cell create-inputs", createTextVNode("-"), 2, {
          "onClick": this.onClick,
          "title": this.translate('Add input')
        });
      }
    }]);
    return CreateInputsCell;
  }(Component);
  CreateInputsCell.$inject = ['editorActions', 'translate'];

  var LOW_PRIORITY$6 = 500;
  var CreateInputsProvider = /*#__PURE__*/_createClass(function CreateInputsProvider(components, sheet) {
    _classCallCheck(this, CreateInputsProvider);
    components.onGetComponent('cell', LOW_PRIORITY$6, function (_ref) {
      var cellType = _ref.cellType;
      var _sheet$getRoot = sheet.getRoot(),
        businessObject = _sheet$getRoot.businessObject;
      if (businessObject.input && businessObject.input.length) {
        return;
      }
      if (cellType === 'before-label-cells') {
        return CreateInputsHeaderCell;
      } else if (cellType === 'before-rule-cells') {
        return CreateInputsCell;
      }
    });
  });
  CreateInputsProvider.$inject = ['components', 'sheet'];

  var createInputsModule = {
    __depends__: [decisionTableEditorActionsModule],
    __init__: ['createInputsProvider'],
    createInputsProvider: ['type', CreateInputsProvider]
  };

  var DEFAULT_DATA_TYPES = ['string', 'boolean', 'number', 'date', 'time', 'dateTime', 'dayTimeDuration', 'yearMonthDuration', 'Any'];

  /**
   * Provide data types via config.
   *
   * @example
   *
   * // The data types will include multiple number types: integer, long, and double.
   * const editor = new DmnJS({
   *   common: {
   *     dataTypes: [
   *       'string',
   *       'boolean',
   *       'integer',
   *       'long',
   *       'double',
   *       'date'
   *     ]
   *   }
   * })
   */
  var DataTypes = /*#__PURE__*/function () {
    /**
     * @param {string[]} configuredDataTypes
     */
    function DataTypes(configuredDataTypes) {
      _classCallCheck(this, DataTypes);
      this._dataTypes = configuredDataTypes || DEFAULT_DATA_TYPES;
    }

    /**
     * Get list of configured data types.
     *
     * @returns {string[]}
     */
    _createClass(DataTypes, [{
      key: "getAll",
      value: function getAll() {
        return this._dataTypes;
      }
    }]);
    return DataTypes;
  }();
  DataTypes.$inject = ['config.dataTypes'];

  var DataTypesModule = {
    __init__: ['dataTypes'],
    dataTypes: ['type', DataTypes]
  };

  var ContextMenu = /*#__PURE__*/function () {
    function ContextMenu(components, contextMenu, clipboard, editorActions, eventBus, elementRegistry, modeling, selection, sheet, rules, translate) {
      _classCallCheck(this, ContextMenu);
      var _this = this;
      this._contextMenu = contextMenu;
      this._clipboard = clipboard;
      this._editorActions = editorActions;
      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;
      this._modeling = modeling;
      this._selection = selection;
      this._sheet = sheet;
      this._rules = rules;
      this._translate = translate;
      this._getEntries = this._getEntries.bind(this);
      components.onGetComponent('context-menu', function () {
        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (context.contextMenuType && context.contextMenuType === 'context-menu') {
          var entries = _this._getEntries(context);
          var element = _this._elementRegistry.get(context.id);
          var additionalCellEntries = isCell(element) && components.getComponents('context-menu-cell-additional', context);
          if (additionalCellEntries && additionalCellEntries.length) {
            var cellEntriesGroup = createVNode(1, "div", "context-menu-group context-menu-group-cell", additionalCellEntries, 0);
            return function () {
              return createVNode(1, "div", "context-menu-flex", (entries || []).concat(cellEntriesGroup), 0);
            };
          } else {
            return function () {
              return createVNode(1, "div", "context-menu-flex", entries || [], 0);
            };
          }
        }
      });
      eventBus.on('cell.contextmenu', function (_ref) {
        var event = _ref.event,
          id = _ref.id;
          _ref.node;
        event.preventDefault();
        contextMenu.open({
          x: event.pageX,
          y: event.pageY
        }, {
          contextMenuType: 'context-menu',
          event: event,
          id: id
        });
      });
    }
    _createClass(ContextMenu, [{
      key: "_getEntries",
      value: function _getEntries(context) {
        var _this2 = this;
        var handlers = {
          addRuleAbove: function addRuleAbove(rule) {
            var selectedIndex = rule.cells.map(function (cell) {
              return cell.id;
            }).indexOf(context.id);
            var newRule = _this2._editorActions.trigger('addRuleAbove', {
              rule: rule
            });
            if (newRule.cells[selectedIndex]) {
              _this2._selection.select(newRule.cells[selectedIndex]);
            } else {
              _this2._selection.select(newRule.cells[0]);
            }
            _this2._contextMenu.close();
          },
          addRuleBelow: function addRuleBelow(rule) {
            var selectedIndex = rule.cells.map(function (cell) {
              return cell.id;
            }).indexOf(context.id);
            var newRule = _this2._editorActions.trigger('addRuleBelow', {
              rule: rule
            });
            if (newRule.cells[selectedIndex]) {
              _this2._selection.select(newRule.cells[selectedIndex]);
            } else {
              _this2._selection.select(newRule.cells[0]);
            }
            _this2._contextMenu.close();
          },
          removeRule: function removeRule(rule) {
            _this2._editorActions.trigger('removeRule', {
              rule: rule
            });
            _this2._contextMenu.close();
          },
          addInputLeft: function addInputLeft(input) {
            _this2._editorActions.trigger('addInputLeft', {
              input: input
            });
            _this2._contextMenu.close();
          },
          addInputRight: function addInputRight(input) {
            _this2._editorActions.trigger('addInputRight', {
              input: input
            });
            _this2._contextMenu.close();
          },
          removeInput: function removeInput(input) {
            _this2._editorActions.trigger('removeInput', {
              input: input
            });
            _this2._contextMenu.close();
          },
          addOutputLeft: function addOutputLeft(output) {
            _this2._editorActions.trigger('addOutputLeft', {
              output: output
            });
            _this2._contextMenu.close();
          },
          addOutputRight: function addOutputRight(output) {
            _this2._editorActions.trigger('addOutputRight', {
              output: output
            });
            _this2._contextMenu.close();
          },
          removeOutput: function removeOutput(output) {
            _this2._editorActions.trigger('removeOutput', {
              output: output
            });
            _this2._contextMenu.close();
          },
          copy: function copy(element) {
            _this2._editorActions.trigger('copy', {
              element: element
            });
            _this2._contextMenu.close();
          },
          cut: function cut(element) {
            _this2._editorActions.trigger('cut', {
              element: element
            });
            _this2._contextMenu.close();
          },
          pasteBefore: function pasteBefore(element) {
            _this2._editorActions.trigger('pasteBefore', {
              element: element
            });
            _this2._contextMenu.close();
          },
          pasteAfter: function pasteAfter(element) {
            _this2._editorActions.trigger('pasteAfter', {
              element: element
            });
            _this2._contextMenu.close();
          }
        };
        var id = context && context.id;
        if (!id) {
          return null;
        }
        var element = this._elementRegistry.get(id);
        if (!element) {
          return null;
        }
        var clipboardData = this._clipboard.get() || {};
        var entries = [];
        var row = element.row || element;
        if (is$1(row, 'dmn:DecisionRule')) {
          var canPaste = this._rules.allowed('paste', {
            data: clipboardData.elements,
            target: row
          });
          entries.push(createVNode(1, "div", "context-menu-group", [createVNode(1, "div", "context-menu-group-entry context-menu-entry-copy-rule", this._translate('Copy rule'), 0, {
            "onClick": function onClick() {
              return handlers.copy(row);
            }
          }), createVNode(1, "div", "context-menu-group-entry context-menu-entry-cut-rule", this._translate('Cut rule'), 0, {
            "onClick": function onClick() {
              return handlers.cut(row);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(canPaste ? '' : 'disabled', " context-menu-entry-paste-rule-above"), this._translate('Paste rule above'), 0, {
            "onClick": function onClick() {
              return handlers.pasteBefore(row);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(canPaste ? '' : 'disabled', " context-menu-entry-paste-rule-below"), this._translate('Paste rule below'), 0, {
            "onClick": function onClick() {
              return handlers.pasteAfter(row);
            }
          })], 4), createVNode(1, "div", "context-menu-group", [createVNode(1, "div", "context-menu-group-entry context-menu-entry-add-rule-above", this._translate('Add rule above'), 0, {
            "onClick": function onClick() {
              return handlers.addRuleAbove(row);
            }
          }), createVNode(1, "div", "context-menu-group-entry context-menu-entry-add-rule-below", this._translate('Add rule below'), 0, {
            "onClick": function onClick() {
              return handlers.addRuleBelow(row);
            }
          }), createVNode(1, "div", "context-menu-group-entry context-menu-entry-remove-rule", this._translate('Remove rule'), 0, {
            "onClick": function onClick() {
              return handlers.removeRule(row);
            }
          })], 4));
        } else if (is$1(element, 'dmn:InputClause')) {
          var actualElement = is$1(element, 'dmn:InputClause') ? element : element.col;
          var canRemove = this._rules.allowed('col.remove', {
            col: element.col || element
          });
          var _canPaste = this._rules.allowed('paste', {
            data: clipboardData.elements,
            target: element.col || element
          });
          entries.push(createVNode(1, "div", "context-menu-group", [createVNode(1, "div", "context-menu-group-entry context-menu-entry-copy-input", this._translate('Copy input column'), 0, {
            "onClick": function onClick() {
              return handlers.copy(actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(canRemove ? '' : 'disabled', " context-menu-entry-cut-input"), this._translate('Cut input column'), 0, {
            "onClick": function onClick() {
              return handlers.cut(actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(_canPaste ? '' : 'disabled', " context-menu-entry-paste-input-left"), this._translate('Paste input column left'), 0, {
            "onClick": function onClick() {
              return handlers.pasteBefore(actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(_canPaste ? '' : 'disabled', " context-menu-entry-paste-input-right"), this._translate('Paste input column right'), 0, {
            "onClick": function onClick() {
              return handlers.pasteAfter(actualElement);
            }
          })], 4), createVNode(1, "div", "context-menu-group", [createVNode(1, "div", "context-menu-group-entry context-menu-entry-add-input-left", this._translate('Add input column left'), 0, {
            "onClick": function onClick() {
              return handlers.addInputLeft(actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry context-menu-entry-add-input-right", this._translate('Add input column right'), 0, {
            "onClick": function onClick() {
              return handlers.addInputRight(actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(canRemove ? '' : 'disabled', " context-menu-entry-remove-input"), this._translate('Remove input column'), 0, {
            "onClick": function onClick() {
              return handlers.removeInput(actualElement);
            }
          })], 4));
        } else if (is$1(element, 'dmn:OutputClause') || is$1(element.col, 'dmn:OutputClause')) {
          var _actualElement = is$1(element, 'dmn:OutputClause') ? element : element.col;
          var _canRemove = this._rules.allowed('col.remove', {
            col: element.col || element
          });
          var _canPaste2 = this._rules.allowed('paste', {
            data: clipboardData.elements,
            target: element.col || element
          });
          entries.push(createVNode(1, "div", "context-menu-group", [createVNode(1, "div", "context-menu-group-entry context-menu-entry-copy-output", this._translate('Copy output column'), 0, {
            "onClick": function onClick() {
              return handlers.copy(_actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(_canRemove ? '' : 'disabled', " context-menu-entry-cut-output"), this._translate('Cut output column'), 0, {
            "onClick": function onClick() {
              return handlers.cut(_actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(_canPaste2 ? '' : 'disabled', " context-menu-entry-paste-output-left"), this._translate('Paste output column left'), 0, {
            "onClick": function onClick() {
              return handlers.pasteBefore(_actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(_canPaste2 ? '' : 'disabled', " context-menu-entry-paste-output-right"), this._translate('Paste output column right'), 0, {
            "onClick": function onClick() {
              return handlers.pasteAfter(_actualElement);
            }
          })], 4), createVNode(1, "div", "context-menu-group", [createVNode(1, "div", "context-menu-group-entry context-menu-entry-add-output-left", this._translate('Add output column left'), 0, {
            "onClick": function onClick() {
              return handlers.addOutputLeft(_actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry context-menu-entry-add-output-right", this._translate('Add output column right'), 0, {
            "onClick": function onClick() {
              return handlers.addOutputRight(_actualElement);
            }
          }), createVNode(1, "div", "context-menu-group-entry ".concat(_canRemove ? '' : 'disabled', " context-menu-entry-remove-output"), this._translate('Remove output column'), 0, {
            "onClick": function onClick() {
              return handlers.removeOutput(_actualElement);
            }
          })], 4));
        }
        return entries;
      }
    }]);
    return ContextMenu;
  }();
  ContextMenu.$inject = ['components', 'contextMenu', 'clipboard', 'editorActions', 'eventBus', 'elementRegistry', 'modeling', 'selection', 'sheet', 'rules', 'translate'];

  // helpers ///////////

  function isCell(element) {
    return element instanceof Cell;
  }

  var COMMANDS = ['row.add', 'row.remove', 'col.add', 'col.remove'];
  var ContextMenuCloseBehavior = /*#__PURE__*/_createClass(function ContextMenuCloseBehavior(contextMenu, eventBus) {
    _classCallCheck(this, ContextMenuCloseBehavior);
    eventBus.on('commandStack.executed', function (_ref) {
      var command = _ref.command;
      // close on certain modeling operations
      if (COMMANDS.indexOf(command) !== -1) {
        contextMenu.close();
      }
    });

    // always close on undo
    eventBus.on('commandStack.reverted', function () {
      contextMenu.close();
    });
  });
  ContextMenuCloseBehavior.$inject = ['contextMenu', 'eventBus'];

  var decisionTableContextMenu = {
    __depends__: [decisionTableEditorActionsModule, contextMenuModule, Rules],
    __init__: ['decisionTableContextMenu', 'contextMenuCloseBehavior'],
    decisionTableContextMenu: ['type', ContextMenu],
    contextMenuCloseBehavior: ['type', ContextMenuCloseBehavior]
  };

  function _defineProperty$s(obj, key, value) {
    key = _toPropertyKey$r(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$r(arg) {
    var key = _toPrimitive$r(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$r(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var OutputCell = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputCell, _Component);
    var _super = _createSuper(OutputCell);
    function OutputCell(props, context) {
      var _this;
      _classCallCheck(this, OutputCell);
      _this = _super.call(this, props, context);
      _defineProperty$s(_assertThisInitialized(_this), "onClick", function (event) {
        var output = _this.props.output;
        _this._eventBus.fire('output.edit', {
          event: event,
          output: output
        });
      });
      _defineProperty$s(_assertThisInitialized(_this), "onContextmenu", function (event) {
        var id = _this.props.output.id;
        _this._eventBus.fire('cell.contextmenu', {
          event: event,
          id: id
        });
      });
      _defineProperty$s(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      mixin(_assertThisInitialized(_this), ComponentWithSlots);
      _this._translate = context.injector.get('translate');
      return _this;
    }
    _createClass(OutputCell, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var injector = this.context.injector;
        this._changeSupport = this.context.changeSupport;
        this._eventBus = injector.get('eventBus');
        this._elementRegistry = injector.get('elementRegistry');
        var output = this.props.output;
        this._changeSupport.onElementsChanged(output.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var output = this.props.output;
        this._changeSupport.offElementsChanged(output.id, this.onElementsChanged);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          output = _this$props.output,
          index = _this$props.index,
          outputsLength = _this$props.outputsLength;
        var label = output.label,
          name = output.name,
          outputValues = output.outputValues,
          typeRef = output.typeRef;
        var width = output.width ? output.width + 'px' : '192px';
        return createVNode(1, "th", "output-cell output-editor", [this.slotFills({
          type: 'cell-inner',
          context: {
            cellType: 'output-cell',
            col: this._elementRegistry.get(output.id),
            index: index,
            outputsLength: outputsLength
          },
          col: output
        }), createVNode(1, "div", "clause", index === 0 ? this._translate('Then') : this._translate('And'), 0), label ? createVNode(1, "div", "output-label", label, 0, {
          "title": this._translate('Output label: ') + label
        }) : createVNode(1, "div", "output-name", name, 0, {
          "title": this._translate('Output name: ') + name
        }), createVNode(1, "div", "output-variable", outputValues && outputValues.text || this._translate(typeRef || ''), 0, {
          "title": outputValues && outputValues.text ? this._translate('Output values') : this._translate('Output type')
        })], 0, {
          "data-col-id": output.id,
          "onDblClick": this.onClick,
          "onContextmenu": this.onContextmenu,
          "style": {
            width: width
          }
        });
      }
    }]);
    return OutputCell;
  }(Component);

  function _defineProperty$r(obj, key, value) {
    key = _toPropertyKey$q(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$q(arg) {
    var key = _toPrimitive$q(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$q(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var Input = /*#__PURE__*/function (_Component) {
    _inherits$1(Input, _Component);
    var _super = _createSuper(Input);
    function Input(props, context) {
      var _this;
      _classCallCheck(this, Input);
      _this = _super.call(this, props, context);
      _defineProperty$r(_assertThisInitialized(_this), "onInput", function (event) {
        var onInput = _this.props.onInput;
        if (typeof onInput !== 'function') {
          return;
        }
        onInput(event.target.value);
      });
      _defineProperty$r(_assertThisInitialized(_this), "onKeyDown", function (event) {
        var onKeyDown = _this.props.onKeyDown;
        if (typeof onKeyDown !== 'function') {
          return;
        }
        onKeyDown(event);
      });
      _defineProperty$r(_assertThisInitialized(_this), "onKeyUp", function (event) {
        var onKeyUp = _this.props.onKeyUp;
        if (typeof onKeyUp !== 'function') {
          return;
        }
        onKeyUp(event);
      });
      return _this;
    }
    _createClass(Input, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
          className = _this$props.className,
          placeholder = _this$props.placeholder,
          type = _this$props.type,
          value = _this$props.value;
        return createVNode(64, "input", [className || '', 'dms-input'].join(' '), null, 1, {
          "placeholder": placeholder || '',
          "onInput": this.onInput,
          "onKeyDown": this.onKeyDown,
          "onKeyUp": this.onKeyUp,
          "spellcheck": "false",
          "type": type || 'text',
          "value": value
        });
      }
    }]);
    return Input;
  }(Component);

  var OutputEditor = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputEditor, _Component);
    var _super = _createSuper(OutputEditor);
    function OutputEditor(props, context) {
      var _this;
      _classCallCheck(this, OutputEditor);
      _this = _super.call(this, props, context);
      _this.translate = context.injector ? context.injector.get('translate') : noopTranslate$1;
      _this.setName = function (name) {
        name = name || undefined;
        _this.handleChange({
          name: name
        });
      };
      _this.setLabel = function (label) {
        label = label || undefined;
        _this.handleChange({
          label: label
        });
      };
      return _this;
    }
    _createClass(OutputEditor, [{
      key: "handleChange",
      value: function handleChange(changes) {
        var onChange = this.props.onChange;
        if (typeof onChange === 'function') {
          onChange(changes);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          name = _this$props.name,
          label = _this$props.label;
        return createVNode(1, "div", "context-menu-container ref-output-editor output-edit", [createVNode(1, "div", "dms-form-control", createComponentVNode(2, ContentEditable, {
          "className": "dms-output-label",
          "value": label || '',
          "placeholder": this.translate('Output'),
          "singleLine": true,
          "onInput": this.setLabel
        }), 2), createVNode(1, "div", "dms-form-control", [createVNode(1, "label", "dms-label", this.translate('Output name'), 0), createComponentVNode(2, Input, {
          "className": "ref-output-name",
          "value": name || '',
          "onInput": this.setName
        })], 4)], 4);
      }
    }]);
    return OutputEditor;
  }(Component);
  function noopTranslate$1(str) {
    return str;
  }

  function ownKeys$6(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$6(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) {
        _defineProperty$q(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$q(obj, key, value) {
    key = _toPropertyKey$p(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$p(arg) {
    var key = _toPrimitive$p(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$p(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var OutputCellContextMenu = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputCellContextMenu, _Component);
    var _super = _createSuper(OutputCellContextMenu);
    function OutputCellContextMenu(props, context) {
      var _this;
      _classCallCheck(this, OutputCellContextMenu);
      _this = _super.call(this, props, context);
      _defineProperty$q(_assertThisInitialized(_this), "persistChanges", function () {
        var output = _this.props.context.output;
        var unsaved = _this.state.unsaved;
        if (!unsaved) {
          return;
        }
        _this.modeling.updateProperties(output, unsaved);
        _this.setState({
          unsaved: false
        });
      });
      _defineProperty$q(_assertThisInitialized(_this), "handleChange", function (changes) {
        _this.setState({
          unsaved: _objectSpread$6(_objectSpread$6({}, _this.state.unsaved), changes)
        }, _this.persistChanges);
      });
      _this.state = {};
      inject(_assertThisInitialized(_this));
      _this.persistChanges = _this.debounceInput(_this.persistChanges);
      return _this;
    }
    _createClass(OutputCellContextMenu, [{
      key: "getValue",
      value: function getValue(attr) {
        var output = this.props.context.output;
        var unsaved = this.state.unsaved;
        return unsaved && attr in unsaved ? unsaved[attr] : output.get(attr);
      }
    }, {
      key: "render",
      value: function render() {
        return createComponentVNode(2, OutputEditor, {
          "name": this.getValue('name'),
          "label": this.getValue('label'),
          "onChange": this.handleChange
        });
      }
    }]);
    return OutputCellContextMenu;
  }(Component);
  OutputCellContextMenu.$inject = ['debounceInput', 'modeling'];

  var OutputEditingProvider = /*#__PURE__*/_createClass(function OutputEditingProvider(components, contextMenu, eventBus, renderer) {
    _classCallCheck(this, OutputEditingProvider);
    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;
      if (cellType === 'output-header') {
        return OutputCell;
      }
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType === 'output-edit') {
        return OutputCellContextMenu;
      }
    });
    eventBus.on('output.edit', function (_ref2) {
      var event = _ref2.event,
        output = _ref2.output;
      var target = event.target;
      var node = closest(target, 'th', true);
      var _node$getBoundingClie = node.getBoundingClientRect(),
        left = _node$getBoundingClie.left,
        top = _node$getBoundingClie.top;
      var offset = getOffset(node);
      contextMenu.open({
        x: left,
        y: top,
        align: 'bottom-right'
      }, {
        contextMenuType: 'output-edit',
        output: output,
        offset: offset
      });
    });
  });
  OutputEditingProvider.$inject = ['components', 'contextMenu', 'eventBus', 'renderer'];
  function getOffset(element) {
    if (!matches(element, '.output-cell + .output-cell')) {
      return {
        x: -1,
        y: 0
      };
    }
  }

  function _defineProperty$p(obj, key, value) {
    key = _toPropertyKey$o(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$o(arg) {
    var key = _toPrimitive$o(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$o(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var InputCell = /*#__PURE__*/function (_Component) {
    _inherits$1(InputCell, _Component);
    var _super = _createSuper(InputCell);
    function InputCell(props, context) {
      var _this;
      _classCallCheck(this, InputCell);
      _this = _super.call(this, props, context);
      _defineProperty$p(_assertThisInitialized(_this), "onClick", function (event) {
        var input = _this.props.input;
        _this._eventBus.fire('input.edit', {
          event: event,
          input: input
        });
      });
      _defineProperty$p(_assertThisInitialized(_this), "onContextmenu", function (event) {
        var id = _this.props.input.id;
        _this._eventBus.fire('cell.contextmenu', {
          event: event,
          id: id
        });
      });
      _defineProperty$p(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      mixin(_assertThisInitialized(_this), ComponentWithSlots);
      _this._translate = context.injector.get('translate');
      return _this;
    }
    _createClass(InputCell, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var injector = this.context.injector;
        this._changeSupport = this.context.changeSupport;
        this._sheet = injector.get('sheet');
        this._eventBus = injector.get('eventBus');
        this._elementRegistry = injector.get('elementRegistry');
        var root = this._sheet.getRoot();
        var input = this.props.input;
        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
        this._changeSupport.onElementsChanged(input.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var root = this._sheet.getRoot();
        var input = this.props.input;
        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
        this._changeSupport.offElementsChanged(input.id, this.onElementsChanged);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          input = _this$props.input,
          index = _this$props.index,
          inputsLength = _this$props.inputsLength;
        var inputExpression = input.inputExpression,
          inputValues = input.inputValues;
        var label = input.get('label');
        var width = input.width ? input.width + 'px' : '192px';
        return createVNode(1, "th", "input-cell input-editor", [this.slotFills({
          type: 'cell-inner',
          context: {
            cellType: 'input-cell',
            col: this._elementRegistry.get(input.id),
            index: index,
            inputsLength: inputsLength
          },
          col: input
        }), createVNode(1, "div", "clause", index === 0 ? this._translate('When') : this._translate('And'), 0), label ? createVNode(1, "div", "input-label", label, 0, {
          "title": this._translate('Input label: ') + label
        }) : createVNode(1, "div", "input-expression", inputExpression.text, 0, {
          "title": this._translate('Input expression: ') + inputExpression.text
        }), createVNode(1, "div", "input-variable", inputValues && inputValues.text || this._translate(inputExpression.typeRef || ''), 0, {
          "title": inputValues && inputValues.text ? this._translate('Input values') : this._translate('Input type')
        })], 0, {
          "data-col-id": input.id,
          "onDblClick": this.onClick,
          "onContextmenu": this.onContextmenu,
          "style": {
            width: width
          }
        });
      }
    }]);
    return InputCell;
  }(Component);

  /**
  The data structure for documents. @nonabstract
  */
  var Text = /*#__PURE__*/function () {
    /**
    @internal
    */
    function Text() {
      _classCallCheck(this, Text);
    }
    /**
    Create a `Text` instance for the given array of lines.
    */
    _createClass(Text, [{
      key: "lineAt",
      value:
      /**
      Get the line description around the given position.
      */
      function lineAt(pos) {
        if (pos < 0 || pos > this.length) throw new RangeError("Invalid position ".concat(pos, " in document of length ").concat(this.length));
        return this.lineInner(pos, false, 1, 0);
      }
      /**
      Get the description for the given (1-based) line number.
      */
    }, {
      key: "line",
      value: function line(n) {
        if (n < 1 || n > this.lines) throw new RangeError("Invalid line number ".concat(n, " in ").concat(this.lines, "-line document"));
        return this.lineInner(n, true, 1, 0);
      }
      /**
      Replace a range of the text with the given content.
      */
    }, {
      key: "replace",
      value: function replace(from, to, text) {
        var parts = [];
        this.decompose(0, from, parts, 2 /* Open.To */);
        if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);
        this.decompose(to, this.length, parts, 1 /* Open.From */);
        return TextNode.from(parts, this.length - (to - from) + text.length);
      }
      /**
      Append another document to this one.
      */
    }, {
      key: "append",
      value: function append(other) {
        return this.replace(this.length, this.length, other);
      }
      /**
      Retrieve the text between the given points.
      */
    }, {
      key: "slice",
      value: function slice(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
        var parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
      }
      /**
      Test whether this text is equal to another instance.
      */
    }, {
      key: "eq",
      value: function eq(other) {
        if (other == this) return true;
        if (other.length != this.length || other.lines != this.lines) return false;
        var start = this.scanIdentical(other, 1),
          end = this.length - this.scanIdentical(other, -1);
        var a = new RawTextCursor(this),
          b = new RawTextCursor(other);
        for (var skip = start, pos = start;;) {
          a.next(skip);
          b.next(skip);
          skip = 0;
          if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;
          pos += a.value.length;
          if (a.done || pos >= end) return true;
        }
      }
      /**
      Iterate over the text. When `dir` is `-1`, iteration happens
      from end to start. This will return lines and the breaks between
      them as separate strings.
      */
    }, {
      key: "iter",
      value: function iter() {
        var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return new RawTextCursor(this, dir);
      }
      /**
      Iterate over a range of the text. When `from` > `to`, the
      iterator will run in reverse.
      */
    }, {
      key: "iterRange",
      value: function iterRange(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
        return new PartialTextCursor(this, from, to);
      }
      /**
      Return a cursor that iterates over the given range of lines,
      _without_ returning the line breaks between, and yielding empty
      strings for empty lines.
      
      When `from` and `to` are given, they should be 1-based line numbers.
      */
    }, {
      key: "iterLines",
      value: function iterLines(from, to) {
        var inner;
        if (from == null) {
          inner = this.iter();
        } else {
          if (to == null) to = this.lines + 1;
          var start = this.line(from).from;
          inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
      }
      /**
      Return the document as a string, using newline characters to
      separate lines.
      */
    }, {
      key: "toString",
      value: function toString() {
        return this.sliceString(0);
      }
      /**
      Convert the document to an array of lines (which can be
      deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
      */
    }, {
      key: "toJSON",
      value: function toJSON() {
        var lines = [];
        this.flatten(lines);
        return lines;
      }
    }], [{
      key: "of",
      value: function of(text) {
        if (text.length == 0) throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0]) return Text.empty;
        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
      }
    }]);
    return Text;
  }(); // Leaves store an array of line strings. There are always line breaks
  // between these strings. Leaves are limited in size and have to be
  // contained in TextNode instances for bigger documents.
  var TextLeaf = /*#__PURE__*/function (_Text) {
    _inherits$1(TextLeaf, _Text);
    var _super = _createSuper(TextLeaf);
    function TextLeaf(text) {
      var _this;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : textLength(text);
      _classCallCheck(this, TextLeaf);
      _this = _super.call(this);
      _this.text = text;
      _this.length = length;
      return _this;
    }
    _createClass(TextLeaf, [{
      key: "lines",
      get: function get() {
        return this.text.length;
      }
    }, {
      key: "children",
      get: function get() {
        return null;
      }
    }, {
      key: "lineInner",
      value: function lineInner(target, isLine, line, offset) {
        for (var i = 0;; i++) {
          var string = this.text[i],
            end = offset + string.length;
          if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);
          offset = end + 1;
          line++;
        }
      }
    }, {
      key: "decompose",
      value: function decompose(from, to, target, open) {
        var text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & 1 /* Open.From */) {
          var prev = target.pop();
          var joined = appendText(text.text, prev.text.slice(), 0, text.length);
          if (joined.length <= 32 /* Tree.Branch */) {
            target.push(new TextLeaf(joined, prev.length + text.length));
          } else {
            var mid = joined.length >> 1;
            target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
          }
        } else {
          target.push(text);
        }
      }
    }, {
      key: "replace",
      value: function replace(from, to, text) {
        if (!(text instanceof TextLeaf)) return _get(_getPrototypeOf(TextLeaf.prototype), "replace", this).call(this, from, to, text);
        var lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        var newLen = this.length + text.length - (to - from);
        if (lines.length <= 32 /* Tree.Branch */) return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
      }
    }, {
      key: "sliceString",
      value: function sliceString(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
        var lineSep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "\n";
        var result = "";
        for (var pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
          var line = this.text[i],
            end = pos + line.length;
          if (pos > from && i) result += lineSep;
          if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);
          pos = end + 1;
        }
        return result;
      }
    }, {
      key: "flatten",
      value: function flatten(target) {
        var _iterator = _createForOfIteratorHelper(this.text),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var line = _step.value;
            target.push(line);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "scanIdentical",
      value: function scanIdentical() {
        return 0;
      }
    }], [{
      key: "split",
      value: function split(text, target) {
        var part = [],
          len = -1;
        var _iterator2 = _createForOfIteratorHelper(text),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var line = _step2.value;
            part.push(line);
            len += line.length + 1;
            if (part.length == 32 /* Tree.Branch */) {
              target.push(new TextLeaf(part, len));
              part = [];
              len = -1;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (len > -1) target.push(new TextLeaf(part, len));
        return target;
      }
    }]);
    return TextLeaf;
  }(Text); // Nodes provide the tree structure of the `Text` type. They store a
  // number of other nodes or leaves, taking care to balance themselves
  // on changes. There are implied line breaks _between_ the children of
  // a node (but not before the first or after the last child).
  var TextNode = /*#__PURE__*/function (_Text2) {
    _inherits$1(TextNode, _Text2);
    var _super2 = _createSuper(TextNode);
    function TextNode(children, length) {
      var _this2;
      _classCallCheck(this, TextNode);
      _this2 = _super2.call(this);
      _this2.children = children;
      _this2.length = length;
      _this2.lines = 0;
      var _iterator3 = _createForOfIteratorHelper(children),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var child = _step3.value;
          _this2.lines += child.lines;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return _this2;
    }
    _createClass(TextNode, [{
      key: "lineInner",
      value: function lineInner(target, isLine, line, offset) {
        for (var i = 0;; i++) {
          var child = this.children[i],
            end = offset + child.length,
            endLine = line + child.lines - 1;
          if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);
          offset = end + 1;
          line = endLine + 1;
        }
      }
    }, {
      key: "decompose",
      value: function decompose(from, to, target, open) {
        for (var i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
          var child = this.children[i],
            end = pos + child.length;
          if (from <= end && to >= pos) {
            var childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));
            if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);
          }
          pos = end + 1;
        }
      }
    }, {
      key: "replace",
      value: function replace(from, to, text) {
        if (text.lines < this.lines) for (var i = 0, pos = 0; i < this.children.length; i++) {
          var child = this.children[i],
            end = pos + child.length;
          // Fast path: if the change only affects one child and the
          // child's size remains in the acceptable range, only update
          // that child
          if (from >= pos && to <= end) {
            var updated = child.replace(from - pos, to - pos, text);
            var totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 /* Tree.BranchShift */ - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */ + 1) {
              var copy = this.children.slice();
              copy[i] = updated;
              return new TextNode(copy, this.length - (to - from) + text.length);
            }
            return _get(_getPrototypeOf(TextNode.prototype), "replace", this).call(this, pos, end, updated);
          }
          pos = end + 1;
        }
        return _get(_getPrototypeOf(TextNode.prototype), "replace", this).call(this, from, to, text);
      }
    }, {
      key: "sliceString",
      value: function sliceString(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
        var lineSep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "\n";
        var result = "";
        for (var i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
          var child = this.children[i],
            end = pos + child.length;
          if (pos > from && i) result += lineSep;
          if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);
          pos = end + 1;
        }
        return result;
      }
    }, {
      key: "flatten",
      value: function flatten(target) {
        var _iterator4 = _createForOfIteratorHelper(this.children),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var child = _step4.value;
            child.flatten(target);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }, {
      key: "scanIdentical",
      value: function scanIdentical(other, dir) {
        if (!(other instanceof TextNode)) return 0;
        var length = 0;
        var _ref = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1],
          _ref2 = _slicedToArray$1(_ref, 4),
          iA = _ref2[0],
          iB = _ref2[1],
          eA = _ref2[2],
          eB = _ref2[3];
        for (;; iA += dir, iB += dir) {
          if (iA == eA || iB == eB) return length;
          var chA = this.children[iA],
            chB = other.children[iB];
          if (chA != chB) return length + chA.scanIdentical(chB, dir);
          length += chA.length + 1;
        }
      }
    }], [{
      key: "from",
      value: function from(children) {
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : children.reduce(function (l, ch) {
          return l + ch.length + 1;
        }, -1);
        var lines = 0;
        var _iterator5 = _createForOfIteratorHelper(children),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _ch = _step5.value;
            lines += _ch.lines;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        if (lines < 32 /* Tree.Branch */) {
          var flat = [];
          var _iterator6 = _createForOfIteratorHelper(children),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var ch = _step6.value;
              ch.flatten(flat);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          return new TextLeaf(flat, length);
        }
        var chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */),
          maxChunk = chunk << 1,
          minChunk = chunk >> 1;
        var chunked = [],
          currentLines = 0,
          currentLen = -1,
          currentChunk = [];
        function add(child) {
          var last;
          if (child.lines > maxChunk && child instanceof TextNode) {
            var _iterator7 = _createForOfIteratorHelper(child.children),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var node = _step7.value;
                add(node);
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
            flush();
            chunked.push(child);
          } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */) {
            currentLines += child.lines;
            currentLen += child.length + 1;
            currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
          } else {
            if (currentLines + child.lines > chunk) flush();
            currentLines += child.lines;
            currentLen += child.length + 1;
            currentChunk.push(child);
          }
        }
        function flush() {
          if (currentLines == 0) return;
          chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
          currentLen = -1;
          currentLines = currentChunk.length = 0;
        }
        var _iterator8 = _createForOfIteratorHelper(children),
          _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var child = _step8.value;
            add(child);
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
      }
    }]);
    return TextNode;
  }(Text);
  Text.empty = /*@__PURE__*/new TextLeaf([""], 0);
  function textLength(text) {
    var length = -1;
    var _iterator9 = _createForOfIteratorHelper(text),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var line = _step9.value;
        length += line.length + 1;
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
    return length;
  }
  function appendText(text, target) {
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e9;
    for (var pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
      var line = text[i],
        end = pos + line.length;
      if (end >= from) {
        if (end > to) line = line.slice(0, to - pos);
        if (pos < from) line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
  }
  var RawTextCursor = /*#__PURE__*/function () {
    function RawTextCursor(text) {
      var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      _classCallCheck(this, RawTextCursor);
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    _createClass(RawTextCursor, [{
      key: "nextInner",
      value: function nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for (;;) {
          var last = this.nodes.length - 1;
          var top = this.nodes[last],
            offsetValue = this.offsets[last],
            offset = offsetValue >> 1;
          var size = top instanceof TextLeaf ? top.text.length : top.children.length;
          if (offset == (dir > 0 ? size : 0)) {
            if (last == 0) {
              this.done = true;
              this.value = "";
              return this;
            }
            if (dir > 0) this.offsets[last - 1]++;
            this.nodes.pop();
            this.offsets.pop();
          } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
            this.offsets[last] += dir;
            if (skip == 0) {
              this.lineBreak = true;
              this.value = "\n";
              return this;
            }
            skip--;
          } else if (top instanceof TextLeaf) {
            // Move to the next string
            var next = top.text[offset + (dir < 0 ? -1 : 0)];
            this.offsets[last] += dir;
            if (next.length > Math.max(0, skip)) {
              this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
              return this;
            }
            skip -= next.length;
          } else {
            var _next = top.children[offset + (dir < 0 ? -1 : 0)];
            if (skip > _next.length) {
              skip -= _next.length;
              this.offsets[last] += dir;
            } else {
              if (dir < 0) this.offsets[last]--;
              this.nodes.push(_next);
              this.offsets.push(dir > 0 ? 1 : (_next instanceof TextLeaf ? _next.text.length : _next.children.length) << 1);
            }
          }
        }
      }
    }, {
      key: "next",
      value: function next() {
        var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        if (skip < 0) {
          this.nextInner(-skip, -this.dir);
          skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
      }
    }]);
    return RawTextCursor;
  }();
  var PartialTextCursor = /*#__PURE__*/function () {
    function PartialTextCursor(text, start, end) {
      _classCallCheck(this, PartialTextCursor);
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
      this.pos = start > end ? text.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    _createClass(PartialTextCursor, [{
      key: "nextInner",
      value: function nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
          this.value = "";
          this.done = true;
          return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        var limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit) skip = limit;
        limit -= skip;
        var _this$cursor$next = this.cursor.next(skip),
          value = _this$cursor$next.value;
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
      }
    }, {
      key: "next",
      value: function next() {
        var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        if (skip < 0) skip = Math.max(skip, this.from - this.pos);else if (skip > 0) skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
      }
    }, {
      key: "lineBreak",
      get: function get() {
        return this.cursor.lineBreak && this.value != "";
      }
    }]);
    return PartialTextCursor;
  }();
  var LineCursor = /*#__PURE__*/function () {
    function LineCursor(inner) {
      _classCallCheck(this, LineCursor);
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    _createClass(LineCursor, [{
      key: "next",
      value: function next() {
        var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var _this$inner$next = this.inner.next(skip),
          done = _this$inner$next.done,
          lineBreak = _this$inner$next.lineBreak,
          value = _this$inner$next.value;
        if (done) {
          this.done = true;
          this.value = "";
        } else if (lineBreak) {
          if (this.afterBreak) {
            this.value = "";
          } else {
            this.afterBreak = true;
            this.next();
          }
        } else {
          this.value = value;
          this.afterBreak = false;
        }
        return this;
      }
    }, {
      key: "lineBreak",
      get: function get() {
        return false;
      }
    }]);
    return LineCursor;
  }();
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function () {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function () {
      return this;
    };
  }
  /**
  This type describes a line in the document. It is created
  on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).
  */
  var Line = /*#__PURE__*/function () {
    /**
    @internal
    */
    function Line(
    /**
    The position of the start of the line.
    */
    from,
    /**
    The position at the end of the line (_before_ the line break,
    or at the end of document for the last line).
    */
    to,
    /**
    This line's line number (1-based).
    */
    number,
    /**
    The line's content.
    */
    text) {
      _classCallCheck(this, Line);
      this.from = from;
      this.to = to;
      this.number = number;
      this.text = text;
    }
    /**
    The length of the line (not including any line break after it).
    */
    _createClass(Line, [{
      key: "length",
      get: function get() {
        return this.to - this.from;
      }
    }]);
    return Line;
  }(); // Compressed representation of the Grapheme_Cluster_Break=Extend
  // information from
  // http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
  // Each pair of elements represents a range, as an offet from the
  // previous range and a length. Numbers are in base-36, with the empty
  // string being a shorthand for 1.
  var extend = /*@__PURE__*/"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(function (s) {
    return s ? parseInt(s, 36) : 1;
  });
  // Convert offsets into absolute values
  for (var i$1 = 1; i$1 < extend.length; i$1++) extend[i$1] += extend[i$1 - 1];
  function isExtendingChar(code) {
    for (var _i = 1; _i < extend.length; _i += 2) if (extend[_i] > code) return extend[_i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 0x1F1E6 && code <= 0x1F1FF;
  }
  var ZWJ = 0x200d;
  /**
  Returns a next grapheme cluster break _after_ (not equal to)
  `pos`, if `forward` is true, or before otherwise. Returns `pos`
  itself if no further cluster break is available in the string.
  Moves across surrogate pairs, extending characters (when
  `includeExtending` is true), characters joined with zero-width
  joiners, and flag emoji.
  */
  function findClusterBreak(str, pos) {
    var forward = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var includeExtending = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length) return pos;
    // If pos is in the middle of a surrogate pair, move to its start
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
    var prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      var next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        var countBefore = 0,
          _i2 = pos - 2;
        while (_i2 >= 0 && isRegionalIndicator(codePointAt(str, _i2))) {
          countBefore++;
          _i2 -= 2;
        }
        if (countBefore % 2 == 0) break;else pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      var found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos) return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 0xDC00 && ch < 0xE000;
  }
  function surrogateHigh(ch) {
    return ch >= 0xD800 && ch < 0xDC00;
  }
  /**
  Find the code point at the given position in a string (like the
  [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
  string method).
  */
  function codePointAt(str, pos) {
    var code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
    var code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1)) return code0;
    return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;
  }
  /**
  Given a Unicode codepoint, return the JavaScript string that
  respresents it (like
  [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
  */
  function fromCodePoint(code) {
    if (code <= 0xffff) return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
  }
  /**
  The amount of positions a character takes up a JavaScript string.
  */
  function codePointSize(code) {
    return code < 0x10000 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  /**
  Distinguishes different ways in which positions can be mapped.
  */
  var MapMode = /*@__PURE__*/function (MapMode) {
    /**
    Map a position to a valid new position, even when its context
    was deleted.
    */
    MapMode[MapMode["Simple"] = 0] = "Simple";
    /**
    Return null if deletion happens across the position.
    */
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    /**
    Return null if the character _before_ the position is deleted.
    */
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    /**
    Return null if the character _after_ the position is deleted.
    */
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
    return MapMode;
  }(MapMode || (MapMode = {}));
  /**
  A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
  that doesn't store the inserted text. As such, it can't be
  applied, but is cheaper to store and manipulate.
  */
  var ChangeDesc = /*#__PURE__*/function () {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    function ChangeDesc(
    /**
    @internal
    */
    sections) {
      _classCallCheck(this, ChangeDesc);
      this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    _createClass(ChangeDesc, [{
      key: "length",
      get: function get() {
        var result = 0;
        for (var _i3 = 0; _i3 < this.sections.length; _i3 += 2) result += this.sections[_i3];
        return result;
      }
      /**
      The length of the document after the change.
      */
    }, {
      key: "newLength",
      get: function get() {
        var result = 0;
        for (var _i4 = 0; _i4 < this.sections.length; _i4 += 2) {
          var ins = this.sections[_i4 + 1];
          result += ins < 0 ? this.sections[_i4] : ins;
        }
        return result;
      }
      /**
      False when there are actual changes in this set.
      */
    }, {
      key: "empty",
      get: function get() {
        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
      }
      /**
      Iterate over the unchanged parts left by these changes. `posA`
      provides the position of the range in the old document, `posB`
      the new position in the changed document.
      */
    }, {
      key: "iterGaps",
      value: function iterGaps(f) {
        for (var _i5 = 0, posA = 0, posB = 0; _i5 < this.sections.length;) {
          var len = this.sections[_i5++],
            ins = this.sections[_i5++];
          if (ins < 0) {
            f(posA, posB, len);
            posB += len;
          } else {
            posB += ins;
          }
          posA += len;
        }
      }
      /**
      Iterate over the ranges changed by these changes. (See
      [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
      variant that also provides you with the inserted text.)
      `fromA`/`toA` provides the extent of the change in the starting
      document, `fromB`/`toB` the extent of the replacement in the
      changed document.
      
      When `individual` is true, adjacent changes (which are kept
      separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
      reported separately.
      */
    }, {
      key: "iterChangedRanges",
      value: function iterChangedRanges(f) {
        var individual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        _iterChanges(this, f, individual);
      }
      /**
      Get a description of the inverted form of these changes.
      */
    }, {
      key: "invertedDesc",
      get: function get() {
        var sections = [];
        for (var _i6 = 0; _i6 < this.sections.length;) {
          var len = this.sections[_i6++],
            ins = this.sections[_i6++];
          if (ins < 0) sections.push(len, ins);else sections.push(ins, len);
        }
        return new ChangeDesc(sections);
      }
      /**
      Compute the combined effect of applying another set of changes
      after this one. The length of the document after this set should
      match the length before `other`.
      */
    }, {
      key: "composeDesc",
      value: function composeDesc(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other);
      }
      /**
      Map this description, which should start with the same document
      as `other`, over another set of changes, so that it can be
      applied after it. When `before` is true, map as if the changes
      in `other` happened before the ones in `this`.
      */
    }, {
      key: "mapDesc",
      value: function mapDesc(other) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return other.empty ? this : mapSet(this, other, before);
      }
    }, {
      key: "mapPos",
      value: function mapPos(pos) {
        var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MapMode.Simple;
        var posA = 0,
          posB = 0;
        for (var _i7 = 0; _i7 < this.sections.length;) {
          var len = this.sections[_i7++],
            ins = this.sections[_i7++],
            endA = posA + len;
          if (ins < 0) {
            if (endA > pos) return posB + (pos - posA);
            posB += len;
          } else {
            if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;
            if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;
            posB += ins;
          }
          posA = endA;
        }
        if (pos > posA) throw new RangeError("Position ".concat(pos, " is out of range for changeset of length ").concat(posA));
        return posB;
      }
      /**
      Check whether these changes touch a given range. When one of the
      changes entirely covers the range, the string `"cover"` is
      returned.
      */
    }, {
      key: "touchesRange",
      value: function touchesRange(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
        for (var _i8 = 0, pos = 0; _i8 < this.sections.length && pos <= to;) {
          var len = this.sections[_i8++],
            ins = this.sections[_i8++],
            end = pos + len;
          if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? "cover" : true;
          pos = end;
        }
        return false;
      }
      /**
      @internal
      */
    }, {
      key: "toString",
      value: function toString() {
        var result = "";
        for (var _i9 = 0; _i9 < this.sections.length;) {
          var len = this.sections[_i9++],
            ins = this.sections[_i9++];
          result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
      }
      /**
      Serialize this change desc to a JSON-representable value.
      */
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.sections;
      }
      /**
      Create a change desc from its JSON representation (as produced
      by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
      */
    }], [{
      key: "fromJSON",
      value: function fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some(function (a) {
          return typeof a != "number";
        })) throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
      }
      /**
      @internal
      */
    }, {
      key: "create",
      value: function create(sections) {
        return new ChangeDesc(sections);
      }
    }]);
    return ChangeDesc;
  }();
  /**
  A change set represents a group of modifications to a document. It
  stores the document length, and can only be applied to documents
  with exactly that length.
  */
  var ChangeSet = /*#__PURE__*/function (_ChangeDesc) {
    _inherits$1(ChangeSet, _ChangeDesc);
    var _super3 = _createSuper(ChangeSet);
    function ChangeSet(sections,
    /**
    @internal
    */
    inserted) {
      var _this3;
      _classCallCheck(this, ChangeSet);
      _this3 = _super3.call(this, sections);
      _this3.inserted = inserted;
      return _this3;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    _createClass(ChangeSet, [{
      key: "apply",
      value: function apply(doc) {
        if (this.length != doc.length) throw new RangeError("Applying change set to a document with the wrong length");
        _iterChanges(this, function (fromA, toA, fromB, _toB, text) {
          return doc = doc.replace(fromB, fromB + (toA - fromA), text);
        }, false);
        return doc;
      }
    }, {
      key: "mapDesc",
      value: function mapDesc(other) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return mapSet(this, other, before, true);
      }
      /**
      Given the document as it existed _before_ the changes, return a
      change set that represents the inverse of this set, which could
      be used to go from the document created by the changes back to
      the document as it existed before the changes.
      */
    }, {
      key: "invert",
      value: function invert(doc) {
        var sections = this.sections.slice(),
          inserted = [];
        for (var _i10 = 0, pos = 0; _i10 < sections.length; _i10 += 2) {
          var len = sections[_i10],
            ins = sections[_i10 + 1];
          if (ins >= 0) {
            sections[_i10] = ins;
            sections[_i10 + 1] = len;
            var index = _i10 >> 1;
            while (inserted.length < index) inserted.push(Text.empty);
            inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
          }
          pos += len;
        }
        return new ChangeSet(sections, inserted);
      }
      /**
      Combine two subsequent change sets into a single set. `other`
      must start in the document produced by `this`. If `this` goes
      `docA`  `docB` and `other` represents `docB`  `docC`, the
      returned value will represent the change `docA`  `docC`.
      */
    }, {
      key: "compose",
      value: function compose(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other, true);
      }
      /**
      Given another change set starting in the same document, maps this
      change set over the other, producing a new change set that can be
      applied to the document produced by applying `other`. When
      `before` is `true`, order changes as if `this` comes before
      `other`, otherwise (the default) treat `other` as coming first.
      
      Given two changes `A` and `B`, `A.compose(B.map(A))` and
      `B.compose(A.map(B, true))` will produce the same document. This
      provides a basic form of [operational
      transformation](https://en.wikipedia.org/wiki/Operational_transformation),
      and can be used for collaborative editing.
      */
    }, {
      key: "map",
      value: function map(other) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return other.empty ? this : mapSet(this, other, before, true);
      }
      /**
      Iterate over the changed ranges in the document, calling `f` for
      each, with the range in the original document (`fromA`-`toA`)
      and the range that replaces it in the new document
      (`fromB`-`toB`).
      
      When `individual` is true, adjacent changes are reported
      separately.
      */
    }, {
      key: "iterChanges",
      value: function iterChanges(f) {
        var individual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        _iterChanges(this, f, individual);
      }
      /**
      Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
      set.
      */
    }, {
      key: "desc",
      get: function get() {
        return ChangeDesc.create(this.sections);
      }
      /**
      @internal
      */
    }, {
      key: "filter",
      value: function filter(ranges) {
        var resultSections = [],
          resultInserted = [],
          filteredSections = [];
        var iter = new SectionIter(this);
        done: for (var _i11 = 0, pos = 0;;) {
          var next = _i11 == ranges.length ? 1e9 : ranges[_i11++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done) break done;
            var len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            var ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0) addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          var end = ranges[_i11++];
          while (pos < end) {
            if (iter.done) break done;
            var _len = Math.min(iter.len, end - pos);
            addSection(resultSections, _len, -1);
            addSection(filteredSections, _len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(_len);
            pos += _len;
          }
        }
        return {
          changes: new ChangeSet(resultSections, resultInserted),
          filtered: ChangeDesc.create(filteredSections)
        };
      }
      /**
      Serialize this change set to a JSON-representable value.
      */
    }, {
      key: "toJSON",
      value: function toJSON() {
        var parts = [];
        for (var _i12 = 0; _i12 < this.sections.length; _i12 += 2) {
          var len = this.sections[_i12],
            ins = this.sections[_i12 + 1];
          if (ins < 0) parts.push(len);else if (ins == 0) parts.push([len]);else parts.push([len].concat(this.inserted[_i12 >> 1].toJSON()));
        }
        return parts;
      }
      /**
      Create a change set for the given changes, for a document of the
      given length, using `lineSep` as line separator.
      */
    }], [{
      key: "of",
      value: function of(changes, length, lineSep) {
        var sections = [],
          inserted = [],
          pos = 0;
        var total = null;
        function flush() {
          var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          if (!force && !sections.length) return;
          if (pos < length) addSection(sections, length - pos, -1);
          var set = new ChangeSet(sections, inserted);
          total = total ? total.compose(set.map(total)) : set;
          sections = [];
          inserted = [];
          pos = 0;
        }
        function process(spec) {
          if (Array.isArray(spec)) {
            var _iterator10 = _createForOfIteratorHelper(spec),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var sub = _step10.value;
                process(sub);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          } else if (spec instanceof ChangeSet) {
            if (spec.length != length) throw new RangeError("Mismatched change set length (got ".concat(spec.length, ", expected ").concat(length, ")"));
            flush();
            total = total ? total.compose(spec.map(total)) : spec;
          } else {
            var from = spec.from,
              _spec$to = spec.to,
              to = _spec$to === void 0 ? from : _spec$to,
              _insert = spec.insert;
            if (from > to || from < 0 || to > length) throw new RangeError("Invalid change range ".concat(from, " to ").concat(to, " (in doc of length ").concat(length, ")"));
            var insText = !_insert ? Text.empty : typeof _insert == "string" ? Text.of(_insert.split(lineSep || DefaultSplit)) : _insert;
            var insLen = insText.length;
            if (from == to && insLen == 0) return;
            if (from < pos) flush();
            if (from > pos) addSection(sections, from - pos, -1);
            addSection(sections, to - from, insLen);
            addInsert(inserted, sections, insText);
            pos = to;
          }
        }
        process(changes);
        flush(!total);
        return total;
      }
      /**
      Create an empty changeset of the given length.
      */
    }, {
      key: "empty",
      value: function empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
      }
      /**
      Create a changeset from its JSON representation (as produced by
      [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
      */
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        if (!Array.isArray(json)) throw new RangeError("Invalid JSON representation of ChangeSet");
        var sections = [],
          inserted = [];
        for (var _i13 = 0; _i13 < json.length; _i13++) {
          var part = json[_i13];
          if (typeof part == "number") {
            sections.push(part, -1);
          } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some(function (e, i) {
            return i && typeof e != "string";
          })) {
            throw new RangeError("Invalid JSON representation of ChangeSet");
          } else if (part.length == 1) {
            sections.push(part[0], 0);
          } else {
            while (inserted.length < _i13) inserted.push(Text.empty);
            inserted[_i13] = Text.of(part.slice(1));
            sections.push(part[0], inserted[_i13].length);
          }
        }
        return new ChangeSet(sections, inserted);
      }
      /**
      @internal
      */
    }, {
      key: "createSet",
      value: function createSet(sections, inserted) {
        return new ChangeSet(sections, inserted);
      }
    }]);
    return ChangeSet;
  }(ChangeDesc);
  function addSection(sections, len, ins) {
    var forceJoin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (len == 0 && ins <= 0) return;
    var last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else sections.push(len, ins);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0) return;
    var index = sections.length - 2 >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index) values.push(Text.empty);
      values.push(value);
    }
  }
  function _iterChanges(desc, f, individual) {
    var inserted = desc.inserted;
    for (var posA = 0, posB = 0, _i14 = 0; _i14 < desc.sections.length;) {
      var len = desc.sections[_i14++],
        ins = desc.sections[_i14++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        var endA = posA,
          endB = posB,
          _text = Text.empty;
        for (;;) {
          endA += len;
          endB += ins;
          if (ins && inserted) _text = _text.append(inserted[_i14 - 2 >> 1]);
          if (individual || _i14 == desc.sections.length || desc.sections[_i14 + 1] < 0) break;
          len = desc.sections[_i14++];
          ins = desc.sections[_i14++];
        }
        f(posA, endA, posB, endB, _text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before) {
    var mkSet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    // Produce a copy of setA that applies to the document after setB
    // has been applied (assuming both start at the same document).
    var sections = [],
      insert = mkSet ? [] : null;
    var a = new SectionIter(setA),
      b = new SectionIter(setB);
    // Iterate over both sets in parallel. inserted tracks, for changes
    // in A that have to be processed piece-by-piece, whether their
    // content has been inserted already, and refers to the section
    // index.
    for (var inserted = -1;;) {
      if (a.ins == -1 && b.ins == -1) {
        // Move across ranges skipped by both sets.
        var len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
        // If there's a change in B that comes before the next change in
        // A (ordered by start pos, then len, then before flag), skip
        // that (and process any changes in A it covers).
        var _len2 = b.len;
        addSection(sections, b.ins, -1);
        while (_len2) {
          var piece = Math.min(a.len, _len2);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert) addInsert(insert, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          _len2 -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        // Process the part of a change in A up to the start of the next
        // non-deletion change in B (if overlapping).
        var _len3 = 0,
          left = a.len;
        while (left) {
          if (b.ins == -1) {
            var _piece = Math.min(left, b.len);
            _len3 += _piece;
            left -= _piece;
            b.forward(_piece);
          } else if (b.ins == 0 && b.len < left) {
            left -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, _len3, inserted < a.i ? a.ins : 0);
        if (insert && inserted < a.i) addInsert(insert, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left);
      } else if (a.done && b.done) {
        return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB) {
    var mkSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var sections = [];
    var insert = mkSet ? [] : null;
    var a = new SectionIter(setA),
      b = new SectionIter(setB);
    for (var open = false;;) {
      if (a.done && b.done) {
        return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        // Deletion in A
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        // Insertion in B
        addSection(sections, 0, b.ins, open);
        if (insert) addInsert(insert, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        var len = Math.min(a.len2, b.len),
          sectionLen = sections.length;
        if (a.ins == -1) {
          var insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert && insB) addInsert(insert, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert) addInsert(insert, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert && !b.off) addInsert(insert, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = /*#__PURE__*/function () {
    function SectionIter(set) {
      _classCallCheck(this, SectionIter);
      this.set = set;
      this.i = 0;
      this.next();
    }
    _createClass(SectionIter, [{
      key: "next",
      value: function next() {
        var sections = this.set.sections;
        if (this.i < sections.length) {
          this.len = sections[this.i++];
          this.ins = sections[this.i++];
        } else {
          this.len = 0;
          this.ins = -2;
        }
        this.off = 0;
      }
    }, {
      key: "done",
      get: function get() {
        return this.ins == -2;
      }
    }, {
      key: "len2",
      get: function get() {
        return this.ins < 0 ? this.len : this.ins;
      }
    }, {
      key: "text",
      get: function get() {
        var inserted = this.set.inserted,
          index = this.i - 2 >> 1;
        return index >= inserted.length ? Text.empty : inserted[index];
      }
    }, {
      key: "textBit",
      value: function textBit(len) {
        var inserted = this.set.inserted,
          index = this.i - 2 >> 1;
        return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
      }
    }, {
      key: "forward",
      value: function forward(len) {
        if (len == this.len) this.next();else {
          this.len -= len;
          this.off += len;
        }
      }
    }, {
      key: "forward2",
      value: function forward2(len) {
        if (this.ins == -1) this.forward(len);else if (len == this.ins) this.next();else {
          this.ins -= len;
          this.off += len;
        }
      }
    }]);
    return SectionIter;
  }();
  /**
  A single selection range. When
  [`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
  is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
  multiple ranges. By default, selections hold exactly one range.
  */
  var SelectionRange = /*#__PURE__*/function () {
    function SelectionRange(
    /**
    The lower boundary of the range.
    */
    from,
    /**
    The upper boundary of the range.
    */
    to, flags) {
      _classCallCheck(this, SelectionRange);
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    /**
    The anchor of the rangethe side that doesn't move when you
    extend it.
    */
    _createClass(SelectionRange, [{
      key: "anchor",
      get: function get() {
        return this.flags & 16 /* RangeFlag.Inverted */ ? this.to : this.from;
      }
      /**
      The head of the range, which is moved when the range is
      [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
      */
    }, {
      key: "head",
      get: function get() {
        return this.flags & 16 /* RangeFlag.Inverted */ ? this.from : this.to;
      }
      /**
      True when `anchor` and `head` are at the same position.
      */
    }, {
      key: "empty",
      get: function get() {
        return this.from == this.to;
      }
      /**
      If this is a cursor that is explicitly associated with the
      character on one of its sides, this returns the side. -1 means
      the character before its position, 1 the character after, and 0
      means no association.
      */
    }, {
      key: "assoc",
      get: function get() {
        return this.flags & 4 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 8 /* RangeFlag.AssocAfter */ ? 1 : 0;
      }
      /**
      The bidirectional text level associated with this cursor, if
      any.
      */
    }, {
      key: "bidiLevel",
      get: function get() {
        var level = this.flags & 3 /* RangeFlag.BidiLevelMask */;
        return level == 3 ? null : level;
      }
      /**
      The goal column (stored vertical offset) associated with a
      cursor. This is used to preserve the vertical position when
      [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
      lines of different length.
      */
    }, {
      key: "goalColumn",
      get: function get() {
        var value = this.flags >> 5 /* RangeFlag.GoalColumnOffset */;
        return value == 33554431 /* RangeFlag.NoGoalColumn */ ? undefined : value;
      }
      /**
      Map this range through a change, producing a valid range in the
      updated document.
      */
    }, {
      key: "map",
      value: function map(change) {
        var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
        var from, to;
        if (this.empty) {
          from = to = change.mapPos(this.from, assoc);
        } else {
          from = change.mapPos(this.from, 1);
          to = change.mapPos(this.to, -1);
        }
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
      }
      /**
      Extend this range to cover at least `from` to `to`.
      */
    }, {
      key: "extend",
      value: function extend(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
        if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);
        var head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return EditorSelection.range(this.anchor, head);
      }
      /**
      Compare this range to another range.
      */
    }, {
      key: "eq",
      value: function eq(other) {
        return this.anchor == other.anchor && this.head == other.head;
      }
      /**
      Return a JSON-serializable object representing the range.
      */
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          anchor: this.anchor,
          head: this.head
        };
      }
      /**
      Convert a JSON representation of a range to a `SelectionRange`
      instance.
      */
    }], [{
      key: "fromJSON",
      value: function fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
      }
      /**
      @internal
      */
    }, {
      key: "create",
      value: function create(from, to, flags) {
        return new SelectionRange(from, to, flags);
      }
    }]);
    return SelectionRange;
  }();
  /**
  An editor selection holds one or more selection ranges.
  */
  var EditorSelection = /*#__PURE__*/function () {
    function EditorSelection(
    /**
    The ranges in the selection, sorted by position. Ranges cannot
    overlap (but they may touch, if they aren't empty).
    */
    ranges,
    /**
    The index of the _main_ range in the selection (which is
    usually the range that was added last).
    */
    mainIndex) {
      _classCallCheck(this, EditorSelection);
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    _createClass(EditorSelection, [{
      key: "map",
      value: function map(change) {
        var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
        if (change.empty) return this;
        return EditorSelection.create(this.ranges.map(function (r) {
          return r.map(change, assoc);
        }), this.mainIndex);
      }
      /**
      Compare this selection to another selection.
      */
    }, {
      key: "eq",
      value: function eq(other) {
        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;
        for (var _i15 = 0; _i15 < this.ranges.length; _i15++) if (!this.ranges[_i15].eq(other.ranges[_i15])) return false;
        return true;
      }
      /**
      Get the primary selection range. Usually, you should make sure
      your code applies to _all_ ranges, by using methods like
      [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
      */
    }, {
      key: "main",
      get: function get() {
        return this.ranges[this.mainIndex];
      }
      /**
      Make sure the selection only has one range. Returns a selection
      holding only the main range from this selection.
      */
    }, {
      key: "asSingle",
      value: function asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
      }
      /**
      Extend this selection with an extra range.
      */
    }, {
      key: "addRange",
      value: function addRange(range) {
        var main = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
      }
      /**
      Replace a given range with another range, and then normalize the
      selection to merge and sort ranges if necessary.
      */
    }, {
      key: "replaceRange",
      value: function replaceRange(range) {
        var which = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.mainIndex;
        var ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
      }
      /**
      Convert this selection to an object that can be serialized to
      JSON.
      */
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          ranges: this.ranges.map(function (r) {
            return r.toJSON();
          }),
          main: this.mainIndex
        };
      }
      /**
      Create a selection from a JSON representation.
      */
    }], [{
      key: "fromJSON",
      value: function fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map(function (r) {
          return SelectionRange.fromJSON(r);
        }), json.main);
      }
      /**
      Create a selection holding a single range.
      */
    }, {
      key: "single",
      value: function single(anchor) {
        var head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchor;
        return new EditorSelection([EditorSelection.range(anchor, head)], 0);
      }
      /**
      Sort and merge the given set of ranges, creating a valid
      selection.
      */
    }, {
      key: "create",
      value: function create(ranges) {
        var mainIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        if (ranges.length == 0) throw new RangeError("A selection needs at least one range");
        for (var pos = 0, _i16 = 0; _i16 < ranges.length; _i16++) {
          var range = ranges[_i16];
          if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);
          pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
      }
      /**
      Create a cursor selection range at the given position. You can
      safely ignore the optional arguments in most situations.
      */
    }, {
      key: "cursor",
      value: function cursor(pos) {
        var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var bidiLevel = arguments.length > 2 ? arguments[2] : undefined;
        var goalColumn = arguments.length > 3 ? arguments[3] : undefined;
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* RangeFlag.AssocBefore */ : 8 /* RangeFlag.AssocAfter */) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */);
      }
      /**
      Create a selection range.
      */
    }, {
      key: "range",
      value: function range(anchor, head, goalColumn, bidiLevel) {
        var flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */ | (bidiLevel == null ? 3 : Math.min(2, bidiLevel));
        return head < anchor ? SelectionRange.create(head, anchor, 16 /* RangeFlag.Inverted */ | 8 /* RangeFlag.AssocAfter */ | flags) : SelectionRange.create(anchor, head, (head > anchor ? 4 /* RangeFlag.AssocBefore */ : 0) | flags);
      }
      /**
      @internal
      */
    }, {
      key: "normalized",
      value: function normalized(ranges) {
        var mainIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var main = ranges[mainIndex];
        ranges.sort(function (a, b) {
          return a.from - b.from;
        });
        mainIndex = ranges.indexOf(main);
        for (var _i17 = 1; _i17 < ranges.length; _i17++) {
          var range = ranges[_i17],
            prev = ranges[_i17 - 1];
          if (range.empty ? range.from <= prev.to : range.from < prev.to) {
            var from = prev.from,
              to = Math.max(range.to, prev.to);
            if (_i17 <= mainIndex) mainIndex--;
            ranges.splice(--_i17, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
          }
        }
        return new EditorSelection(ranges, mainIndex);
      }
    }]);
    return EditorSelection;
  }();
  function checkSelection(selection, docLength) {
    var _iterator11 = _createForOfIteratorHelper(selection.ranges),
      _step11;
    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var range = _step11.value;
        if (range.to > docLength) throw new RangeError("Selection points outside of document");
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }
  }
  var nextID = 0;
  /**
  A facet is a labeled value that is associated with an editor
  state. It takes inputs from any number of extensions, and combines
  those into a single output value.

  Examples of uses of facets are the [tab
  size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor
  attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update
  listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).
  */
  var Facet = /*#__PURE__*/function () {
    function Facet(
    /**
    @internal
    */
    combine,
    /**
    @internal
    */
    compareInput,
    /**
    @internal
    */
    compare, isStatic, enables) {
      _classCallCheck(this, Facet);
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare;
      this.isStatic = isStatic;
      /**
      @internal
      */
      this.id = nextID++;
      this["default"] = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Define a new facet.
    */
    _createClass(Facet, [{
      key: "of",
      value:
      /**
      Returns an extension that adds the given value to this facet.
      */
      function of(value) {
        return new FacetProvider([], this, 0 /* Provider.Static */, value);
      }
      /**
      Create an extension that computes a value for the facet from a
      state. You must take care to declare the parts of the state that
      this value depends on, since your function is only called again
      for a new state when one of those parts changed.
      
      In cases where your value depends only on a single field, you'll
      want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
      */
    }, {
      key: "compute",
      value: function compute(deps, get) {
        if (this.isStatic) throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);
      }
      /**
      Create an extension that computes zero or more values for this
      facet from a state.
      */
    }, {
      key: "computeN",
      value: function computeN(deps, get) {
        if (this.isStatic) throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);
      }
    }, {
      key: "from",
      value: function from(field, get) {
        if (!get) get = function get(x) {
          return x;
        };
        return this.compute([field], function (state) {
          return get(state.field(field));
        });
      }
    }], [{
      key: "define",
      value: function define() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return new Facet(config.combine || function (a) {
          return a;
        }, config.compareInput || function (a, b) {
          return a === b;
        }, config.compare || (!config.combine ? sameArray$1 : function (a, b) {
          return a === b;
        }), !!config["static"], config.enables);
      }
    }]);
    return Facet;
  }();
  function sameArray$1(a, b) {
    return a == b || a.length == b.length && a.every(function (e, i) {
      return e === b[i];
    });
  }
  var FacetProvider = /*#__PURE__*/function () {
    function FacetProvider(dependencies, facet, type, value) {
      _classCallCheck(this, FacetProvider);
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    _createClass(FacetProvider, [{
      key: "dynamicSlot",
      value: function dynamicSlot(addresses) {
        var _this4 = this;
        var _a;
        var getter = this.value;
        var compare = this.facet.compareInput;
        var id = this.id,
          idx = addresses[id] >> 1,
          multi = this.type == 2 /* Provider.Multi */;
        var depDoc = false,
          depSel = false,
          depAddrs = [];
        var _iterator12 = _createForOfIteratorHelper(this.dependencies),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var dep = _step12.value;
            if (dep == "doc") depDoc = true;else if (dep == "selection") depSel = true;else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        return {
          create: function create(state) {
            state.values[idx] = getter(state);
            return 1 /* SlotStatus.Changed */;
          },
          update: function update(state, tr) {
            if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
              var newVal = getter(state);
              if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                state.values[idx] = newVal;
                return 1 /* SlotStatus.Changed */;
              }
            }

            return 0;
          },
          reconfigure: function reconfigure(state, oldState) {
            var newVal,
              oldAddr = oldState.config.address[id];
            if (oldAddr != null) {
              var oldVal = getAddr(oldState, oldAddr);
              if (_this4.dependencies.every(function (dep) {
                return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
              }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
                state.values[idx] = oldVal;
                return 0;
              }
            } else {
              newVal = getter(state);
            }
            state.values[idx] = newVal;
            return 1 /* SlotStatus.Changed */;
          }
        };
      }
    }]);
    return FacetProvider;
  }();
  function compareArray(a, b, compare) {
    if (a.length != b.length) return false;
    for (var _i18 = 0; _i18 < a.length; _i18++) if (!compare(a[_i18], b[_i18])) return false;
    return true;
  }
  function ensureAll(state, addrs) {
    var changed = false;
    var _iterator13 = _createForOfIteratorHelper(addrs),
      _step13;
    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var addr = _step13.value;
        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */) changed = true;
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    var providerAddrs = providers.map(function (p) {
      return addresses[p.id];
    });
    var providerTypes = providers.map(function (p) {
      return p.type;
    });
    var dynamic = providerAddrs.filter(function (p) {
      return !(p & 1);
    });
    var idx = addresses[facet.id] >> 1;
    function get(state) {
      var values = [];
      for (var _i19 = 0; _i19 < providerAddrs.length; _i19++) {
        var value = getAddr(state, providerAddrs[_i19]);
        if (providerTypes[_i19] == 2 /* Provider.Multi */) {
          var _iterator14 = _createForOfIteratorHelper(value),
            _step14;
          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var val = _step14.value;
              values.push(val);
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
        } else values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create: function create(state) {
        var _iterator15 = _createForOfIteratorHelper(providerAddrs),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var addr = _step15.value;
            ensureAddr(state, addr);
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
        state.values[idx] = get(state);
        return 1 /* SlotStatus.Changed */;
      },
      update: function update(state, tr) {
        if (!ensureAll(state, dynamic)) return 0;
        var value = get(state);
        if (facet.compare(value, state.values[idx])) return 0;
        state.values[idx] = value;
        return 1 /* SlotStatus.Changed */;
      },
      reconfigure: function reconfigure(state, oldState) {
        var depChanged = ensureAll(state, providerAddrs);
        var oldProviders = oldState.config.facets[facet.id],
          oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        var value = get(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1 /* SlotStatus.Changed */;
      }
    };
  }

  var initField = /*@__PURE__*/Facet.define({
    "static": true
  });
  /**
  Fields can store additional information in an editor state, and
  keep it in sync with the rest of the state.
  */
  var StateField = /*#__PURE__*/function () {
    function StateField(
    /**
    @internal
    */
    id, createF, updateF, compareF,
    /**
    @internal
    */
    spec) {
      _classCallCheck(this, StateField);
      this.id = id;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      /**
      @internal
      */
      this.provides = undefined;
    }
    /**
    Define a state field.
    */
    _createClass(StateField, [{
      key: "create",
      value: function create(state) {
        var _this5 = this;
        var init = state.facet(initField).find(function (i) {
          return i.field == _this5;
        });
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
      }
      /**
      @internal
      */
    }, {
      key: "slot",
      value: function slot(addresses) {
        var _this6 = this;
        var idx = addresses[this.id] >> 1;
        return {
          create: function create(state) {
            state.values[idx] = _this6.create(state);
            return 1 /* SlotStatus.Changed */;
          },

          update: function update(state, tr) {
            var oldVal = state.values[idx];
            var value = _this6.updateF(oldVal, tr);
            if (_this6.compareF(oldVal, value)) return 0;
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
          },

          reconfigure: function reconfigure(state, oldState) {
            if (oldState.config.address[_this6.id] != null) {
              state.values[idx] = oldState.field(_this6);
              return 0;
            }
            state.values[idx] = _this6.create(state);
            return 1 /* SlotStatus.Changed */;
          }
        };
      }
      /**
      Returns an extension that enables this field and overrides the
      way it is initialized. Can be useful when you need to provide a
      non-default starting value for the field.
      */
    }, {
      key: "init",
      value: function init(create) {
        return [this, initField.of({
          field: this,
          create: create
        })];
      }
      /**
      State field instances can be used as
      [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
      given state.
      */
    }, {
      key: "extension",
      get: function get() {
        return this;
      }
    }], [{
      key: "define",
      value: function define(config) {
        var field = new StateField(nextID++, config.create, config.update, config.compare || function (a, b) {
          return a === b;
        }, config);
        if (config.provide) field.provides = config.provide(field);
        return field;
      }
    }]);
    return StateField;
  }();
  var Prec_ = {
    lowest: 4,
    low: 3,
    "default": 2,
    high: 1,
    highest: 0
  };
  function prec(value) {
    return function (ext) {
      return new PrecExtension(ext, value);
    };
  }
  /**
  By default extensions are registered in the order they are found
  in the flattened form of nested array that was provided.
  Individual extension values can be assigned a precedence to
  override this. Extensions that do not have a precedence set get
  the precedence of the nearest parent with a precedence, or
  [`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
  final ordering of extensions is determined by first sorting by
  precedence and then by order within each precedence.
  */
  var Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: /*@__PURE__*/prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: /*@__PURE__*/prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    "default": /*@__PURE__*/prec(Prec_["default"]),
    /**
    A lower-than-default precedence.
    */
    low: /*@__PURE__*/prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: /*@__PURE__*/prec(Prec_.lowest)
  };
  var PrecExtension = /*#__PURE__*/_createClass(function PrecExtension(inner, prec) {
    _classCallCheck(this, PrecExtension);
    this.inner = inner;
    this.prec = prec;
  });
  /**
  Extension compartments can be used to make a configuration
  dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
  configuration in a compartment, you can later
  [replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
  transaction.
  */
  var Compartment = /*#__PURE__*/function () {
    function Compartment() {
      _classCallCheck(this, Compartment);
    }
    _createClass(Compartment, [{
      key: "of",
      value:
      /**
      Create an instance of this compartment to add to your [state
      configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
      */
      function of(ext) {
        return new CompartmentInstance(this, ext);
      }
      /**
      Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
      reconfigures this compartment.
      */
    }, {
      key: "reconfigure",
      value: function reconfigure(content) {
        return Compartment.reconfigure.of({
          compartment: this,
          extension: content
        });
      }
      /**
      Get the current content of the compartment in the state, or
      `undefined` if it isn't present.
      */
    }, {
      key: "get",
      value: function get(state) {
        return state.config.compartments.get(this);
      }
    }]);
    return Compartment;
  }();
  var CompartmentInstance = /*#__PURE__*/_createClass(function CompartmentInstance(compartment, inner) {
    _classCallCheck(this, CompartmentInstance);
    this.compartment = compartment;
    this.inner = inner;
  });
  var Configuration = /*#__PURE__*/function () {
    function Configuration(base, compartments, dynamicSlots, address, staticValues, facets) {
      _classCallCheck(this, Configuration);
      this.base = base;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0 /* SlotStatus.Unresolved */);
    }
    _createClass(Configuration, [{
      key: "staticFacet",
      value: function staticFacet(facet) {
        var addr = this.address[facet.id];
        return addr == null ? facet["default"] : this.staticValues[addr >> 1];
      }
    }], [{
      key: "resolve",
      value: function resolve(base, compartments, oldState) {
        var fields = [];
        var facets = Object.create(null);
        var newCompartments = new Map();
        var _iterator16 = _createForOfIteratorHelper(flatten(base, compartments, newCompartments)),
          _step16;
        try {
          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
            var ext = _step16.value;
            if (ext instanceof StateField) fields.push(ext);else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
        var address = Object.create(null);
        var staticValues = [];
        var dynamicSlots = [];
        var _loop = function _loop() {
          var field = _fields[_i20];
          address[field.id] = dynamicSlots.length << 1;
          dynamicSlots.push(function (a) {
            return field.slot(a);
          });
        };
        for (var _i20 = 0, _fields = fields; _i20 < _fields.length; _i20++) {
          _loop();
        }
        var oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        var _loop2 = function _loop2() {
          var providers = facets[id],
            facet = providers[0].facet;
          var oldProviders = oldFacets && oldFacets[id] || [];
          if (providers.every(function (p) {
            return p.type == 0;
          } /* Provider.Static */)) {
            address[facet.id] = staticValues.length << 1 | 1;
            if (sameArray$1(oldProviders, providers)) {
              staticValues.push(oldState.facet(facet));
            } else {
              var value = facet.combine(providers.map(function (p) {
                return p.value;
              }));
              staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
            }
          } else {
            var _iterator17 = _createForOfIteratorHelper(providers),
              _step17;
            try {
              var _loop3 = function _loop3() {
                var p = _step17.value;
                if (p.type == 0 /* Provider.Static */) {
                  address[p.id] = staticValues.length << 1 | 1;
                  staticValues.push(p.value);
                } else {
                  address[p.id] = dynamicSlots.length << 1;
                  dynamicSlots.push(function (a) {
                    return p.dynamicSlot(a);
                  });
                }
              };
              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                _loop3();
              }
            } catch (err) {
              _iterator17.e(err);
            } finally {
              _iterator17.f();
            }
            address[facet.id] = dynamicSlots.length << 1;
            dynamicSlots.push(function (a) {
              return dynamicFacetSlot(a, facet, providers);
            });
          }
        };
        for (var id in facets) {
          _loop2();
        }
        var dynamic = dynamicSlots.map(function (f) {
          return f(address);
        });
        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
      }
    }]);
    return Configuration;
  }();
  function flatten(extension, compartments, newCompartments) {
    var result = [[], [], [], [], []];
    var seen = new Map();
    function inner(ext, prec) {
      var known = seen.get(ext);
      if (known != null) {
        if (known <= prec) return;
        var found = result[known].indexOf(ext);
        if (found > -1) result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance) newCompartments["delete"](ext.compartment);
      }
      seen.set(ext, prec);
      if (Array.isArray(ext)) {
        var _iterator18 = _createForOfIteratorHelper(ext),
          _step18;
        try {
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            var e = _step18.value;
            inner(e, prec);
          }
        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment)) throw new RangeError("Duplicate use of compartment in extensions");
        var content = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content);
        inner(content, prec);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec].push(ext);
        if (ext.provides) inner(ext.provides, prec);
      } else if (ext instanceof FacetProvider) {
        result[prec].push(ext);
        if (ext.facet.extensions) inner(ext.facet.extensions, Prec_["default"]);
      } else {
        var _content = ext.extension;
        if (!_content) throw new Error("Unrecognized extension value in extension set (".concat(ext, "). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks."));
        inner(_content, prec);
      }
    }
    inner(extension, Prec_["default"]);
    return result.reduce(function (a, b) {
      return a.concat(b);
    });
  }
  function ensureAddr(state, addr) {
    if (addr & 1) return 2 /* SlotStatus.Computed */;
    var idx = addr >> 1;
    var status = state.status[idx];
    if (status == 4 /* SlotStatus.Computing */) throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2 /* SlotStatus.Computed */) return status;
    state.status[idx] = 4 /* SlotStatus.Computing */;
    var changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /*@__PURE__*/Facet.define();
  var allowMultipleSelections = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.some(function (v) {
        return v;
      });
    },
    "static": true
  });
  var lineSeparator = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.length ? values[0] : undefined;
    },
    "static": true
  });
  var changeFilter = /*@__PURE__*/Facet.define();
  var transactionFilter = /*@__PURE__*/Facet.define();
  var transactionExtender = /*@__PURE__*/Facet.define();
  var readOnly = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.length ? values[0] : false;
    }
  });

  /**
  Annotations are tagged values that are used to add metadata to
  transactions in an extensible way. They should be used to model
  things that effect the entire transaction (such as its [time
  stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
  [origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
  _alongside_ the other changes made by the transaction, [state
  effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
  */
  var Annotation = /*#__PURE__*/function () {
    /**
    @internal
    */
    function Annotation(
    /**
    The annotation type.
    */
    type,
    /**
    The value of this annotation.
    */
    value) {
      _classCallCheck(this, Annotation);
      this.type = type;
      this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    _createClass(Annotation, null, [{
      key: "define",
      value: function define() {
        return new AnnotationType();
      }
    }]);
    return Annotation;
  }();
  /**
  Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
  */
  var AnnotationType = /*#__PURE__*/function () {
    function AnnotationType() {
      _classCallCheck(this, AnnotationType);
    }
    _createClass(AnnotationType, [{
      key: "of",
      value:
      /**
      Create an instance of this annotation.
      */
      function of(value) {
        return new Annotation(this, value);
      }
    }]);
    return AnnotationType;
  }();
  /**
  Representation of a type of state effect. Defined with
  [`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
  */
  var StateEffectType = /*#__PURE__*/function () {
    /**
    @internal
    */
    function StateEffectType(
    // The `any` types in these function types are there to work
    // around TypeScript issue #37631, where the type guard on
    // `StateEffect.is` mysteriously stops working when these properly
    // have type `Value`.
    /**
    @internal
    */
    map) {
      _classCallCheck(this, StateEffectType);
      this.map = map;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    _createClass(StateEffectType, [{
      key: "of",
      value: function of(value) {
        return new StateEffect(this, value);
      }
    }]);
    return StateEffectType;
  }();
  /**
  State effects can be used to represent additional effects
  associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
  are often useful to model changes to custom [state
  fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
  document or selection changes.
  */
  var StateEffect = /*#__PURE__*/function () {
    /**
    @internal
    */
    function StateEffect(
    /**
    @internal
    */
    type,
    /**
    The value of this effect.
    */
    value) {
      _classCallCheck(this, StateEffect);
      this.type = type;
      this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    _createClass(StateEffect, [{
      key: "map",
      value: function map(mapping) {
        var mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
      }
      /**
      Tells you whether this effect object is of a given
      [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
      */
    }, {
      key: "is",
      value: function is(type) {
        return this.type == type;
      }
      /**
      Define a new effect type. The type parameter indicates the type
      of values that his effect holds. It should be a type that
      doesn't include `undefined`, since that is used in
      [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
      removed.
      */
    }], [{
      key: "define",
      value: function define() {
        var spec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return new StateEffectType(spec.map || function (v) {
          return v;
        });
      }
      /**
      Map an array of effects through a change set.
      */
    }, {
      key: "mapEffects",
      value: function mapEffects(effects, mapping) {
        if (!effects.length) return effects;
        var result = [];
        var _iterator19 = _createForOfIteratorHelper(effects),
          _step19;
        try {
          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
            var effect = _step19.value;
            var mapped = effect.map(mapping);
            if (mapped) result.push(mapped);
          }
        } catch (err) {
          _iterator19.e(err);
        } finally {
          _iterator19.f();
        }
        return result;
      }
    }]);
    return StateEffect;
  }();
  /**
  This effect can be used to reconfigure the root extensions of
  the editor. Doing this will discard any extensions
  [appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
  the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
  compartments.
  */
  StateEffect.reconfigure = /*@__PURE__*/StateEffect.define();
  /**
  Append extensions to the top-level configuration of the editor.
  */
  StateEffect.appendConfig = /*@__PURE__*/StateEffect.define();
  /**
  Changes to the editor state are grouped into transactions.
  Typically, a user action creates a single transaction, which may
  contain any number of document changes, may change the selection,
  or have other effects. Create a transaction by calling
  [`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately
  dispatch one by calling
  [`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).
  */
  var Transaction = /*#__PURE__*/function () {
    function Transaction(
    /**
    The state from which the transaction starts.
    */
    startState,
    /**
    The document changes made by this transaction.
    */
    changes,
    /**
    The selection set by this transaction, or undefined if it
    doesn't explicitly set a selection.
    */
    selection,
    /**
    The effects added to the transaction.
    */
    effects,
    /**
    @internal
    */
    annotations,
    /**
    Whether the selection should be scrolled into view after this
    transaction is dispatched.
    */
    scrollIntoView) {
      _classCallCheck(this, Transaction);
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView;
      /**
      @internal
      */
      this._doc = null;
      /**
      @internal
      */
      this._state = null;
      if (selection) checkSelection(selection, changes.newLength);
      if (!annotations.some(function (a) {
        return a.type == Transaction.time;
      })) this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    _createClass(Transaction, [{
      key: "newDoc",
      get:
      /**
      The new document produced by the transaction. Contrary to
      [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
      force the entire new state to be computed right away, so it is
      recommended that [transaction
      filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
      when they need to look at the new document.
      */
      function get() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
      }
      /**
      The new selection produced by the transaction. If
      [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
      this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
      current selection through the changes made by the transaction.
      */
    }, {
      key: "newSelection",
      get: function get() {
        return this.selection || this.startState.selection.map(this.changes);
      }
      /**
      The new state created by the transaction. Computed on demand
      (but retained for subsequent access), so it is recommended not to
      access it in [transaction
      filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
      */
    }, {
      key: "state",
      get: function get() {
        if (!this._state) this.startState.applyTransaction(this);
        return this._state;
      }
      /**
      Get the value of the given annotation type, if any.
      */
    }, {
      key: "annotation",
      value: function annotation(type) {
        var _iterator20 = _createForOfIteratorHelper(this.annotations),
          _step20;
        try {
          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
            var ann = _step20.value;
            if (ann.type == type) return ann.value;
          }
        } catch (err) {
          _iterator20.e(err);
        } finally {
          _iterator20.f();
        }
        return undefined;
      }
      /**
      Indicates whether the transaction changed the document.
      */
    }, {
      key: "docChanged",
      get: function get() {
        return !this.changes.empty;
      }
      /**
      Indicates whether this transaction reconfigures the state
      (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
      with a top-level configuration
      [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
      */
    }, {
      key: "reconfigured",
      get: function get() {
        return this.startState.config != this.state.config;
      }
      /**
      Returns true if the transaction has a [user
      event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
      or more specific than `event`. For example, if the transaction
      has `"select.pointer"` as user event, `"select"` and
      `"select.pointer"` will match it.
      */
    }, {
      key: "isUserEvent",
      value: function isUserEvent(event) {
        var e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
      }
    }], [{
      key: "create",
      value: function create(startState, changes, selection, effects, annotations, scrollIntoView) {
        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
      }
    }]);
    return Transaction;
  }();
  /**
  Annotation used to store transaction timestamps. Automatically
  added to every transaction, holding `Date.now()`.
  */
  Transaction.time = /*@__PURE__*/Annotation.define();
  /**
  Annotation used to associate a transaction with a user interface
  event. Holds a string identifying the event, using a
  dot-separated format to support attaching more specific
  information. The events used by the core libraries are:

   - `"input"` when content is entered
     - `"input.type"` for typed input
       - `"input.type.compose"` for composition
     - `"input.paste"` for pasted input
     - `"input.drop"` when adding content with drag-and-drop
     - `"input.complete"` when autocompleting
   - `"delete"` when the user deletes content
     - `"delete.selection"` when deleting the selection
     - `"delete.forward"` when deleting forward from the selection
     - `"delete.backward"` when deleting backward from the selection
     - `"delete.cut"` when cutting to the clipboard
   - `"move"` when content is moved
     - `"move.drop"` when content is moved within the editor through drag-and-drop
   - `"select"` when explicitly changing the selection
     - `"select.pointer"` when selecting with a mouse or other pointing device
   - `"undo"` and `"redo"` for history actions

  Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
  whether the annotation matches a given event.
  */
  Transaction.userEvent = /*@__PURE__*/Annotation.define();
  /**
  Annotation indicating whether a transaction should be added to
  the undo history or not.
  */
  Transaction.addToHistory = /*@__PURE__*/Annotation.define();
  /**
  Annotation indicating (when present and true) that a transaction
  represents a change made by some other actor, not the user. This
  is used, for example, to tag other people's changes in
  collaborative editing.
  */
  Transaction.remote = /*@__PURE__*/Annotation.define();
  function joinRanges(a, b) {
    var result = [];
    for (var iA = 0, iB = 0;;) {
      var from = void 0,
        to = void 0;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else return result;
      if (!result.length || result[result.length - 1] < from) result.push(from, to);else if (result[result.length - 1] < to) result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a;
    var mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes: changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    var sel = spec.selection,
      annotations = asArray(spec.annotations);
    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations: annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    var s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false) filter = false;
    for (var _i21 = 1; _i21 < specs.length; _i21++) {
      if (specs[_i21].filter === false) filter = false;
      var seq = !!specs[_i21].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[_i21], seq ? s.changes.newLength : state.doc.length), seq);
    }
    var tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  // Finish a transaction by applying filters if necessary.
  function filterTransaction(tr) {
    var state = tr.startState;
    // Change filters
    var result = true;
    var _iterator21 = _createForOfIteratorHelper(state.facet(changeFilter)),
      _step21;
    try {
      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
        var filter = _step21.value;
        var value = filter(tr);
        if (value === false) {
          result = false;
          break;
        }
        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);
      }
    } catch (err) {
      _iterator21.e(err);
    } finally {
      _iterator21.f();
    }
    if (result !== true) {
      var changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        var filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    // Transaction filters
    var filters = state.facet(transactionFilter);
    for (var _i22 = filters.length - 1; _i22 >= 0; _i22--) {
      var _filtered = filters[_i22](tr);
      if (_filtered instanceof Transaction) tr = _filtered;else if (Array.isArray(_filtered) && _filtered.length == 1 && _filtered[0] instanceof Transaction) tr = _filtered[0];else tr = resolveTransaction(state, asArray(_filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    var state = tr.startState,
      extenders = state.facet(transactionExtender),
      spec = tr;
    for (var _i23 = extenders.length - 1; _i23 >= 0; _i23--) {
      var extension = extenders[_i23](tr);
      if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none$1 = [];
  function asArray(value) {
    return value == null ? none$1 : Array.isArray(value) ? value : [value];
  }

  /**
  The categories produced by a [character
  categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
  do things like selecting by word.
  */
  var CharCategory = /*@__PURE__*/function (CharCategory) {
    /**
    Word characters.
    */
    CharCategory[CharCategory["Word"] = 0] = "Word";
    /**
    Whitespace.
    */
    CharCategory[CharCategory["Space"] = 1] = "Space";
    /**
    Anything else.
    */
    CharCategory[CharCategory["Other"] = 2] = "Other";
    return CharCategory;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /*@__PURE__*/new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {}
  function hasWordChar(str) {
    if (wordChar) return wordChar.test(str);
    for (var _i24 = 0; _i24 < str.length; _i24++) {
      var ch = str[_i24];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return function (_char) {
      if (!/\S/.test(_char)) return CharCategory.Space;
      if (hasWordChar(_char)) return CharCategory.Word;
      for (var _i25 = 0; _i25 < wordChars.length; _i25++) if (_char.indexOf(wordChars[_i25]) > -1) return CharCategory.Word;
      return CharCategory.Other;
    };
  }

  /**
  The editor state class is a persistent (immutable) data structure.
  To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
  [transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
  instance, without modifying the original object.

  As such, _never_ mutate properties of a state directly. That'll
  just break things.
  */
  var EditorState = /*#__PURE__*/function () {
    function EditorState(
    /**
    @internal
    */
    config,
    /**
    The current document.
    */
    doc,
    /**
    The current selection.
    */
    selection,
    /**
    @internal
    */
    values, computeSlot, tr) {
      _classCallCheck(this, EditorState);
      this.config = config;
      this.doc = doc;
      this.selection = selection;
      this.values = values;
      this.status = config.statusTemplate.slice();
      this.computeSlot = computeSlot;
      // Fill in the computed state immediately, so that further queries
      // for it made during the update return this state
      if (tr) tr._state = this;
      for (var _i26 = 0; _i26 < this.config.dynamicSlots.length; _i26++) ensureAddr(this, _i26 << 1);
      this.computeSlot = null;
    }
    _createClass(EditorState, [{
      key: "field",
      value: function field(_field) {
        var require = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var addr = this.config.address[_field.id];
        if (addr == null) {
          if (require) throw new RangeError("Field is not present in this state");
          return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
      }
      /**
      Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
      state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
      can be passed. Unless
      [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
      [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
      are assumed to start in the _current_ document (not the document
      produced by previous specs), and its
      [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
      [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
      to the document created by its _own_ changes. The resulting
      transaction contains the combined effect of all the different
      specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
      specs take precedence over earlier ones.
      */
    }, {
      key: "update",
      value: function update() {
        for (var _len4 = arguments.length, specs = new Array(_len4), _key = 0; _key < _len4; _key++) {
          specs[_key] = arguments[_key];
        }
        return resolveTransaction(this, specs, true);
      }
      /**
      @internal
      */
    }, {
      key: "applyTransaction",
      value: function applyTransaction(tr) {
        var _this7 = this;
        var conf = this.config,
          _conf = conf,
          base = _conf.base,
          compartments = _conf.compartments;
        var _iterator22 = _createForOfIteratorHelper(tr.effects),
          _step22;
        try {
          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
            var effect = _step22.value;
            if (effect.is(Compartment.reconfigure)) {
              if (conf) {
                compartments = new Map();
                conf.compartments.forEach(function (val, key) {
                  return compartments.set(key, val);
                });
                conf = null;
              }
              compartments.set(effect.value.compartment, effect.value.extension);
            } else if (effect.is(StateEffect.reconfigure)) {
              conf = null;
              base = effect.value;
            } else if (effect.is(StateEffect.appendConfig)) {
              conf = null;
              base = asArray(base).concat(effect.value);
            }
          }
        } catch (err) {
          _iterator22.e(err);
        } finally {
          _iterator22.f();
        }
        var startValues;
        if (!conf) {
          conf = Configuration.resolve(base, compartments, this);
          var intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(function () {
            return null;
          }), function (state, slot) {
            return slot.reconfigure(state, _this7);
          }, null);
          startValues = intermediateState.values;
        } else {
          startValues = tr.startState.values.slice();
        }
        new EditorState(conf, tr.newDoc, tr.newSelection, startValues, function (state, slot) {
          return slot.update(state, tr);
        }, tr);
      }
      /**
      Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
      replaces every selection range with the given content.
      */
    }, {
      key: "replaceSelection",
      value: function replaceSelection(text) {
        if (typeof text == "string") text = this.toText(text);
        return this.changeByRange(function (range) {
          return {
            changes: {
              from: range.from,
              to: range.to,
              insert: text
            },
            range: EditorSelection.cursor(range.from + text.length)
          };
        });
      }
      /**
      Create a set of changes and a new selection by running the given
      function for each range in the active selection. The function
      can return an optional set of changes (in the coordinate space
      of the start document), plus an updated range (in the coordinate
      space of the document produced by the call's own changes). This
      method will merge all the changes and ranges into a single
      changeset and selection, and return it as a [transaction
      spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
      [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
      */
    }, {
      key: "changeByRange",
      value: function changeByRange(f) {
        var sel = this.selection;
        var result1 = f(sel.ranges[0]);
        var changes = this.changes(result1.changes),
          ranges = [result1.range];
        var effects = asArray(result1.effects);
        for (var _i27 = 1; _i27 < sel.ranges.length; _i27++) {
          var result = f(sel.ranges[_i27]);
          var newChanges = this.changes(result.changes),
            newMapped = newChanges.map(changes);
          for (var j = 0; j < _i27; j++) ranges[j] = ranges[j].map(newMapped);
          var mapBy = changes.mapDesc(newChanges, true);
          ranges.push(result.range.map(mapBy));
          changes = changes.compose(newMapped);
          effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
          changes: changes,
          selection: EditorSelection.create(ranges, sel.mainIndex),
          effects: effects
        };
      }
      /**
      Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
      description, taking the state's document length and line
      separator into account.
      */
    }, {
      key: "changes",
      value: function changes() {
        var spec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        if (spec instanceof ChangeSet) return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
      }
      /**
      Using the state's [line
      separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
      [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
      */
    }, {
      key: "toText",
      value: function toText(string) {
        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
      }
      /**
      Return the given range of the document as a string.
      */
    }, {
      key: "sliceDoc",
      value: function sliceDoc() {
        var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.doc.length;
        return this.doc.sliceString(from, to, this.lineBreak);
      }
      /**
      Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
      */
    }, {
      key: "facet",
      value: function facet(_facet) {
        var addr = this.config.address[_facet.id];
        if (addr == null) return _facet["default"];
        ensureAddr(this, addr);
        return getAddr(this, addr);
      }
      /**
      Convert this state to a JSON-serializable object. When custom
      fields should be serialized, you can pass them in as an object
      mapping property names (in the resulting object, which should
      not use `doc` or `selection`) to fields.
      */
    }, {
      key: "toJSON",
      value: function toJSON(fields) {
        var result = {
          doc: this.sliceDoc(),
          selection: this.selection.toJSON()
        };
        if (fields) for (var prop in fields) {
          var value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
        return result;
      }
      /**
      Deserialize a state from its JSON representation. When custom
      fields should be deserialized, pass the same object you passed
      to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
      third argument.
      */
    }, {
      key: "tabSize",
      get:
      /**
      The size (in columns) of a tab in the document, determined by
      the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
      */
      function get() {
        return this.facet(EditorState.tabSize);
      }
      /**
      Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
      string for this state.
      */
    }, {
      key: "lineBreak",
      get: function get() {
        return this.facet(EditorState.lineSeparator) || "\n";
      }
      /**
      Returns true when the editor is
      [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
      */
    }, {
      key: "readOnly",
      get: function get() {
        return this.facet(readOnly);
      }
      /**
      Look up a translation for the given phrase (via the
      [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
      original string if no translation is found.
      
      If additional arguments are passed, they will be inserted in
      place of markers like `$1` (for the first value) and `$2`, etc.
      A single `$` is equivalent to `$1`, and `$$` will produce a
      literal dollar sign.
      */
    }, {
      key: "phrase",
      value: function phrase(_phrase) {
        for (var _len5 = arguments.length, insert = new Array(_len5 > 1 ? _len5 - 1 : 0), _key2 = 1; _key2 < _len5; _key2++) {
          insert[_key2 - 1] = arguments[_key2];
        }
        var _iterator23 = _createForOfIteratorHelper(this.facet(EditorState.phrases)),
          _step23;
        try {
          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
            var map = _step23.value;
            if (Object.prototype.hasOwnProperty.call(map, _phrase)) {
              _phrase = map[_phrase];
              break;
            }
          }
        } catch (err) {
          _iterator23.e(err);
        } finally {
          _iterator23.f();
        }
        if (insert.length) _phrase = _phrase.replace(/\$(\$|\d*)/g, function (m, i) {
          if (i == "$") return "$";
          var n = +(i || 1);
          return !n || n > insert.length ? m : insert[n - 1];
        });
        return _phrase;
      }
      /**
      Find the values for a given language data field, provided by the
      the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
      
      Examples of language data fields are...
      
      - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
        comment syntax.
      - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
        for providing language-specific completion sources.
      - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
        characters that should be considered part of words in this
        language.
      - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
        bracket closing behavior.
      */
    }, {
      key: "languageDataAt",
      value: function languageDataAt(name, pos) {
        var side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        var values = [];
        var _iterator24 = _createForOfIteratorHelper(this.facet(languageData)),
          _step24;
        try {
          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
            var provider = _step24.value;
            var _iterator25 = _createForOfIteratorHelper(provider(this, pos, side)),
              _step25;
            try {
              for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                var result = _step25.value;
                if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);
              }
            } catch (err) {
              _iterator25.e(err);
            } finally {
              _iterator25.f();
            }
          }
        } catch (err) {
          _iterator24.e(err);
        } finally {
          _iterator24.f();
        }
        return values;
      }
      /**
      Return a function that can categorize strings (expected to
      represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
      into one of:
      
       - Word (contains an alphanumeric character or a character
         explicitly listed in the local language's `"wordChars"`
         language data, which should be a string)
       - Space (contains only whitespace)
       - Other (anything else)
      */
    }, {
      key: "charCategorizer",
      value: function charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
      }
      /**
      Find the word at the given position, meaning the range
      containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
      around it. If no word characters are adjacent to the position,
      this returns null.
      */
    }, {
      key: "wordAt",
      value: function wordAt(pos) {
        var _this$doc$lineAt = this.doc.lineAt(pos),
          text = _this$doc$lineAt.text,
          from = _this$doc$lineAt.from,
          length = _this$doc$lineAt.length;
        var cat = this.charCategorizer(pos);
        var start = pos - from,
          end = pos - from;
        while (start > 0) {
          var prev = findClusterBreak(text, start, false);
          if (cat(text.slice(prev, start)) != CharCategory.Word) break;
          start = prev;
        }
        while (end < length) {
          var next = findClusterBreak(text, end);
          if (cat(text.slice(end, next)) != CharCategory.Word) break;
          end = next;
        }
        return start == end ? null : EditorSelection.range(start + from, end + from);
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(json) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var fields = arguments.length > 2 ? arguments[2] : undefined;
        if (!json || typeof json.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
        var fieldInit = [];
        if (fields) {
          var _loop4 = function _loop4() {
            if (Object.prototype.hasOwnProperty.call(json, prop)) {
              var field = fields[prop],
                value = json[prop];
              fieldInit.push(field.init(function (state) {
                return field.spec.fromJSON(value, state);
              }));
            }
          };
          for (var prop in fields) {
            _loop4();
          }
        }
        return EditorState.create({
          doc: json.doc,
          selection: EditorSelection.fromJSON(json.selection),
          extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
        });
      }
      /**
      Create a new state. You'll usually only need this when
      initializing an editorupdated states are created by applying
      transactions.
      */
    }, {
      key: "create",
      value: function create() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var configuration = Configuration.resolve(config.extensions || [], new Map());
        var doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        var selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
        checkSelection(selection, doc.length);
        if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();
        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(function () {
          return null;
        }), function (state, slot) {
          return slot.create(state);
        }, null);
      }
    }]);
    return EditorState;
  }();
  /**
  A facet that, when enabled, causes the editor to allow multiple
  ranges to be selected. Be careful though, because by default the
  editor relies on the native DOM selection, which cannot handle
  multiple selections. An extension like
  [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
  secondary selections visible to the user.
  */
  EditorState.allowMultipleSelections = allowMultipleSelections;
  /**
  Configures the tab size to use in this state. The first
  (highest-precedence) value of the facet is used. If no value is
  given, this defaults to 4.
  */
  EditorState.tabSize = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.length ? values[0] : 4;
    }
  });
  /**
  The line separator to use. By default, any of `"\n"`, `"\r\n"`
  and `"\r"` is treated as a separator when splitting lines, and
  lines are joined with `"\n"`.

  When you configure a value here, only that precise separator
  will be used, allowing you to round-trip documents through the
  editor without normalizing line separators.
  */
  EditorState.lineSeparator = lineSeparator;
  /**
  This facet controls the value of the
  [`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
  consulted by commands and extensions that implement editing
  functionality to determine whether they should apply. It
  defaults to false, but when its highest-precedence value is
  `true`, such functionality disables itself.

  Not to be confused with
  [`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
  controls whether the editor's DOM is set to be editable (and
  thus focusable).
  */
  EditorState.readOnly = readOnly;
  /**
  Registers translation phrases. The
  [`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
  all objects registered with this facet to find translations for
  its argument.
  */
  EditorState.phrases = /*@__PURE__*/Facet.define({
    compare: function compare(a, b) {
      var kA = Object.keys(a),
        kB = Object.keys(b);
      return kA.length == kB.length && kA.every(function (k) {
        return a[k] == b[k];
      });
    }
  });
  /**
  A facet used to register [language
  data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
  */
  EditorState.languageData = languageData;
  /**
  Facet used to register change filters, which are called for each
  transaction (unless explicitly
  [disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
  part of the transaction's changes.

  Such a function can return `true` to indicate that it doesn't
  want to do anything, `false` to completely stop the changes in
  the transaction, or a set of ranges in which changes should be
  suppressed. Such ranges are represented as an array of numbers,
  with each pair of two numbers indicating the start and end of a
  range. So for example `[10, 20, 100, 110]` suppresses changes
  between 10 and 20, and between 100 and 110.
  */
  EditorState.changeFilter = changeFilter;
  /**
  Facet used to register a hook that gets a chance to update or
  replace transaction specs before they are applied. This will
  only be applied for transactions that don't have
  [`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
  can either return a single transaction spec (possibly the input
  transaction), or an array of specs (which will be combined in
  the same way as the arguments to
  [`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

  When possible, it is recommended to avoid accessing
  [`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
  since it will force creation of a state that will then be
  discarded again, if the transaction is actually filtered.

  (This functionality should be used with care. Indiscriminately
  modifying transaction is likely to break something or degrade
  the user experience.)
  */
  EditorState.transactionFilter = transactionFilter;
  /**
  This is a more limited form of
  [`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
  which can only add
  [annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
  of filter runs even if the transaction has disabled regular
  [filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
  for effects that don't need to touch the changes or selection,
  but do want to process every transaction.

  Extenders run _after_ filters, when both are present.
  */
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /*@__PURE__*/StateEffect.define();

  /**
  Utility function for combining behaviors to fill in a config
  object from an array of provided configs. `defaults` should hold
  default values for all optional fields in `Config`.

  The function will, by default, error
  when a field gets two values that aren't `===`-equal, but you can
  provide combine functions per field to do something else.
  */
  function combineConfig(configs, defaults) {
    var combine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var result = {};
    var _iterator26 = _createForOfIteratorHelper(configs),
      _step26;
    try {
      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
        var config = _step26.value;
        for (var _i28 = 0, _Object$keys = Object.keys(config); _i28 < _Object$keys.length; _i28++) {
          var _key3 = _Object$keys[_i28];
          var value = config[_key3],
            current = result[_key3];
          if (current === undefined) result[_key3] = value;else if (current === value || value === undefined) ; // No conflict
          else if (Object.hasOwnProperty.call(combine, _key3)) result[_key3] = combine[_key3](current, value);else throw new Error("Config merge conflict for field " + _key3);
        }
      }
    } catch (err) {
      _iterator26.e(err);
    } finally {
      _iterator26.f();
    }
    for (var key in defaults) if (result[key] === undefined) result[key] = defaults[key];
    return result;
  }

  /**
  Each range is associated with a value, which must inherit from
  this class.
  */
  var RangeValue = /*#__PURE__*/function () {
    function RangeValue() {
      _classCallCheck(this, RangeValue);
    }
    _createClass(RangeValue, [{
      key: "eq",
      value:
      /**
      Compare this value with another value. Used when comparing
      rangesets. The default implementation compares by identity.
      Unless you are only creating a fixed number of unique instances
      of your value type, it is a good idea to implement this
      properly.
      */
      function eq(other) {
        return this == other;
      }
      /**
      Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
      */
    }, {
      key: "range",
      value: function range(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
        return Range$1.create(from, to, this);
      }
    }]);
    return RangeValue;
  }();
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  /**
  A range associates a value with a range of positions.
  */
  var Range$1 = /*#__PURE__*/function () {
    function Range(
    /**
    The range's start position.
    */
    from,
    /**
    Its end position.
    */
    to,
    /**
    The value associated with this range.
    */
    value) {
      _classCallCheck(this, Range);
      this.from = from;
      this.to = to;
      this.value = value;
    }
    /**
    @internal
    */
    _createClass(Range, null, [{
      key: "create",
      value: function create(from, to, value) {
        return new Range(from, to, value);
      }
    }]);
    return Range;
  }();
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = /*#__PURE__*/function () {
    function Chunk(from, to, value,
    // Chunks are marked with the largest point that occurs
    // in them (or -1 for no points), so that scans that are
    // only interested in points (such as the
    // heightmap-related logic) can skip range-only chunks.
    maxPoint) {
      _classCallCheck(this, Chunk);
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    _createClass(Chunk, [{
      key: "length",
      get: function get() {
        return this.to[this.to.length - 1];
      }
      // Find the index of the given position and side. Use the ranges'
      // `from` pos when `end == false`, `to` when `end == true`.
    }, {
      key: "findIndex",
      value: function findIndex(pos, side, end) {
        var startAt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var arr = end ? this.to : this.from;
        for (var lo = startAt, hi = arr.length;;) {
          if (lo == hi) return lo;
          var mid = lo + hi >> 1;
          var diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
          if (mid == lo) return diff >= 0 ? lo : hi;
          if (diff >= 0) hi = mid;else lo = mid + 1;
        }
      }
    }, {
      key: "between",
      value: function between(offset, from, to, f) {
        for (var _i29 = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, _i29); _i29 < e; _i29++) if (f(this.from[_i29] + offset, this.to[_i29] + offset, this.value[_i29]) === false) return false;
      }
    }, {
      key: "map",
      value: function map(offset, changes) {
        var value = [],
          from = [],
          to = [],
          newPos = -1,
          maxPoint = -1;
        for (var _i30 = 0; _i30 < this.value.length; _i30++) {
          var val = this.value[_i30],
            curFrom = this.from[_i30] + offset,
            curTo = this.to[_i30] + offset,
            newFrom = void 0,
            newTo = void 0;
          if (curFrom == curTo) {
            var mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
            if (mapped == null) continue;
            newFrom = newTo = mapped;
            if (val.startSide != val.endSide) {
              newTo = changes.mapPos(curFrom, val.endSide);
              if (newTo < newFrom) continue;
            }
          } else {
            newFrom = changes.mapPos(curFrom, val.startSide);
            newTo = changes.mapPos(curTo, val.endSide);
            if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;
          }
          if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;
          if (newPos < 0) newPos = newFrom;
          if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);
          value.push(val);
          from.push(newFrom - newPos);
          to.push(newTo - newPos);
        }
        return {
          mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,
          pos: newPos
        };
      }
    }]);
    return Chunk;
  }();
  /**
  A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a
  way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and
  [update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data
  structure.
  */
  var RangeSet = /*#__PURE__*/function () {
    function RangeSet(
    /**
    @internal
    */
    chunkPos,
    /**
    @internal
    */
    chunk,
    /**
    @internal
    */
    nextLayer,
    /**
    @internal
    */
    maxPoint) {
      _classCallCheck(this, RangeSet);
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    _createClass(RangeSet, [{
      key: "length",
      get:
      /**
      @internal
      */
      function get() {
        var last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
      }
      /**
      The number of ranges in the set.
      */
    }, {
      key: "size",
      get: function get() {
        if (this.isEmpty) return 0;
        var size = this.nextLayer.size;
        var _iterator27 = _createForOfIteratorHelper(this.chunk),
          _step27;
        try {
          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
            var chunk = _step27.value;
            size += chunk.value.length;
          }
        } catch (err) {
          _iterator27.e(err);
        } finally {
          _iterator27.f();
        }
        return size;
      }
      /**
      @internal
      */
    }, {
      key: "chunkEnd",
      value: function chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
      }
      /**
      Update the range set, optionally adding new ranges or filtering
      out existing ones.
      
      (Note: The type parameter is just there as a kludge to work
      around TypeScript variance issues that prevented `RangeSet<X>`
      from being a subtype of `RangeSet<Y>` when `X` is a subtype of
      `Y`.)
      */
    }, {
      key: "update",
      value: function update(updateSpec) {
        var _updateSpec$add = updateSpec.add,
          add = _updateSpec$add === void 0 ? [] : _updateSpec$add,
          _updateSpec$sort = updateSpec.sort,
          sort = _updateSpec$sort === void 0 ? false : _updateSpec$sort,
          _updateSpec$filterFro = updateSpec.filterFrom,
          filterFrom = _updateSpec$filterFro === void 0 ? 0 : _updateSpec$filterFro,
          _updateSpec$filterTo = updateSpec.filterTo,
          filterTo = _updateSpec$filterTo === void 0 ? this.length : _updateSpec$filterTo;
        var filter = updateSpec.filter;
        if (add.length == 0 && !filter) return this;
        if (sort) add = add.slice().sort(cmpRange);
        if (this.isEmpty) return add.length ? RangeSet.of(add) : this;
        var cur = new LayerCursor(this, null, -1)["goto"](0),
          i = 0,
          spill = [];
        var builder = new RangeSetBuilder();
        while (cur.value || i < add.length) {
          if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
            var range = add[i++];
            if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);
          } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
            cur.nextChunk();
          } else {
            if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
              if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range$1.create(cur.from, cur.to, cur.value));
            }
            cur.next();
          }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({
          add: spill,
          filter: filter,
          filterFrom: filterFrom,
          filterTo: filterTo
        }));
      }
      /**
      Map this range set through a set of changes, return the new set.
      */
    }, {
      key: "map",
      value: function map(changes) {
        if (changes.empty || this.isEmpty) return this;
        var chunks = [],
          chunkPos = [],
          maxPoint = -1;
        for (var _i31 = 0; _i31 < this.chunk.length; _i31++) {
          var start = this.chunkPos[_i31],
            chunk = this.chunk[_i31];
          var touch = changes.touchesRange(start, start + chunk.length);
          if (touch === false) {
            maxPoint = Math.max(maxPoint, chunk.maxPoint);
            chunks.push(chunk);
            chunkPos.push(changes.mapPos(start));
          } else if (touch === true) {
            var _chunk$map = chunk.map(start, changes),
              mapped = _chunk$map.mapped,
              pos = _chunk$map.pos;
            if (mapped) {
              maxPoint = Math.max(maxPoint, mapped.maxPoint);
              chunks.push(mapped);
              chunkPos.push(pos);
            }
          }
        }
        var next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
      }
      /**
      Iterate over the ranges that touch the region `from` to `to`,
      calling `f` for each. There is no guarantee that the ranges will
      be reported in any specific order. When the callback returns
      `false`, iteration stops.
      */
    }, {
      key: "between",
      value: function between(from, to, f) {
        if (this.isEmpty) return;
        for (var _i32 = 0; _i32 < this.chunk.length; _i32++) {
          var start = this.chunkPos[_i32],
            chunk = this.chunk[_i32];
          if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;
        }
        this.nextLayer.between(from, to, f);
      }
      /**
      Iterate over the ranges in this set, in order, including all
      ranges that end at or after `from`.
      */
    }, {
      key: "iter",
      value: function iter() {
        var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return HeapCursor.from([this])["goto"](from);
      }
      /**
      @internal
      */
    }, {
      key: "isEmpty",
      get: function get() {
        return this.nextLayer == this;
      }
      /**
      Iterate over the ranges in a collection of sets, in order,
      starting from `from`.
      */
    }], [{
      key: "create",
      value: function create(chunkPos, chunk, nextLayer, maxPoint) {
        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
      }
    }, {
      key: "iter",
      value: function iter(sets) {
        var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return HeapCursor.from(sets)["goto"](from);
      }
      /**
      Iterate over two groups of sets, calling methods on `comparator`
      to notify it of possible differences.
      */
    }, {
      key: "compare",
      value: function compare(oldSets, newSets,
      /**
      This indicates how the underlying data changed between these
      ranges, and is needed to synchronize the iteration.
      */
      textDiff, comparator) {
        var minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
        var a = oldSets.filter(function (set) {
          return set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize;
        });
        var b = newSets.filter(function (set) {
          return set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize;
        });
        var sharedChunks = findSharedChunks(a, b, textDiff);
        var sideA = new SpanCursor(a, sharedChunks, minPointSize);
        var sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps(function (fromA, fromB, length) {
          return _compare(sideA, fromA, sideB, fromB, length, comparator);
        });
        if (textDiff.empty && textDiff.length == 0) _compare(sideA, 0, sideB, 0, 0, comparator);
      }
      /**
      Compare the contents of two groups of range sets, returning true
      if they are equivalent in the given range.
      */
    }, {
      key: "eq",
      value: function eq(oldSets, newSets) {
        var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var to = arguments.length > 3 ? arguments[3] : undefined;
        if (to == null) to = 1000000000 /* C.Far */ - 1;
        var a = oldSets.filter(function (set) {
          return !set.isEmpty && newSets.indexOf(set) < 0;
        });
        var b = newSets.filter(function (set) {
          return !set.isEmpty && oldSets.indexOf(set) < 0;
        });
        if (a.length != b.length) return false;
        if (!a.length) return true;
        var sharedChunks = findSharedChunks(a, b);
        var sideA = new SpanCursor(a, sharedChunks, 0)["goto"](from),
          sideB = new SpanCursor(b, sharedChunks, 0)["goto"](from);
        for (;;) {
          if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;
          if (sideA.to > to) return true;
          sideA.next();
          sideB.next();
        }
      }
      /**
      Iterate over a group of range sets at the same time, notifying
      the iterator about the ranges covering every given piece of
      content. Returns the open count (see
      [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
      of the iteration.
      */
    }, {
      key: "spans",
      value: function spans(sets, from, to, iterator) {
        var minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
        var cursor = new SpanCursor(sets, null, minPointSize)["goto"](from),
          pos = from;
        var openRanges = cursor.openStart;
        for (;;) {
          var curTo = Math.min(cursor.to, to);
          if (cursor.point) {
            var active = cursor.activeForPoint(cursor.to);
            var openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
            iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
            openRanges = Math.min(cursor.openEnd(curTo), active.length);
          } else if (curTo > pos) {
            iterator.span(pos, curTo, cursor.active, openRanges);
            openRanges = cursor.openEnd(curTo);
          }
          if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
          pos = cursor.to;
          cursor.next();
        }
      }
      /**
      Create a range set for the given range or array of ranges. By
      default, this expects the ranges to be _sorted_ (by start
      position and, if two start at the same position,
      `value.startSide`). You can pass `true` as second argument to
      cause the method to sort them.
      */
    }, {
      key: "of",
      value: function of(ranges) {
        var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var build = new RangeSetBuilder();
        var _iterator28 = _createForOfIteratorHelper(ranges instanceof Range$1 ? [ranges] : sort ? lazySort(ranges) : ranges),
          _step28;
        try {
          for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
            var range = _step28.value;
            build.add(range.from, range.to, range.value);
          }
        } catch (err) {
          _iterator28.e(err);
        } finally {
          _iterator28.f();
        }
        return build.finish();
      }
    }]);
    return RangeSet;
  }();
  /**
  The empty set of ranges.
  */
  RangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1) for (var prev = ranges[0], _i33 = 1; _i33 < ranges.length; _i33++) {
      var cur = ranges[_i33];
      if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);
      prev = cur;
    }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  /**
  A range set builder is a data structure that helps build up a
  [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating
  an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.
  */
  var RangeSetBuilder = /*#__PURE__*/function () {
    /**
    Create an empty builder.
    */
    function RangeSetBuilder() {
      _classCallCheck(this, RangeSetBuilder);
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1000000000 /* C.Far */;
      this.lastTo = -1000000000 /* C.Far */;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    _createClass(RangeSetBuilder, [{
      key: "finishChunk",
      value: function finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
          this.from = [];
          this.to = [];
          this.value = [];
        }
      }
    }, {
      key: "add",
      value: function add(from, to, value) {
        if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
      }
      /**
      @internal
      */
    }, {
      key: "addInner",
      value: function addInner(from, to, value) {
        var diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0) return false;
        if (this.from.length == 250 /* C.ChunkSize */) this.finishChunk(true);
        if (this.chunkStart < 0) this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
      }
      /**
      @internal
      */
    }, {
      key: "addChunk",
      value: function addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;
        if (this.from.length) this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        var last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
      }
      /**
      Finish the range set. Returns the new set. The builder can't be
      used anymore after this has been called.
      */
    }, {
      key: "finish",
      value: function finish() {
        return this.finishInner(RangeSet.empty);
      }
      /**
      @internal
      */
    }, {
      key: "finishInner",
      value: function finishInner(next) {
        if (this.from.length) this.finishChunk(false);
        if (this.chunks.length == 0) return next;
        var result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null; // Make sure further `add` calls produce errors
        return result;
      }
    }]);
    return RangeSetBuilder;
  }();
  function findSharedChunks(a, b, textDiff) {
    var inA = new Map();
    var _iterator29 = _createForOfIteratorHelper(a),
      _step29;
    try {
      for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
        var set = _step29.value;
        for (var _i34 = 0; _i34 < set.chunk.length; _i34++) if (set.chunk[_i34].maxPoint <= 0) inA.set(set.chunk[_i34], set.chunkPos[_i34]);
      }
    } catch (err) {
      _iterator29.e(err);
    } finally {
      _iterator29.f();
    }
    var shared = new Set();
    var _iterator30 = _createForOfIteratorHelper(b),
      _step30;
    try {
      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
        var _set = _step30.value;
        for (var _i35 = 0; _i35 < _set.chunk.length; _i35++) {
          var known = inA.get(_set.chunk[_i35]);
          if (known != null && (textDiff ? textDiff.mapPos(known) : known) == _set.chunkPos[_i35] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + _set.chunk[_i35].length))) shared.add(_set.chunk[_i35]);
        }
      }
    } catch (err) {
      _iterator30.e(err);
    } finally {
      _iterator30.f();
    }
    return shared;
  }
  var LayerCursor = /*#__PURE__*/function () {
    function LayerCursor(layer, skip, minPoint) {
      var rank = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      _classCallCheck(this, LayerCursor);
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    _createClass(LayerCursor, [{
      key: "startSide",
      get: function get() {
        return this.value ? this.value.startSide : 0;
      }
    }, {
      key: "endSide",
      get: function get() {
        return this.value ? this.value.endSide : 0;
      }
    }, {
      key: "goto",
      value: function goto(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
      }
    }, {
      key: "gotoInner",
      value: function gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
          var next = this.layer.chunk[this.chunkIndex];
          if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;
          this.chunkIndex++;
          forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
          var rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
          if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);
        }
        this.next();
      }
    }, {
      key: "forward",
      value: function forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);
      }
    }, {
      key: "next",
      value: function next() {
        for (;;) {
          if (this.chunkIndex == this.layer.chunk.length) {
            this.from = this.to = 1000000000 /* C.Far */;
            this.value = null;
            break;
          } else {
            var chunkPos = this.layer.chunkPos[this.chunkIndex],
              chunk = this.layer.chunk[this.chunkIndex];
            var from = chunkPos + chunk.from[this.rangeIndex];
            this.from = from;
            this.to = chunkPos + chunk.to[this.rangeIndex];
            this.value = chunk.value[this.rangeIndex];
            this.setRangeIndex(this.rangeIndex + 1);
            if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;
          }
        }
      }
    }, {
      key: "setRangeIndex",
      value: function setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
          this.chunkIndex++;
          if (this.skip) {
            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;
          }
          this.rangeIndex = 0;
        } else {
          this.rangeIndex = index;
        }
      }
    }, {
      key: "nextChunk",
      value: function nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
      }
    }, {
      key: "compare",
      value: function compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
      }
    }]);
    return LayerCursor;
  }();
  var HeapCursor = /*#__PURE__*/function () {
    function HeapCursor(heap) {
      _classCallCheck(this, HeapCursor);
      this.heap = heap;
    }
    _createClass(HeapCursor, [{
      key: "startSide",
      get: function get() {
        return this.value ? this.value.startSide : 0;
      }
    }, {
      key: "goto",
      value: function goto(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;
        var _iterator31 = _createForOfIteratorHelper(this.heap),
          _step31;
        try {
          for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
            var cur = _step31.value;
            cur["goto"](pos, side);
          }
        } catch (err) {
          _iterator31.e(err);
        } finally {
          _iterator31.f();
        }
        for (var _i36 = this.heap.length >> 1; _i36 >= 0; _i36--) heapBubble(this.heap, _i36);
        this.next();
        return this;
      }
    }, {
      key: "forward",
      value: function forward(pos, side) {
        var _iterator32 = _createForOfIteratorHelper(this.heap),
          _step32;
        try {
          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
            var cur = _step32.value;
            cur.forward(pos, side);
          }
        } catch (err) {
          _iterator32.e(err);
        } finally {
          _iterator32.f();
        }
        for (var _i37 = this.heap.length >> 1; _i37 >= 0; _i37--) heapBubble(this.heap, _i37);
        if ((this.to - pos || this.value.endSide - side) < 0) this.next();
      }
    }, {
      key: "next",
      value: function next() {
        if (this.heap.length == 0) {
          this.from = this.to = 1000000000 /* C.Far */;
          this.value = null;
          this.rank = -1;
        } else {
          var top = this.heap[0];
          this.from = top.from;
          this.to = top.to;
          this.value = top.value;
          this.rank = top.rank;
          if (top.value) top.next();
          heapBubble(this.heap, 0);
        }
      }
    }], [{
      key: "from",
      value: function from(sets) {
        var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var minPoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        var heap = [];
        for (var _i38 = 0; _i38 < sets.length; _i38++) {
          for (var cur = sets[_i38]; !cur.isEmpty; cur = cur.nextLayer) {
            if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, _i38));
          }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
      }
    }]);
    return HeapCursor;
  }();
  function heapBubble(heap, index) {
    for (var cur = heap[index];;) {
      var childIndex = (index << 1) + 1;
      if (childIndex >= heap.length) break;
      var child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur.compare(child) < 0) break;
      heap[childIndex] = cur;
      heap[index] = child;
      index = childIndex;
    }
  }
  var SpanCursor = /*#__PURE__*/function () {
    function SpanCursor(sets, skip, minPoint) {
      _classCallCheck(this, SpanCursor);
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      // A currently active point range, if any
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1000000000 /* C.Far */;
      this.endSide = 0;
      // The amount of open active ranges at the start of the iterator.
      // Not including points.
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    _createClass(SpanCursor, [{
      key: "goto",
      value: function goto(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;
        this.cursor["goto"](pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
      }
    }, {
      key: "forward",
      value: function forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
      }
    }, {
      key: "removeActive",
      value: function removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
      }
    }, {
      key: "addActive",
      value: function addActive(trackOpen) {
        var i = 0,
          _this$cursor = this.cursor,
          value = _this$cursor.value,
          to = _this$cursor.to,
          rank = _this$cursor.rank;
        while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen) insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
      }
      // After calling this, if `this.point` != null, the next range is a
      // point. Otherwise, it's a regular range, covered by `this.active`.
    }, {
      key: "next",
      value: function next() {
        var from = this.to,
          wasPoint = this.point;
        this.point = null;
        var trackOpen = this.openStart < 0 ? [] : null;
        for (;;) {
          var a = this.minActive;
          if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
            if (this.activeTo[a] > from) {
              this.to = this.activeTo[a];
              this.endSide = this.active[a].endSide;
              break;
            }
            this.removeActive(a);
            if (trackOpen) remove(trackOpen, a);
          } else if (!this.cursor.value) {
            this.to = this.endSide = 1000000000 /* C.Far */;
            break;
          } else if (this.cursor.from > from) {
            this.to = this.cursor.from;
            this.endSide = this.cursor.startSide;
            break;
          } else {
            var nextVal = this.cursor.value;
            if (!nextVal.point) {
              // Opening a range
              this.addActive(trackOpen);
              this.cursor.next();
            } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
              // Ignore any non-empty points that end precisely at the end of the prev point
              this.cursor.next();
            } else {
              // New point
              this.point = nextVal;
              this.pointFrom = this.cursor.from;
              this.pointRank = this.cursor.rank;
              this.to = this.cursor.to;
              this.endSide = nextVal.endSide;
              this.cursor.next();
              this.forward(this.to, this.endSide);
              break;
            }
          }
        }
        if (trackOpen) {
          this.openStart = 0;
          for (var _i39 = trackOpen.length - 1; _i39 >= 0 && trackOpen[_i39] < from; _i39--) this.openStart++;
        }
      }
    }, {
      key: "activeForPoint",
      value: function activeForPoint(to) {
        if (!this.active.length) return this.active;
        var active = [];
        for (var _i40 = this.active.length - 1; _i40 >= 0; _i40--) {
          if (this.activeRank[_i40] < this.pointRank) break;
          if (this.activeTo[_i40] > to || this.activeTo[_i40] == to && this.active[_i40].endSide >= this.point.endSide) active.push(this.active[_i40]);
        }
        return active.reverse();
      }
    }, {
      key: "openEnd",
      value: function openEnd(to) {
        var open = 0;
        for (var _i41 = this.activeTo.length - 1; _i41 >= 0 && this.activeTo[_i41] > to; _i41--) open++;
        return open;
      }
    }]);
    return SpanCursor;
  }();
  function _compare(a, startA, b, startB, length, comparator) {
    a["goto"](startA);
    b["goto"](startB);
    var endB = startB + length;
    var pos = startB,
      dPos = startB - startA;
    for (;;) {
      var diff = a.to + dPos - b.to || a.endSide - b.endSide;
      var end = diff < 0 ? a.to + dPos : b.to,
        clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB) break;
      pos = end;
      if (diff <= 0) a.next();
      if (diff >= 0) b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length) return false;
    for (var _i42 = 0; _i42 < a.length; _i42++) if (a[_i42] != b[_i42] && !a[_i42].eq(b[_i42])) return false;
    return true;
  }
  function remove(array, index) {
    for (var _i43 = index, e = array.length - 1; _i43 < e; _i43++) array[_i43] = array[_i43 + 1];
    array.pop();
  }
  function insert(array, index, value) {
    for (var _i44 = array.length - 1; _i44 >= index; _i44--) array[_i44 + 1] = array[_i44];
    array[index] = value;
  }
  function findMinIndex(value, array) {
    var found = -1,
      foundPos = 1000000000 /* C.Far */;
    for (var _i45 = 0; _i45 < array.length; _i45++) if ((array[_i45] - foundPos || value[_i45].endSide - value[found].endSide) < 0) {
      found = _i45;
      foundPos = array[_i45];
    }
    return found;
  }

  /**
  Count the column position at the given offset into the string,
  taking extending characters and tab size into account.
  */
  function countColumn(string, tabSize) {
    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string.length;
    var n = 0;
    for (var _i46 = 0; _i46 < to;) {
      if (string.charCodeAt(_i46) == 9) {
        n += tabSize - n % tabSize;
        _i46++;
      } else {
        n++;
        _i46 = findClusterBreak(string, _i46);
      }
    }
    return n;
  }
  /**
  Find the offset that corresponds to the given column position in a
  string, taking extending characters and tab size into account. By
  default, the string length is returned when it is too short to
  reach the column. Pass `strict` true to make it return -1 in that
  situation.
  */
  function findColumn(string, col, tabSize, strict) {
    for (var _i47 = 0, n = 0;;) {
      if (n >= col) return _i47;
      if (_i47 == string.length) break;
      n += string.charCodeAt(_i47) == 9 ? tabSize - n % tabSize : 1;
      _i47 = findClusterBreak(string, _i47);
    }
    return strict === true ? -1 : string.length;
  }

  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol["for"](C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};

  // :: - Style modules encapsulate a set of CSS rules defined from
  // JavaScript. Their definitions are only available in a given DOM
  // root after it has been _mounted_ there with `StyleModule.mount`.
  //
  // Style modules should be created once and stored somewhere, as
  // opposed to re-creating them every time you need them. The amount of
  // CSS rules generated for a given DOM root is bounded by the amount
  // of style modules that were used. So to avoid leaking rules, don't
  // create these dynamically, but treat them as one-time allocations.
  var StyleModule = /*#__PURE__*/function () {
    // :: (Object<Style>, ?{finish: ?(string)  string})
    // Create a style module from the given spec.
    //
    // When `finish` is given, it is called on regular (non-`@`)
    // selectors (after `&` expansion) to compute the final selector.
    function StyleModule(spec, options) {
      _classCallCheck(this, StyleModule);
      this.rules = [];
      var _ref = options || {},
        finish = _ref.finish;
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec, target, isKeyframes) {
        var local = [],
          isAt = /^@(\w+)\b/.exec(selectors[0]),
          keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec == null) return target.push(selectors[0] + ";");
        for (var prop in spec) {
          var value = spec[prop];
          if (/&/.test(prop)) {
            render(prop.split(/,\s*/).map(function (part) {
              return selectors.map(function (sel) {
                return part.replace(/&/, sel);
              });
            }).reduce(function (a, b) {
              return a.concat(b);
            }), value, target);
          } else if (value && _typeof(value) == "object") {
            if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, function (l) {
              return "-" + l.toLowerCase();
            }) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (var prop in spec) render(splitSelector(prop), spec[prop], this.rules);
    }

    // :: ()  string
    // Returns a string containing the module's CSS rules.
    _createClass(StyleModule, [{
      key: "getRules",
      value: function getRules() {
        return this.rules.join("\n");
      }

      // :: ()  string
      // Generate a new unique CSS class name.
    }], [{
      key: "newName",
      value: function newName() {
        var id = top[COUNT] || 1;
        top[COUNT] = id + 1;
        return C + id.toString(36);
      }

      // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
      //
      // Mount the given set of modules in the given DOM root, which ensures
      // that the CSS rules defined by the module are available in that
      // context.
      //
      // Rules are only added to the document once per root.
      //
      // Rule order will follow the order of the modules, so that rules from
      // modules later in the array take precedence of those from earlier
      // modules. If you call this function multiple times for the same root
      // in a way that changes the order of already mounted modules, the old
      // order will be changed.
      //
      // If a Content Security Policy nonce is provided, it is added to
      // the `<style>` tag generated by the library.
    }, {
      key: "mount",
      value: function mount(root, modules, options) {
        var set = root[SET],
          nonce = options && options.nonce;
        if (!set) set = new StyleSet(root, nonce);else if (nonce) set.setNonce(nonce);
        set.mount(Array.isArray(modules) ? modules : [modules]);
      }
    }]);
    return StyleModule;
  }();
  var adoptedSet = new Map(); //<Document, StyleSet>
  var StyleSet = /*#__PURE__*/function () {
    function StyleSet(root, nonce) {
      _classCallCheck(this, StyleSet);
      var doc = root.ownerDocument || root,
        win = doc.defaultView;
      if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
        var adopted = adoptedSet.get(doc);
        if (adopted) {
          root.adoptedStyleSheets = [adopted.sheet].concat(_toConsumableArray(root.adoptedStyleSheets));
          return root[SET] = adopted;
        }
        this.sheet = new win.CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(_toConsumableArray(root.adoptedStyleSheets));
        adoptedSet.set(doc, this);
      } else {
        this.styleTag = doc.createElement("style");
        if (nonce) this.styleTag.setAttribute("nonce", nonce);
        var target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    _createClass(StyleSet, [{
      key: "mount",
      value: function mount(modules) {
        var sheet = this.sheet;
        var pos = 0 /* Current rule offset */,
          j = 0; /* Index into this.modules */
        for (var i = 0; i < modules.length; i++) {
          var mod = modules[i],
            index = this.modules.indexOf(mod);
          if (index < j && index > -1) {
            // Ordering conflict
            this.modules.splice(index, 1);
            j--;
            index = -1;
          }
          if (index == -1) {
            this.modules.splice(j++, 0, mod);
            if (sheet) for (var k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);
          } else {
            while (j < index) pos += this.modules[j++].rules.length;
            pos += mod.rules.length;
            j++;
          }
        }
        if (!sheet) {
          var text = "";
          for (var _i = 0; _i < this.modules.length; _i++) text += this.modules[_i].getRules() + "\n";
          this.styleTag.textContent = text;
        }
      }
    }, {
      key: "setNonce",
      value: function setNonce(nonce) {
        if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce) this.styleTag.setAttribute("nonce", nonce);
      }
    }]);
    return StyleSet;
  }(); // Style::Object<union<Style,string>>
  //
  // A style is an object that, in the simple case, maps CSS property
  // names to strings holding their values, as in `{color: "red",
  // fontWeight: "bold"}`. The property names can be given in
  // camel-casethe library will insert a dash before capital letters
  // when converting them to CSS.
  //
  // If you include an underscore in a property name, it and everything
  // after it will be removed from the output, which can be useful when
  // providing a property multiple times, for browser compatibility
  // reasons.
  //
  // A property in a style object can also be a sub-selector, which
  // extends the current context to add a pseudo-selector or a child
  // selector. Such a property should contain a `&` character, which
  // will be replaced by the current selector. For example `{"&:before":
  // {content: '"hi"'}}`. Sub-selectors and regular properties can
  // freely be mixed in a given object. Any property containing a `&` is
  // assumed to be a sub-selector.
  //
  // Finally, a property can specify an @-block to be wrapped around the
  // styles defined inside the object that's the property's value. For
  // example to create a media query you can do `{"@media screen and
  // (min-width: 400px)": {...}}`.

  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: "\""
  };
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

  // Fill in the digit keys
  for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

  // The function keys
  for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

  // And the alphabetic keys
  for (var i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }

  // For each code that doesn't have a shift-equivalent, copy the base name
  for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  function keyName(event) {
    // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
    // On IE, shift effect is never included in `.key`.
    var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie$1 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    // Edge sometimes produces wrong names (Issue #3)
    if (name == "Esc") name = "Escape";
    if (name == "Del") name = "Delete";
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
    if (name == "Left") name = "ArrowLeft";
    if (name == "Up") name = "ArrowUp";
    if (name == "Right") name = "ArrowRight";
    if (name == "Down") name = "ArrowDown";
    return name;
  }

  function getSelection(root) {
    var target;
    // Browsers differ on whether shadow roots have a getSelection
    // method. If it exists, use that, otherwise, call it on the
    // document.
    if (root.nodeType == 11) {
      // Shadow root
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement(doc) {
    var elt = doc.activeElement;
    while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection) {
    if (!selection.anchorNode) return false;
    try {
      // Firefox will raise 'permission denied' errors when accessing
      // properties of `sel.anchorNode` when it's in a generated CSS
      // element.
      return contains(dom, selection.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();else if (dom.nodeType == 1) return dom.getClientRects();else return [];
  }
  // Scans forward and backward through DOM positions equivalent to the
  // given one to see if the two are in the same place (i.e. after a
  // text node vs at the end of that text node)
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0;; index++) {
      node = node.previousSibling;
      if (!node) return index;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
      if (node == targetNode && off == targetOff) return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV") return false;
        var parent = node.parentNode;
        if (!parent || parent.nodeType != 1) return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false") return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function flattenRect(rect, left) {
    var x = left ? rect.left : rect.right;
    return {
      left: x,
      right: x,
      top: rect.top,
      bottom: rect.bottom
    };
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    var doc = dom.ownerDocument,
      win = doc.defaultView || window;
    for (var cur = dom, stop = false; cur && !stop;) {
      if (cur.nodeType == 1) {
        // Element
        var bounding = void 0,
          top = cur == doc.body;
        var scaleX = 1,
          scaleY = 1;
        if (top) {
          bounding = windowRect(win);
        } else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;
          if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
            cur = cur.assignedSlot || cur.parentNode;
            continue;
          }
          var _rect = cur.getBoundingClientRect();
          scaleX = _rect.width / cur.offsetWidth;
          scaleY = _rect.height / cur.offsetHeight;
          // Make sure scrollbar width isn't included in the rectangle
          bounding = {
            left: _rect.left,
            right: _rect.left + cur.clientWidth * scaleX,
            top: _rect.top,
            bottom: _rect.top + cur.clientHeight * scaleY
          };
        }
        var moveX = 0,
          moveY = 0;
        if (y == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          var rectHeight = rect.bottom - rect.top,
            boundingHeight = bounding.bottom - bounding.top;
          var targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          var targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top) {
            win.scrollBy(moveX, moveY);
          } else {
            var movedX = 0,
              movedY = 0;
            if (moveY) {
              var start = cur.scrollTop;
              cur.scrollTop += moveY / scaleY;
              movedY = (cur.scrollTop - start) * scaleY;
            }
            if (moveX) {
              var _start = cur.scrollLeft;
              cur.scrollLeft += moveX / scaleX;
              movedX = (cur.scrollLeft - _start) * scaleX;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1) x = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1) y = "nearest";
          }
        }
        if (top) break;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        // A shadow root
        cur = cur.host;
      } else {
        break;
      }
    }
  }
  function scrollableParent(dom) {
    var doc = dom.ownerDocument;
    for (var cur = dom.parentNode; cur;) {
      if (cur == doc.body) {
        break;
      } else if (cur.nodeType == 1) {
        if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth) return cur;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
    return null;
  }
  var DOMSelectionState = /*#__PURE__*/function () {
    function DOMSelectionState() {
      _classCallCheck(this, DOMSelectionState);
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    _createClass(DOMSelectionState, [{
      key: "eq",
      value: function eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
      }
    }, {
      key: "setRange",
      value: function setRange(range) {
        var anchorNode = range.anchorNode,
          focusNode = range.focusNode;
        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
      }
    }, {
      key: "set",
      value: function set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
      }
    }]);
    return DOMSelectionState;
  }();
  var preventScrollSupported = null;
  // Feature-detects support for .focus({preventScroll: true}), and uses
  // a fallback kludge when not supported.
  function focusPreventScroll(dom) {
    if (dom.setActive) return dom.setActive(); // in IE
    if (preventScrollSupported) return dom.focus(preventScrollSupported);
    var stack = [];
    for (var cur = dom; cur; cur = cur.parentNode) {
      stack.push(cur, cur.scrollTop, cur.scrollLeft);
      if (cur == cur.ownerDocument) break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = {
          preventScroll: true
        };
        return true;
      }
    } : undefined);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (var i = 0; i < stack.length;) {
        var elt = stack[i++],
          top = stack[i++],
          left = stack[i++];
        if (elt.scrollTop != top) elt.scrollTop = top;
        if (elt.scrollLeft != left) elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from) {
    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;
    var range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt, name, code) {
    var options = {
      key: name,
      code: name,
      keyCode: code,
      which: code,
      cancelable: true
    };
    var down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    var up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length) node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc, selection) {
    var node = selection.focusNode,
      offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;
    // Safari can report bogus offsets (#1152)
    offset = Math.min(offset, maxOffset(node));
    for (;;) {
      if (offset) {
        if (node.nodeType != 1) return false;
        var prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false") offset--;else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
  }
  var DOMPos = /*#__PURE__*/function () {
    function DOMPos(node, offset) {
      var precise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      _classCallCheck(this, DOMPos);
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    _createClass(DOMPos, null, [{
      key: "before",
      value: function before(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom), precise);
      }
    }, {
      key: "after",
      value: function after(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
      }
    }]);
    return DOMPos;
  }();
  var noChildren = [];
  var ContentView = /*#__PURE__*/function () {
    function ContentView() {
      _classCallCheck(this, ContentView);
      this.parent = null;
      this.dom = null;
      this.flags = 2 /* ViewFlag.NodeDirty */;
    }
    _createClass(ContentView, [{
      key: "overrideDOMText",
      get: function get() {
        return null;
      }
    }, {
      key: "posAtStart",
      get: function get() {
        return this.parent ? this.parent.posBefore(this) : 0;
      }
    }, {
      key: "posAtEnd",
      get: function get() {
        return this.posAtStart + this.length;
      }
    }, {
      key: "posBefore",
      value: function posBefore(view) {
        var pos = this.posAtStart;
        var _iterator = _createForOfIteratorHelper(this.children),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;
            if (child == view) return pos;
            pos += child.length + child.breakAfter;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        throw new RangeError("Invalid child in posBefore");
      }
    }, {
      key: "posAfter",
      value: function posAfter(view) {
        return this.posBefore(view) + view.length;
      }
    }, {
      key: "sync",
      value: function sync(view, track) {
        if (this.flags & 2 /* ViewFlag.NodeDirty */) {
          var parent = this.dom;
          var prev = null,
            next;
          var _iterator2 = _createForOfIteratorHelper(this.children),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var child = _step2.value;
              if (child.flags & 7 /* ViewFlag.Dirty */) {
                if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                  var contentView = ContentView.get(next);
                  if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);
                }
                child.sync(view, track);
                child.flags &= ~7 /* ViewFlag.Dirty */;
              }

              next = prev ? prev.nextSibling : parent.firstChild;
              if (track && !track.written && track.node == parent && next != child.dom) track.written = true;
              if (child.dom.parentNode == parent) {
                while (next && next != child.dom) next = rm$1(next);
              } else {
                parent.insertBefore(child.dom, next);
              }
              prev = child.dom;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (next && track && track.node == parent) track.written = true;
          while (next) next = rm$1(next);
        } else if (this.flags & 1 /* ViewFlag.ChildDirty */) {
          var _iterator3 = _createForOfIteratorHelper(this.children),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _child = _step3.value;
              if (_child.flags & 7 /* ViewFlag.Dirty */) {
                _child.sync(view, track);
                _child.flags &= ~7 /* ViewFlag.Dirty */;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }
    }, {
      key: "reuseDOM",
      value: function reuseDOM(_dom) {}
    }, {
      key: "localPosFromDOM",
      value: function localPosFromDOM(node, offset) {
        var after;
        if (node == this.dom) {
          after = this.dom.childNodes[offset];
        } else {
          var bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
          for (;;) {
            var parent = node.parentNode;
            if (parent == this.dom) break;
            if (bias == 0 && parent.firstChild != parent.lastChild) {
              if (node == parent.firstChild) bias = -1;else bias = 1;
            }
            node = parent;
          }
          if (bias < 0) after = node;else after = node.nextSibling;
        }
        if (after == this.dom.firstChild) return 0;
        while (after && !ContentView.get(after)) after = after.nextSibling;
        if (!after) return this.length;
        for (var i = 0, pos = 0;; i++) {
          var child = this.children[i];
          if (child.dom == after) return pos;
          pos += child.length + child.breakAfter;
        }
      }
    }, {
      key: "domBoundsAround",
      value: function domBoundsAround(from, to) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var fromI = -1,
          fromStart = -1,
          toI = -1,
          toEnd = -1;
        for (var i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
          var child = this.children[i],
            end = pos + child.length;
          if (pos < from && end > to) return child.domBoundsAround(from, to, pos);
          if (end >= from && fromI == -1) {
            fromI = i;
            fromStart = pos;
          }
          if (pos > to && child.dom.parentNode == this.dom) {
            toI = i;
            toEnd = prevEnd;
            break;
          }
          prevEnd = end;
          pos = end + child.breakAfter;
        }
        return {
          from: fromStart,
          to: toEnd < 0 ? offset + this.length : toEnd,
          startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
          endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
        };
      }
    }, {
      key: "markDirty",
      value: function markDirty() {
        var andParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        this.flags |= 2 /* ViewFlag.NodeDirty */;
        this.markParentsDirty(andParent);
      }
    }, {
      key: "markParentsDirty",
      value: function markParentsDirty(childList) {
        for (var parent = this.parent; parent; parent = parent.parent) {
          if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */;
          if (parent.flags & 1 /* ViewFlag.ChildDirty */) return;
          parent.flags |= 1 /* ViewFlag.ChildDirty */;
          childList = false;
        }
      }
    }, {
      key: "setParent",
      value: function setParent(parent) {
        if (this.parent != parent) {
          this.parent = parent;
          if (this.flags & 7 /* ViewFlag.Dirty */) this.markParentsDirty(true);
        }
      }
    }, {
      key: "setDOM",
      value: function setDOM(dom) {
        if (this.dom == dom) return;
        if (this.dom) this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
      }
    }, {
      key: "rootView",
      get: function get() {
        for (var v = this;;) {
          var parent = v.parent;
          if (!parent) return v;
          v = parent;
        }
      }
    }, {
      key: "replaceChildren",
      value: function replaceChildren(from, to) {
        var _this$children;
        var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noChildren;
        this.markDirty();
        for (var i = from; i < to; i++) {
          var child = this.children[i];
          if (child.parent == this) child.destroy();
        }
        (_this$children = this.children).splice.apply(_this$children, [from, to - from].concat(_toConsumableArray(children)));
        for (var _i = 0; _i < children.length; _i++) children[_i].setParent(this);
      }
    }, {
      key: "ignoreMutation",
      value: function ignoreMutation(_rec) {
        return false;
      }
    }, {
      key: "ignoreEvent",
      value: function ignoreEvent(_event) {
        return false;
      }
    }, {
      key: "childCursor",
      value: function childCursor() {
        var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.length;
        return new ChildCursor(this.children, pos, this.children.length);
      }
    }, {
      key: "childPos",
      value: function childPos(pos) {
        var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return this.childCursor().findPos(pos, bias);
      }
    }, {
      key: "toString",
      value: function toString() {
        var name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
      }
    }, {
      key: "isEditable",
      get: function get() {
        return true;
      }
    }, {
      key: "isWidget",
      get: function get() {
        return false;
      }
    }, {
      key: "isHidden",
      get: function get() {
        return false;
      }
    }, {
      key: "merge",
      value: function merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
      }
    }, {
      key: "become",
      value: function become(other) {
        return false;
      }
    }, {
      key: "canReuseDOM",
      value: function canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
      }
      // When this is a zero-length view with a side, this should return a
      // number <= 0 to indicate it is before its position, or a
      // number > 0 when after its position.
    }, {
      key: "getSide",
      value: function getSide() {
        return 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.parent = null;
      }
    }], [{
      key: "get",
      value: function get(node) {
        return node.cmView;
      }
    }]);
    return ContentView;
  }();
  ContentView.prototype.breakAfter = 0;
  // Remove a DOM node and return its next sibling.
  function rm$1(dom) {
    var next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = /*#__PURE__*/function () {
    function ChildCursor(children, pos, i) {
      _classCallCheck(this, ChildCursor);
      this.children = children;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    _createClass(ChildCursor, [{
      key: "findPos",
      value: function findPos(pos) {
        var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        for (;;) {
          if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
            this.off = pos - this.pos;
            return this;
          }
          var next = this.children[--this.i];
          this.pos -= next.length + next.breakAfter;
        }
      }
    }]);
    return ChildCursor;
  }();
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
    var children = parent.children;
    var before = children.length ? children[fromI] : null;
    var last = insert.length ? insert[insert.length - 1] : null;
    var breakAtEnd = last ? last.breakAfter : breakAtStart;
    // Change within a single child
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;
    if (toI < children.length) {
      var after = children[toI];
      // Make sure the end of the child after the update is preserved in `after`
      if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
        // If we're splitting a child, separate part of it to avoid that
        // being mangled when updating the child before the update.
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        // If the element after the replacement should be merged with
        // the last replacing element, update `content`
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert[insert.length - 1] = after;
        } else {
          // Remove the start of the after element, if necessary, and
          // add it to `content`.
          if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);
          insert.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        // The element at `toI` is entirely covered by this range.
        // Preserve its line break, if any.
        if (last) last.breakAfter = 1;else breakAtStart = 1;
      }
      // Since we've handled the next element from the current elements
      // now, make sure `toI` points after that.
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
          before.breakAfter = insert.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    // Try to merge widgets on the boundaries of the replacement
    while (fromI < toI && insert.length) {
      if (children[toI - 1].become(insert[insert.length - 1])) {
        toI--;
        insert.pop();
        openEnd = insert.length ? 0 : openStart;
      } else if (children[fromI].become(insert[0])) {
        fromI++;
        insert.shift();
        openStart = insert.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;
    if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);
  }
  function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
    var cur = parent.childCursor();
    var _cur$findPos = cur.findPos(to, 1),
      toI = _cur$findPos.i,
      toOff = _cur$findPos.off;
    var _cur$findPos2 = cur.findPos(from, -1),
      fromI = _cur$findPos2.i,
      fromOff = _cur$findPos2.off;
    var dLen = from - to;
    var _iterator4 = _createForOfIteratorHelper(insert),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var view = _step4.value;
        dLen += view.length;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : {
    userAgent: "",
    vendor: "",
    platform: ""
  };
  var doc = typeof document != "undefined" ? document : {
    documentElement: {
      style: {}
    }
  };
  var ie_edge = /*@__PURE__*/ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /*@__PURE__*/ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /*@__PURE__*/ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko = !ie && /*@__PURE__*/ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome = !ie && /*@__PURE__*/ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = ("webkitFontSmoothing" in doc.documentElement.style);
  var safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);
  var ios = safari && ( /*@__PURE__*/ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),
    windows: /*@__PURE__*/ /Win/.test(nav.platform),
    linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),
    ie: ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko,
    gecko_version: gecko ? +( /*@__PURE__*/ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios: ios,
    android: /*@__PURE__*/ /Android\b/.test(nav.userAgent),
    webkit: webkit,
    safari: safari,
    webkit_version: webkit ? +( /*@__PURE__*/ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = /*#__PURE__*/function (_ContentView) {
    _inherits$1(TextView, _ContentView);
    var _super = _createSuper(TextView);
    function TextView(text) {
      var _this;
      _classCallCheck(this, TextView);
      _this = _super.call(this);
      _this.text = text;
      return _this;
    }
    _createClass(TextView, [{
      key: "length",
      get: function get() {
        return this.text.length;
      }
    }, {
      key: "createDOM",
      value: function createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
      }
    }, {
      key: "sync",
      value: function sync(view, track) {
        if (!this.dom) this.createDOM();
        if (this.dom.nodeValue != this.text) {
          if (track && track.node == this.dom) track.written = true;
          this.dom.nodeValue = this.text;
        }
      }
    }, {
      key: "reuseDOM",
      value: function reuseDOM(dom) {
        if (dom.nodeType == 3) this.createDOM(dom);
      }
    }, {
      key: "merge",
      value: function merge(from, to, source) {
        if (this.flags & 8 /* ViewFlag.Composition */ || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8 /* ViewFlag.Composition */)) return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
      }
    }, {
      key: "split",
      value: function split(from) {
        var result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        result.flags |= this.flags & 8 /* ViewFlag.Composition */;
        return result;
      }
    }, {
      key: "localPosFromDOM",
      value: function localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
      }
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        return new DOMPos(this.dom, pos);
      }
    }, {
      key: "domBoundsAround",
      value: function domBoundsAround(_from, _to, offset) {
        return {
          from: offset,
          to: offset + this.length,
          startDOM: this.dom,
          endDOM: this.dom.nextSibling
        };
      }
    }, {
      key: "coordsAt",
      value: function coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
      }
    }]);
    return TextView;
  }(ContentView);
  var MarkView = /*#__PURE__*/function (_ContentView2) {
    _inherits$1(MarkView, _ContentView2);
    var _super2 = _createSuper(MarkView);
    function MarkView(mark) {
      var _this2;
      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      _classCallCheck(this, MarkView);
      _this2 = _super2.call(this);
      _this2.mark = mark;
      _this2.children = children;
      _this2.length = length;
      var _iterator5 = _createForOfIteratorHelper(children),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ch = _step5.value;
          ch.setParent(_assertThisInitialized(_this2));
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return _this2;
    }
    _createClass(MarkView, [{
      key: "setAttrs",
      value: function setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark["class"]) dom.className = this.mark["class"];
        if (this.mark.attrs) for (var name in this.mark.attrs) dom.setAttribute(name, this.mark.attrs[name]);
        return dom;
      }
    }, {
      key: "canReuseDOM",
      value: function canReuseDOM(other) {
        return _get(_getPrototypeOf(MarkView.prototype), "canReuseDOM", this).call(this, other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
      }
    }, {
      key: "reuseDOM",
      value: function reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
          this.setDOM(node);
          this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
      }
    }, {
      key: "sync",
      value: function sync(view, track) {
        if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));else if (this.flags & 4 /* ViewFlag.AttrsDirty */) this.setAttrs(this.dom);
        _get(_getPrototypeOf(MarkView.prototype), "sync", this).call(this, view, track);
      }
    }, {
      key: "merge",
      value: function merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
        mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
      }
    }, {
      key: "split",
      value: function split(from) {
        var result = [],
          off = 0,
          detachFrom = -1,
          i = 0;
        var _iterator6 = _createForOfIteratorHelper(this.children),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var elt = _step6.value;
            var end = off + elt.length;
            if (end > from) result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from) detachFrom = i;
            off = end;
            i++;
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        var length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
          this.children.length = detachFrom;
          this.markDirty();
        }
        return new MarkView(this.mark, result, length);
      }
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
      }
    }, {
      key: "coordsAt",
      value: function coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
      }
    }]);
    return MarkView;
  }(ContentView);
  function textCoords(text, pos, side) {
    var length = text.nodeValue.length;
    if (pos > length) pos = length;
    var from = pos,
      to = pos,
      flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        // These browsers reliably return valid rectangles for empty ranges
        if (pos) {
          from--;
          flatten = 1;
        } // FIXME this is wrong in RTL text
        else if (to < length) {
          to++;
          flatten = -1;
        }
      }
    } else {
      if (side < 0) from--;else if (to < length) to++;
    }
    var rects = textRange(text, from, to).getClientRects();
    if (!rects.length) return null;
    var rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, function (r) {
      return r.width;
    }) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect || null;
  }
  // Also used for collapsed ranges that don't have a placeholder widget!
  var WidgetView = /*#__PURE__*/function (_ContentView3) {
    _inherits$1(WidgetView, _ContentView3);
    var _super3 = _createSuper(WidgetView);
    function WidgetView(widget, length, side) {
      var _this3;
      _classCallCheck(this, WidgetView);
      _this3 = _super3.call(this);
      _this3.widget = widget;
      _this3.length = length;
      _this3.side = side;
      _this3.prevWidget = null;
      return _this3;
    }
    _createClass(WidgetView, [{
      key: "split",
      value: function split(from) {
        var result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
      }
    }, {
      key: "sync",
      value: function sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
          this.prevWidget = null;
          this.setDOM(this.widget.toDOM(view));
          this.dom.contentEditable = "false";
        }
      }
    }, {
      key: "getSide",
      value: function getSide() {
        return this.side;
      }
    }, {
      key: "merge",
      value: function merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
      }
    }, {
      key: "become",
      value: function become(other) {
        if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
          if (!this.widget.compare(other.widget)) this.markDirty(true);
          if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
          this.widget = other.widget;
          this.length = other.length;
          return true;
        }
        return false;
      }
    }, {
      key: "ignoreMutation",
      value: function ignoreMutation() {
        return true;
      }
    }, {
      key: "ignoreEvent",
      value: function ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
      }
    }, {
      key: "overrideDOMText",
      get: function get() {
        if (this.length == 0) return Text.empty;
        var top = this;
        while (top.parent) top = top.parent;
        var _top = top,
          view = _top.view,
          text = view && view.state.doc,
          start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : Text.empty;
      }
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
      }
    }, {
      key: "domBoundsAround",
      value: function domBoundsAround() {
        return null;
      }
    }, {
      key: "coordsAt",
      value: function coordsAt(pos, side) {
        var custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom) return custom;
        var rects = this.dom.getClientRects(),
          rect = null;
        if (!rects.length) return null;
        var fromBack = this.side ? this.side < 0 : pos > 0;
        for (var i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1) {
          rect = rects[i];
          if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;
        }
        return flattenRect(rect, !fromBack);
      }
    }, {
      key: "isEditable",
      get: function get() {
        return false;
      }
    }, {
      key: "isWidget",
      get: function get() {
        return true;
      }
    }, {
      key: "isHidden",
      get: function get() {
        return this.widget.isHidden;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(WidgetView.prototype), "destroy", this).call(this);
        if (this.dom) this.widget.destroy(this.dom);
      }
    }], [{
      key: "create",
      value: function create(widget, length, side) {
        return new WidgetView(widget, length, side);
      }
    }]);
    return WidgetView;
  }(ContentView); // These are drawn around uneditable widgets to avoid a number of
  // browser bugs that show up when the cursor is directly next to
  // uneditable inline content.
  var WidgetBufferView = /*#__PURE__*/function (_ContentView4) {
    _inherits$1(WidgetBufferView, _ContentView4);
    var _super4 = _createSuper(WidgetBufferView);
    function WidgetBufferView(side) {
      var _this4;
      _classCallCheck(this, WidgetBufferView);
      _this4 = _super4.call(this);
      _this4.side = side;
      return _this4;
    }
    _createClass(WidgetBufferView, [{
      key: "length",
      get: function get() {
        return 0;
      }
    }, {
      key: "merge",
      value: function merge() {
        return false;
      }
    }, {
      key: "become",
      value: function become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
      }
    }, {
      key: "split",
      value: function split() {
        return new WidgetBufferView(this.side);
      }
    }, {
      key: "sync",
      value: function sync() {
        if (!this.dom) {
          var dom = document.createElement("img");
          dom.className = "cm-widgetBuffer";
          dom.setAttribute("aria-hidden", "true");
          this.setDOM(dom);
        }
      }
    }, {
      key: "getSide",
      value: function getSide() {
        return this.side;
      }
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
      }
    }, {
      key: "localPosFromDOM",
      value: function localPosFromDOM() {
        return 0;
      }
    }, {
      key: "domBoundsAround",
      value: function domBoundsAround() {
        return null;
      }
    }, {
      key: "coordsAt",
      value: function coordsAt(pos) {
        return this.dom.getBoundingClientRect();
      }
    }, {
      key: "overrideDOMText",
      get: function get() {
        return Text.empty;
      }
    }, {
      key: "isHidden",
      get: function get() {
        return true;
      }
    }]);
    return WidgetBufferView;
  }(ContentView);
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineDOMAtPos(parent, pos) {
    var dom = parent.dom,
      children = parent.children,
      i = 0;
    for (var off = 0; i < children.length; i++) {
      var child = children[i],
        end = off + child.length;
      if (end == off && child.getSide() <= 0) continue;
      if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);
      if (pos <= off) break;
      off = end;
    }
    for (var j = i; j > 0; j--) {
      var prev = children[j - 1];
      if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);
    }
    for (var _j = i; _j < children.length; _j++) {
      var next = children[_j];
      if (next.dom.parentNode == dom) return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  // Assumes `view`, if a mark view, has precisely 1 child.
  function joinInlineInto(parent, view, open) {
    var last,
      children = parent.children;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    var before = null,
      beforePos = -1,
      after = null,
      afterPos = -1;
    function scan(view, pos) {
      for (var i = 0, off = 0; i < view.children.length && off <= pos; i++) {
        var child = view.children[i],
          end = off + child.length;
        if (end >= pos) {
          if (child.children.length) {
            scan(child, pos - off);
          } else if ((!after || after.isHidden && side > 0) && (end > pos || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos - off;
          } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {
            before = child;
            beforePos = pos - off;
          }
        }
        off = end;
      }
    }
    scan(view, pos);
    var target = (side < 0 ? before : after) || before || after;
    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  function fallbackRect(view) {
    var last = view.dom.lastChild;
    if (!last) return view.dom.getBoundingClientRect();
    var rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (var name in source) {
      if (name == "class" && target["class"]) target["class"] += " " + source["class"];else if (name == "style" && target.style) target.style += ";" + source.style;else target[name] = source[name];
    }
    return target;
  }
  var noAttrs = /*@__PURE__*/Object.create(null);
  function attrsEq(a, b, ignore) {
    if (a == b) return true;
    if (!a) a = noAttrs;
    if (!b) b = noAttrs;
    var keysA = Object.keys(a),
      keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;
    for (var _i2 = 0, _keysA = keysA; _i2 < _keysA.length; _i2++) {
      var key = _keysA[_i2];
      if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;
    }
    return true;
  }
  function _updateAttrs(dom, prev, attrs) {
    var changed = false;
    if (prev) for (var name in prev) if (!(attrs && name in attrs)) {
      changed = true;
      if (name == "style") dom.style.cssText = "";else dom.removeAttribute(name);
    }
    if (attrs) for (var _name in attrs) if (!(prev && prev[_name] == attrs[_name])) {
      changed = true;
      if (_name == "style") dom.style.cssText = attrs[_name];else dom.setAttribute(_name, attrs[_name]);
    }
    return changed;
  }
  function getAttrs(dom) {
    var attrs = Object.create(null);
    for (var i = 0; i < dom.attributes.length; i++) {
      var attr = dom.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }
  var LineView = /*#__PURE__*/function (_ContentView5) {
    _inherits$1(LineView, _ContentView5);
    var _super5 = _createSuper(LineView);
    function LineView() {
      var _this5;
      _classCallCheck(this, LineView);
      _this5 = _super5.apply(this, arguments);
      _this5.children = [];
      _this5.length = 0;
      _this5.prevAttrs = undefined;
      _this5.attrs = null;
      _this5.breakAfter = 0;
      return _this5;
    }
    // Consumes source
    _createClass(LineView, [{
      key: "merge",
      value: function merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
          if (!(source instanceof LineView)) return false;
          if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate
        }

        if (hasStart) this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
        return true;
      }
    }, {
      key: "split",
      value: function split(at) {
        var end = new LineView();
        end.breakAfter = this.breakAfter;
        if (this.length == 0) return end;
        var _this$childPos = this.childPos(at),
          i = _this$childPos.i,
          off = _this$childPos.off;
        if (off) {
          end.append(this.children[i].split(off), 0);
          this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
          i++;
        }
        for (var j = i; j < this.children.length; j++) end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0) this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
      }
    }, {
      key: "transferDOM",
      value: function transferDOM(other) {
        if (!this.dom) return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
      }
    }, {
      key: "setDeco",
      value: function setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
          if (this.dom) {
            this.prevAttrs = this.attrs;
            this.markDirty();
          }
          this.attrs = attrs;
        }
      }
    }, {
      key: "append",
      value: function append(child, openStart) {
        joinInlineInto(this, child, openStart);
      }
      // Only called when building a line view in ContentBuilder
    }, {
      key: "addLineDeco",
      value: function addLineDeco(deco) {
        var attrs = deco.spec.attributes,
          cls = deco.spec["class"];
        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls) this.attrs = combineAttrs({
          "class": cls
        }, this.attrs || {});
      }
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
      }
    }, {
      key: "reuseDOM",
      value: function reuseDOM(node) {
        if (node.nodeName == "DIV") {
          this.setDOM(node);
          this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
      }
    }, {
      key: "sync",
      value: function sync(view, track) {
        var _a;
        if (!this.dom) {
          this.setDOM(document.createElement("div"));
          this.dom.className = "cm-line";
          this.prevAttrs = this.attrs ? null : undefined;
        } else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {
          clearAttributes(this.dom);
          this.dom.className = "cm-line";
          this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
          _updateAttrs(this.dom, this.prevAttrs, this.attrs);
          this.dom.classList.add("cm-line");
          this.prevAttrs = undefined;
        }
        _get(_getPrototypeOf(LineView.prototype), "sync", this).call(this, view, track);
        var last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild;
        if (!last || !this.length || last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some(function (ch) {
          return ch instanceof TextView;
        }))) {
          var hack = document.createElement("BR");
          hack.cmIgnore = true;
          this.dom.appendChild(hack);
        }
      }
    }, {
      key: "measureTextSize",
      value: function measureTextSize() {
        if (this.children.length == 0 || this.length > 20) return null;
        var totalWidth = 0,
          textHeight;
        var _iterator7 = _createForOfIteratorHelper(this.children),
          _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var child = _step7.value;
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;
            var rects = clientRectsFor(child.dom);
            if (rects.length != 1) return null;
            totalWidth += rects[0].width;
            textHeight = rects[0].height;
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
        return !totalWidth ? null : {
          lineHeight: this.dom.getBoundingClientRect().height,
          charWidth: totalWidth / this.length,
          textHeight: textHeight
        };
      }
    }, {
      key: "coordsAt",
      value: function coordsAt(pos, side) {
        var rect = coordsInChildren(this, pos, side);
        // Correct rectangle height for empty lines when the returned
        // height is larger than the text height.
        if (!this.children.length && rect && this.parent) {
          var heightOracle = this.parent.view.viewState.heightOracle,
            height = rect.bottom - rect.top;
          if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
            var _dist = (height - heightOracle.textHeight) / 2;
            return {
              top: rect.top + _dist,
              bottom: rect.bottom - _dist,
              left: rect.left,
              right: rect.left
            };
          }
        }
        return rect;
      }
    }, {
      key: "become",
      value: function become(_other) {
        return false;
      }
    }, {
      key: "covers",
      value: function covers() {
        return true;
      }
    }], [{
      key: "find",
      value: function find(docView, pos) {
        for (var i = 0, off = 0; i < docView.children.length; i++) {
          var block = docView.children[i],
            end = off + block.length;
          if (end >= pos) {
            if (block instanceof LineView) return block;
            if (end > pos) break;
          }
          off = end + block.breakAfter;
        }
        return null;
      }
    }]);
    return LineView;
  }(ContentView);
  var BlockWidgetView = /*#__PURE__*/function (_ContentView6) {
    _inherits$1(BlockWidgetView, _ContentView6);
    var _super6 = _createSuper(BlockWidgetView);
    function BlockWidgetView(widget, length, deco) {
      var _this6;
      _classCallCheck(this, BlockWidgetView);
      _this6 = _super6.call(this);
      _this6.widget = widget;
      _this6.length = length;
      _this6.deco = deco;
      _this6.breakAfter = 0;
      _this6.prevWidget = null;
      return _this6;
    }
    _createClass(BlockWidgetView, [{
      key: "merge",
      value: function merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
      }
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
      }
    }, {
      key: "split",
      value: function split(at) {
        var len = this.length - at;
        this.length = at;
        var end = new BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
      }
    }, {
      key: "children",
      get: function get() {
        return noChildren;
      }
    }, {
      key: "sync",
      value: function sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
          this.prevWidget = null;
          this.setDOM(this.widget.toDOM(view));
          this.dom.contentEditable = "false";
        }
      }
    }, {
      key: "overrideDOMText",
      get: function get() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
      }
    }, {
      key: "domBoundsAround",
      value: function domBoundsAround() {
        return null;
      }
    }, {
      key: "become",
      value: function become(other) {
        if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
          if (!other.widget.compare(this.widget)) this.markDirty(true);
          if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
          this.widget = other.widget;
          this.length = other.length;
          this.deco = other.deco;
          this.breakAfter = other.breakAfter;
          return true;
        }
        return false;
      }
    }, {
      key: "ignoreMutation",
      value: function ignoreMutation() {
        return true;
      }
    }, {
      key: "ignoreEvent",
      value: function ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
      }
    }, {
      key: "isEditable",
      get: function get() {
        return false;
      }
    }, {
      key: "isWidget",
      get: function get() {
        return true;
      }
    }, {
      key: "coordsAt",
      value: function coordsAt(pos, side) {
        return this.widget.coordsAt(this.dom, pos, side);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(BlockWidgetView.prototype), "destroy", this).call(this);
        if (this.dom) this.widget.destroy(this.dom);
      }
    }, {
      key: "covers",
      value: function covers(side) {
        var _this$deco = this.deco,
          startSide = _this$deco.startSide,
          endSide = _this$deco.endSide;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
      }
    }]);
    return BlockWidgetView;
  }(ContentView);
  /**
  Widgets added to the content are described by subclasses of this
  class. Using a description object like that makes it possible to
  delay creating of the DOM structure for a widget until it is
  needed, and to avoid redrawing widgets even if the decorations
  that define them are recreated.
  */
  var WidgetType = /*#__PURE__*/function () {
    function WidgetType() {
      _classCallCheck(this, WidgetType);
    }
    _createClass(WidgetType, [{
      key: "eq",
      value:
      /**
      Compare this instance to another instance of the same type.
      (TypeScript can't express this, but only instances of the same
      specific class will be passed to this method.) This is used to
      avoid redrawing widgets when they are replaced by a new
      decoration of the same type. The default implementation just
      returns `false`, which will cause new instances of the widget to
      always be redrawn.
      */
      function eq(widget) {
        return false;
      }
      /**
      Update a DOM element created by a widget of the same type (but
      different, non-`eq` content) to reflect this widget. May return
      true to indicate that it could update, false to indicate it
      couldn't (in which case the widget will be redrawn). The default
      implementation just returns false.
      */
    }, {
      key: "updateDOM",
      value: function updateDOM(dom, view) {
        return false;
      }
      /**
      @internal
      */
    }, {
      key: "compare",
      value: function compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
      }
      /**
      The estimated height this widget will have, to be used when
      estimating the height of content that hasn't been drawn. May
      return -1 to indicate you don't know. The default implementation
      returns -1.
      */
    }, {
      key: "estimatedHeight",
      get: function get() {
        return -1;
      }
      /**
      For inline widgets that are displayed inline (as opposed to
      `inline-block`) and introduce line breaks (through `<br>` tags
      or textual newlines), this must indicate the amount of line
      breaks they introduce. Defaults to 0.
      */
    }, {
      key: "lineBreaks",
      get: function get() {
        return 0;
      }
      /**
      Can be used to configure which kinds of events inside the widget
      should be ignored by the editor. The default is to ignore all
      events.
      */
    }, {
      key: "ignoreEvent",
      value: function ignoreEvent(event) {
        return true;
      }
      /**
      Override the way screen coordinates for positions at/in the
      widget are found. `pos` will be the offset into the widget, and
      `side` the side of the position that is being queriedless than
      zero for before, greater than zero for after, and zero for
      directly at that position.
      */
    }, {
      key: "coordsAt",
      value: function coordsAt(dom, pos, side) {
        return null;
      }
      /**
      @internal
      */
    }, {
      key: "isHidden",
      get: function get() {
        return false;
      }
      /**
      This is called when the an instance of the widget is removed
      from the editor view.
      */
    }, {
      key: "destroy",
      value: function destroy(dom) {}
    }]);
    return WidgetType;
  }();
  /**
  The different types of blocks that can occur in an editor view.
  */
  var BlockType = /*@__PURE__*/function (BlockType) {
    /**
    A line of text.
    */
    BlockType[BlockType["Text"] = 0] = "Text";
    /**
    A block widget associated with the position after it.
    */
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    /**
    A block widget associated with the position before it.
    */
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
    return BlockType;
  }(BlockType || (BlockType = {}));
  /**
  A decoration provides information on how to draw or style a piece
  of content. You'll usually use it wrapped in a
  [`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
  @nonabstract
  */
  var Decoration = /*#__PURE__*/function (_RangeValue) {
    _inherits$1(Decoration, _RangeValue);
    var _super7 = _createSuper(Decoration);
    function Decoration(
    /**
    @internal
    */
    startSide,
    /**
    @internal
    */
    endSide,
    /**
    @internal
    */
    widget,
    /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
    spec) {
      var _this7;
      _classCallCheck(this, Decoration);
      _this7 = _super7.call(this);
      _this7.startSide = startSide;
      _this7.endSide = endSide;
      _this7.widget = widget;
      _this7.spec = spec;
      return _this7;
    }
    /**
    @internal
    */
    _createClass(Decoration, [{
      key: "heightRelevant",
      get: function get() {
        return false;
      }
      /**
      Create a mark decoration, which influences the styling of the
      content in its range. Nested mark decorations will cause nested
      DOM elements to be created. Nesting order is determined by
      precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
      the higher-precedence decorations creating the inner DOM nodes.
      Such elements are split on line boundaries and on the boundaries
      of lower-precedence decorations.
      */
    }, {
      key: "hasHeight",
      value:
      /**
      @internal
      */
      function hasHeight() {
        return this.widget ? this.widget.estimatedHeight > -1 : false;
      }
    }], [{
      key: "mark",
      value: function mark(spec) {
        return new MarkDecoration(spec);
      }
      /**
      Create a widget decoration, which displays a DOM element at the
      given position.
      */
    }, {
      key: "widget",
      value: function widget(spec) {
        var side = Math.max(-10000, Math.min(10000, spec.side || 0)),
          block = !!spec.block;
        side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */ : side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */;
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
      }
      /**
      Create a replace decoration which replaces the given range with
      a widget, or simply hides it.
      */
    }, {
      key: "replace",
      value: function replace(spec) {
        var block = !!spec.block,
          startSide,
          endSide;
        if (spec.isBlockGap) {
          startSide = -500000000 /* Side.GapStart */;
          endSide = 400000000 /* Side.GapEnd */;
        } else {
          var _getInclusive = getInclusive(spec, block),
            start = _getInclusive.start,
            end = _getInclusive.end;
          startSide = (start ? block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */) - 1;
          endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
      }
      /**
      Create a line decoration, which can add DOM attributes to the
      line starting at the given position.
      */
    }, {
      key: "line",
      value: function line(spec) {
        return new LineDecoration(spec);
      }
      /**
      Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
      decorated range or ranges. If the ranges aren't already sorted,
      pass `true` for `sort` to make the library sort them for you.
      */
    }, {
      key: "set",
      value: function set(of) {
        var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return RangeSet.of(of, sort);
      }
    }]);
    return Decoration;
  }(RangeValue);
  /**
  The empty set of decorations.
  */
  Decoration.none = RangeSet.empty;
  var MarkDecoration = /*#__PURE__*/function (_Decoration) {
    _inherits$1(MarkDecoration, _Decoration);
    var _super8 = _createSuper(MarkDecoration);
    function MarkDecoration(spec) {
      var _this8;
      _classCallCheck(this, MarkDecoration);
      var _getInclusive2 = getInclusive(spec),
        start = _getInclusive2.start,
        end = _getInclusive2.end;
      _this8 = _super8.call(this, start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);
      _this8.tagName = spec.tagName || "span";
      _this8["class"] = spec["class"] || "";
      _this8.attrs = spec.attributes || null;
      return _this8;
    }
    _createClass(MarkDecoration, [{
      key: "eq",
      value: function eq(other) {
        var _a, _b;
        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this["class"] || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a["class"])) == (other["class"] || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b["class"])) && attrsEq(this.attrs, other.attrs, "class");
      }
    }, {
      key: "range",
      value: function range(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
        if (from >= to) throw new RangeError("Mark decorations may not be empty");
        return _get(_getPrototypeOf(MarkDecoration.prototype), "range", this).call(this, from, to);
      }
    }]);
    return MarkDecoration;
  }(Decoration);
  MarkDecoration.prototype.point = false;
  var LineDecoration = /*#__PURE__*/function (_Decoration2) {
    _inherits$1(LineDecoration, _Decoration2);
    var _super9 = _createSuper(LineDecoration);
    function LineDecoration(spec) {
      _classCallCheck(this, LineDecoration);
      return _super9.call(this, -200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);
    }
    _createClass(LineDecoration, [{
      key: "eq",
      value: function eq(other) {
        return other instanceof LineDecoration && this.spec["class"] == other.spec["class"] && attrsEq(this.spec.attributes, other.spec.attributes);
      }
    }, {
      key: "range",
      value: function range(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
        if (to != from) throw new RangeError("Line decoration ranges must be zero-length");
        return _get(_getPrototypeOf(LineDecoration.prototype), "range", this).call(this, from, to);
      }
    }]);
    return LineDecoration;
  }(Decoration);
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = /*#__PURE__*/function (_Decoration3) {
    _inherits$1(PointDecoration, _Decoration3);
    var _super10 = _createSuper(PointDecoration);
    function PointDecoration(spec, startSide, endSide, block, widget, isReplace) {
      var _this9;
      _classCallCheck(this, PointDecoration);
      _this9 = _super10.call(this, startSide, endSide, widget, spec);
      _this9.block = block;
      _this9.isReplace = isReplace;
      _this9.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
      return _this9;
    }
    // Only relevant when this.block == true
    _createClass(PointDecoration, [{
      key: "type",
      get: function get() {
        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
      }
    }, {
      key: "heightRelevant",
      get: function get() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
      }
    }, {
      key: "eq",
      value: function eq(other) {
        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
      }
    }, {
      key: "range",
      value: function range(from) {
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from) throw new RangeError("Widget decorations can only have zero-length ranges");
        return _get(_getPrototypeOf(PointDecoration.prototype), "range", this).call(this, from, to);
      }
    }]);
    return PointDecoration;
  }(Decoration);
  PointDecoration.prototype.point = true;
  function getInclusive(spec) {
    var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var start = spec.inclusiveStart,
      end = spec.inclusiveEnd;
    if (start == null) start = spec.inclusive;
    if (end == null) end = spec.inclusive;
    return {
      start: start !== null && start !== void 0 ? start : block,
      end: end !== null && end !== void 0 ? end : block
    };
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges) {
    var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);else ranges.push(from, to);
  }
  var ContentBuilder = /*#__PURE__*/function () {
    function ContentBuilder(doc, pos, end, disallowBlockEffectsFor) {
      _classCallCheck(this, ContentBuilder);
      this.doc = doc;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0 /* Buf.No */;
      this.bufferMarks = [];
      // Set to false directly after a widget that covers the position after it
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc.iter();
      this.skip = pos;
    }
    _createClass(ContentBuilder, [{
      key: "posCovered",
      value: function posCovered() {
        if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        var last = this.content[this.content.length - 1];
        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
      }
    }, {
      key: "getLine",
      value: function getLine() {
        if (!this.curLine) {
          this.content.push(this.curLine = new LineView());
          this.atCursorPos = true;
        }
        return this.curLine;
      }
    }, {
      key: "flushBuffer",
      value: function flushBuffer() {
        var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.bufferMarks;
        if (this.pendingBuffer) {
          this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
          this.pendingBuffer = 0 /* Buf.No */;
        }
      }
    }, {
      key: "addBlockWidget",
      value: function addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
      }
    }, {
      key: "finish",
      value: function finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();else this.pendingBuffer = 0 /* Buf.No */;
        if (!openEnd && !this.posCovered()) this.getLine();
      }
    }, {
      key: "buildText",
      value: function buildText(length, active, openStart) {
        while (length > 0) {
          if (this.textOff == this.text.length) {
            var _this$cursor$next = this.cursor.next(this.skip),
              value = _this$cursor$next.value,
              lineBreak = _this$cursor$next.lineBreak,
              done = _this$cursor$next.done;
            this.skip = 0;
            if (done) throw new Error("Ran out of text content when drawing inline views");
            if (lineBreak) {
              if (!this.posCovered()) this.getLine();
              if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;else this.breakAtStart = 1;
              this.flushBuffer();
              this.curLine = null;
              this.atCursorPos = true;
              length--;
              continue;
            } else {
              this.text = value;
              this.textOff = 0;
            }
          }
          var take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);
          this.flushBuffer(active.slice(active.length - openStart));
          this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
          this.atCursorPos = true;
          this.textOff += take;
          length -= take;
          openStart = 0;
        }
      }
    }, {
      key: "span",
      value: function span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0) this.openStart = openStart;
      }
    }, {
      key: "point",
      value: function point(from, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
          if (deco.block) throw new RangeError("Block decorations may not be specified via plugins");
          if (to > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        var len = to - from;
        if (deco instanceof PointDecoration) {
          if (deco.block) {
            if (deco.startSide > 0 && !this.posCovered()) this.getLine();
            this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, deco));
          } else {
            var view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
            var cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
            var cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
            var line = this.getLine();
            if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable) this.pendingBuffer = 0 /* Buf.No */;
            this.flushBuffer(active);
            if (cursorBefore) {
              line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
              openStart = active.length + Math.max(0, openStart - active.length);
            }
            line.append(wrapMarks(view, active), openStart);
            this.atCursorPos = cursorAfter;
            this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;
            if (this.pendingBuffer) this.bufferMarks = active.slice();
          }
        } else if (this.doc.lineAt(this.pos).from == this.pos) {
          // Line decoration
          this.getLine().addLineDeco(deco);
        }
        if (len) {
          // Advance the iterator past the replaced content
          if (this.textOff + len <= this.text.length) {
            this.textOff += len;
          } else {
            this.skip += len - (this.text.length - this.textOff);
            this.text = "";
            this.textOff = 0;
          }
          this.pos = to;
        }
        if (this.openStart < 0) this.openStart = openStart;
      }
    }], [{
      key: "build",
      value: function build(text, from, to, decorations, dynamicDecorationMap) {
        var builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
        builder.openEnd = RangeSet.spans(decorations, from, to, builder);
        if (builder.openStart < 0) builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
      }
    }]);
    return ContentBuilder;
  }();
  function wrapMarks(view, active) {
    var _iterator8 = _createForOfIteratorHelper(active),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var mark = _step8.value;
        view = new MarkView(mark, [view], view.length);
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
    return view;
  }
  var NullWidget = /*#__PURE__*/function (_WidgetType) {
    _inherits$1(NullWidget, _WidgetType);
    var _super11 = _createSuper(NullWidget);
    function NullWidget(tag) {
      var _this10;
      _classCallCheck(this, NullWidget);
      _this10 = _super11.call(this);
      _this10.tag = tag;
      return _this10;
    }
    _createClass(NullWidget, [{
      key: "eq",
      value: function eq(other) {
        return other.tag == this.tag;
      }
    }, {
      key: "toDOM",
      value: function toDOM() {
        return document.createElement(this.tag);
      }
    }, {
      key: "updateDOM",
      value: function updateDOM(elt) {
        return elt.nodeName.toLowerCase() == this.tag;
      }
    }, {
      key: "isHidden",
      get: function get() {
        return true;
      }
    }]);
    return NullWidget;
  }(WidgetType);
  var clickAddsSelectionRange = /*@__PURE__*/Facet.define();
  var dragMovesSelection$1 = /*@__PURE__*/Facet.define();
  var mouseSelectionStyle = /*@__PURE__*/Facet.define();
  var exceptionSink = /*@__PURE__*/Facet.define();
  var updateListener = /*@__PURE__*/Facet.define();
  var inputHandler$1 = /*@__PURE__*/Facet.define();
  var focusChangeEffect = /*@__PURE__*/Facet.define();
  var perLineTextDirection = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.some(function (x) {
        return x;
      });
    }
  });
  var nativeSelectionHidden = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.some(function (x) {
        return x;
      });
    }
  });
  var ScrollTarget = /*#__PURE__*/function () {
    function ScrollTarget(range) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "nearest";
      var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "nearest";
      var yMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
      var xMargin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;
      _classCallCheck(this, ScrollTarget);
      this.range = range;
      this.y = y;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
    _createClass(ScrollTarget, [{
      key: "map",
      value: function map(changes) {
        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
      }
    }]);
    return ScrollTarget;
  }();
  var _scrollIntoView2 = /*@__PURE__*/StateEffect.define({
    map: function map(t, ch) {
      return t.map(ch);
    }
  });
  /**
  Log or report an unhandled exception in client code. Should
  probably only be used by extension code that allows client code to
  provide functions, and calls those functions in a context where an
  exception can't be propagated to calling code in a reasonable way
  (for example when in an event handler).

  Either calls a handler registered with
  [`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
  `window.onerror`, if defined, or `console.error` (in which case
  it'll pass `context`, when given, as first argument).
  */
  function logException(state, exception, context) {
    var handler = state.facet(exceptionSink);
    if (handler.length) handler[0](exception);else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);else if (context) console.error(context + ":", exception);else console.error(exception);
  }
  var editable = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.length ? values[0] : true;
    }
  });
  var nextPluginID = 0;
  var viewPlugin = /*@__PURE__*/Facet.define();
  /**
  View plugins associate stateful values with a view. They can
  influence the way the content is drawn, and are notified of things
  that happen in the view.
  */
  var ViewPlugin = /*#__PURE__*/function () {
    function ViewPlugin(
    /**
    @internal
    */
    id,
    /**
    @internal
    */
    create,
    /**
    @internal
    */
    domEventHandlers,
    /**
    @internal
    */
    domEventObservers, buildExtensions) {
      _classCallCheck(this, ViewPlugin);
      this.id = id;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.domEventObservers = domEventObservers;
      this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    _createClass(ViewPlugin, null, [{
      key: "define",
      value: function define(create, spec) {
        var _ref = spec || {},
          eventHandlers = _ref.eventHandlers,
          eventObservers = _ref.eventObservers,
          provide = _ref.provide,
          deco = _ref.decorations;
        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, function (plugin) {
          var ext = [viewPlugin.of(plugin)];
          if (deco) ext.push(decorations.of(function (view) {
            var pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
          if (provide) ext.push(provide(plugin));
          return ext;
        });
      }
      /**
      Create a plugin for a class whose constructor takes a single
      editor view as argument.
      */
    }, {
      key: "fromClass",
      value: function fromClass(cls, spec) {
        return ViewPlugin.define(function (view) {
          return new cls(view);
        }, spec);
      }
    }]);
    return ViewPlugin;
  }();
  var PluginInstance = /*#__PURE__*/function () {
    function PluginInstance(spec) {
      _classCallCheck(this, PluginInstance);
      this.spec = spec;
      // When starting an update, all plugins have this field set to the
      // update object, indicating they need to be updated. When finished
      // updating, it is set to `false`. Retrieving a plugin that needs to
      // be updated with `view.plugin` forces an eager update.
      this.mustUpdate = null;
      // This is null when the plugin is initially created, but
      // initialized on the first update.
      this.value = null;
    }
    _createClass(PluginInstance, [{
      key: "update",
      value: function update(view) {
        if (!this.value) {
          if (this.spec) {
            try {
              this.value = this.spec.create(view);
            } catch (e) {
              logException(view.state, e, "CodeMirror plugin crashed");
              this.deactivate();
            }
          }
        } else if (this.mustUpdate) {
          var update = this.mustUpdate;
          this.mustUpdate = null;
          if (this.value.update) {
            try {
              this.value.update(update);
            } catch (e) {
              logException(update.state, e, "CodeMirror plugin crashed");
              if (this.value.destroy) try {
                this.value.destroy();
              } catch (_) {}
              this.deactivate();
            }
          }
        }
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
          try {
            this.value.destroy();
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
          }
        }
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.spec = this.value = null;
      }
    }]);
    return PluginInstance;
  }();
  var editorAttributes = /*@__PURE__*/Facet.define();
  var contentAttributes = /*@__PURE__*/Facet.define();
  // Provide decorations
  var decorations = /*@__PURE__*/Facet.define();
  var atomicRanges = /*@__PURE__*/Facet.define();
  var bidiIsolatedRanges = /*@__PURE__*/Facet.define();
  function getIsolatedRanges(view, from, to) {
    var isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length) return isolates;
    var sets = isolates.map(function (i) {
      return i instanceof Function ? i(view) : i;
    });
    var result = [];
    RangeSet.spans(sets, from, to, {
      point: function point() {},
      span: function span(from, to, active, open) {
        var level = result;
        for (var i = active.length - 1; i >= 0; i--, open--) {
          var iso = active[i].spec.bidiIsolate,
            update = void 0;
          if (iso == null) continue;
          if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == iso) {
            update.to = to;
            level = update.inner;
          } else {
            var add = {
              from: from,
              to: to,
              direction: iso,
              inner: []
            };
            level.push(add);
            level = add.inner;
          }
        }
      }
    });
    return result;
  }
  var scrollMargins = /*@__PURE__*/Facet.define();
  function getScrollMargins(view) {
    var left = 0,
      right = 0,
      top = 0,
      bottom = 0;
    var _iterator9 = _createForOfIteratorHelper(view.state.facet(scrollMargins)),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var source = _step9.value;
        var m = source(view);
        if (m) {
          if (m.left != null) left = Math.max(left, m.left);
          if (m.right != null) right = Math.max(right, m.right);
          if (m.top != null) top = Math.max(top, m.top);
          if (m.bottom != null) bottom = Math.max(bottom, m.bottom);
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
    return {
      left: left,
      right: right,
      top: top,
      bottom: bottom
    };
  }
  var styleModule = /*@__PURE__*/Facet.define();
  var ChangedRange = /*#__PURE__*/function () {
    function ChangedRange(fromA, toA, fromB, toB) {
      _classCallCheck(this, ChangedRange);
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    _createClass(ChangedRange, [{
      key: "join",
      value: function join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
      }
    }, {
      key: "addToSet",
      value: function addToSet(set) {
        var i = set.length,
          me = this;
        for (; i > 0; i--) {
          var range = set[i - 1];
          if (range.fromA > me.toA) continue;
          if (range.toA < me.fromA) break;
          me = me.join(range);
          set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
      }
    }], [{
      key: "extendWithRanges",
      value: function extendWithRanges(diff, ranges) {
        if (ranges.length == 0) return diff;
        var result = [];
        for (var dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
          var next = dI == diff.length ? null : diff[dI],
            off = posA - posB;
          var end = next ? next.fromB : 1e9;
          while (rI < ranges.length && ranges[rI] < end) {
            var from = ranges[rI],
              to = ranges[rI + 1];
            var fromB = Math.max(posB, from),
              toB = Math.min(end, to);
            if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
            if (to > end) break;else rI += 2;
          }
          if (!next) return result;
          new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
          posA = next.toA;
          posB = next.toB;
        }
      }
    }]);
    return ChangedRange;
  }();
  /**
  View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
  class, which describe what happened, whenever the view is updated.
  */
  var ViewUpdate = /*#__PURE__*/function () {
    function ViewUpdate(
    /**
    The editor view that the update is associated with.
    */
    view,
    /**
    The new editor state.
    */
    state,
    /**
    The transactions involved in the update. May be empty.
    */
    transactions) {
      _classCallCheck(this, ViewUpdate);
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      /**
      @internal
      */
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      var _iterator10 = _createForOfIteratorHelper(transactions),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var tr = _step10.value;
          this.changes = this.changes.compose(tr.changes);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
      var changedRanges = [];
      this.changes.iterChangedRanges(function (fromA, toA, fromB, toB) {
        return changedRanges.push(new ChangedRange(fromA, toA, fromB, toB));
      });
      this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    _createClass(ViewUpdate, [{
      key: "viewportChanged",
      get:
      /**
      Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
      [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
      update.
      */
      function get() {
        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;
      }
      /**
      Indicates whether the height of a block element in the editor
      changed in this update.
      */
    }, {
      key: "heightChanged",
      get: function get() {
        return (this.flags & 2 /* UpdateFlag.Height */) > 0;
      }
      /**
      Returns true when the document was modified or the size of the
      editor, or elements within the editor, changed.
      */
    }, {
      key: "geometryChanged",
      get: function get() {
        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;
      }
      /**
      True when this update indicates a focus change.
      */
    }, {
      key: "focusChanged",
      get: function get() {
        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;
      }
      /**
      Whether the document changed in this update.
      */
    }, {
      key: "docChanged",
      get: function get() {
        return !this.changes.empty;
      }
      /**
      Whether the selection was explicitly set in this update.
      */
    }, {
      key: "selectionSet",
      get: function get() {
        return this.transactions.some(function (tr) {
          return tr.selection;
        });
      }
      /**
      @internal
      */
    }, {
      key: "empty",
      get: function get() {
        return this.flags == 0 && this.transactions.length == 0;
      }
    }], [{
      key: "create",
      value: function create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
      }
    }]);
    return ViewUpdate;
  }();
  /**
  Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  */
  var Direction = /*@__PURE__*/function (Direction) {
    // (These are chosen to match the base levels, in bidi algorithm
    // terms, of spans in that direction.)
    /**
    Left-to-right.
    */
    Direction[Direction["LTR"] = 0] = "LTR";
    /**
    Right-to-left.
    */
    Direction[Direction["RTL"] = 1] = "RTL";
    return Direction;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR,
    RTL = Direction.RTL;
  // Decode a string with each type encoded as log2(type)
  function dec(str) {
    var result = [];
    for (var i = 0; i < str.length; i++) result.push(1 << +str[i]);
    return result;
  }
  // Character types for codepoints 0 to 0xf8
  var LowTypes = /*@__PURE__*/dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  // Character types for codepoints 0x600 to 0x6f9
  var ArabicTypes = /*@__PURE__*/dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /*@__PURE__*/Object.create(null),
    BracketStack = [];
  // There's a lot more in
  // https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
  // which are left out to keep code size down.
  for (var _i3 = 0, _arr$1 = ["()", "[]", "{}"]; _i3 < _arr$1.length; _i3++) {
    var p = _arr$1[_i3];
    var l = /*@__PURE__*/p.charCodeAt(0),
      r = /*@__PURE__*/p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ : 0x2000 <= ch && ch <= 0x200b ? 256 /* T.NI */ : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ : ch == 0x200c ? 256 /* T.NI */ : 1 /* T.L */;
  }

  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  /**
  Represents a contiguous range of text that has a single direction
  (as in left-to-right or right-to-left).
  */
  var BidiSpan = /*#__PURE__*/function () {
    /**
    @internal
    */
    function BidiSpan(
    /**
    The start of the span (relative to the start of the line).
    */
    from,
    /**
    The end of the span.
    */
    to,
    /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
    level) {
      _classCallCheck(this, BidiSpan);
      this.from = from;
      this.to = to;
      this.level = level;
    }
    /**
    @internal
    */
    _createClass(BidiSpan, [{
      key: "dir",
      get:
      /**
      The direction of this span.
      */
      function get() {
        return this.level % 2 ? RTL : LTR;
      }
    }, {
      key: "side",
      value: function side(end, dir) {
        return this.dir == dir == end ? this.to : this.from;
      }
      /**
      @internal
      */
    }], [{
      key: "find",
      value: function find(order, index, level, assoc) {
        var maybe = -1;
        for (var i = 0; i < order.length; i++) {
          var span = order[i];
          if (span.from <= index && span.to >= index) {
            if (span.level == level) return i;
            // When multiple spans match, if assoc != 0, take the one that
            // covers that side, otherwise take the one with the minimum
            // level.
            if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;
          }
        }
        if (maybe < 0) throw new RangeError("Index out of range");
        return maybe;
      }
    }]);
    return BidiSpan;
  }();
  function isolatesEq(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) {
      var iA = a[i],
        iB = b[i];
      if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;
    }
    return true;
  }
  // Reused array of character types
  var types = [];
  // Fill in the character types (in `types`) from `from` to `to` and
  // apply W normalization rules.
  function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (var iI = 0; iI <= isolates.length; iI++) {
      var from = iI ? isolates[iI - 1].to : rFrom,
        to = iI < isolates.length ? isolates[iI].from : rTo;
      var prevType = iI ? 256 /* T.NI */ : outerType;
      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      // (Left after this: L, R, EN, AN, ET, CS, NI)
      for (var i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
        var type = charType(line.charCodeAt(i));
        if (type == 512 /* T.NSM */) type = prev;else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */) type = 16 /* T.AN */;
        types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;
        if (type & 7 /* T.Strong */) prevStrong = type;
        prev = type;
      }
      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      // (Left after this: L, R, EN+AN, NI)
      for (var _i4 = from, _prev = prevType, _prevStrong = prevType; _i4 < to; _i4++) {
        var _type2 = types[_i4];
        if (_type2 == 128 /* T.CS */) {
          if (_i4 < to - 1 && _prev == types[_i4 + 1] && _prev & 24 /* T.Num */) _type2 = types[_i4] = _prev;else types[_i4] = 256 /* T.NI */;
        } else if (_type2 == 64 /* T.ET */) {
          var end = _i4 + 1;
          while (end < to && types[end] == 64 /* T.ET */) end++;
          var replace = _i4 && _prev == 8 /* T.EN */ || end < rTo && types[end] == 8 /* T.EN */ ? _prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */ : 256 /* T.NI */;
          for (var j = _i4; j < end; j++) types[j] = replace;
          _i4 = end - 1;
        } else if (_type2 == 8 /* T.EN */ && _prevStrong == 1 /* T.L */) {
          types[_i4] = 1 /* T.L */;
        }

        _prev = _type2;
        if (_type2 & 7 /* T.Strong */) _prevStrong = _type2;
      }
    }
  }
  // Process brackets throughout a run sequence.
  function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    var oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;
    for (var iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
      var from = iI ? isolates[iI - 1].to : rFrom,
        to = iI < isolates.length ? isolates[iI].from : rTo;
      // N0. Process bracket pairs in an isolating run sequence
      // sequentially in the logical order of the text positions of the
      // opening paired brackets using the logic given below. Within this
      // scope, bidirectional types EN and AN are treated as R.
      for (var i = from, ch, br, type; i < to; i++) {
        // Keeps [startIndex, type, strongSeen] triples for each open
        // bracket on BracketStack.
        if (br = Brackets[ch = line.charCodeAt(i)]) {
          if (br < 0) {
            // Closing bracket
            for (var sJ = sI - 3; sJ >= 0; sJ -= 3) {
              if (BracketStack[sJ + 1] == -br) {
                var flags = BracketStack[sJ + 2];
                var _type3 = flags & 2 /* Bracketed.EmbedInside */ ? outerType : !(flags & 4 /* Bracketed.OppositeInside */) ? 0 : flags & 1 /* Bracketed.OppositeBefore */ ? oppositeType : outerType;
                if (_type3) types[i] = types[BracketStack[sJ]] = _type3;
                sI = sJ;
                break;
              }
            }
          } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
            break;
          } else {
            BracketStack[sI++] = i;
            BracketStack[sI++] = ch;
            BracketStack[sI++] = context;
          }
        } else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
          var embed = type == outerType;
          context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;
          for (var _sJ = sI - 3; _sJ >= 0; _sJ -= 3) {
            var cur = BracketStack[_sJ + 2];
            if (cur & 2 /* Bracketed.EmbedInside */) break;
            if (embed) {
              BracketStack[_sJ + 2] |= 2 /* Bracketed.EmbedInside */;
            } else {
              if (cur & 4 /* Bracketed.OppositeInside */) break;
              BracketStack[_sJ + 2] |= 4 /* Bracketed.OppositeInside */;
            }
          }
        }
      }
    }
  }

  function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (var iI = 0, prev = outerType; iI <= isolates.length; iI++) {
      var from = iI ? isolates[iI - 1].to : rFrom,
        to = iI < isolates.length ? isolates[iI].from : rTo;
      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      // (Left after this: L, R, EN+AN)
      for (var i = from; i < to;) {
        var type = types[i];
        if (type == 256 /* T.NI */) {
          var end = i + 1;
          for (;;) {
            if (end == to) {
              if (iI == isolates.length) break;
              end = isolates[iI++].to;
              to = iI < isolates.length ? isolates[iI].from : rTo;
            } else if (types[end] == 256 /* T.NI */) {
              end++;
            } else {
              break;
            }
          }
          var beforeL = prev == 1 /* T.L */;
          var afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */;
          var replace = beforeL == afterL ? beforeL ? 1 /* T.L */ : 2 /* T.R */ : outerType;
          for (var j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
            if (j == fromJ) {
              j = isolates[--jI].from;
              fromJ = jI ? isolates[jI - 1].to : rFrom;
            }
            types[--j] = replace;
          }
          i = end;
        } else {
          prev = type;
          i++;
        }
      }
    }
  }
  // Find the contiguous ranges of character types in a given range, and
  // emit spans for them. Flip the order of the spans as appropriate
  // based on the level, and call through to compute the spans for
  // isolates at the proper point.
  function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    var ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;
    if (level % 2 == baseLevel % 2) {
      // Same dir as base direction, don't flip
      for (var iCh = from, iI = 0; iCh < to;) {
        // Scan a section of characters in direction ourType, unless
        // there's another type of char right after iCh, in which case
        // we scan a section of other characters (which, if ourType ==
        // T.L, may contain both T.R and T.AN chars).
        var sameDir = true,
          isNum = false;
        if (iI == isolates.length || iCh < isolates[iI].from) {
          var next = types[iCh];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16 /* T.AN */;
          }
        }
        // Holds an array of isolates to pass to a recursive call if we
        // must recurse (to distinguish T.AN inside an RTL section in
        // LTR text), null if we can emit directly
        var recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
        var localLevel = sameDir ? level : level + 1;
        var iScan = iCh;
        run: for (;;) {
          if (iI < isolates.length && iScan == isolates[iI].from) {
            if (isNum) break run;
            var iso = isolates[iI];
            // Scan ahead to verify that there is another char in this dir after the isolate(s)
            if (!sameDir) for (var upto = iso.to, jI = iI + 1;;) {
              if (upto == to) break run;
              if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;else if (types[upto] == ourType) break run;else break;
            }
            iI++;
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));
              var dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.to;
            }
            iScan = iso.to;
          } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
            break;
          } else {
            iScan++;
          }
        }
        if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));
        iCh = iScan;
      }
    } else {
      // Iterate in reverse to flip the span order. Same code again, but
      // going from the back of the section to the front
      for (var _iCh = to, _iI = isolates.length; _iCh > from;) {
        var _sameDir = true,
          _isNum = false;
        if (!_iI || _iCh > isolates[_iI - 1].to) {
          var _next = types[_iCh - 1];
          if (_next != ourType) {
            _sameDir = false;
            _isNum = _next == 16 /* T.AN */;
          }
        }

        var _recurse = !_sameDir && ourType == 1 /* T.L */ ? [] : null;
        var _localLevel = _sameDir ? level : level + 1;
        var _iScan = _iCh;
        run: for (;;) {
          if (_iI && _iScan == isolates[_iI - 1].to) {
            if (_isNum) break run;
            var _iso = isolates[--_iI];
            // Scan ahead to verify that there is another char in this dir after the isolate(s)
            if (!_sameDir) for (var _upto = _iso.from, _jI = _iI;;) {
              if (_upto == from) break run;
              if (_jI && isolates[_jI - 1].to == _upto) _upto = isolates[--_jI].from;else if (types[_upto - 1] == ourType) break run;else break;
            }
            if (_recurse) {
              _recurse.push(_iso);
            } else {
              if (_iso.to < _iCh) order.push(new BidiSpan(_iso.to, _iCh, _localLevel));
              var _dirSwap = _iso.direction == LTR != !(_localLevel % 2);
              computeSectionOrder(line, _dirSwap ? level + 1 : level, baseLevel, _iso.inner, _iso.from, _iso.to, order);
              _iCh = _iso.from;
            }
            _iScan = _iso.from;
          } else if (_iScan == from || (_sameDir ? types[_iScan - 1] != ourType : types[_iScan - 1] == ourType)) {
            break;
          } else {
            _iScan--;
          }
        }
        if (_recurse) emitSpans(line, _iScan, _iCh, level + 1, baseLevel, _recurse, order);else if (_iScan < _iCh) order.push(new BidiSpan(_iScan, _iCh, _localLevel));
        _iCh = _iScan;
      }
    }
  }
  function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    var outerType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
  }
  function computeOrder(line, direction, isolates) {
    if (!line) return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);
    if (isolates.length) while (line.length > types.length) types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps
    var order = [],
      level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a;
    var startIndex = start.head - line.from,
      spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length) return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward) return null;
      var last = order[order.length - 1];
      if (last.level != dir) {
        startIndex = last.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0) spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    var span = order[spanI];
    // End of span. (But not end of line--that was checked for above.)
    if (startIndex == span.side(forward, dir)) {
      span = order[spanI += forward ? 1 : -1];
      startIndex = span.side(!forward, dir);
    }
    var indexForward = forward == (span.dir == dir);
    var nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir)) return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    var nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir) return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level) return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  var DocView = /*#__PURE__*/function (_ContentView7) {
    _inherits$1(DocView, _ContentView7);
    var _super12 = _createSuper(DocView);
    function DocView(view) {
      var _this11;
      _classCallCheck(this, DocView);
      _this11 = _super12.call(this);
      _this11.view = view;
      _this11.decorations = [];
      _this11.dynamicDecorationMap = [];
      _this11.domChanged = null;
      _this11.hasComposition = null;
      _this11.markedForComposition = new Set();
      // Track a minimum width for the editor. When measuring sizes in
      // measureVisibleLineHeights, this is updated to point at the width
      // of a given element and its extent in the document. When a change
      // happens in that range, these are reset. That way, once we've seen
      // a line/element of a given length, we keep the editor wide enough
      // to fit at least that element, until it is changed, at which point
      // we forget it again.
      _this11.minWidth = 0;
      _this11.minWidthFrom = 0;
      _this11.minWidthTo = 0;
      // Track whether the DOM selection was set in a lossy way, so that
      // we don't mess it up when reading it back it
      _this11.impreciseAnchor = null;
      _this11.impreciseHead = null;
      _this11.forceSelection = false;
      // Used by the resize observer to ignore resizes that we caused
      // ourselves
      _this11.lastUpdate = Date.now();
      _this11.setDOM(view.contentDOM);
      _this11.children = [new LineView()];
      _this11.children[0].setParent(_assertThisInitialized(_this11));
      _this11.updateDeco();
      _this11.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
      return _this11;
    }
    // Update the document view to a given state.
    _createClass(DocView, [{
      key: "length",
      get: function get() {
        return this.view.state.doc.length;
      }
    }, {
      key: "update",
      value: function update(_update) {
        var _this12 = this;
        var _a;
        var changedRanges = _update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
          if (!changedRanges.every(function (_ref2) {
            var fromA = _ref2.fromA,
              toA = _ref2.toA;
            return toA < _this12.minWidthFrom || fromA > _this12.minWidthTo;
          })) {
            this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
          } else {
            this.minWidthFrom = _update.changes.mapPos(this.minWidthFrom, 1);
            this.minWidthTo = _update.changes.mapPos(this.minWidthTo, 1);
          }
        }
        var readCompositionAt = -1;
        if (this.view.inputState.composing >= 0) {
          if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;else if (!touchesComposition(_update.changes, this.hasComposition) && !_update.selectionSet) readCompositionAt = _update.state.selection.main.head;
        }
        var composition = readCompositionAt > -1 ? findCompositionRange(this.view, _update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
          this.markedForComposition.clear();
          var _this$hasComposition = this.hasComposition,
            from = _this$hasComposition.from,
            to = _this$hasComposition.to;
          changedRanges = new ChangedRange(from, to, _update.changes.mapPos(from, -1), _update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? {
          from: composition.range.fromB,
          to: composition.range.toB
        } : null;
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        if ((browser.ie || browser.chrome) && !composition && _update && _update.state.doc.lines != _update.startState.doc.lines) this.forceSelection = true;
        var prevDeco = this.decorations,
          deco = this.updateDeco();
        var decoDiff = findChangedDeco(prevDeco, deco, _update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {
          return false;
        } else {
          this.updateInner(changedRanges, _update.startState.doc.length, composition);
          if (_update.transactions.length) this.lastUpdate = Date.now();
          return true;
        }
      }
      // Used by update and the constructor do perform the actual DOM
      // update
    }, {
      key: "updateInner",
      value: function updateInner(changes, oldLength, composition) {
        var _this13 = this;
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        var observer = this.view.observer;
        observer.ignore(function () {
          // Lock the height during redrawing, since Chrome sometimes
          // messes with the scroll position during DOM mutation (though
          // no relayout is triggered and I cannot imagine how it can
          // recompute the scroll position without a layout)
          _this13.dom.style.height = _this13.view.viewState.contentHeight / _this13.view.scaleY + "px";
          _this13.dom.style.flexBasis = _this13.minWidth ? _this13.minWidth + "px" : "";
          // Chrome will sometimes, when DOM mutations occur directly
          // around the selection, get confused and report a different
          // selection from the one it displays (issue #218). This tries
          // to detect that situation.
          var track = browser.chrome || browser.ios ? {
            node: observer.selectionRange.focusNode,
            written: false
          } : undefined;
          _this13.sync(_this13.view, track);
          _this13.flags &= ~7 /* ViewFlag.Dirty */;
          if (track && (track.written || observer.selectionRange.focusNode != track.node)) _this13.forceSelection = true;
          _this13.dom.style.height = "";
        });
        this.markedForComposition.forEach(function (cView) {
          return cView.flags &= ~8;
        } /* ViewFlag.Composition */);
        var gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
          var _iterator11 = _createForOfIteratorHelper(this.children),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var child = _step11.value;
              if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        }
        observer.updateGaps(gaps);
      }
    }, {
      key: "updateChildren",
      value: function updateChildren(changes, oldLength, composition) {
        var ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        var cursor = this.childCursor(oldLength);
        for (var i = ranges.length - 1;; i--) {
          var next = i >= 0 ? ranges[i] : null;
          if (!next) break;
          var fromA = next.fromA,
            toA = next.toA,
            fromB = next.fromB,
            toB = next.toB,
            content = void 0,
            breakAtStart = void 0,
            openStart = void 0,
            openEnd = void 0;
          if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
            var before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
            var after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
            breakAtStart = before.breakAtStart;
            openStart = before.openStart;
            openEnd = after.openEnd;
            var compLine = this.compositionView(composition);
            if (after.breakAtStart) {
              compLine.breakAfter = 1;
            } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
              compLine.breakAfter = after.content[0].breakAfter;
              after.content.shift();
            }
            if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
              before.content.pop();
            }
            content = before.content.concat(compLine).concat(after.content);
          } else {
            var _ContentBuilder$build = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
            content = _ContentBuilder$build.content;
            breakAtStart = _ContentBuilder$build.breakAtStart;
            openStart = _ContentBuilder$build.openStart;
            openEnd = _ContentBuilder$build.openEnd;
          }
          var _cursor$findPos = cursor.findPos(toA, 1),
            toI = _cursor$findPos.i,
            toOff = _cursor$findPos.off;
          var _cursor$findPos2 = cursor.findPos(fromA, -1),
            fromI = _cursor$findPos2.i,
            fromOff = _cursor$findPos2.off;
          replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
        if (composition) this.fixCompositionDOM(composition);
      }
    }, {
      key: "compositionView",
      value: function compositionView(composition) {
        var cur = new TextView(composition.text.nodeValue);
        cur.flags |= 8 /* ViewFlag.Composition */;
        var _iterator12 = _createForOfIteratorHelper(composition.marks),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var deco = _step12.value.deco;
            cur = new MarkView(deco, [cur], cur.length);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        var line = new LineView();
        line.append(cur, 0);
        return line;
      }
    }, {
      key: "fixCompositionDOM",
      value: function fixCompositionDOM(composition) {
        var _this14 = this;
        var fix = function fix(dom, cView) {
          cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(function (c) {
            return c.flags & 7;
          } /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);
          _this14.markedForComposition.add(cView);
          var prev = ContentView.get(dom);
          if (prev && prev != cView) prev.dom = null;
          cView.setDOM(dom);
        };
        var pos = this.childPos(composition.range.fromB, 1);
        var cView = this.children[pos.i];
        fix(composition.line, cView);
        for (var i = composition.marks.length - 1; i >= -1; i--) {
          pos = cView.childPos(pos.off, 1);
          cView = cView.children[pos.i];
          fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
        }
      }
      // Sync the DOM selection to this.state.selection
    }, {
      key: "updateSelection",
      value: function updateSelection() {
        var _this15 = this;
        var mustRead = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var fromPointer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();
        var activeElt = this.view.root.activeElement,
          focused = activeElt == this.dom;
        var selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus)) return;
        var force = this.forceSelection;
        this.forceSelection = false;
        var main = this.view.state.selection.main;
        var anchor = this.moveToLine(this.domAtPos(main.anchor));
        var head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        // Always reset on Firefox when next to an uneditable node to
        // avoid invisible cursor bugs (#111)
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
          var dummy = document.createTextNode("");
          this.view.observer.ignore(function () {
            return anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null);
          });
          anchor = head = new DOMPos(dummy, 0);
          force = true;
        }
        var domSel = this.view.observer.selectionRange;
        // If the selection is already here, or in an equivalent position, don't touch it
        if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
          this.view.observer.ignore(function () {
            // Chrome Android will hide the virtual keyboard when tapping
            // inside an uneditable node, and not bring it back when we
            // move the cursor to its proper position. This tries to
            // restore the keyboard by cycling focus.
            if (browser.android && browser.chrome && _this15.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, _this15.dom)) {
              _this15.dom.blur();
              _this15.dom.focus({
                preventScroll: true
              });
            }
            var rawSel = getSelection(_this15.view.root);
            if (!rawSel) ;else if (main.empty) {
              // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
              if (browser.gecko) {
                var nextTo = nextToUneditable(anchor.node, anchor.offset);
                if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {
                  var text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);
                  if (text) anchor = new DOMPos(text.node, text.offset);
                }
              }
              rawSel.collapse(anchor.node, anchor.offset);
              if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;
            } else if (rawSel.extend) {
              // Selection.extend can be used to create an 'inverted' selection
              // (one where the focus is before the anchor), but not all
              // browsers support it yet.
              rawSel.collapse(anchor.node, anchor.offset);
              // Safari will ignore the call above when the editor is
              // hidden, and then raise an error on the call to extend
              // (#940).
              try {
                rawSel.extend(head.node, head.offset);
              } catch (_) {}
            } else {
              // Primitive (IE) way
              var range = document.createRange();
              if (main.anchor > main.head) {
                var _ref3 = [head, anchor];
                anchor = _ref3[0];
                head = _ref3[1];
              }
              range.setEnd(head.node, head.offset);
              range.setStart(anchor.node, anchor.offset);
              rawSel.removeAllRanges();
              rawSel.addRange(range);
            }
            if (selectionNotFocus && _this15.view.root.activeElement == _this15.dom) {
              _this15.dom.blur();
              if (activeElt) activeElt.focus();
            }
          });
          this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
      }
    }, {
      key: "enforceCursorAssoc",
      value: function enforceCursorAssoc() {
        if (this.hasComposition) return;
        var view = this.view,
          cursor = view.state.selection.main;
        var sel = getSelection(view.root);
        var _view$observer$select = view.observer.selectionRange,
          anchorNode = _view$observer$select.anchorNode,
          anchorOffset = _view$observer$select.anchorOffset;
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;
        var line = LineView.find(this, cursor.head);
        if (!line) return;
        var lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;
        var before = this.coordsAt(cursor.head, -1),
          after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top) return;
        var dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
        // This can go wrong in corner cases like single-character lines,
        // so check and reset if necessary.
        view.observer.readSelectionRange();
        var newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);
      }
      // If a position is in/near a block widget, move it to a nearby text
      // line, since we don't want the cursor inside a block widget.
    }, {
      key: "moveToLine",
      value: function moveToLine(pos) {
        // Block widgets will return positions before/after them, which
        // are thus directly in the document DOM element.
        var dom = this.dom,
          newPos;
        if (pos.node != dom) return pos;
        for (var i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
          var view = ContentView.get(dom.childNodes[i]);
          if (view instanceof LineView) newPos = view.domAtPos(0);
        }
        for (var _i5 = pos.offset - 1; !newPos && _i5 >= 0; _i5--) {
          var _view2 = ContentView.get(dom.childNodes[_i5]);
          if (_view2 instanceof LineView) newPos = _view2.domAtPos(_view2.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
      }
    }, {
      key: "nearest",
      value: function nearest(dom) {
        for (var cur = dom; cur;) {
          var domView = ContentView.get(cur);
          if (domView && domView.rootView == this) return domView;
          cur = cur.parentNode;
        }
        return null;
      }
    }, {
      key: "posFromDOM",
      value: function posFromDOM(node, offset) {
        var view = this.nearest(node);
        if (!view) throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
      }
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        var _this$childCursor$fin = this.childCursor().findPos(pos, -1),
          i = _this$childCursor$fin.i,
          off = _this$childCursor$fin.off;
        for (; i < this.children.length - 1;) {
          var child = this.children[i];
          if (off < child.length || child instanceof LineView) break;
          i++;
          off = 0;
        }
        return this.children[i].domAtPos(off);
      }
    }, {
      key: "coordsAt",
      value: function coordsAt(pos, side) {
        var best = null,
          bestPos = 0;
        for (var off = this.length, i = this.children.length - 1; i >= 0; i--) {
          var child = this.children[i],
            end = off - child.breakAfter,
            start = end - child.length;
          if (end < pos) break;
          if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
            best = child;
            bestPos = start;
          }
          off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
      }
    }, {
      key: "coordsForChar",
      value: function coordsForChar(pos) {
        var _this$childPos2 = this.childPos(pos, 1),
          i = _this$childPos2.i,
          off = _this$childPos2.off,
          child = this.children[i];
        if (!(child instanceof LineView)) return null;
        while (child.children.length) {
          var _child$childPos = child.childPos(off, 1),
            _i6 = _child$childPos.i,
            childOff = _child$childPos.off;
          for (;; _i6++) {
            if (_i6 == child.children.length) return null;
            if ((child = child.children[_i6]).length) break;
          }
          off = childOff;
        }
        if (!(child instanceof TextView)) return null;
        var end = findClusterBreak(child.text, off);
        if (end == off) return null;
        var rects = textRange(child.dom, off, end).getClientRects();
        return !rects.length || rects[0].top >= rects[0].bottom ? null : rects[0];
      }
    }, {
      key: "measureVisibleLineHeights",
      value: function measureVisibleLineHeights(viewport) {
        var result = [],
          from = viewport.from,
          to = viewport.to;
        var contentWidth = this.view.contentDOM.clientWidth;
        var isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        var widest = -1,
          ltr = this.view.textDirection == Direction.LTR;
        for (var pos = 0, i = 0; i < this.children.length; i++) {
          var child = this.children[i],
            end = pos + child.length;
          if (end > to) break;
          if (pos >= from) {
            var childRect = child.dom.getBoundingClientRect();
            result.push(childRect.height);
            if (isWider) {
              var last = child.dom.lastChild;
              var rects = last ? clientRectsFor(last) : [];
              if (rects.length) {
                var rect = rects[rects.length - 1];
                var width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                if (width > widest) {
                  widest = width;
                  this.minWidth = contentWidth;
                  this.minWidthFrom = pos;
                  this.minWidthTo = end;
                }
              }
            }
          }
          pos = end + child.breakAfter;
        }
        return result;
      }
    }, {
      key: "textDirectionAt",
      value: function textDirectionAt(pos) {
        var _this$childPos3 = this.childPos(pos, 1),
          i = _this$childPos3.i;
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
      }
    }, {
      key: "measureTextSize",
      value: function measureTextSize() {
        var _this16 = this;
        var _iterator13 = _createForOfIteratorHelper(this.children),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var child = _step13.value;
            if (child instanceof LineView) {
              var measure = child.measureTextSize();
              if (measure) return measure;
            }
          }
          // If no workable line exists, force a layout of a measurable element
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
        var dummy = document.createElement("div"),
          lineHeight,
          charWidth,
          textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(function () {
          _this16.dom.appendChild(dummy);
          var rect = clientRectsFor(dummy.firstChild)[0];
          lineHeight = dummy.getBoundingClientRect().height;
          charWidth = rect ? rect.width / 27 : 7;
          textHeight = rect ? rect.height : lineHeight;
          dummy.remove();
        });
        return {
          lineHeight: lineHeight,
          charWidth: charWidth,
          textHeight: textHeight
        };
      }
    }, {
      key: "childCursor",
      value: function childCursor() {
        var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.length;
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        var i = this.children.length;
        if (i) pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
      }
    }, {
      key: "computeBlockGapDeco",
      value: function computeBlockGapDeco() {
        var deco = [],
          vs = this.view.viewState;
        for (var pos = 0, i = 0;; i++) {
          var next = i == vs.viewports.length ? null : vs.viewports[i];
          var end = next ? next.from - 1 : this.length;
          if (end > pos) {
            var height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
            deco.push(Decoration.replace({
              widget: new BlockGapWidget(height),
              block: true,
              inclusive: true,
              isBlockGap: true
            }).range(pos, end));
          }
          if (!next) break;
          pos = next.to + 1;
        }
        return Decoration.set(deco);
      }
    }, {
      key: "updateDeco",
      value: function updateDeco() {
        var _this17 = this;
        var allDeco = this.view.state.facet(decorations).map(function (d, i) {
          var dynamic = _this17.dynamicDecorationMap[i] = typeof d == "function";
          return dynamic ? d(_this17.view) : d;
        });
        for (var i = allDeco.length; i < allDeco.length + 3; i++) this.dynamicDecorationMap[i] = false;
        return this.decorations = [].concat(_toConsumableArray(allDeco), [this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]);
      }
    }, {
      key: "scrollIntoView",
      value: function scrollIntoView(target) {
        var range = target.range;
        var rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),
          other;
        if (!rect) return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
        var margins = getScrollMargins(this.view);
        var targetRect = {
          left: rect.left - margins.left,
          top: rect.top - margins.top,
          right: rect.right + margins.right,
          bottom: rect.bottom + margins.bottom
        };
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
      }
    }]);
    return DocView;
  }(ContentView);
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = /*#__PURE__*/function (_WidgetType2) {
    _inherits$1(BlockGapWidget, _WidgetType2);
    var _super13 = _createSuper(BlockGapWidget);
    function BlockGapWidget(height) {
      var _this18;
      _classCallCheck(this, BlockGapWidget);
      _this18 = _super13.call(this);
      _this18.height = height;
      return _this18;
    }
    _createClass(BlockGapWidget, [{
      key: "toDOM",
      value: function toDOM() {
        var elt = document.createElement("div");
        this.updateDOM(elt);
        return elt;
      }
    }, {
      key: "eq",
      value: function eq(other) {
        return other.height == this.height;
      }
    }, {
      key: "updateDOM",
      value: function updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
      }
    }, {
      key: "estimatedHeight",
      get: function get() {
        return this.height;
      }
    }]);
    return BlockGapWidget;
  }(WidgetType);
  function findCompositionNode(view, headPos) {
    var sel = view.observer.selectionRange;
    var textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode) return null;
    var from = headPos - textNode.offset;
    return {
      from: from,
      to: from + textNode.node.nodeValue.length,
      node: textNode.node
    };
  }
  function findCompositionRange(view, changes, headPos) {
    var found = findCompositionNode(view, headPos);
    if (!found) return null;
    var textNode = found.node,
      from = found.from,
      to = found.to,
      text = textNode.nodeValue;
    // Don't try to preserve multi-line compositions
    if (/[\n\r]/.test(text)) return null;
    if (view.state.doc.sliceString(found.from, found.to) != text) return null;
    var inv = changes.invertedDesc;
    var range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    var marks = [];
    for (var parent = textNode.parentNode;; parent = parent.parentNode) {
      var parentView = ContentView.get(parent);
      if (parentView instanceof MarkView) marks.push({
        node: parent,
        deco: parentView.mark
      });else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM) return {
        range: range,
        text: textNode,
        marks: marks,
        line: parent
      };else if (parent != view.contentDOM) marks.push({
        node: parent,
        deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs(parent),
          tagName: parent.tagName.toLowerCase()
        })
      });else return null;
    }
  }
  function nearbyTextNode(startNode, startOffset, side) {
    if (side <= 0) for (var node = startNode, offset = startOffset;;) {
      if (node.nodeType == 3) return {
        node: node,
        offset: offset
      };
      if (node.nodeType == 1 && offset > 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else {
        break;
      }
    }
    if (side >= 0) for (var _node = startNode, _offset = startOffset;;) {
      if (_node.nodeType == 3) return {
        node: _node,
        offset: _offset
      };
      if (_node.nodeType == 1 && _offset < _node.childNodes.length && side >= 0) {
        _node = _node.childNodes[_offset];
        _offset = 0;
      } else {
        break;
      }
    }
    return null;
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1) return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* NextTo.Before */ : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* NextTo.After */ : 0);
  }
  var DecorationComparator$1 = /*#__PURE__*/function () {
    function DecorationComparator() {
      _classCallCheck(this, DecorationComparator);
      this.changes = [];
    }
    _createClass(DecorationComparator, [{
      key: "compareRange",
      value: function compareRange(from, to) {
        addRange(from, to, this.changes);
      }
    }, {
      key: "comparePoint",
      value: function comparePoint(from, to) {
        addRange(from, to, this.changes);
      }
    }]);
    return DecorationComparator;
  }();
  function findChangedDeco(a, b, diff) {
    var comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside) {
    for (var cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
      if (cur.nodeType == 1 && cur.contentEditable == 'false') {
        return true;
      }
    }
    return false;
  }
  function touchesComposition(changes, composition) {
    var touched = false;
    if (composition) changes.iterChangedRanges(function (from, to) {
      if (from < composition.to && to > composition.from) touched = true;
    });
    return touched;
  }
  function groupAt(state, pos) {
    var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var categorize = state.charCategorizer(pos);
    var line = state.doc.lineAt(pos),
      linePos = pos - line.from;
    if (line.length == 0) return EditorSelection.cursor(pos);
    if (linePos == 0) bias = 1;else if (linePos == line.length) bias = -1;
    var from = linePos,
      to = linePos;
    if (bias < 0) from = findClusterBreak(line.text, linePos, false);else to = findClusterBreak(line.text, linePos);
    var cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      var prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat) break;
      from = prev;
    }
    while (to < line.length) {
      var next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat) break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  // Search the DOM for the {node, offset} position closest to the given
  // coordinates. Very inefficient and crude, but can usually be avoided
  // by calling caret(Position|Range)FromPoint instead.
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top) {
    return top < rect.top ? {
      top: top,
      left: rect.left,
      right: rect.right,
      bottom: rect.bottom
    } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? {
      top: rect.top,
      left: rect.left,
      right: rect.right,
      bottom: bottom
    } : rect;
  }
  function domPosAtCoords(parent, x, y) {
    var closest,
      closestRect,
      closestX,
      closestY,
      closestOverlap = false;
    var above, below, aboveRect, belowRect;
    for (var child = parent.firstChild; child; child = child.nextSibling) {
      var rects = clientRectsFor(child);
      for (var i = 0; i < rects.length; i++) {
        var rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        var dx = getdx(x, rect),
          dy = getdy(y, rect);
        if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          var side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest) return {
      node: parent,
      offset: 0
    };
    var clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false") return domPosAtCoords(closest, clipX, y);
    var offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return {
      node: parent,
      offset: offset
    };
  }
  function domPosInText(node, x, y) {
    var len = node.nodeValue.length;
    var closestOffset = -1,
      closestDY = 1e9,
      generalSide = 0;
    for (var i = 0; i < len; i++) {
      var rects = textRange(node, i, i + 1).getClientRects();
      for (var j = 0; j < rects.length; j++) {
        var rect = rects[j];
        if (rect.top == rect.bottom) continue;
        if (!generalSide) generalSide = x - rect.left;
        var dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          var right = x >= (rect.left + rect.right) / 2,
            after = right;
          if (browser.chrome || browser.gecko) {
            // Check for RTL on browsers that support getting client
            // rects for empty ranges.
            var rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right) after = !right;
          }
          if (dy <= 0) return {
            node: node,
            offset: i + (after ? 1 : 0)
          };
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return {
      node: node,
      offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
    };
  }
  function _posAtCoords(view, coords, precise) {
    var bias = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    var _a, _b;
    var content = view.contentDOM.getBoundingClientRect(),
      docTop = content.top + view.viewState.paddingTop;
    var block,
      docHeight = view.viewState.docHeight;
    var x = coords.x,
      y = coords.y,
      yOffset = y - docTop;
    if (yOffset < 0) return 0;
    if (yOffset > docHeight) return view.state.doc.length;
    // Scan for a text block near the queried y position
    for (var halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text) break;
      for (;;) {
        // Move the y position out of this block
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight) break;
        // If the document consists entirely of replaced widgets, we
        // won't find a text block, so return 0
        if (bounced) return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y = docTop + yOffset;
    var lineStart = block.from;
    // If this is outside of the rendered viewport, we can't determine a position
    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
    var doc = view.dom.ownerDocument;
    var root = view.root.elementFromPoint ? view.root : doc;
    var element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element)) element = null;
    // If the element is unexpected, clip x at the sides of the content area and try again
    if (!element) {
      x = Math.max(content.left + 1, Math.min(content.right - 1, x));
      element = root.elementFromPoint(x, y);
      if (element && !view.contentDOM.contains(element)) element = null;
    }
    // There's visible editor content under the point, so we can try
    // using caret(Position|Range)FromPoint as a shortcut
    var node,
      offset = -1;
    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
      if (doc.caretPositionFromPoint) {
        var pos = doc.caretPositionFromPoint(x, y);
        if (pos) {
          node = pos.offsetNode;
          offset = pos.offset;
        }
      } else if (doc.caretRangeFromPoint) {
        var range = doc.caretRangeFromPoint(x, y);
        if (range) {
          node = range.startContainer;
          offset = range.startOffset;
          if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;
        }
      }
    }
    // No luck, do our own (potentially expensive) search
    if (!node || !view.docView.dom.contains(node)) {
      var line = LineView.find(view.docView, lineStart);
      if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;
      var _domPosAtCoords = domPosAtCoords(line.dom, x, y);
      node = _domPosAtCoords.node;
      offset = _domPosAtCoords.offset;
    }
    var nearest = view.docView.nearest(node);
    if (!nearest) return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      var rect = nearest.dom.getBoundingClientRect();
      return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    var into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      var textHeight = view.viewState.heightOracle.textHeight;
      var line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    var content = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content, into, view.state.tabSize);
  }
  // In case of a high line height, Safari's caretRangeFromPoint treats
  // the space between lines as belonging to the last character of the
  // line before. This is used to detect such a result so that it can be
  // ignored (issue #401).
  function isSuspiciousSafariCaretResult(node, offset, x) {
    var len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;
    for (var next = node.nextSibling; next; next = next.nextSibling) if (next.nodeType != 1 || next.nodeName != "BR") return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  // Chrome will move positions between lines to the start of the next line
  function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0) return false;
    for (var cur = node;;) {
      var parent = cur.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;
      if (parent.classList.contains("cm-line")) break;
      cur = parent;
    }
    var rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
  }
  function blockAt(view, pos) {
    var line = view.lineBlockAt(pos);
    if (Array.isArray(line.type)) {
      var _iterator14 = _createForOfIteratorHelper(line.type),
        _step14;
      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var _l = _step14.value;
          if (_l.to > pos || _l.to == pos && (_l.to == line.to || _l.type == BlockType.Text)) return _l;
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    return line;
  }
  function _moveToLineBoundary(view, start, forward, includeWrap) {
    var line = blockAt(view, start.head);
    var coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      var editorRect = view.dom.getBoundingClientRect();
      var direction = view.textDirectionAt(line.from);
      var pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null) return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
  }
  function _moveByChar(view, start, forward, by) {
    var line = view.state.doc.lineAt(start.head),
      spans = view.bidiSpans(line);
    var direction = view.textDirectionAt(line.from);
    for (var cur = start, check = null;;) {
      var next = moveVisually(line, spans, direction, cur, forward),
        _char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1)) return cur;
        _char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by) return next;
        check = by(_char);
      } else if (!check(_char)) {
        return cur;
      }
      cur = next;
    }
  }
  function byGroup(view, pos, start) {
    var categorize = view.state.charCategorizer(pos);
    var cat = categorize(start);
    return function (next) {
      var nextCat = categorize(next);
      if (cat == CharCategory.Space) cat = nextCat;
      return cat == nextCat;
    };
  }
  function _moveVertically(view, start, forward, distance) {
    var startPos = start.head,
      dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0)) return EditorSelection.cursor(startPos, start.assoc);
    var goal = start.goalColumn,
      startY;
    var rect = view.contentDOM.getBoundingClientRect();
    var startCoords = view.coordsAtPos(startPos, start.assoc || -1),
      docTop = view.documentTop;
    if (startCoords) {
      if (goal == null) goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      var line = view.viewState.lineBlockAt(startPos);
      if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    var resolvedGoal = rect.left + goal;
    var dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
    for (var extra = 0;; extra += 10) {
      var curY = startY + (dist + extra) * dir;
      var pos = _posAtCoords(view, {
        x: resolvedGoal,
        y: curY
      }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
        var charRect = view.docView.coordsForChar(pos);
        var assoc = !charRect || curY < charRect.top ? -1 : 1;
        return EditorSelection.cursor(pos, assoc, undefined, goal);
      }
    }
  }
  function skipAtomicRanges(atoms, pos, bias) {
    var _loop = function _loop() {
      var moved = 0;
      var _iterator15 = _createForOfIteratorHelper(atoms),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var set = _step15.value;
          set.between(pos - 1, pos + 1, function (from, to, value) {
            if (pos > from && pos < to) {
              var side = moved || bias || (pos - from < to - pos ? -1 : 1);
              pos = side < 0 ? from : to;
              moved = side;
            }
          });
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      if (!moved) return {
        v: pos
      };
    };
    for (;;) {
      var _ret = _loop();
      if (_typeof(_ret) === "object") return _ret.v;
    }
  }
  function skipAtoms(view, oldPos, pos) {
    var newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(function (f) {
      return f(view);
    }), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
  }

  // This will also be where dragging info and such goes
  var InputState = /*#__PURE__*/function () {
    function InputState(view) {
      var _this19 = this;
      _classCallCheck(this, InputState);
      this.view = view;
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      // On iOS, some keys need to have their default behavior happen
      // (after which we retroactively handle them and reset the DOM) to
      // avoid messing up the virtual keyboard state.
      this.pendingIOSKey = undefined;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.handlers = Object.create(null);
      // -1 means not in a composition. Otherwise, this counts the number
      // of changes made during the composition. The count is used to
      // avoid treating the start state of the composition, before any
      // changes have been made, as part of the composition.
      this.composing = -1;
      // Tracks whether the next change should be marked as starting the
      // composition (null means no composition, true means next is the
      // first, false means first has already been marked for this
      // composition)
      this.compositionFirstChange = null;
      // End time of the previous composition
      this.compositionEndedAt = 0;
      // Used in a kludge to detect when an Enter keypress should be
      // considered part of the composition on Safari, which fires events
      // in the wrong order
      this.compositionPendingKey = false;
      // Used to categorize changes as part of a composition, even when
      // the mutation events fire shortly after the compositionend event
      this.compositionPendingChange = false;
      this.mouseSelection = null;
      this.handleEvent = this.handleEvent.bind(this);
      view.scrollDOM.addEventListener("mousedown", function (event) {
        if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom) {
          _this19.runHandlers("mousedown", event);
          if (!event.defaultPrevented && event.button == 2) {
            // Make sure the content covers the entire scroller height, in order
            // to catch a native context menu click below it
            var start = view.contentDOM.style.minHeight;
            view.contentDOM.style.minHeight = "100%";
            setTimeout(function () {
              return view.contentDOM.style.minHeight = start;
            }, 200);
          }
        }
      });
      view.scrollDOM.addEventListener("drop", function (event) {
        if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom) _this19.runHandlers("drop", event);
      });
      this.notifiedFocused = view.hasFocus;
      // On Safari adding an input event handler somehow prevents an
      // issue where the composition vanishes when you press enter.
      if (browser.safari) view.contentDOM.addEventListener("input", function () {
        return null;
      });
      if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    _createClass(InputState, [{
      key: "setSelectionOrigin",
      value: function setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;
        if (event.type == "keydown" && this.keydown(event)) return;
        this.runHandlers(event.type, event);
      }
    }, {
      key: "runHandlers",
      value: function runHandlers(type, event) {
        var handlers = this.handlers[type];
        if (handlers) {
          var _iterator16 = _createForOfIteratorHelper(handlers.observers),
            _step16;
          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var observer = _step16.value;
              observer(this.view, event);
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }
          var _iterator17 = _createForOfIteratorHelper(handlers.handlers),
            _step17;
          try {
            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
              var handler = _step17.value;
              if (event.defaultPrevented) break;
              if (handler(this.view, event)) {
                event.preventDefault();
                break;
              }
            }
          } catch (err) {
            _iterator17.e(err);
          } finally {
            _iterator17.f();
          }
        }
      }
    }, {
      key: "ensureHandlers",
      value: function ensureHandlers(plugins) {
        var handlers = computeHandlers(plugins),
          prev = this.handlers,
          dom = this.view.contentDOM;
        for (var type in handlers) if (type != "scroll") {
          var passive = !handlers[type].handlers.length;
          var exists = prev[type];
          if (exists && passive != !exists.handlers.length) {
            dom.removeEventListener(type, this.handleEvent);
            exists = null;
          }
          if (!exists) dom.addEventListener(type, this.handleEvent, {
            passive: passive
          });
        }
        for (var _type4 in prev) if (_type4 != "scroll" && !handlers[_type4]) dom.removeEventListener(_type4, this.handleEvent);
        this.handlers = handlers;
      }
    }, {
      key: "keydown",
      value: function keydown(event) {
        var _this20 = this;
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000) return true;
        if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.view.inputState.lastEscPress = 0;
        // Chrome for Android usually doesn't fire proper key events, but
        // occasionally does, usually surrounded by a bunch of complicated
        // composition changes. When an enter or backspace key event is
        // seen, hold off on handling DOM events for a bit, and then
        // dispatch it.
        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
          this.view.observer.delayAndroidKey(event.key, event.keyCode);
          return true;
        }
        // Preventing the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        var pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find(function (key) {
          return key.keyCode == event.keyCode;
        })) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
          this.pendingIOSKey = pending || event;
          setTimeout(function () {
            return _this20.flushIOSKey();
          }, 250);
          return true;
        }
        if (event.keyCode != 229) this.view.observer.forceFlush();
        return false;
      }
    }, {
      key: "flushIOSKey",
      value: function flushIOSKey() {
        var key = this.pendingIOSKey;
        if (!key) return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode);
      }
    }, {
      key: "ignoreDuringComposition",
      value: function ignoreDuringComposition(event) {
        if (!/^key/.test(event.type)) return false;
        if (this.composing > 0) return true;
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
          this.compositionPendingKey = false;
          return true;
        }
        return false;
      }
    }, {
      key: "startMouseSelection",
      value: function startMouseSelection(mouseSelection) {
        if (this.mouseSelection) this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
      }
    }, {
      key: "update",
      value: function update(_update2) {
        if (this.mouseSelection) this.mouseSelection.update(_update2);
        if (_update2.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.mouseSelection) this.mouseSelection.destroy();
      }
    }]);
    return InputState;
  }();
  function bindHandler(plugin, handler) {
    return function (view, event) {
      try {
        return handler.call(plugin, event, view);
      } catch (e) {
        logException(view.state, e);
      }
    };
  }
  function computeHandlers(plugins) {
    var result = Object.create(null);
    function record(type) {
      return result[type] || (result[type] = {
        observers: [],
        handlers: []
      });
    }
    var _iterator18 = _createForOfIteratorHelper(plugins),
      _step18;
    try {
      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
        var _plugin2 = _step18.value;
        var spec = _plugin2.spec;
        if (spec && spec.domEventHandlers) for (var _type6 in spec.domEventHandlers) {
          var f = spec.domEventHandlers[_type6];
          if (f) record(_type6).handlers.push(bindHandler(_plugin2.value, f));
        }
        if (spec && spec.domEventObservers) for (var _type7 in spec.domEventObservers) {
          var _f2 = spec.domEventObservers[_type7];
          if (_f2) record(_type7).observers.push(bindHandler(_plugin2.value, _f2));
        }
      }
    } catch (err) {
      _iterator18.e(err);
    } finally {
      _iterator18.f();
    }
    for (var type in handlers) record(type).handlers.push(handlers[type]);
    for (var _type5 in observers) record(_type5).observers.push(observers[_type5]);
    return result;
  }
  var PendingKeys = [{
    key: "Backspace",
    keyCode: 8,
    inputType: "deleteContentBackward"
  }, {
    key: "Enter",
    keyCode: 13,
    inputType: "insertParagraph"
  }, {
    key: "Enter",
    keyCode: 13,
    inputType: "insertLineBreak"
  }, {
    key: "Delete",
    keyCode: 46,
    inputType: "deleteContentForward"
  }];
  var EmacsyPendingKeys = "dthko";
  // Key codes for modifier keys
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var dragScrollMargin = 6;
  function dragScrollSpeed(dist) {
    return Math.max(0, dist) * 0.7 + 8;
  }
  function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
  }
  var MouseSelection = /*#__PURE__*/function () {
    function MouseSelection(view, startEvent, style, mustSelect) {
      _classCallCheck(this, MouseSelection);
      this.view = view;
      this.startEvent = startEvent;
      this.style = style;
      this.mustSelect = mustSelect;
      this.scrollSpeed = {
        x: 0,
        y: 0
      };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParent = scrollableParent(view.contentDOM);
      this.atoms = view.state.facet(atomicRanges).map(function (f) {
        return f(view);
      });
      var doc = view.contentDOM.ownerDocument;
      doc.addEventListener("mousemove", this.move = this.move.bind(this));
      doc.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    _createClass(MouseSelection, [{
      key: "start",
      value: function start(event) {
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false) this.select(event);
      }
    }, {
      key: "move",
      value: function move(event) {
        var _a;
        if (event.buttons == 0) return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;
        this.select(this.lastEvent = event);
        var sx = 0,
          sy = 0;
        var rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {
          left: 0,
          top: 0,
          right: this.view.win.innerWidth,
          bottom: this.view.win.innerHeight
        };
        var margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= rect.left + dragScrollMargin) sx = -dragScrollSpeed(rect.left - event.clientX);else if (event.clientX + margins.right >= rect.right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - rect.right);
        if (event.clientY - margins.top <= rect.top + dragScrollMargin) sy = -dragScrollSpeed(rect.top - event.clientY);else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - rect.bottom);
        this.setScrollSpeed(sx, sy);
      }
    }, {
      key: "up",
      value: function up(event) {
        if (this.dragging == null) this.select(this.lastEvent);
        if (!this.dragging) event.preventDefault();
        this.destroy();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.setScrollSpeed(0, 0);
        var doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = null;
      }
    }, {
      key: "setScrollSpeed",
      value: function setScrollSpeed(sx, sy) {
        var _this21 = this;
        this.scrollSpeed = {
          x: sx,
          y: sy
        };
        if (sx || sy) {
          if (this.scrolling < 0) this.scrolling = setInterval(function () {
            return _this21.scroll();
          }, 50);
        } else if (this.scrolling > -1) {
          clearInterval(this.scrolling);
          this.scrolling = -1;
        }
      }
    }, {
      key: "scroll",
      value: function scroll() {
        if (this.scrollParent) {
          this.scrollParent.scrollLeft += this.scrollSpeed.x;
          this.scrollParent.scrollTop += this.scrollSpeed.y;
        } else {
          this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
        }
        if (this.dragging === false) this.select(this.lastEvent);
      }
    }, {
      key: "skipAtoms",
      value: function skipAtoms(sel) {
        var ranges = null;
        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i],
            updated = null;
          if (range.empty) {
            var pos = skipAtomicRanges(this.atoms, range.from, 0);
            if (pos != range.from) updated = EditorSelection.cursor(pos, -1);
          } else {
            var from = skipAtomicRanges(this.atoms, range.from, -1);
            var to = skipAtomicRanges(this.atoms, range.to, 1);
            if (from != range.from || to != range.to) updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
          }
          if (updated) {
            if (!ranges) ranges = sel.ranges.slice();
            ranges[i] = updated;
          }
        }
        return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
      }
    }, {
      key: "select",
      value: function select(event) {
        var view = this.view,
          selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection.eq(view.state.selection) || selection.main.assoc != view.state.selection.main.assoc && this.dragging === false) this.view.dispatch({
          selection: selection,
          userEvent: "select.pointer"
        });
        this.mustSelect = false;
      }
    }, {
      key: "update",
      value: function update(_update3) {
        var _this22 = this;
        if (_update3.docChanged && this.dragging) this.dragging = this.dragging.map(_update3.changes);
        if (this.style.update(_update3)) setTimeout(function () {
          return _this22.select(_this22.lastEvent);
        }, 20);
      }
    }]);
    return MouseSelection;
  }();
  function addsSelectionRange(view, event) {
    var facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    var facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    var main = view.state.selection.main;
    if (main.empty) return false;
    // On boundary clicks, check whether the coordinates are inside the
    // selection's client rectangles
    var sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0) return true;
    var rects = sel.getRangeAt(0).getClientRects();
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles) return true;
    if (event.defaultPrevented) return false;
    for (var node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;
    return true;
  }
  var handlers = /*@__PURE__*/Object.create(null);
  var observers = /*@__PURE__*/Object.create(null);
  // This is very crude, but unfortunately both these browsers _pretend_
  // that they have a clipboard APIall the objects and methods are
  // there, they just don't work, and they are hard to test.
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    var parent = view.dom.parentNode;
    if (!parent) return;
    var target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(function () {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input) {
    var state = view.state,
      changes,
      i = 1,
      text = state.toText(input);
    var byLine = text.lines == state.selection.ranges.length;
    var linewise = lastLinewiseCopy != null && state.selection.ranges.every(function (r) {
      return r.empty;
    }) && lastLinewiseCopy == text.toString();
    if (linewise) {
      var lastLine = -1;
      changes = state.changeByRange(function (range) {
        var line = state.doc.lineAt(range.from);
        if (line.from == lastLine) return {
          range: range
        };
        lastLine = line.from;
        var insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
        return {
          changes: {
            from: line.from,
            insert: insert
          },
          range: EditorSelection.cursor(range.from + insert.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange(function (range) {
        var line = text.line(i++);
        return {
          changes: {
            from: range.from,
            to: range.to,
            insert: line.text
          },
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  observers.scroll = function (view) {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
  };
  handlers.keydown = function (view, event) {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27) view.inputState.lastEscPress = Date.now();
    return false;
  };
  observers.touchstart = function (view, e) {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  observers.touchmove = function (view) {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = function (view, event) {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction
    var style = null;
    var _iterator19 = _createForOfIteratorHelper(view.state.facet(mouseSelectionStyle)),
      _step19;
    try {
      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
        var makeStyle = _step19.value;
        style = makeStyle(view, event);
        if (style) break;
      }
    } catch (err) {
      _iterator19.e(err);
    } finally {
      _iterator19.f();
    }
    if (!style && event.button == 0) style = basicMouseSelection(view, event);
    if (style) {
      var mustFocus = !view.hasFocus;
      view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
      if (mustFocus) view.observer.ignore(function () {
        return focusPreventScroll(view.contentDOM);
      });
      var mouseSel = view.inputState.mouseSelection;
      if (mouseSel) {
        mouseSel.start(event);
        return !mouseSel.dragging;
      }
    }
    return false;
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      // Single click
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      // Double click
      return groupAt(view.state, pos, bias);
    } else {
      // Triple click
      var visual = LineView.find(view.docView, pos),
        line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      var from = visual ? visual.posAtStart : line.from,
        to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to) to++;
      return EditorSelection.range(from, to);
    }
  }
  var insideY = function insideY(y, rect) {
    return y >= rect.top && y <= rect.bottom;
  };
  var inside = function inside(x, y, rect) {
    return insideY(y, rect) && x >= rect.left && x <= rect.right;
  };
  // Try to determine, for the given coordinates, associated with the
  // given position, whether they are related to the element before or
  // the element after the position.
  function findPositionSide(view, pos, x, y) {
    var line = LineView.find(view.docView, pos);
    if (!line) return 1;
    var off = pos - line.posAtStart;
    // Line boundaries point into the line
    if (off == 0) return 1;
    if (off == line.length) return -1;
    // Positions on top of an element point at that element
    var before = line.coordsAt(off, -1);
    if (before && inside(x, y, before)) return -1;
    var after = line.coordsAt(off, 1);
    if (after && inside(x, y, after)) return 1;
    // This is probably a line wrap point. Pick before if the point is
    // beside it.
    return before && insideY(y, before) ? -1 : 1;
  }
  function queryPos(view, event) {
    var pos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    }, false);
    return {
      pos: pos,
      bias: findPositionSide(view, pos, event.clientX, event.clientY)
    };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null,
    lastMouseDownCount = 0,
    lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail) return event.detail;
    var last = lastMouseDown,
      lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    var start = queryPos(view, event),
      type = getClickType(event);
    var startSel = view.state.selection;
    return {
      update: function update(_update4) {
        if (_update4.docChanged) {
          start.pos = _update4.changes.mapPos(start.pos);
          startSel = startSel.map(_update4.changes);
        }
      },
      get: function get(event, extend, multiple) {
        var cur = queryPos(view, event),
          removed;
        var range = rangeForClick(view, cur.pos, cur.bias, type);
        if (start.pos != cur.pos && !extend) {
          var startRange = rangeForClick(view, start.pos, start.bias, type);
          var from = Math.min(startRange.from, range.from),
            to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;else if (multiple) return startSel.addRange(range);else return EditorSelection.create([range]);
      }
    };
  }
  function removeRangeAround(sel, pos) {
    for (var i = 0; i < sel.ranges.length; i++) {
      var _sel$ranges$i = sel.ranges[i],
        from = _sel$ranges$i.from,
        to = _sel$ranges$i.to;
      if (from <= pos && to >= pos) return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
  }
  handlers.dragstart = function (view, event) {
    var main = view.state.selection.main;
    var mouseSelection = view.inputState.mouseSelection;
    if (mouseSelection) mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
  };
  function dropText(view, event, text, direct) {
    if (!text) return;
    var dropPos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    }, false);
    var mouseSelection = view.inputState.mouseSelection;
    var del = direct && mouseSelection && mouseSelection.dragging && dragMovesSelection(view, event) ? {
      from: mouseSelection.dragging.from,
      to: mouseSelection.dragging.to
    } : null;
    var ins = {
      from: dropPos,
      insert: text
    };
    var changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
      changes: changes,
      selection: {
        anchor: changes.mapPos(dropPos, -1),
        head: changes.mapPos(dropPos, 1)
      },
      userEvent: del ? "move.drop" : "input.drop"
    });
  }
  handlers.drop = function (view, event) {
    if (!event.dataTransfer) return false;
    if (view.state.readOnly) return true;
    var files = event.dataTransfer.files;
    if (files && files.length) {
      // For a file drop, read the file's text.
      var text = Array(files.length),
        read = 0;
      var finishFile = function finishFile() {
        if (++read == files.length) dropText(view, event, text.filter(function (s) {
          return s != null;
        }).join(view.state.lineBreak), false);
      };
      var _loop2 = function _loop2(i) {
        var reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = function () {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      };
      for (var i = 0; i < files.length; i++) {
        _loop2(i);
      }
      return true;
    } else {
      var _text = event.dataTransfer.getData("Text");
      if (_text) {
        dropText(view, event, _text, true);
        return true;
      }
    }
    return false;
  };
  handlers.paste = function (view, event) {
    if (view.state.readOnly) return true;
    view.observer.flush();
    var data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain") || data.getData("text/uri-text"));
      return true;
    } else {
      capturePaste(view);
      return false;
    }
  };
  function captureCopy(view, text) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    var parent = view.dom.parentNode;
    if (!parent) return;
    var target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(function () {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    var content = [],
      ranges = [],
      linewise = false;
    var _iterator20 = _createForOfIteratorHelper(state.selection.ranges),
      _step20;
    try {
      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
        var range = _step20.value;
        if (!range.empty) {
          content.push(state.sliceDoc(range.from, range.to));
          ranges.push(range);
        }
      }
    } catch (err) {
      _iterator20.e(err);
    } finally {
      _iterator20.f();
    }
    if (!content.length) {
      // Nothing selected, do a line-wise copy
      var upto = -1;
      var _iterator21 = _createForOfIteratorHelper(state.selection.ranges),
        _step21;
      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var from = _step21.value.from;
          var line = state.doc.lineAt(from);
          if (line.number > upto) {
            content.push(line.text);
            ranges.push({
              from: line.from,
              to: Math.min(state.doc.length, line.to + 1)
            });
          }
          upto = line.number;
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }
      linewise = true;
    }
    return {
      text: content.join(state.lineBreak),
      ranges: ranges,
      linewise: linewise
    };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = function (view, event) {
    var _copiedRange = copiedRange(view.state),
      text = _copiedRange.text,
      ranges = _copiedRange.ranges,
      linewise = _copiedRange.linewise;
    if (!text && !linewise) return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly) view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
    var data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      data.clearData();
      data.setData("text/plain", text);
      return true;
    } else {
      captureCopy(view, text);
      return false;
    }
  };
  var isFocusChange = /*@__PURE__*/Annotation.define();
  function focusChangeTransaction(state, focus) {
    var effects = [];
    var _iterator22 = _createForOfIteratorHelper(state.facet(focusChangeEffect)),
      _step22;
    try {
      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
        var getEffect = _step22.value;
        var effect = getEffect(state, focus);
        if (effect) effects.push(effect);
      }
    } catch (err) {
      _iterator22.e(err);
    } finally {
      _iterator22.f();
    }
    return effects ? state.update({
      effects: effects,
      annotations: isFocusChange.of(true)
    }) : null;
  }
  function updateForFocusChange(view) {
    setTimeout(function () {
      var focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        var tr = focusChangeTransaction(view.state, focus);
        if (tr) view.dispatch(tr);else view.update([]);
      }
    }, 10);
  }
  observers.focus = function (view) {
    view.inputState.lastFocusTime = Date.now();
    // When focusing reset the scroll position, move it back to where it was
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  observers.blur = function (view) {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  observers.compositionstart = observers.compositionupdate = function (view) {
    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      // FIXME possibly set a timeout to clear it again on Android
      view.inputState.composing = 0;
    }
  };
  observers.compositionend = function (view) {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
      // Delay flushing for a bit on Android because it'll often fire a
      // bunch of contradictory changes in a row at end of compositon
      view.observer.flushSoon();
    } else if (view.inputState.compositionPendingChange) {
      // If we found pending records, schedule a flush.
      Promise.resolve().then(function () {
        return view.observer.flush();
      });
    } else {
      // Otherwise, make sure that, if no changes come in soon, the
      // composition view is cleared.
      setTimeout(function () {
        if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);
      }, 50);
    }
  };
  observers.contextmenu = function (view) {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = function (view, event) {
    var _a;
    // Because Chrome Android doesn't fire useful key events, use
    // beforeinput to detect backspace (and possibly enter and delete,
    // but those usually don't even seem to fire beforeinput events at
    // the moment) and fake a key event for it.
    //
    // (preventDefault on beforeinput, though supported in the spec,
    // seems to do nothing at all on Chrome).
    var pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find(function (key) {
      return key.inputType == event.inputType;
    }))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        var startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;
        setTimeout(function () {
          var _a;
          // Backspacing near uneditable nodes on Chrome Android sometimes
          // closes the virtual keyboard. This tries to crudely detect
          // that and refocus to get it back.
          if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
    return false;
  };
  var appliedFirefoxHack = /*@__PURE__*/new Set();
  // In Firefox, when cut/copy handlers are added to the document, that
  // somehow avoids a bug where those events aren't fired when the
  // selection is empty. See https://github.com/codemirror/dev/issues/1082
  // and https://bugzilla.mozilla.org/show_bug.cgi?id=995961
  function firefoxCopyCutHack(doc) {
    if (!appliedFirefoxHack.has(doc)) {
      appliedFirefoxHack.add(doc);
      doc.addEventListener("copy", function () {});
      doc.addEventListener("cut", function () {});
    }
  }
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = /*#__PURE__*/function () {
    function HeightOracle(lineWrapping) {
      _classCallCheck(this, HeightOracle);
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14; // The height of an entire line (line-height)
      this.charWidth = 7;
      this.textHeight = 14; // The height of the actual font (font-size)
      this.lineLength = 30;
      // Used to track, during updateHeight, if any actual heights changed
      this.heightChanged = false;
    }
    _createClass(HeightOracle, [{
      key: "heightForGap",
      value: function heightForGap(from, to) {
        var lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
        return this.lineHeight * lines;
      }
    }, {
      key: "heightForLine",
      value: function heightForLine(length) {
        if (!this.lineWrapping) return this.lineHeight;
        var lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
      }
    }, {
      key: "setDoc",
      value: function setDoc(doc) {
        this.doc = doc;
        return this;
      }
    }, {
      key: "mustRefreshForWrapping",
      value: function mustRefreshForWrapping(whiteSpace) {
        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
      }
    }, {
      key: "mustRefreshForHeights",
      value: function mustRefreshForHeights(lineHeights) {
        var newHeight = false;
        for (var i = 0; i < lineHeights.length; i++) {
          var h = lineHeights[i];
          if (h < 0) {
            i++;
          } else if (!this.heightSamples[Math.floor(h * 10)]) {
            // Round to .1 pixels
            newHeight = true;
            this.heightSamples[Math.floor(h * 10)] = true;
          }
        }
        return newHeight;
      }
    }, {
      key: "refresh",
      value: function refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        var lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        var changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
          this.heightSamples = {};
          for (var i = 0; i < knownHeights.length; i++) {
            var h = knownHeights[i];
            if (h < 0) i++;else this.heightSamples[Math.floor(h * 10)] = true;
          }
        }
        return changed;
      }
    }]);
    return HeightOracle;
  }(); // This object is used by `updateHeight` to make DOM measurements
  // arrive at the right nides. The `heights` array is a sequence of
  // block heights, starting from position `from`.
  var MeasuredHeights = /*#__PURE__*/function () {
    function MeasuredHeights(from, heights) {
      _classCallCheck(this, MeasuredHeights);
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    _createClass(MeasuredHeights, [{
      key: "more",
      get: function get() {
        return this.index < this.heights.length;
      }
    }]);
    return MeasuredHeights;
  }();
  /**
  Record used to represent information about a block-level element
  in the editor view.
  */
  var BlockInfo = /*#__PURE__*/function () {
    /**
    @internal
    */
    function BlockInfo(
    /**
    The start of the element in the document.
    */
    from,
    /**
    The length of the element.
    */
    length,
    /**
    The top position of the element (relative to the top of the
    document).
    */
    top,
    /**
    Its height.
    */
    height,
    /**
    @internal Weird packed field that holds an array of children
    for composite blocks, a decoration for block widgets, and a
    number indicating the amount of widget-create line breaks for
    text blocks.
    */
    _content) {
      _classCallCheck(this, BlockInfo);
      this.from = from;
      this.length = length;
      this.top = top;
      this.height = height;
      this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    _createClass(BlockInfo, [{
      key: "type",
      get: function get() {
        return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
      }
      /**
      The end of the element as a document position.
      */
    }, {
      key: "to",
      get: function get() {
        return this.from + this.length;
      }
      /**
      The bottom position of the element.
      */
    }, {
      key: "bottom",
      get: function get() {
        return this.top + this.height;
      }
      /**
      If this is a widget block, this will return the widget
      associated with it.
      */
    }, {
      key: "widget",
      get: function get() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
      }
      /**
      If this is a textblock, this holds the number of line breaks
      that appear in widgets inside the block.
      */
    }, {
      key: "widgetLineBreaks",
      get: function get() {
        return typeof this._content == "number" ? this._content : 0;
      }
      /**
      @internal
      */
    }, {
      key: "join",
      value: function join(other) {
        var content = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
      }
    }]);
    return BlockInfo;
  }();
  var QueryType = /*@__PURE__*/function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = /*#__PURE__*/function () {
    function HeightMap(length,
    // The number of characters covered
    height) {
      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
      _classCallCheck(this, HeightMap);
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    _createClass(HeightMap, [{
      key: "outdated",
      get: function get() {
        return (this.flags & 2 /* Flag.Outdated */) > 0;
      },
      set: function set(value) {
        this.flags = (value ? 2 /* Flag.Outdated */ : 0) | this.flags & ~2 /* Flag.Outdated */;
      }
    }, {
      key: "setHeight",
      value: function setHeight(oracle, height) {
        if (this.height != height) {
          if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;
          this.height = height;
        }
      }
      // Base case is to replace a leaf node, which simply builds a tree
      // from the new nodes and returns that (HeightMapBranch and
      // HeightMapGap override this to actually use from/to)
    }, {
      key: "replace",
      value: function replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
      }
      // Again, these are base cases, and are overridden for branch and gap nodes.
    }, {
      key: "decomposeLeft",
      value: function decomposeLeft(_to, result) {
        result.push(this);
      }
    }, {
      key: "decomposeRight",
      value: function decomposeRight(_from, result) {
        result.push(this);
      }
    }, {
      key: "applyChanges",
      value: function applyChanges(decorations, oldDoc, oracle, changes) {
        var me = this,
          doc = oracle.doc;
        for (var i = changes.length - 1; i >= 0; i--) {
          var _changes$i = changes[i],
            fromA = _changes$i.fromA,
            toA = _changes$i.toA,
            fromB = _changes$i.fromB,
            toB = _changes$i.toB;
          var start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
          var end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
          toB += end.to - toA;
          toA = end.to;
          while (i > 0 && start.from <= changes[i - 1].toA) {
            fromA = changes[i - 1].fromA;
            fromB = changes[i - 1].fromB;
            i--;
            if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
          }
          fromB += start.from - fromA;
          fromA = start.from;
          var nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
          me = me.replace(fromA, toA, nodes);
        }
        return me.updateHeight(oracle, 0);
      }
    }], [{
      key: "empty",
      value: function empty() {
        return new HeightMapText(0, 0);
      }
      // nodes uses null values to indicate the position of line breaks.
      // There are never line breaks at the start or end of the array, or
      // two line breaks next to each other, and the array isn't allowed
      // to be empty (same restrictions as return value from the builder).
    }, {
      key: "of",
      value: function of(nodes) {
        if (nodes.length == 1) return nodes[0];
        var i = 0,
          j = nodes.length,
          before = 0,
          after = 0;
        for (;;) {
          if (i == j) {
            if (before > after * 2) {
              var split = nodes[i - 1];
              if (split["break"]) nodes.splice(--i, 1, split.left, null, split.right);else nodes.splice(--i, 1, split.left, split.right);
              j += 1 + split["break"];
              before -= split.size;
            } else if (after > before * 2) {
              var _split = nodes[j];
              if (_split["break"]) nodes.splice(j, 1, _split.left, null, _split.right);else nodes.splice(j, 1, _split.left, _split.right);
              j += 2 + _split["break"];
              after -= _split.size;
            } else {
              break;
            }
          } else if (before < after) {
            var next = nodes[i++];
            if (next) before += next.size;
          } else {
            var _next2 = nodes[--j];
            if (_next2) after += _next2.size;
          }
        }
        var brk = 0;
        if (nodes[i - 1] == null) {
          brk = 1;
          i--;
        } else if (nodes[i] == null) {
          brk = 1;
          j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
      }
    }]);
    return HeightMap;
  }();
  HeightMap.prototype.size = 1;
  var HeightMapBlock = /*#__PURE__*/function (_HeightMap) {
    _inherits$1(HeightMapBlock, _HeightMap);
    var _super14 = _createSuper(HeightMapBlock);
    function HeightMapBlock(length, height, deco) {
      var _this23;
      _classCallCheck(this, HeightMapBlock);
      _this23 = _super14.call(this, length, height);
      _this23.deco = deco;
      return _this23;
    }
    _createClass(HeightMapBlock, [{
      key: "blockAt",
      value: function blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
      }
    }, {
      key: "lineAt",
      value: function lineAt(_value, _type, oracle, top, offset) {
        return this.blockAt(0, oracle, top, offset);
      }
    }, {
      key: "forEachLine",
      value: function forEachLine(from, to, oracle, top, offset, f) {
        if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));
      }
    }, {
      key: "updateHeight",
      value: function updateHeight(oracle) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var measured = arguments.length > 3 ? arguments[3] : undefined;
        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);
        this.outdated = false;
        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "block(".concat(this.length, ")");
      }
    }]);
    return HeightMapBlock;
  }(HeightMap);
  var HeightMapText = /*#__PURE__*/function (_HeightMapBlock) {
    _inherits$1(HeightMapText, _HeightMapBlock);
    var _super15 = _createSuper(HeightMapText);
    function HeightMapText(length, height) {
      var _this24;
      _classCallCheck(this, HeightMapText);
      _this24 = _super15.call(this, length, height, null);
      _this24.collapsed = 0; // Amount of collapsed content in the line
      _this24.widgetHeight = 0; // Maximum inline widget height
      _this24.breaks = 0; // Number of widget-introduced line breaks on the line
      return _this24;
    }
    _createClass(HeightMapText, [{
      key: "blockAt",
      value: function blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.breaks);
      }
    }, {
      key: "replace",
      value: function replace(_from, _to, nodes) {
        var node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */) && Math.abs(this.length - node.length) < 10) {
          if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);else node.height = this.height;
          if (!this.outdated) node.outdated = false;
          return node;
        } else {
          return HeightMap.of(nodes);
        }
      }
    }, {
      key: "updateHeight",
      value: function updateHeight(oracle) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var measured = arguments.length > 3 ? arguments[3] : undefined;
        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "line(".concat(this.length).concat(this.collapsed ? -this.collapsed : "").concat(this.widgetHeight ? ":" + this.widgetHeight : "", ")");
      }
    }]);
    return HeightMapText;
  }(HeightMapBlock);
  var HeightMapGap = /*#__PURE__*/function (_HeightMap2) {
    _inherits$1(HeightMapGap, _HeightMap2);
    var _super16 = _createSuper(HeightMapGap);
    function HeightMapGap(length) {
      _classCallCheck(this, HeightMapGap);
      return _super16.call(this, length, 0);
    }
    _createClass(HeightMapGap, [{
      key: "heightMetrics",
      value: function heightMetrics(oracle, offset) {
        var firstLine = oracle.doc.lineAt(offset).number,
          lastLine = oracle.doc.lineAt(offset + this.length).number;
        var lines = lastLine - firstLine + 1;
        var perLine,
          perChar = 0;
        if (oracle.lineWrapping) {
          var totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
          perLine = totalPerLine / lines;
          if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        } else {
          perLine = this.height / lines;
        }
        return {
          firstLine: firstLine,
          lastLine: lastLine,
          perLine: perLine,
          perChar: perChar
        };
      }
    }, {
      key: "blockAt",
      value: function blockAt(height, oracle, top, offset) {
        var _this$heightMetrics = this.heightMetrics(oracle, offset),
          firstLine = _this$heightMetrics.firstLine,
          lastLine = _this$heightMetrics.lastLine,
          perLine = _this$heightMetrics.perLine,
          perChar = _this$heightMetrics.perChar;
        if (oracle.lineWrapping) {
          var guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);
          var line = oracle.doc.lineAt(guess),
            lineHeight = perLine + line.length * perChar;
          var lineTop = Math.max(top, height - lineHeight / 2);
          return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        } else {
          var _line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
          var _oracle$doc$line = oracle.doc.line(firstLine + _line),
            from = _oracle$doc$line.from,
            length = _oracle$doc$line.length;
          return new BlockInfo(from, length, top + perLine * _line, perLine, 0);
        }
      }
    }, {
      key: "lineAt",
      value: function lineAt(value, type, oracle, top, offset) {
        if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);
        if (type == QueryType.ByPosNoHeight) {
          var _oracle$doc$lineAt = oracle.doc.lineAt(value),
            from = _oracle$doc$lineAt.from,
            to = _oracle$doc$lineAt.to;
          return new BlockInfo(from, to - from, 0, 0, 0);
        }
        var _this$heightMetrics2 = this.heightMetrics(oracle, offset),
          firstLine = _this$heightMetrics2.firstLine,
          perLine = _this$heightMetrics2.perLine,
          perChar = _this$heightMetrics2.perChar;
        var line = oracle.doc.lineAt(value),
          lineHeight = perLine + line.length * perChar;
        var linesAbove = line.number - firstLine;
        var lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
      }
    }, {
      key: "forEachLine",
      value: function forEachLine(from, to, oracle, top, offset, f) {
        from = Math.max(from, offset);
        to = Math.min(to, offset + this.length);
        var _this$heightMetrics3 = this.heightMetrics(oracle, offset),
          firstLine = _this$heightMetrics3.firstLine,
          perLine = _this$heightMetrics3.perLine,
          perChar = _this$heightMetrics3.perChar;
        for (var pos = from, lineTop = top; pos <= to;) {
          var line = oracle.doc.lineAt(pos);
          if (pos == from) {
            var linesAbove = line.number - firstLine;
            lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
          }
          var lineHeight = perLine + perChar * line.length;
          f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
          lineTop += lineHeight;
          pos = line.to + 1;
        }
      }
    }, {
      key: "replace",
      value: function replace(from, to, nodes) {
        var after = this.length - to;
        if (after > 0) {
          var last = nodes[nodes.length - 1];
          if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);else nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
          var first = nodes[0];
          if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);else nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
      }
    }, {
      key: "decomposeLeft",
      value: function decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
      }
    }, {
      key: "decomposeRight",
      value: function decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
      }
    }, {
      key: "updateHeight",
      value: function updateHeight(oracle) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var measured = arguments.length > 3 ? arguments[3] : undefined;
        var end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
          // Fill in part of this gap with measured lines. We know there
          // can't be widgets or collapsed ranges in those lines, because
          // they would already have been added to the heightmap (gaps
          // only contain plain text).
          var nodes = [],
            pos = Math.max(offset, measured.from),
            singleHeight = -1;
          if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
          while (pos <= end && measured.more) {
            var len = oracle.doc.lineAt(pos).length;
            if (nodes.length) nodes.push(null);
            var height = measured.heights[measured.index++];
            if (singleHeight == -1) singleHeight = height;else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;
            var line = new HeightMapText(len, height);
            line.outdated = false;
            nodes.push(line);
            pos += len + 1;
          }
          if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
          var result = HeightMap.of(nodes);
          if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) oracle.heightChanged = true;
          return result;
        } else if (force || this.outdated) {
          this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
          this.outdated = false;
        }
        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "gap(".concat(this.length, ")");
      }
    }]);
    return HeightMapGap;
  }(HeightMap);
  var HeightMapBranch = /*#__PURE__*/function (_HeightMap3) {
    _inherits$1(HeightMapBranch, _HeightMap3);
    var _super17 = _createSuper(HeightMapBranch);
    function HeightMapBranch(left, brk, right) {
      var _this25;
      _classCallCheck(this, HeightMapBranch);
      _this25 = _super17.call(this, left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));
      _this25.left = left;
      _this25.right = right;
      _this25.size = left.size + right.size;
      return _this25;
    }
    _createClass(HeightMapBranch, [{
      key: "break",
      get: function get() {
        return this.flags & 1 /* Flag.Break */;
      }
    }, {
      key: "blockAt",
      value: function blockAt(height, oracle, top, offset) {
        var mid = top + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this["break"]);
      }
    }, {
      key: "lineAt",
      value: function lineAt(value, type, oracle, top, offset) {
        var rightTop = top + this.left.height,
          rightOffset = offset + this.left.length + this["break"];
        var left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        var base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this["break"] || (left ? base.to < rightOffset : base.from > rightOffset)) return base;
        var subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
      }
    }, {
      key: "forEachLine",
      value: function forEachLine(from, to, oracle, top, offset, f) {
        var rightTop = top + this.left.height,
          rightOffset = offset + this.left.length + this["break"];
        if (this["break"]) {
          if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);
          if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
        } else {
          var mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
          if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
          if (mid.to >= from && mid.from <= to) f(mid);
          if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
        }
      }
    }, {
      key: "replace",
      value: function replace(from, to, nodes) {
        var rightStart = this.left.length + this["break"];
        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        var result = [];
        if (from > 0) this.decomposeLeft(from, result);
        var left = result.length;
        var _iterator23 = _createForOfIteratorHelper(nodes),
          _step23;
        try {
          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
            var node = _step23.value;
            result.push(node);
          }
        } catch (err) {
          _iterator23.e(err);
        } finally {
          _iterator23.f();
        }
        if (from > 0) mergeGaps(result, left - 1);
        if (to < this.length) {
          var right = result.length;
          this.decomposeRight(to, result);
          mergeGaps(result, right);
        }
        return HeightMap.of(result);
      }
    }, {
      key: "decomposeLeft",
      value: function decomposeLeft(to, result) {
        var left = this.left.length;
        if (to <= left) return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this["break"]) {
          left++;
          if (to >= left) result.push(null);
        }
        if (to > left) this.right.decomposeLeft(to - left, result);
      }
    }, {
      key: "decomposeRight",
      value: function decomposeRight(from, result) {
        var left = this.left.length,
          right = left + this["break"];
        if (from >= right) return this.right.decomposeRight(from - right, result);
        if (from < left) this.left.decomposeRight(from, result);
        if (this["break"] && from < right) result.push(null);
        result.push(this.right);
      }
    }, {
      key: "balanced",
      value: function balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this["break"] ? [left, null, right] : [left, right]);
        this.left = left;
        this.right = right;
        this.height = left.height + right.height;
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this["break"] + right.length;
        return this;
      }
    }, {
      key: "updateHeight",
      value: function updateHeight(oracle) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var measured = arguments.length > 3 ? arguments[3] : undefined;
        var left = this.left,
          right = this.right,
          rightStart = offset + left.length + this["break"],
          rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);else left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);else right.updateHeight(oracle, rightStart, force);
        if (rebalance) return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.left + (this["break"] ? " " : "-") + this.right;
      }
    }]);
    return HeightMapBranch;
  }(HeightMap);
  function mergeGaps(nodes, around) {
    var before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = /*#__PURE__*/function () {
    function NodeBuilder(pos, oracle) {
      _classCallCheck(this, NodeBuilder);
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    _createClass(NodeBuilder, [{
      key: "isCovered",
      get: function get() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
      }
    }, {
      key: "span",
      value: function span(_from, to) {
        if (this.lineStart > -1) {
          var end = Math.min(to, this.lineEnd),
            last = this.nodes[this.nodes.length - 1];
          if (last instanceof HeightMapText) last.length += end - this.pos;else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));
          this.writtenTo = end;
          if (to > end) {
            this.nodes.push(null);
            this.writtenTo++;
            this.lineStart = -1;
          }
        }
        this.pos = to;
      }
    }, {
      key: "point",
      value: function point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
          var height = deco.widget ? deco.widget.estimatedHeight : 0;
          var breaks = deco.widget ? deco.widget.lineBreaks : 0;
          if (height < 0) height = this.oracle.lineHeight;
          var len = to - from;
          if (deco.block) {
            this.addBlock(new HeightMapBlock(len, height, deco));
          } else if (len || breaks || height >= relevantWidgetHeight) {
            this.addLineDeco(height, breaks, len);
          }
        } else if (to > from) {
          this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
      }
    }, {
      key: "enterLine",
      value: function enterLine() {
        if (this.lineStart > -1) return;
        var _this$oracle$doc$line = this.oracle.doc.lineAt(this.pos),
          from = _this$oracle$doc$line.from,
          to = _this$oracle$doc$line.to;
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
          if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));
          this.nodes.push(null);
        }
        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
      }
    }, {
      key: "blankContent",
      value: function blankContent(from, to) {
        var gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */;
        return gap;
      }
    }, {
      key: "ensureLine",
      value: function ensureLine() {
        this.enterLine();
        var last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText) return last;
        var line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
      }
    }, {
      key: "addBlock",
      value: function addBlock(block) {
        this.enterLine();
        var deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0) this.covering = block;
      }
    }, {
      key: "addLineDeco",
      value: function addLineDeco(height, breaks, length) {
        var line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
      }
    }, {
      key: "finish",
      value: function finish(from) {
        var last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        var pos = from;
        var _iterator24 = _createForOfIteratorHelper(this.nodes),
          _step24;
        try {
          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
            var node = _step24.value;
            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
          }
        } catch (err) {
          _iterator24.e(err);
        } finally {
          _iterator24.f();
        }
        return this.nodes;
      }
      // Always called with a region that on both sides either stretches
      // to a line break or the end of the document.
      // The returned array uses null to indicate line breaks, but never
      // starts or ends in a line break, or has multiple line breaks next
      // to each other.
    }], [{
      key: "build",
      value: function build(oracle, decorations, from, to) {
        var builder = new NodeBuilder(from, oracle);
        RangeSet.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
      }
    }]);
    return NodeBuilder;
  }();
  function heightRelevantDecoChanges(a, b, diff) {
    var comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = /*#__PURE__*/function () {
    function DecorationComparator() {
      _classCallCheck(this, DecorationComparator);
      this.changes = [];
    }
    _createClass(DecorationComparator, [{
      key: "compareRange",
      value: function compareRange() {}
    }, {
      key: "comparePoint",
      value: function comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);
      }
    }]);
    return DecorationComparator;
  }();
  function visiblePixelRange(dom, paddingTop) {
    var rect = dom.getBoundingClientRect();
    var doc = dom.ownerDocument,
      win = doc.defaultView || window;
    var left = Math.max(0, rect.left),
      right = Math.min(win.innerWidth, rect.right);
    var top = Math.max(0, rect.top),
      bottom = Math.min(win.innerHeight, rect.bottom);
    for (var parent = dom.parentNode; parent && parent != doc.body;) {
      if (parent.nodeType == 1) {
        var elt = parent;
        var style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          var parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top = Math.max(top, parentRect.top);
          bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        // Shadow root
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top - (rect.top + paddingTop),
      bottom: Math.max(top, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    var rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  // Line gaps are placeholder widgets used to hide pieces of overlong
  // lines within the viewport, as a kludge to keep the editor
  // responsive when a ridiculously long line is loaded into it.
  var LineGap = /*#__PURE__*/function () {
    function LineGap(from, to, size) {
      _classCallCheck(this, LineGap);
      this.from = from;
      this.to = to;
      this.size = size;
    }
    _createClass(LineGap, [{
      key: "draw",
      value: function draw(viewState, wrapping) {
        return Decoration.replace({
          widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
      }
    }], [{
      key: "same",
      value: function same(a, b) {
        if (a.length != b.length) return false;
        for (var i = 0; i < a.length; i++) {
          var gA = a[i],
            gB = b[i];
          if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;
        }
        return true;
      }
    }]);
    return LineGap;
  }();
  var LineGapWidget = /*#__PURE__*/function (_WidgetType3) {
    _inherits$1(LineGapWidget, _WidgetType3);
    var _super18 = _createSuper(LineGapWidget);
    function LineGapWidget(size, vertical) {
      var _this26;
      _classCallCheck(this, LineGapWidget);
      _this26 = _super18.call(this);
      _this26.size = size;
      _this26.vertical = vertical;
      return _this26;
    }
    _createClass(LineGapWidget, [{
      key: "eq",
      value: function eq(other) {
        return other.size == this.size && other.vertical == this.vertical;
      }
    }, {
      key: "toDOM",
      value: function toDOM() {
        var elt = document.createElement("div");
        if (this.vertical) {
          elt.style.height = this.size + "px";
        } else {
          elt.style.width = this.size + "px";
          elt.style.height = "2px";
          elt.style.display = "inline-block";
        }
        return elt;
      }
    }, {
      key: "estimatedHeight",
      get: function get() {
        return this.vertical ? this.size : -1;
      }
    }]);
    return LineGapWidget;
  }(WidgetType);
  var ViewState = /*#__PURE__*/function () {
    function ViewState(state) {
      var _this27 = this;
      _classCallCheck(this, ViewState);
      this.state = state;
      // These are contentDOM-local coordinates
      this.pixelViewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: 0
      };
      this.inView = true;
      this.paddingTop = 0; // Padding above the document, scaled
      this.paddingBottom = 0; // Padding below the document, scaled
      this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width
      this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height
      this.editorHeight = 0; // scrollDOM.clientHeight, unscaled
      this.editorWidth = 0; // scrollDOM.clientWidth, unscaled
      this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled
      this.scrolledToBottom = true;
      // The CSS-transformation scale of the editor (transformed size /
      // concrete size)
      this.scaleX = 1;
      this.scaleY = 1;
      // The vertical position (document-relative) to which to anchor the
      // scroll position. -1 means anchor to the end of the document.
      this.scrollAnchorPos = 0;
      // The height at the anchor position. Set by the DOM update phase.
      // -1 means no height available.
      this.scrollAnchorHeight = -1;
      // See VP.MaxDOMHeight
      this.scaler = IdScaler;
      this.scrollTarget = null;
      // Briefly set to true when printing, to disable viewport limiting
      this.printing = false;
      // Flag set when editor content was redrawn, so that the next
      // measure stage knows it must read DOM layout
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      // Cursor 'assoc' is only significant when the cursor is on a line
      // wrap point, where it must stick to the character that it is
      // associated with. Since browsers don't provide a reasonable
      // interface to set or query this, when a selection is set that
      // might cause this to be significant, this flag is set. The next
      // measure phase will check whether the cursor is on a line-wrapping
      // boundary and, if so, reset it to make sure it is positioned in
      // the right place.
      this.mustEnforceCursorAssoc = false;
      var guessWrapping = state.facet(contentAttributes).some(function (v) {
        return typeof v != "function" && v["class"] == "cm-lineWrapping";
      });
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter(function (d) {
        return typeof d != "function";
      });
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map(function (gap) {
        return gap.draw(_this27, false);
      }));
      this.computeVisibleRanges();
    }
    _createClass(ViewState, [{
      key: "updateForViewport",
      value: function updateForViewport() {
        var _this28 = this;
        var viewports = [this.viewport],
          main = this.state.selection.main;
        var _loop3 = function _loop3() {
          var pos = i ? main.head : main.anchor;
          if (!viewports.some(function (_ref4) {
            var from = _ref4.from,
              to = _ref4.to;
            return pos >= from && pos <= to;
          })) {
            var _this28$lineBlockAt = _this28.lineBlockAt(pos),
              from = _this28$lineBlockAt.from,
              to = _this28$lineBlockAt.to;
            viewports.push(new Viewport(from, to));
          }
        };
        for (var i = 0; i <= 1; i++) {
          _loop3();
        }
        this.viewports = viewports.sort(function (a, b) {
          return a.from - b.from;
        });
        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
      }
    }, {
      key: "updateViewportLines",
      value: function updateViewportLines() {
        var _this29 = this;
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, function (block) {
          _this29.viewportLines.push(_this29.scaler.scale == 1 ? block : scaleBlock(block, _this29.scaler));
        });
      }
    }, {
      key: "update",
      value: function update(_update5) {
        var scrollTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        this.state = _update5.state;
        var prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter(function (d) {
          return typeof d != "function";
        });
        var contentChanges = _update5.changedRanges;
        var heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, _update5 ? _update5.changes : ChangeSet.empty(this.state.doc.length)));
        var prevHeight = this.heightMap.height;
        var scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, _update5.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight) _update5.flags |= 2 /* UpdateFlag.Height */;
        if (scrollAnchor) {
          this.scrollAnchorPos = _update5.changes.mapPos(scrollAnchor.from, -1);
          this.scrollAnchorHeight = scrollAnchor.top;
        } else {
          this.scrollAnchorPos = -1;
          this.scrollAnchorHeight = this.heightMap.height;
        }
        var viewport = heightChanges.length ? this.mapViewport(this.viewport, _update5.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);
        var updateLines = !_update5.changes.empty || _update5.flags & 2 /* UpdateFlag.Height */ || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        this.updateForViewport();
        if (updateLines) this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, _update5.changes)));
        _update5.flags |= this.computeVisibleRanges();
        if (scrollTarget) this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && _update5.selectionSet && _update5.view.lineWrapping && _update5.state.selection.main.empty && _update5.state.selection.main.assoc && !_update5.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;
      }
    }, {
      key: "measure",
      value: function measure(view) {
        var dom = view.contentDOM,
          style = window.getComputedStyle(dom);
        var oracle = this.heightOracle;
        var whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        var refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        var domRect = dom.getBoundingClientRect();
        var measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        var result = 0,
          bias = 0;
        if (domRect.width && domRect.height) {
          var scaleX = domRect.width / dom.offsetWidth;
          var scaleY = domRect.height / dom.offsetHeight;
          if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(domRect.width - dom.offsetWidth) < 1) scaleX = 1;
          if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(domRect.height - dom.offsetHeight) < 1) scaleY = 1;
          if (this.scaleX != scaleX || this.scaleY != scaleY) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            result |= 8 /* UpdateFlag.Geometry */;
            refresh = measureContent = true;
          }
        }
        // Vertical padding
        var paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        var paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
          this.paddingTop = paddingTop;
          this.paddingBottom = paddingBottom;
          result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;
        }

        if (this.editorWidth != view.scrollDOM.clientWidth) {
          if (oracle.lineWrapping) measureContent = true;
          this.editorWidth = view.scrollDOM.clientWidth;
          result |= 8 /* UpdateFlag.Geometry */;
        }

        var scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
          this.scrollAnchorHeight = -1;
          this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        // Pixel viewport
        var pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        var dTop = pixelViewport.top - this.pixelViewport.top,
          dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        var inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
          this.inView = inView;
          if (inView) measureContent = true;
        }
        if (!this.inView && !this.scrollTarget) return 0;
        var contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
          this.contentDOMWidth = domRect.width;
          this.editorHeight = view.scrollDOM.clientHeight;
          result |= 8 /* UpdateFlag.Geometry */;
        }

        if (measureContent) {
          var lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
          if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;
          if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
            var _view$docView$measure = view.docView.measureTextSize(),
              lineHeight = _view$docView$measure.lineHeight,
              charWidth = _view$docView$measure.charWidth,
              textHeight = _view$docView$measure.textHeight;
            refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
            if (refresh) {
              view.docView.minWidth = 0;
              result |= 8 /* UpdateFlag.Geometry */;
            }
          }

          if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);
          oracle.heightChanged = false;
          var _iterator25 = _createForOfIteratorHelper(this.viewports),
            _step25;
          try {
            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
              var vp = _step25.value;
              var heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
              this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
          } catch (err) {
            _iterator25.e(err);
          } finally {
            _iterator25.f();
          }
          if (oracle.heightChanged) result |= 2 /* UpdateFlag.Height */;
        }

        var viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);
        this.updateForViewport();
        if (result & 2 /* UpdateFlag.Height */ || viewportChange) this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
          this.mustEnforceCursorAssoc = false;
          // This is done in the read stage, because moving the selection
          // to a line end is going to trigger a layout anyway, so it
          // can't be a pure write. It should be rare that it does any
          // writing.
          view.docView.enforceCursorAssoc();
        }
        return result;
      }
    }, {
      key: "visibleTop",
      get: function get() {
        return this.scaler.fromDOM(this.pixelViewport.top);
      }
    }, {
      key: "visibleBottom",
      get: function get() {
        return this.scaler.fromDOM(this.pixelViewport.bottom);
      }
    }, {
      key: "getViewport",
      value: function getViewport(bias, scrollTarget) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        var marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));
        var map = this.heightMap,
          oracle = this.heightOracle;
        var visibleTop = this.visibleTop,
          visibleBottom = this.visibleBottom;
        var viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);
        // If scrollTarget is given, make sure the viewport includes that position
        if (scrollTarget) {
          var head = scrollTarget.range.head;
          if (head < viewport.from || head > viewport.to) {
            var viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
            var block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0),
              topPos;
            if (scrollTarget.y == "center") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from) topPos = block.top;else topPos = block.bottom - viewHeight;
            viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);
          }
        }
        return viewport;
      }
    }, {
      key: "mapViewport",
      value: function mapViewport(viewport, changes) {
        var from = changes.mapPos(viewport.from, -1),
          to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
      }
      // Checks if a given viewport covers the visible part of the
      // document and not too much beyond that.
    }, {
      key: "viewportIsAppropriate",
      value: function viewportIsAppropriate(_ref5) {
        var from = _ref5.from,
          to = _ref5.to;
        var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        if (!this.inView) return true;
        var _this$heightMap$lineA = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0),
          top = _this$heightMap$lineA.top;
        var _this$heightMap$lineA2 = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0),
          bottom = _this$heightMap$lineA2.bottom;
        var visibleTop = this.visibleTop,
          visibleBottom = this.visibleBottom;
        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) && top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */;
      }
    }, {
      key: "mapLineGaps",
      value: function mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty) return gaps;
        var mapped = [];
        var _iterator26 = _createForOfIteratorHelper(gaps),
          _step26;
        try {
          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
            var gap = _step26.value;
            if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
          }
        } catch (err) {
          _iterator26.e(err);
        } finally {
          _iterator26.f();
        }
        return mapped;
      }
      // Computes positions in the viewport where the start or end of a
      // line should be hidden, trying to reuse existing line gaps when
      // appropriate to avoid unneccesary redraws.
      // Uses crude character-counting for the positioning and sizing,
      // since actual DOM coordinates aren't always available and
      // predictable. Relies on generous margins (see LG.Margin) to hide
      // the artifacts this might produce from the user.
    }, {
      key: "ensureLineGaps",
      value: function ensureLineGaps(current, mayMeasure) {
        var _this30 = this;
        var wrapping = this.heightOracle.lineWrapping;
        var margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */,
          halfMargin = margin >> 1,
          doubleMargin = margin << 1;
        // The non-wrapping logic won't work at all in predominantly right-to-left text.
        if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];
        var gaps = [];
        var addGap = function addGap(from, to, line, structure) {
          if (to - from < halfMargin) return;
          var sel = _this30.state.selection.main,
            avoid = [sel.from];
          if (!sel.empty) avoid.push(sel.to);
          for (var _i7 = 0, _avoid = avoid; _i7 < _avoid.length; _i7++) {
            var pos = _avoid[_i7];
            if (pos > from && pos < to) {
              addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);
              addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);
              return;
            }
          }
          var gap = find(current, function (gap) {
            return gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some(function (pos) {
              return gap.from < pos && gap.to > pos;
            });
          });
          if (!gap) {
            // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
            if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some(function (r) {
              return r.from <= to && r.to >= to;
            })) {
              var lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
              if (lineStart > from) to = lineStart;
            }
            gap = new LineGap(from, to, _this30.gapSize(line, from, to, structure));
          }
          gaps.push(gap);
        };
        var _iterator27 = _createForOfIteratorHelper(this.viewportLines),
          _step27;
        try {
          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
            var line = _step27.value;
            if (line.length < doubleMargin) continue;
            var structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin) continue;
            var target = this.scrollTarget ? this.scrollTarget.range.head : null;
            var viewFrom = void 0,
              viewTo = void 0;
            if (wrapping) {
              var marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
              var top = void 0,
                bot = void 0;
              if (target != null) {
                var targetFrac = findFraction(structure, target);
                var spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                top = targetFrac - spaceFrac;
                bot = targetFrac + spaceFrac;
              } else {
                top = (this.visibleTop - line.top - marginHeight) / line.height;
                bot = (this.visibleBottom - line.top + marginHeight) / line.height;
              }
              viewFrom = findPosition(structure, top);
              viewTo = findPosition(structure, bot);
            } else {
              var totalWidth = structure.total * this.heightOracle.charWidth;
              var marginWidth = margin * this.heightOracle.charWidth;
              var left = void 0,
                right = void 0;
              if (target != null) {
                var _targetFrac = findFraction(structure, target);
                var _spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
                left = _targetFrac - _spaceFrac;
                right = _targetFrac + _spaceFrac;
              } else {
                left = (this.pixelViewport.left - marginWidth) / totalWidth;
                right = (this.pixelViewport.right + marginWidth) / totalWidth;
              }
              viewFrom = findPosition(structure, left);
              viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to) addGap(viewTo, line.to, line, structure);
          }
        } catch (err) {
          _iterator27.e(err);
        } finally {
          _iterator27.f();
        }
        return gaps;
      }
    }, {
      key: "gapSize",
      value: function gapSize(line, from, to, structure) {
        var fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
          return line.height * fraction;
        } else {
          return structure.total * this.heightOracle.charWidth * fraction;
        }
      }
    }, {
      key: "updateLineGaps",
      value: function updateLineGaps(gaps) {
        var _this31 = this;
        if (!LineGap.same(gaps, this.lineGaps)) {
          this.lineGaps = gaps;
          this.lineGapDeco = Decoration.set(gaps.map(function (gap) {
            return gap.draw(_this31, _this31.heightOracle.lineWrapping);
          }));
        }
      }
    }, {
      key: "computeVisibleRanges",
      value: function computeVisibleRanges() {
        var deco = this.stateDeco;
        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);
        var ranges = [];
        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
          span: function span(from, to) {
            ranges.push({
              from: from,
              to: to
            });
          },
          point: function point() {}
        }, 20);
        var changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some(function (r, i) {
          return r.from != ranges[i].from || r.to != ranges[i].to;
        });
        this.visibleRanges = ranges;
        return changed ? 4 /* UpdateFlag.Viewport */ : 0;
      }
    }, {
      key: "lineBlockAt",
      value: function lineBlockAt(pos) {
        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(function (b) {
          return b.from <= pos && b.to >= pos;
        }) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
      }
    }, {
      key: "lineBlockAtHeight",
      value: function lineBlockAtHeight(height) {
        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
      }
    }, {
      key: "scrollAnchorAt",
      value: function scrollAnchorAt(scrollTop) {
        var block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
      }
    }, {
      key: "elementAtHeight",
      value: function elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
      }
    }, {
      key: "docHeight",
      get: function get() {
        return this.scaler.toDOM(this.heightMap.height);
      }
    }, {
      key: "contentHeight",
      get: function get() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
      }
    }]);
    return ViewState;
  }();
  var Viewport = /*#__PURE__*/_createClass(function Viewport(from, to) {
    _classCallCheck(this, Viewport);
    this.from = from;
    this.to = to;
  });
  function lineStructure(from, to, stateDeco) {
    var ranges = [],
      pos = from,
      total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span: function span() {},
      point: function point(from, to) {
        if (from > pos) {
          ranges.push({
            from: pos,
            to: from
          });
          total += from - pos;
        }
        pos = to;
      }
    }, 20); // We're only interested in collapsed ranges of a significant size
    if (pos < to) {
      ranges.push({
        from: pos,
        to: to
      });
      total += to - pos;
    }
    return {
      total: total,
      ranges: ranges
    };
  }
  function findPosition(_ref6, ratio) {
    var total = _ref6.total,
      ranges = _ref6.ranges;
    if (ratio <= 0) return ranges[0].from;
    if (ratio >= 1) return ranges[ranges.length - 1].to;
    var dist = Math.floor(total * ratio);
    for (var i = 0;; i++) {
      var _ranges$i = ranges[i],
        from = _ranges$i.from,
        to = _ranges$i.to,
        size = to - from;
      if (dist <= size) return from + dist;
      dist -= size;
    }
  }
  function findFraction(structure, pos) {
    var counted = 0;
    var _iterator28 = _createForOfIteratorHelper(structure.ranges),
      _step28;
    try {
      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
        var _step28$value = _step28.value,
          from = _step28$value.from,
          to = _step28$value.to;
        if (pos <= to) {
          counted += pos - from;
          break;
        }
        counted += to - from;
      }
    } catch (err) {
      _iterator28.e(err);
    } finally {
      _iterator28.f();
    }
    return counted / structure.total;
  }
  function find(array, f) {
    var _iterator29 = _createForOfIteratorHelper(array),
      _step29;
    try {
      for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
        var val = _step29.value;
        if (f(val)) return val;
      }
    } catch (err) {
      _iterator29.e(err);
    } finally {
      _iterator29.f();
    }
    return undefined;
  }
  // Don't scale when the document height is within the range of what
  // the DOM can handle.
  var IdScaler = {
    toDOM: function toDOM(n) {
      return n;
    },
    fromDOM: function fromDOM(n) {
      return n;
    },
    scale: 1
  };
  // When the height is too big (> VP.MaxDOMHeight), scale down the
  // regions outside the viewports so that the total height is
  // VP.MaxDOMHeight.
  var BigScaler = /*#__PURE__*/function () {
    function BigScaler(oracle, heightMap, viewports) {
      _classCallCheck(this, BigScaler);
      var vpHeight = 0,
        base = 0,
        domBase = 0;
      this.viewports = viewports.map(function (_ref7) {
        var from = _ref7.from,
          to = _ref7.to;
        var top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
        var bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom - top;
        return {
          from: from,
          to: to,
          top: top,
          bottom: bottom,
          domTop: 0,
          domBottom: 0
        };
      });
      this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
      var _iterator30 = _createForOfIteratorHelper(this.viewports),
        _step30;
      try {
        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
          var obj = _step30.value;
          obj.domTop = domBase + (obj.top - base) * this.scale;
          domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
          base = obj.bottom;
        }
      } catch (err) {
        _iterator30.e(err);
      } finally {
        _iterator30.f();
      }
    }
    _createClass(BigScaler, [{
      key: "toDOM",
      value: function toDOM(n) {
        for (var i = 0, _base = 0, domBase = 0;; i++) {
          var vp = i < this.viewports.length ? this.viewports[i] : null;
          if (!vp || n < vp.top) return domBase + (n - _base) * this.scale;
          if (n <= vp.bottom) return vp.domTop + (n - vp.top);
          _base = vp.bottom;
          domBase = vp.domBottom;
        }
      }
    }, {
      key: "fromDOM",
      value: function fromDOM(n) {
        for (var i = 0, _base2 = 0, domBase = 0;; i++) {
          var vp = i < this.viewports.length ? this.viewports[i] : null;
          if (!vp || n < vp.domTop) return _base2 + (n - domBase) / this.scale;
          if (n <= vp.domBottom) return vp.top + (n - vp.domTop);
          _base2 = vp.bottom;
          domBase = vp.domBottom;
        }
      }
    }]);
    return BigScaler;
  }();
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1) return block;
    var bTop = scaler.toDOM(block.top),
      bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(function (b) {
      return scaleBlock(b, scaler);
    }) : block._content);
  }
  var _theme = /*@__PURE__*/Facet.define({
    combine: function combine(strs) {
      return strs.join(" ");
    }
  });
  var darkTheme = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.indexOf(true) > -1;
    }
  });
  var baseThemeID = /*@__PURE__*/StyleModule.newName(),
    baseLightID = /*@__PURE__*/StyleModule.newName(),
    baseDarkID = /*@__PURE__*/StyleModule.newName();
  var lightDarkIDs = {
    "&light": "." + baseLightID,
    "&dark": "." + baseDarkID
  };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish: function finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, function (m) {
          if (m == "&") return main;
          if (!scopes || !scopes[m]) throw new RangeError("Unsupported selector: ".concat(m));
          return scopes[m];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1$1 = /*@__PURE__*/buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        // Provide a simple default outline to make sure a focused
        // editor is visually distinct. Can't leave the default behavior
        // because that will apply to the content element, which is
        // inside the scrollable container and doesn't include the
        // gutters. We also can't use an 'auto' outline, since those
        // are, for some reason, drawn behind the element content, which
        // will cause things like the active line background to cover
        // the outline (#297).
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": {
      caretColor: "black"
    },
    "&dark .cm-content": {
      caretColor: "white"
    },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    "@keyframes cm-blink2": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": {
      backgroundColor: "#cceeff44"
    },
    "&dark .cm-activeLine": {
      backgroundColor: "#99eeff33"
    },
    "&light .cm-specialChar": {
      color: "red"
    },
    "&dark .cm-specialChar": {
      color: "#f78"
    },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      insetInlineStart: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-highlightSpace:before": {
      content: "attr(data-display)",
      position: "absolute",
      pointerEvents: "none",
      color: "#888"
    },
    ".cm-highlightTab": {
      backgroundImage: "url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')",
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = /*#__PURE__*/function () {
    function DOMReader(points, state) {
      _classCallCheck(this, DOMReader);
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    _createClass(DOMReader, [{
      key: "append",
      value: function append(text) {
        this.text += text;
      }
    }, {
      key: "lineBreak",
      value: function lineBreak() {
        this.text += LineBreakPlaceholder;
      }
    }, {
      key: "readRange",
      value: function readRange(start, end) {
        if (!start) return this;
        var parent = start.parentNode;
        for (var cur = start;;) {
          this.findPointBefore(parent, cur);
          var oldLen = this.text.length;
          this.readNode(cur);
          var next = cur.nextSibling;
          if (next == end) break;
          var view = ContentView.get(cur),
            nextView = ContentView.get(next);
          if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen) this.lineBreak();
          cur = next;
        }
        this.findPointBefore(parent, end);
        return this;
      }
    }, {
      key: "readTextNode",
      value: function readTextNode(node) {
        var text = node.nodeValue;
        var _iterator31 = _createForOfIteratorHelper(this.points),
          _step31;
        try {
          for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
            var _point = _step31.value;
            if (_point.node == node) _point.pos = this.text.length + Math.min(_point.offset, text.length);
          }
        } catch (err) {
          _iterator31.e(err);
        } finally {
          _iterator31.f();
        }
        for (var off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
          var nextBreak = -1,
            breakSize = 1,
            m = void 0;
          if (this.lineSeparator) {
            nextBreak = text.indexOf(this.lineSeparator, off);
            breakSize = this.lineSeparator.length;
          } else if (m = re.exec(text)) {
            nextBreak = m.index;
            breakSize = m[0].length;
          }
          this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
          if (nextBreak < 0) break;
          this.lineBreak();
          if (breakSize > 1) {
            var _iterator32 = _createForOfIteratorHelper(this.points),
              _step32;
            try {
              for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
                var point = _step32.value;
                if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;
              }
            } catch (err) {
              _iterator32.e(err);
            } finally {
              _iterator32.f();
            }
          }
          off = nextBreak + breakSize;
        }
      }
    }, {
      key: "readNode",
      value: function readNode(node) {
        if (node.cmIgnore) return;
        var view = ContentView.get(node);
        var fromView = view && view.overrideDOMText;
        if (fromView != null) {
          this.findPointInside(node, fromView.length);
          for (var i = fromView.iter(); !i.next().done;) {
            if (i.lineBreak) this.lineBreak();else this.append(i.value);
          }
        } else if (node.nodeType == 3) {
          this.readTextNode(node);
        } else if (node.nodeName == "BR") {
          if (node.nextSibling) this.lineBreak();
        } else if (node.nodeType == 1) {
          this.readRange(node.firstChild, null);
        }
      }
    }, {
      key: "findPointBefore",
      value: function findPointBefore(node, next) {
        var _iterator33 = _createForOfIteratorHelper(this.points),
          _step33;
        try {
          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
            var point = _step33.value;
            if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;
          }
        } catch (err) {
          _iterator33.e(err);
        } finally {
          _iterator33.f();
        }
      }
    }, {
      key: "findPointInside",
      value: function findPointInside(node, length) {
        var _iterator34 = _createForOfIteratorHelper(this.points),
          _step34;
        try {
          for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
            var point = _step34.value;
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
          }
        } catch (err) {
          _iterator34.e(err);
        } finally {
          _iterator34.f();
        }
      }
    }]);
    return DOMReader;
  }();
  function isAtEnd(parent, node, offset) {
    for (;;) {
      if (!node || offset < maxOffset(node)) return false;
      if (node == parent) return true;
      offset = domIndex(node) + 1;
      node = node.parentNode;
    }
  }
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = /*#__PURE__*/_createClass(function DOMPoint(node, offset) {
    _classCallCheck(this, DOMPoint);
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  });
  var DOMChange = /*#__PURE__*/_createClass(function DOMChange(view, start, end, typeOver) {
    _classCallCheck(this, DOMChange);
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    var _view$docView = view.docView,
      iHead = _view$docView.impreciseHead,
      iAnchor = _view$docView.impreciseAnchor;
    if (view.state.readOnly && start > -1) {
      // Ignore changes when the editor is read-only
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      var selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      var reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      var domSel = view.observer.selectionRange;
      var head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      var anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      this.newSel = EditorSelection.single(anchor, head);
    }
  });
  function applyDOMChange(view, domChange) {
    var change;
    var newSel = domChange.newSel,
      sel = view.state.selection.main;
    var lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
      var _domChange$bounds = domChange.bounds,
        from = _domChange$bounds.from,
        to = _domChange$bounds.to;
      var preferredPos = sel.from,
        preferredSide = null;
      // Prefer anchoring to end when Backspace is pressed (or, on
      // Android, when something was deleted)
      if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      var diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        // Chrome inserts two newlines when pressing shift-enter at the
        // end of a line. DomChange drops one of those.
        if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel) return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      // Heuristic to notice typing over a selected character
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, sel.to)
      };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      // If the change is inside the selection and covers most of it,
      // assume it is a selection replace (with identical characters at
      // the start/end not included in the diff)
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
      // Detect insert-period-on-double-space Mac and Android behavior,
      // and transform it into a regular space insert.
      if (newSel && change.insert.length == 2) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {
        from: sel.from,
        to: sel.to,
        insert: Text.of([" "])
      };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      // In Chrome, if you insert a space at the start of a wrapped
      // line, it will actually insert a newline and a space, causing a
      // bogus new line to be created in CodeMirror (#968)
      if (newSel) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {
        from: sel.from,
        to: sel.to,
        insert: Text.of([" "])
      };
    }
    if (change) {
      if (browser.ios && view.inputState.flushIOSKey()) return true;
      // Android browsers don't fire reasonable key events for enter,
      // backspace, or delete. So this detects changes that look like
      // they're caused by those keys, and reinterprets them as key
      // events. (Some of these keys are also handled by beforeinput
      // events and the pendingAndroidKey mechanism, but that's not
      // reliable in all situations.)
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46))) return true;
      var text = change.insert.toString();
      if (view.inputState.composing >= 0) view.inputState.composing++;
      var defaultTr;
      var defaultInsert = function defaultInsert() {
        return defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
      };
      if (!view.state.facet(inputHandler$1).some(function (h) {
        return h(view, change.from, change.to, text, defaultInsert);
      })) view.dispatch(defaultInsert());
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      var _scrollIntoView = false,
        userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select") _scrollIntoView = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({
        selection: newSel,
        scrollIntoView: _scrollIntoView,
        userEvent: userEvent
      });
      return true;
    } else {
      return false;
    }
  }
  function applyDefaultInsert(view, change, newSel) {
    var tr,
      startState = view.state,
      sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
      var before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      var after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
    } else {
      var changes = startState.changes(change);
      var mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
      // Try to apply a composition change to all cursors
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        var replaced = view.state.sliceDoc(change.from, change.to);
        var compositionRange,
          composition = newSel && findCompositionNode(view, newSel.main.head);
        if (composition) {
          var dLen = change.insert.length - (change.to - change.from);
          compositionRange = {
            from: composition.from,
            to: composition.to - dLen
          };
        } else {
          compositionRange = view.state.doc.lineAt(sel.head);
        }
        var offset = sel.to - change.to,
          size = sel.to - sel.from;
        tr = startState.changeByRange(function (range) {
          if (range.from == sel.from && range.to == sel.to) return {
            changes: changes,
            range: mainSel || range.map(changes)
          };
          var to = range.to - offset,
            from = to - replaced.length;
          if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
          // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          range.to >= compositionRange.from && range.from <= compositionRange.to) return {
            range: range
          };
          var rangeChanges = startState.changes({
              from: from,
              to: to,
              insert: change.insert
            }),
            selOff = range.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes: changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    var userEvent = "input.type";
    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
      view.inputState.compositionPendingChange = false;
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    return startState.update(tr, {
      userEvent: userEvent,
      scrollIntoView: true
    });
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    var minLen = Math.min(a.length, b.length);
    var from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;
    if (from == minLen && a.length == b.length) return null;
    var toA = a.length,
      toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      var adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      var move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      var _move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= _move;
      toA = from + (toA - toB);
      toB = from;
    }
    return {
      from: from,
      toA: toA,
      toB: toB
    };
  }
  function selectionPoints(view) {
    var result = [];
    if (view.root.activeElement != view.contentDOM) return result;
    var _view$observer$select2 = view.observer.selectionRange,
      anchorNode = _view$observer$select2.anchorNode,
      anchorOffset = _view$observer$select2.anchorOffset,
      focusNode = _view$observer$select2.focusNode,
      focusOffset = _view$observer$select2.focusOffset;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base) {
    if (points.length == 0) return null;
    var anchor = points[0].pos,
      head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base, head + base) : null;
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  // IE11 has very broken mutation observers, so we also listen to
  // DOMCharacterDataModified there
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = /*#__PURE__*/function () {
    function DOMObserver(view) {
      var _this32 = this;
      _classCallCheck(this, DOMObserver);
      this.view = view;
      this.active = false;
      // The known selection. Kept in our own object, as opposed to just
      // directly accessing the selection because:
      //  - Safari doesn't report the right selection in shadow DOM
      //  - Reading from the selection forces a DOM layout
      //  - This way, we can ignore selectionchange events if we have
      //    already seen the 'new' selection
      this.selectionRange = new DOMSelectionState();
      // Set when a selection change is detected, cleared on flush
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.resizeContent = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      // Timeout for scheduling check of the parents that need scroll handlers
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver(function (mutations) {
        var _iterator35 = _createForOfIteratorHelper(mutations),
          _step35;
        try {
          for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
            var mut = _step35.value;
            _this32.queue.push(mut);
          }
          // IE11 will sometimes (on typing over a selection or
          // backspacing out a single character text node) call the
          // observer callback before actually updating the DOM.
          //
          // Unrelatedly, iOS Safari will, when ending a composition,
          // sometimes first clear it, deliver the mutations, and then
          // reinsert the finished text. CodeMirror's handling of the
          // deletion will prevent the reinsertion from happening,
          // breaking composition.
        } catch (err) {
          _iterator35.e(err);
        } finally {
          _iterator35.f();
        }
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(function (m) {
          return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
        })) _this32.flushSoon();else _this32.flush();
      });
      if (useCharData) this.onCharData = function (event) {
        _this32.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        _this32.flushSoon();
      };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(function () {
          var _a;
          if (((_a = _this32.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) _this32.onResize();
        });
        this.resizeScroll.observe(view.scrollDOM);
        this.resizeContent = new ResizeObserver(function () {
          return _this32.view.requestMeasure();
        });
        this.resizeContent.observe(view.contentDOM);
      }
      this.addWindowListeners(this.win = view.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver(function (entries) {
          if (_this32.parentCheck < 0) _this32.parentCheck = setTimeout(_this32.listenForScroll.bind(_this32), 1000);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != _this32.intersecting) {
            _this32.intersecting = !_this32.intersecting;
            if (_this32.intersecting != _this32.view.inView) _this32.onScrollChanged(document.createEvent("Event"));
          }
        }, {
          threshold: [0, .001]
        });
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver(function (entries) {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) _this32.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    _createClass(DOMObserver, [{
      key: "onScrollChanged",
      value: function onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting) this.view.measure();
      }
    }, {
      key: "onScroll",
      value: function onScroll(e) {
        if (this.intersecting) this.flush(false);
        this.onScrollChanged(e);
      }
    }, {
      key: "onResize",
      value: function onResize() {
        var _this33 = this;
        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(function () {
          _this33.resizeTimeout = -1;
          _this33.view.requestMeasure();
        }, 50);
      }
    }, {
      key: "onPrint",
      value: function onPrint() {
        var _this34 = this;
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(function () {
          _this34.view.viewState.printing = false;
          _this34.view.requestMeasure();
        }, 500);
      }
    }, {
      key: "updateGaps",
      value: function updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some(function (g, i) {
          return g != gaps[i];
        }))) {
          this.gapIntersection.disconnect();
          var _iterator36 = _createForOfIteratorHelper(gaps),
            _step36;
          try {
            for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
              var gap = _step36.value;
              this.gapIntersection.observe(gap);
            }
          } catch (err) {
            _iterator36.e(err);
          } finally {
            _iterator36.f();
          }
          this.gaps = gaps;
        }
      }
    }, {
      key: "onSelectionChange",
      value: function onSelectionChange(event) {
        var wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey) return;
        var view = this.view,
          sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;
        var context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
          if (!wasChanged) this.selectionChanged = false;
          return;
        }
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // Chrome Android has a similar issue when backspacing out a
        // selection (#645).
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
        // (Selection.isCollapsed isn't reliable on IE)
        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();else this.flush(false);
      }
    }, {
      key: "readSelectionRange",
      value: function readSelectionRange() {
        var view = this.view;
        // The Selection object is broken in shadow roots in Safari. See
        // https://github.com/codemirror/dev/issues/414
        var range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
        if (!range || this.selectionRange.eq(range)) return false;
        var local = hasSelection(this.dom, range);
        // Detect the situation where the browser has, on focus, moved the
        // selection to the start of the content element. Reset it to the
        // position from the editor state.
        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
          this.view.inputState.lastFocusTime = 0;
          view.docView.updateSelection();
          return false;
        }
        this.selectionRange.setRange(range);
        if (local) this.selectionChanged = true;
        return true;
      }
    }, {
      key: "setSelectionRange",
      value: function setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
      }
    }, {
      key: "clearSelectionRange",
      value: function clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
      }
    }, {
      key: "listenForScroll",
      value: function listenForScroll() {
        this.parentCheck = -1;
        var i = 0,
          changed = null;
        for (var dom = this.dom; dom;) {
          if (dom.nodeType == 1) {
            if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;else if (!changed) changed = this.scrollTargets.slice(0, i);
            if (changed) changed.push(dom);
            dom = dom.assignedSlot || dom.parentNode;
          } else if (dom.nodeType == 11) {
            // Shadow root
            dom = dom.host;
          } else {
            break;
          }
        }
        if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);
        if (changed) {
          var _iterator37 = _createForOfIteratorHelper(this.scrollTargets),
            _step37;
          try {
            for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
              var _dom2 = _step37.value;
              _dom2.removeEventListener("scroll", this.onScroll);
            }
          } catch (err) {
            _iterator37.e(err);
          } finally {
            _iterator37.f();
          }
          var _iterator38 = _createForOfIteratorHelper(this.scrollTargets = changed),
            _step38;
          try {
            for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
              var _dom3 = _step38.value;
              _dom3.addEventListener("scroll", this.onScroll);
            }
          } catch (err) {
            _iterator38.e(err);
          } finally {
            _iterator38.f();
          }
        }
      }
    }, {
      key: "ignore",
      value: function ignore(f) {
        if (!this.active) return f();
        try {
          this.stop();
          return f();
        } finally {
          this.start();
          this.clear();
        }
      }
    }, {
      key: "start",
      value: function start() {
        if (this.active) return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData) this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
      }
    }, {
      key: "stop",
      value: function stop() {
        if (!this.active) return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData) this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      }
      // Throw away any pending changes
    }, {
      key: "clear",
      value: function clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
      }
      // Chrome Android, especially in combination with GBoard, not only
      // doesn't reliably fire regular key events, but also often
      // surrounds the effect of enter or backspace with a bunch of
      // composition events that, when interrupted, cause text duplication
      // or other kinds of corruption. This hack makes the editor back off
      // from handling DOM changes for a moment when such a key is
      // detected (via beforeinput or keydown), and then tries to flush
      // them or, if that has no effect, dispatches the given key.
    }, {
      key: "delayAndroidKey",
      value: function delayAndroidKey(key, keyCode) {
        var _this35 = this;
        var _a;
        if (!this.delayedAndroidKey) {
          var flush = function flush() {
            var key = _this35.delayedAndroidKey;
            if (key) {
              _this35.clearDelayedAndroidKey();
              _this35.view.inputState.lastKeyCode = key.keyCode;
              _this35.view.inputState.lastKeyTime = Date.now();
              var flushed = _this35.flush();
              if (!flushed && key.force) dispatchKey(_this35.dom, key.key, key.keyCode);
            }
          };
          this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        // Since backspace beforeinput is sometimes signalled spuriously,
        // Enter always takes precedence.
        if (!this.delayedAndroidKey || key == "Enter") this.delayedAndroidKey = {
          key: key,
          keyCode: keyCode,
          // Only run the key handler when no changes are detected if
          // this isn't coming right after another change, in which case
          // it is probably part of a weird chain of updates, and should
          // be ignored if it returns the DOM to its previous state.
          force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
        };
      }
    }, {
      key: "clearDelayedAndroidKey",
      value: function clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
      }
    }, {
      key: "flushSoon",
      value: function flushSoon() {
        var _this36 = this;
        if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(function () {
          _this36.delayedFlush = -1;
          _this36.flush();
        });
      }
    }, {
      key: "forceFlush",
      value: function forceFlush() {
        if (this.delayedFlush >= 0) {
          this.view.win.cancelAnimationFrame(this.delayedFlush);
          this.delayedFlush = -1;
        }
        this.flush();
      }
    }, {
      key: "pendingRecords",
      value: function pendingRecords() {
        var _iterator39 = _createForOfIteratorHelper(this.observer.takeRecords()),
          _step39;
        try {
          for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
            var mut = _step39.value;
            this.queue.push(mut);
          }
        } catch (err) {
          _iterator39.e(err);
        } finally {
          _iterator39.f();
        }
        return this.queue;
      }
    }, {
      key: "processRecords",
      value: function processRecords() {
        var records = this.pendingRecords();
        if (records.length) this.queue = [];
        var from = -1,
          to = -1,
          typeOver = false;
        var _iterator40 = _createForOfIteratorHelper(records),
          _step40;
        try {
          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
            var record = _step40.value;
            var range = this.readMutation(record);
            if (!range) continue;
            if (range.typeOver) typeOver = true;
            if (from == -1) {
              from = range.from;
              to = range.to;
            } else {
              from = Math.min(range.from, from);
              to = Math.max(range.to, to);
            }
          }
        } catch (err) {
          _iterator40.e(err);
        } finally {
          _iterator40.f();
        }
        return {
          from: from,
          to: to,
          typeOver: typeOver
        };
      }
    }, {
      key: "readChange",
      value: function readChange() {
        var _this$processRecords = this.processRecords(),
          from = _this$processRecords.from,
          to = _this$processRecords.to,
          typeOver = _this$processRecords.typeOver;
        var newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel) return null;
        if (from > -1) this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        var change = new DOMChange(this.view, from, to, typeOver);
        this.view.docView.domChanged = {
          newSel: change.newSel ? change.newSel.main : null
        };
        return change;
      }
      // Apply pending changes, if any
    }, {
      key: "flush",
      value: function flush() {
        var readSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        // Completely hold off flushing when pending keys are setthe code
        // managing those will make sure processRecords is called and the
        // view is resynchronized after
        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
        if (readSelection) this.readSelectionRange();
        var domChange = this.readChange();
        if (!domChange) return false;
        var startState = this.view.state;
        var handled = applyDOMChange(this.view, domChange);
        // The view wasn't updated
        if (this.view.state == startState) this.view.update([]);
        return handled;
      }
    }, {
      key: "readMutation",
      value: function readMutation(rec) {
        var cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec)) return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes") cView.flags |= 4 /* ViewFlag.AttrsDirty */;
        if (rec.type == "childList") {
          var childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
          var childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
          return {
            from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
            to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
            typeOver: false
          };
        } else if (rec.type == "characterData") {
          return {
            from: cView.posAtStart,
            to: cView.posAtEnd,
            typeOver: rec.target.nodeValue == rec.oldValue
          };
        } else {
          return null;
        }
      }
    }, {
      key: "setWindow",
      value: function setWindow(win) {
        if (win != this.win) {
          this.removeWindowListeners(this.win);
          this.win = win;
          this.addWindowListeners(this.win);
        }
      }
    }, {
      key: "addWindowListeners",
      value: function addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "removeWindowListeners",
      value: function removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _a, _b, _c, _d;
        this.stop();
        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();
        var _iterator41 = _createForOfIteratorHelper(this.scrollTargets),
          _step41;
        try {
          for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
            var dom = _step41.value;
            dom.removeEventListener("scroll", this.onScroll);
          }
        } catch (err) {
          _iterator41.e(err);
        } finally {
          _iterator41.f();
        }
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
      }
    }]);
    return DOMObserver;
  }();
  function findChild(cView, dom, dir) {
    while (dom) {
      var curView = ContentView.get(dom);
      if (curView && curView.parent == cView) return curView;
      var parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  // Used to work around a Safari Selection/shadow DOM bug (#414)
  function safariSelectionRangeHack(view) {
    var found = null;
    // Because Safari (at least in 2018-2021) doesn't provide regular
    // access to the selection inside a shadowroot, we have to perform a
    // ridiculous hack to get at itusing `execCommand` to trigger a
    // `beforeInput` event so that we can read the target range from the
    // event.
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found) return null;
    var anchorNode = found.startContainer,
      anchorOffset = found.startOffset;
    var focusNode = found.endContainer,
      focusOffset = found.endOffset;
    var curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    // Since such a range doesn't distinguish between anchor and head,
    // use a heuristic that flips it around if its end matches the
    // current anchor.
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) {
      var _ref8 = [focusNode, focusOffset, anchorNode, anchorOffset];
      anchorNode = _ref8[0];
      anchorOffset = _ref8[1];
      focusNode = _ref8[2];
      focusOffset = _ref8[3];
    }
    return {
      anchorNode: anchorNode,
      anchorOffset: anchorOffset,
      focusNode: focusNode,
      focusOffset: focusOffset
    };
  }

  // The editor's update state machine looks something like this:
  //
  //     Idle  Updating  Idle (unchecked)  Measuring  Idle
  //                                               
  //                                         Updating (measure)
  //
  // The difference between 'Idle' and 'Idle (unchecked)' lies in
  // whether a layout check has been scheduled. A regular update through
  // the `update` method updates the DOM in a write-only fashion, and
  // relies on a check (scheduled with `requestAnimationFrame`) to make
  // sure everything is where it should be and the viewport covers the
  // visible code. That check continues to measure and then optionally
  // update until it reaches a coherent state.
  /**
  An editor view represents the editor's user interface. It holds
  the editable DOM surface, and possibly other elements such as the
  line number gutter. It handles events and dispatches state
  transactions for editing actions.
  */
  var EditorView = /*#__PURE__*/function () {
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    function EditorView() {
      var _this37 = this;
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, EditorView);
      this.plugins = [];
      this.pluginMap = new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      /**
      @internal
      */
      this.updateState = 2 /* UpdateState.Updating */;
      /**
      @internal
      */
      this.measureScheduled = -1;
      /**
      @internal
      */
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: fixed; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      var dispatch = config.dispatch;
      this.dispatchTransactions = config.dispatchTransactions || dispatch && function (trs) {
        return trs.forEach(function (tr) {
          return dispatch(tr, _this37);
        });
      } || function (trs) {
        return _this37.update(trs);
      };
      this.dispatch = this.dispatch.bind(this);
      this._root = config.root || getRoot(config.parent) || document;
      this.viewState = new ViewState(config.state || EditorState.create(config));
      this.plugins = this.state.facet(viewPlugin).map(function (spec) {
        return new PluginInstance(spec);
      });
      var _iterator42 = _createForOfIteratorHelper(this.plugins),
        _step42;
      try {
        for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
          var _plugin4 = _step42.value;
          _plugin4.update(this);
        }
      } catch (err) {
        _iterator42.e(err);
      } finally {
        _iterator42.f();
      }
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0 /* UpdateState.Idle */;
      this.requestMeasure();
      if (config.parent) config.parent.appendChild(this.dom);
    }
    _createClass(EditorView, [{
      key: "state",
      get:
      /**
      The current editor state.
      */
      function get() {
        return this.viewState.state;
      }
      /**
      To be able to display large documents without consuming too much
      memory or overloading the browser, CodeMirror only draws the
      code that is visible (plus a margin around it) to the DOM. This
      property tells you the extent of the current drawn viewport, in
      document positions.
      */
    }, {
      key: "viewport",
      get: function get() {
        return this.viewState.viewport;
      }
      /**
      When there are, for example, large collapsed ranges in the
      viewport, its size can be a lot bigger than the actual visible
      content. Thus, if you are doing something like styling the
      content in the viewport, it is preferable to only do so for
      these ranges, which are the subset of the viewport that is
      actually drawn.
      */
    }, {
      key: "visibleRanges",
      get: function get() {
        return this.viewState.visibleRanges;
      }
      /**
      Returns false when the editor is entirely scrolled out of view
      or otherwise hidden.
      */
    }, {
      key: "inView",
      get: function get() {
        return this.viewState.inView;
      }
      /**
      Indicates whether the user is currently composing text via
      [IME](https://en.wikipedia.org/wiki/Input_method), and at least
      one change has been made in the current composition.
      */
    }, {
      key: "composing",
      get: function get() {
        return this.inputState.composing > 0;
      }
      /**
      Indicates whether the user is currently in composing state. Note
      that on some platforms, like Android, this will be the case a
      lot, since just putting the cursor on a word starts a
      composition there.
      */
    }, {
      key: "compositionStarted",
      get: function get() {
        return this.inputState.composing >= 0;
      }
      /**
      The document or shadow root that the view lives in.
      */
    }, {
      key: "root",
      get: function get() {
        return this._root;
      }
      /**
      @internal
      */
    }, {
      key: "win",
      get: function get() {
        return this.dom.ownerDocument.defaultView || window;
      }
    }, {
      key: "dispatch",
      value: function dispatch() {
        var _this$state;
        for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {
          input[_key] = arguments[_key];
        }
        var trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [(_this$state = this.state).update.apply(_this$state, input)];
        this.dispatchTransactions(trs, this);
      }
      /**
      Update the view for the given array of transactions. This will
      update the visible document and selection to match the state
      produced by the transactions, and notify view plugins of the
      change. You should usually call
      [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
      as a primitive.
      */
    }, {
      key: "update",
      value: function update(transactions) {
        var _this38 = this;
        if (this.updateState != 0 /* UpdateState.Idle */) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        var redrawn = false,
          attrsChanged = false,
          update;
        var state = this.state;
        var _iterator43 = _createForOfIteratorHelper(transactions),
          _step43;
        try {
          for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
            var _tr = _step43.value;
            if (_tr.startState != state) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state = _tr.state;
          }
        } catch (err) {
          _iterator43.e(err);
        } finally {
          _iterator43.f();
        }
        if (this.destroyed) {
          this.viewState.state = state;
          return;
        }
        var focus = this.hasFocus,
          focusFlag = 0,
          dispatchFocus = null;
        if (transactions.some(function (tr) {
          return tr.annotation(isFocusChange);
        })) {
          this.inputState.notifiedFocused = focus;
          // If a focus-change transaction is being dispatched, set this update flag.
          focusFlag = 1 /* UpdateFlag.Focus */;
        } else if (focus != this.inputState.notifiedFocused) {
          this.inputState.notifiedFocused = focus;
          // Schedule a separate focus transaction if necessary, otherwise
          // add a flag to this update
          dispatchFocus = focusChangeTransaction(state, focus);
          if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */;
        }
        // If there was a pending DOM change, eagerly read it and try to
        // apply it after the given transactions.
        var pendingKey = this.observer.delayedAndroidKey,
          domChange = null;
        if (pendingKey) {
          this.observer.clearDelayedAndroidKey();
          domChange = this.observer.readChange();
          // Only try to apply DOM changes if the transactions didn't
          // change the doc or selection.
          if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;
        } else {
          this.observer.clear();
        }
        // When the phrases change, redraw the editor
        if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases)) return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        update.flags |= focusFlag;
        var scrollTarget = this.viewState.scrollTarget;
        try {
          this.updateState = 2 /* UpdateState.Updating */;
          var _iterator44 = _createForOfIteratorHelper(transactions),
            _step44;
          try {
            for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
              var tr = _step44.value;
              if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);
              if (tr.scrollIntoView) {
                var main = tr.state.selection.main;
                scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
              }
              var _iterator45 = _createForOfIteratorHelper(tr.effects),
                _step45;
              try {
                for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
                  var e = _step45.value;
                  if (e.is(_scrollIntoView2)) scrollTarget = e.value;
                }
              } catch (err) {
                _iterator45.e(err);
              } finally {
                _iterator45.f();
              }
            }
          } catch (err) {
            _iterator44.e(err);
          } finally {
            _iterator44.f();
          }
          this.viewState.update(update, scrollTarget);
          this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
          }
          redrawn = this.docView.update(update);
          if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();
          attrsChanged = this.updateAttrs();
          this.showAnnouncements(transactions);
          this.docView.updateSelection(redrawn, transactions.some(function (tr) {
            return tr.isUserEvent("select.pointer");
          }));
        } finally {
          this.updateState = 0 /* UpdateState.Idle */;
        }

        if (update.startState.facet(_theme) != update.state.facet(_theme)) this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();
        if (!update.empty) {
          var _iterator46 = _createForOfIteratorHelper(this.state.facet(updateListener)),
            _step46;
          try {
            for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
              var listener = _step46.value;
              listener(update);
            }
          } catch (err) {
            _iterator46.e(err);
          } finally {
            _iterator46.f();
          }
        }
        if (dispatchFocus || domChange) Promise.resolve().then(function () {
          if (dispatchFocus && _this38.state == dispatchFocus.startState) _this38.dispatch(dispatchFocus);
          if (domChange) {
            if (!applyDOMChange(_this38, domChange) && pendingKey.force) dispatchKey(_this38.contentDOM, pendingKey.key, pendingKey.keyCode);
          }
        });
      }
      /**
      Reset the view to the given state. (This will cause the entire
      document to be redrawn and all view plugins to be reinitialized,
      so you should probably only use it when the new state isn't
      derived from the old state. Otherwise, use
      [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
      */
    }, {
      key: "setState",
      value: function setState(newState) {
        if (this.updateState != 0 /* UpdateState.Idle */) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
          this.viewState.state = newState;
          return;
        }
        this.updateState = 2 /* UpdateState.Updating */;
        var hadFocus = this.hasFocus;
        try {
          var _iterator47 = _createForOfIteratorHelper(this.plugins),
            _step47;
          try {
            for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
              var _plugin5 = _step47.value;
              _plugin5.destroy(this);
            }
          } catch (err) {
            _iterator47.e(err);
          } finally {
            _iterator47.f();
          }
          this.viewState = new ViewState(newState);
          this.plugins = newState.facet(viewPlugin).map(function (spec) {
            return new PluginInstance(spec);
          });
          this.pluginMap.clear();
          var _iterator48 = _createForOfIteratorHelper(this.plugins),
            _step48;
          try {
            for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
              var _plugin6 = _step48.value;
              _plugin6.update(this);
            }
          } catch (err) {
            _iterator48.e(err);
          } finally {
            _iterator48.f();
          }
          this.docView = new DocView(this);
          this.inputState.ensureHandlers(this.plugins);
          this.mountStyles();
          this.updateAttrs();
          this.bidiCache = [];
        } finally {
          this.updateState = 0 /* UpdateState.Idle */;
        }

        if (hadFocus) this.focus();
        this.requestMeasure();
      }
    }, {
      key: "updatePlugins",
      value: function updatePlugins(update) {
        var prevSpecs = update.startState.facet(viewPlugin),
          specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
          var newPlugins = [];
          var _iterator49 = _createForOfIteratorHelper(specs),
            _step49;
          try {
            for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
              var spec = _step49.value;
              var found = prevSpecs.indexOf(spec);
              if (found < 0) {
                newPlugins.push(new PluginInstance(spec));
              } else {
                var _plugin7 = this.plugins[found];
                _plugin7.mustUpdate = update;
                newPlugins.push(_plugin7);
              }
            }
          } catch (err) {
            _iterator49.e(err);
          } finally {
            _iterator49.f();
          }
          var _iterator50 = _createForOfIteratorHelper(this.plugins),
            _step50;
          try {
            for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
              var _plugin8 = _step50.value;
              if (_plugin8.mustUpdate != update) _plugin8.destroy(this);
            }
          } catch (err) {
            _iterator50.e(err);
          } finally {
            _iterator50.f();
          }
          this.plugins = newPlugins;
          this.pluginMap.clear();
        } else {
          var _iterator51 = _createForOfIteratorHelper(this.plugins),
            _step51;
          try {
            for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
              var _p = _step51.value;
              _p.mustUpdate = update;
            }
          } catch (err) {
            _iterator51.e(err);
          } finally {
            _iterator51.f();
          }
        }
        for (var i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);
        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);
      }
      /**
      @internal
      */
    }, {
      key: "measure",
      value: function measure() {
        var _this39 = this;
        var flush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        if (this.destroyed) return;
        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
          this.measureScheduled = -1;
          this.requestMeasure();
          return;
        }
        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame
        if (flush) this.observer.forceFlush();
        var updated = null;
        var sDOM = this.scrollDOM,
          scrollTop = sDOM.scrollTop * this.scaleY;
        var _this$viewState = this.viewState,
          scrollAnchorPos = _this$viewState.scrollAnchorPos,
          scrollAnchorHeight = _this$viewState.scrollAnchorHeight;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
          for (var i = 0;; i++) {
            if (scrollAnchorHeight < 0) {
              if (isScrolledToBottom(sDOM)) {
                scrollAnchorPos = -1;
                scrollAnchorHeight = this.viewState.heightMap.height;
              } else {
                var block = this.viewState.scrollAnchorAt(scrollTop);
                scrollAnchorPos = block.from;
                scrollAnchorHeight = block.top;
              }
            }
            this.updateState = 1 /* UpdateState.Measuring */;
            var changed = this.viewState.measure(this);
            if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
            if (i > 5) {
              console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
              break;
            }
            var measuring = [];
            // Only run measure requests in this cycle when the viewport didn't change
            if (!(changed & 4 /* UpdateFlag.Viewport */)) {
              var _ref9 = [measuring, this.measureRequests];
              this.measureRequests = _ref9[0];
              measuring = _ref9[1];
            }
            var measured = measuring.map(function (m) {
              try {
                return m.read(_this39);
              } catch (e) {
                logException(_this39.state, e);
                return BadMeasure;
              }
            });
            var update = ViewUpdate.create(this, this.state, []),
              redrawn = false;
            update.flags |= changed;
            if (!updated) updated = update;else updated.flags |= changed;
            this.updateState = 2 /* UpdateState.Updating */;
            if (!update.empty) {
              this.updatePlugins(update);
              this.inputState.update(update);
              this.updateAttrs();
              redrawn = this.docView.update(update);
            }
            for (var _i8 = 0; _i8 < measuring.length; _i8++) if (measured[_i8] != BadMeasure) {
              try {
                var m = measuring[_i8];
                if (m.write) m.write(measured[_i8], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
            if (redrawn) this.docView.updateSelection(true);
            if (!update.viewportChanged && this.measureRequests.length == 0) {
              if (this.viewState.editorHeight) {
                if (this.viewState.scrollTarget) {
                  this.docView.scrollIntoView(this.viewState.scrollTarget);
                  this.viewState.scrollTarget = null;
                  continue;
                } else {
                  var newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                  var diff = newAnchorHeight - scrollAnchorHeight;
                  if (diff > 1 || diff < -1) {
                    scrollTop = scrollTop + diff;
                    sDOM.scrollTop = scrollTop / this.scaleY;
                    scrollAnchorHeight = -1;
                    continue;
                  }
                }
              }
              break;
            }
          }
        } finally {
          this.updateState = 0 /* UpdateState.Idle */;
          this.measureScheduled = -1;
        }
        if (updated && !updated.empty) {
          var _iterator52 = _createForOfIteratorHelper(this.state.facet(updateListener)),
            _step52;
          try {
            for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
              var listener = _step52.value;
              listener(updated);
            }
          } catch (err) {
            _iterator52.e(err);
          } finally {
            _iterator52.f();
          }
        }
      }
      /**
      Get the CSS classes for the currently active editor themes.
      */
    }, {
      key: "themeClasses",
      get: function get() {
        return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(_theme);
      }
    }, {
      key: "updateAttrs",
      value: function updateAttrs() {
        var _this40 = this;
        var editorAttrs = attrsFromFacet(this, editorAttributes, {
          "class": "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        var contentAttrs = {
          spellcheck: "false",
          autocorrect: "off",
          autocapitalize: "off",
          translate: "no",
          contenteditable: !this.state.facet(editable) ? "false" : "true",
          "class": "cm-content",
          style: "".concat(browser.tabSize, ": ").concat(this.state.tabSize),
          role: "textbox",
          "aria-multiline": "true"
        };
        if (this.state.readOnly) contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        var changed = this.observer.ignore(function () {
          var changedContent = _updateAttrs(_this40.contentDOM, _this40.contentAttrs, contentAttrs);
          var changedEditor = _updateAttrs(_this40.dom, _this40.editorAttrs, editorAttrs);
          return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
      }
    }, {
      key: "showAnnouncements",
      value: function showAnnouncements(trs) {
        var first = true;
        var _iterator53 = _createForOfIteratorHelper(trs),
          _step53;
        try {
          for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
            var tr = _step53.value;
            var _iterator54 = _createForOfIteratorHelper(tr.effects),
              _step54;
            try {
              for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
                var effect = _step54.value;
                if (effect.is(EditorView.announce)) {
                  if (first) this.announceDOM.textContent = "";
                  first = false;
                  var div = this.announceDOM.appendChild(document.createElement("div"));
                  div.textContent = effect.value;
                }
              }
            } catch (err) {
              _iterator54.e(err);
            } finally {
              _iterator54.f();
            }
          }
        } catch (err) {
          _iterator53.e(err);
        } finally {
          _iterator53.f();
        }
      }
    }, {
      key: "mountStyles",
      value: function mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        var nonce = this.state.facet(EditorView.cspNonce);
        StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$1).reverse(), nonce ? {
          nonce: nonce
        } : undefined);
      }
    }, {
      key: "readMeasured",
      value: function readMeasured() {
        if (this.updateState == 2 /* UpdateState.Updating */) throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1) this.measure(false);
      }
      /**
      Schedule a layout measurement, optionally providing callbacks to
      do custom DOM measuring followed by a DOM write phase. Using
      this is preferable reading DOM layout directly from, for
      example, an event handler, because it'll make sure measuring and
      drawing done by other components is synchronized, avoiding
      unnecessary DOM layout computations.
      */
    }, {
      key: "requestMeasure",
      value: function requestMeasure(request) {
        var _this41 = this;
        if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(function () {
          return _this41.measure();
        });
        if (request) {
          if (this.measureRequests.indexOf(request) > -1) return;
          if (request.key != null) for (var i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request.key) {
              this.measureRequests[i] = request;
              return;
            }
          }
          this.measureRequests.push(request);
        }
      }
      /**
      Get the value of a specific plugin, if present. Note that
      plugins that crash can be dropped from a view, so even when you
      know you registered a given plugin, it is recommended to check
      the return value of this method.
      */
    }, {
      key: "plugin",
      value: function plugin(_plugin3) {
        var known = this.pluginMap.get(_plugin3);
        if (known === undefined || known && known.spec != _plugin3) this.pluginMap.set(_plugin3, known = this.plugins.find(function (p) {
          return p.spec == _plugin3;
        }) || null);
        return known && known.update(this).value;
      }
      /**
      The top position of the document, in screen coordinates. This
      may be negative when the editor is scrolled down. Points
      directly to the top of the first line, not above the padding.
      */
    }, {
      key: "documentTop",
      get: function get() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
      }
      /**
      Reports the padding above and below the document.
      */
    }, {
      key: "documentPadding",
      get: function get() {
        return {
          top: this.viewState.paddingTop,
          bottom: this.viewState.paddingBottom
        };
      }
      /**
      If the editor is transformed with CSS, this provides the scale
      along the X axis. Otherwise, it will just be 1. Note that
      transforms other than translation and scaling are not supported.
      */
    }, {
      key: "scaleX",
      get: function get() {
        return this.viewState.scaleX;
      }
      /**
      Provide the CSS transformed scale along the Y axis.
      */
    }, {
      key: "scaleY",
      get: function get() {
        return this.viewState.scaleY;
      }
      /**
      Find the text line or block widget at the given vertical
      position (which is interpreted as relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
      */
    }, {
      key: "elementAtHeight",
      value: function elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
      }
      /**
      Find the line block (see
      [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
      height, again interpreted relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
      */
    }, {
      key: "lineBlockAtHeight",
      value: function lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
      }
      /**
      Get the extent and vertical position of all [line
      blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
      are relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
      */
    }, {
      key: "viewportLineBlocks",
      get: function get() {
        return this.viewState.viewportLines;
      }
      /**
      Find the line block around the given document position. A line
      block is a range delimited on both sides by either a
      non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
      start/end of the document. It will usually just hold a line of
      text, but may be broken into multiple textblocks by block
      widgets.
      */
    }, {
      key: "lineBlockAt",
      value: function lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
      }
      /**
      The editor's total content height.
      */
    }, {
      key: "contentHeight",
      get: function get() {
        return this.viewState.contentHeight;
      }
      /**
      Move a cursor position by [grapheme
      cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
      the motion is away from the line start, or towards it. In
      bidirectional text, the line is traversed in visual order, using
      the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
      When the start position was the last one on the line, the
      returned position will be across the line break. If there is no
      further line, the original position is returned.
      
      By default, this method moves over a single cluster. The
      optional `by` argument can be used to move across more. It will
      be called with the first cluster as argument, and should return
      a predicate that determines, for each subsequent cluster,
      whether it should also be moved over.
      */
    }, {
      key: "moveByChar",
      value: function moveByChar(start, forward, by) {
        return skipAtoms(this, start, _moveByChar(this, start, forward, by));
      }
      /**
      Move a cursor position across the next group of either
      [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
      non-whitespace characters.
      */
    }, {
      key: "moveByGroup",
      value: function moveByGroup(start, forward) {
        var _this42 = this;
        return skipAtoms(this, start, _moveByChar(this, start, forward, function (initial) {
          return byGroup(_this42, start.head, initial);
        }));
      }
      /**
      Move to the next line boundary in the given direction. If
      `includeWrap` is true, line wrapping is on, and there is a
      further wrap point on the current line, the wrap point will be
      returned. Otherwise this function will return the start or end
      of the line.
      */
    }, {
      key: "moveToLineBoundary",
      value: function moveToLineBoundary(start, forward) {
        var includeWrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        return _moveToLineBoundary(this, start, forward, includeWrap);
      }
      /**
      Move a cursor position vertically. When `distance` isn't given,
      it defaults to moving to the next line (including wrapped
      lines). Otherwise, `distance` should provide a positive distance
      in pixels.
      
      When `start` has a
      [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
      motion will use that as a target horizontal position. Otherwise,
      the cursor's own horizontal position is used. The returned
      cursor will have its goal column set to whichever column was
      used.
      */
    }, {
      key: "moveVertically",
      value: function moveVertically(start, forward, distance) {
        return skipAtoms(this, start, _moveVertically(this, start, forward, distance));
      }
      /**
      Find the DOM parent node and offset (child offset if `node` is
      an element, character offset when it is a text node) at the
      given document position.
      
      Note that for positions that aren't currently in
      `visibleRanges`, the resulting DOM position isn't necessarily
      meaningful (it may just point before or after a placeholder
      element).
      */
    }, {
      key: "domAtPos",
      value: function domAtPos(pos) {
        return this.docView.domAtPos(pos);
      }
      /**
      Find the document position at the given DOM node. Can be useful
      for associating positions with DOM events. Will raise an error
      when `node` isn't part of the editor content.
      */
    }, {
      key: "posAtDOM",
      value: function posAtDOM(node) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this.docView.posFromDOM(node, offset);
      }
    }, {
      key: "posAtCoords",
      value: function posAtCoords(coords) {
        var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.readMeasured();
        return _posAtCoords(this, coords, precise);
      }
      /**
      Get the screen coordinates at the given document position.
      `side` determines whether the coordinates are based on the
      element before (-1) or after (1) the position (if no element is
      available on the given side, the method will transparently use
      another strategy to get reasonable coordinates).
      */
    }, {
      key: "coordsAtPos",
      value: function coordsAtPos(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        this.readMeasured();
        var rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right) return rect;
        var line = this.state.doc.lineAt(pos),
          order = this.bidiSpans(line);
        var span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, span.dir == Direction.LTR == side > 0);
      }
      /**
      Return the rectangle around a given character. If `pos` does not
      point in front of a character that is in the viewport and
      rendered (i.e. not replaced, not a line break), this will return
      null. For space characters that are a line wrap point, this will
      return the position before the line break.
      */
    }, {
      key: "coordsForChar",
      value: function coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
      }
      /**
      The default width of a character in the editor. May not
      accurately reflect the width of all characters (given variable
      width fonts or styling of invididual ranges).
      */
    }, {
      key: "defaultCharacterWidth",
      get: function get() {
        return this.viewState.heightOracle.charWidth;
      }
      /**
      The default height of a line in the editor. May not be accurate
      for all lines.
      */
    }, {
      key: "defaultLineHeight",
      get: function get() {
        return this.viewState.heightOracle.lineHeight;
      }
      /**
      The text direction
      ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
      CSS property) of the editor's content element.
      */
    }, {
      key: "textDirection",
      get: function get() {
        return this.viewState.defaultTextDirection;
      }
      /**
      Find the text direction of the block at the given position, as
      assigned by CSS. If
      [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
      isn't enabled, or the given position is outside of the viewport,
      this will always return the same as
      [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
      this may trigger a DOM layout.
      */
    }, {
      key: "textDirectionAt",
      value: function textDirectionAt(pos) {
        var perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
      }
      /**
      Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
      (as determined by the
      [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
      CSS property of its content element).
      */
    }, {
      key: "lineWrapping",
      get: function get() {
        return this.viewState.heightOracle.lineWrapping;
      }
      /**
      Returns the bidirectional text structure of the given line
      (which should be in the current document) as an array of span
      objects. The order of these spans matches the [text
      direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
      left-to-right, the leftmost spans come first, otherwise the
      rightmost spans come first.
      */
    }, {
      key: "bidiSpans",
      value: function bidiSpans(line) {
        if (line.length > MaxBidiLine) return trivialOrder(line.length);
        var dir = this.textDirectionAt(line.from),
          isolates;
        var _iterator55 = _createForOfIteratorHelper(this.bidiCache),
          _step55;
        try {
          for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
            var entry = _step55.value;
            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to)))) return entry.order;
          }
        } catch (err) {
          _iterator55.e(err);
        } finally {
          _iterator55.f();
        }
        if (!isolates) isolates = getIsolatedRanges(this, line.from, line.to);
        var order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
      }
      /**
      Check whether the editor has focus.
      */
    }, {
      key: "hasFocus",
      get: function get() {
        var _a;
        // Safari return false for hasFocus when the context menu is open
        // or closing, which leads us to ignore selection changes from the
        // context menu because it looks like the editor isn't focused.
        // This kludges around that.
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
      }
      /**
      Put focus on the editor.
      */
    }, {
      key: "focus",
      value: function focus() {
        var _this43 = this;
        this.observer.ignore(function () {
          focusPreventScroll(_this43.contentDOM);
          _this43.docView.updateSelection();
        });
      }
      /**
      Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
      necessary when moving the editor's existing DOM to a new window or shadow root.
      */
    }, {
      key: "setRoot",
      value: function setRoot(root) {
        if (this._root != root) {
          this._root = root;
          this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
          this.mountStyles();
        }
      }
      /**
      Clean up this editor view, removing its element from the
      document, unregistering event handlers, and notifying
      plugins. The view instance can no longer be used after
      calling this.
      */
    }, {
      key: "destroy",
      value: function destroy() {
        var _iterator56 = _createForOfIteratorHelper(this.plugins),
          _step56;
        try {
          for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
            var _plugin9 = _step56.value;
            _plugin9.destroy(this);
          }
        } catch (err) {
          _iterator56.e(err);
        } finally {
          _iterator56.f();
        }
        this.plugins = [];
        this.inputState.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
      }
      /**
      Returns an effect that can be
      [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
      cause it to scroll the given position or range into view.
      */
    }], [{
      key: "scrollIntoView",
      value: function scrollIntoView(pos) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return _scrollIntoView2.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
      }
      /**
      Returns an extension that can be used to add DOM event handlers.
      The value should be an object mapping event names to handler
      functions. For any given event, such functions are ordered by
      extension precedence, and the first handler to return true will
      be assumed to have handled that event, and no other handlers or
      built-in behavior will be activated for it. These are registered
      on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
      for `scroll` handlers, which will be called any time the
      editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
      its parent nodes is scrolled.
      */
    }, {
      key: "domEventHandlers",
      value: function domEventHandlers(handlers) {
        return ViewPlugin.define(function () {
          return {};
        }, {
          eventHandlers: handlers
        });
      }
      /**
      Create an extension that registers DOM event observers. Contrary
      to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
      observers can't be prevented from running by a higher-precedence
      handler returning true. They also don't prevent other handlers
      and observers from running when they return true, and should not
      call `preventDefault`.
      */
    }, {
      key: "domEventObservers",
      value: function domEventObservers(observers) {
        return ViewPlugin.define(function () {
          return {};
        }, {
          eventObservers: observers
        });
      }
      /**
      Create a theme extension. The first argument can be a
      [`style-mod`](https://github.com/marijnh/style-mod#documentation)
      style spec providing the styles for the theme. These will be
      prefixed with a generated class for the style.
      
      Because the selectors will be prefixed with a scope class, rule
      that directly match the editor's [wrapper
      element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
      addedneed to be explicitly differentiated by adding an `&` to
      the selector for that elementfor example
      `&.cm-focused`.
      
      When `dark` is set to true, the theme will be marked as dark,
      which will cause the `&dark` rules from [base
      themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
      `&light` when a light theme is active).
      */
    }, {
      key: "theme",
      value: function theme(spec, options) {
        var prefix = StyleModule.newName();
        var result = [_theme.of(prefix), styleModule.of(buildTheme(".".concat(prefix), spec))];
        if (options && options.dark) result.push(darkTheme.of(true));
        return result;
      }
      /**
      Create an extension that adds styles to the base theme. Like
      with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
      place of the editor wrapper element when directly targeting
      that. You can also use `&dark` or `&light` instead to only
      target editors with a dark or light theme.
      */
    }, {
      key: "baseTheme",
      value: function baseTheme(spec) {
        return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
      }
      /**
      Retrieve an editor view instance from the view's DOM
      representation.
      */
    }, {
      key: "findFromDOM",
      value: function findFromDOM(dom) {
        var _a;
        var content = dom.querySelector(".cm-content");
        var cView = content && ContentView.get(content) || ContentView.get(dom);
        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
      }
    }]);
    return EditorView;
  }();
  /**
  Facet to add a [style
  module](https://github.com/marijnh/style-mod#documentation) to
  an editor view. The view will ensure that the module is
  mounted in its [document
  root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
  */
  EditorView.styleModule = styleModule;
  /**
  An input handler can override the way changes to the editable
  DOM content are handled. Handlers are passed the document
  positions between which the change was found, and the new
  content. When one returns true, no further input handlers are
  called and the default behavior is prevented.

  The `insert` argument can be used to get the default transaction
  that would be applied for this input. This can be useful when
  dispatching the custom behavior as a separate transaction.
  */
  EditorView.inputHandler = inputHandler$1;
  /**
  This facet can be used to provide functions that create effects
  to be dispatched when the editor's focus state changes.
  */
  EditorView.focusChangeEffect = focusChangeEffect;
  /**
  By default, the editor assumes all its content has the same
  [text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
  value to make it read the text direction of every (rendered)
  line separately.
  */
  EditorView.perLineTextDirection = perLineTextDirection;
  /**
  Allows you to provide a function that should be called when the
  library catches an exception from an extension (mostly from view
  plugins, but may be used by other extensions to route exceptions
  from user-code-provided callbacks). This is mostly useful for
  debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
  */
  EditorView.exceptionSink = exceptionSink;
  /**
  A facet that can be used to register a function to be called
  every time the view updates.
  */
  EditorView.updateListener = updateListener;
  /**
  Facet that controls whether the editor content DOM is editable.
  When its highest-precedence value is `false`, the element will
  not have its `contenteditable` attribute set. (Note that this
  doesn't affect API calls that change the editor content, even
  when those are bound to keys or buttons. See the
  [`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
  */
  EditorView.editable = editable;
  /**
  Allows you to influence the way mouse selection happens. The
  functions in this facet will be called for a `mousedown` event
  on the editor, and can return an object that overrides the way a
  selection is computed from that mouse click or drag.
  */
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  /**
  Facet used to configure whether a given selection drag event
  should move or copy the selection. The given predicate will be
  called with the `mousedown` event, and can return `true` when
  the drag should move the content.
  */
  EditorView.dragMovesSelection = dragMovesSelection$1;
  /**
  Facet used to configure whether a given selecting click adds a
  new range to the existing selection or replaces it entirely. The
  default behavior is to check `event.metaKey` on macOS, and
  `event.ctrlKey` elsewhere.
  */
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  /**
  A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
  are shown in the view. Decorations can be provided in two
  waysdirectly, or via a function that takes an editor view.

  Only decoration sets provided directly are allowed to influence
  the editor's vertical layout structure. The ones provided as
  functions are called _after_ the new viewport has been computed,
  and thus **must not** introduce block widgets or replacing
  decorations that cover line breaks.

  If you want decorated ranges to behave like atomic units for
  cursor motion and deletion purposes, also provide the range set
  containing the decorations to
  [`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
  */
  EditorView.decorations = decorations;
  /**
  Used to provide ranges that should be treated as atoms as far as
  cursor motion is concerned. This causes methods like
  [`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
  [`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
  commands built on top of them) to skip across such regions when
  a selection endpoint would enter them. This does _not_ prevent
  direct programmatic [selection
  updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
  regions.
  */
  EditorView.atomicRanges = atomicRanges;
  /**
  When range decorations add a `unicode-bidi: isolate` style, they
  should also include a
  [`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property
  in their decoration spec, and be exposed through this facet, so
  that the editor can compute the proper text order. (Other values
  for `unicode-bidi`, except of course `normal`, are not
  supported.)
  */
  EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
  /**
  Facet that allows extensions to provide additional scroll
  margins (space around the sides of the scrolling element that
  should be considered invisible). This can be useful when the
  plugin introduces elements that cover part of that element (for
  example a horizontally fixed gutter).
  */
  EditorView.scrollMargins = scrollMargins;
  /**
  This facet records whether a dark theme is active. The extension
  returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
  includes an instance of this when the `dark` option is set to
  true.
  */
  EditorView.darkTheme = darkTheme;
  /**
  Provides a Content Security Policy nonce to use when creating
  the style sheets for the editor. Holds the empty string when no
  nonce has been provided.
  */
  EditorView.cspNonce = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.length ? values[0] : "";
    }
  });
  /**
  Facet that provides additional DOM attributes for the editor's
  editable DOM element.
  */
  EditorView.contentAttributes = contentAttributes;
  /**
  Facet that provides DOM attributes for the editor's outer
  element.
  */
  EditorView.editorAttributes = editorAttributes;
  /**
  An extension that enables line wrapping in the editor (by
  setting CSS `white-space` to `pre-wrap` in the content).
  */
  EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({
    "class": "cm-lineWrapping"
  });
  /**
  State effect used to include screen reader announcements in a
  transaction. These will be added to the DOM in a visually hidden
  element with `aria-live="polite"` set, and should be used to
  describe effects that are visually obvious but may not be
  noticed by screen reader users (such as moving to the next
  search match).
  */
  EditorView.announce = /*@__PURE__*/StateEffect.define();
  // Maximum line length for which we compute accurate bidi info
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = /*#__PURE__*/function () {
    function CachedOrder(from, to, dir, isolates, fresh, order) {
      _classCallCheck(this, CachedOrder);
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.isolates = isolates;
      this.fresh = fresh;
      this.order = order;
    }
    _createClass(CachedOrder, null, [{
      key: "update",
      value: function update(cache, changes) {
        if (changes.empty && !cache.some(function (c) {
          return c.fresh;
        })) return cache;
        var result = [],
          lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for (var i = Math.max(0, cache.length - 10); i < cache.length; i++) {
          var entry = cache[i];
          if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
      }
    }]);
    return CachedOrder;
  }();
  function attrsFromFacet(view, facet, base) {
    for (var sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      var source = sources[i],
        value = typeof source == "function" ? source(view) : source;
      if (value) combineAttrs(value, base);
    }
    return base;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name, platform) {
    var parts = name.split(/-(?!$)/);
    var result = parts[parts.length - 1];
    if (result == "Space") result = " ";
    var alt, ctrl, shift, meta;
    for (var i = 0; i < parts.length - 1; ++i) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
        if (platform == "mac") meta = true;else ctrl = true;
      } else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) result = "Alt-" + result;
    if (ctrl) result = "Ctrl-" + result;
    if (meta) result = "Meta-" + result;
    if (shift) result = "Shift-" + result;
    return result;
  }
  function modifiers(name, event, shift) {
    if (event.altKey) name = "Alt-" + name;
    if (event.ctrlKey) name = "Ctrl-" + name;
    if (event.metaKey) name = "Meta-" + name;
    if (shift !== false && event.shiftKey) name = "Shift-" + name;
    return name;
  }
  var handleKeyEvents = /*@__PURE__*/Prec["default"]( /*@__PURE__*/EditorView.domEventHandlers({
    keydown: function keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  }));
  /**
  Facet used for registering keymaps.

  You can add multiple keymaps to an editor. Their priorities
  determine their precedence (the ones specified early or with high
  priority get checked first). When a handler has returned `true`
  for a given key, no further handlers are called.
  */
  var keymap = /*@__PURE__*/Facet.define({
    enables: handleKeyEvents
  });
  var Keymaps = /*@__PURE__*/new WeakMap();
  // This is hidden behind an indirection, rather than directly computed
  // by the facet, to keep internal types out of the facet's type.
  function getKeymap(state) {
    var bindings = state.facet(keymap);
    var map = Keymaps.get(bindings);
    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce(function (a, b) {
      return a.concat(b);
    }, [])));
    return map;
  }
  var storedPrefix = null;
  var PrefixTimeout = 4000;
  function buildKeymap(bindings) {
    var platform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentPlatform;
    var bound = Object.create(null);
    var isPrefix = Object.create(null);
    var checkPrefix = function checkPrefix(name, is) {
      var current = isPrefix[name];
      if (current == null) isPrefix[name] = is;else if (current != is) throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    var add = function add(scope, key, command, preventDefault, stopPropagation) {
      var _a, _b;
      var scopeObj = bound[scope] || (bound[scope] = Object.create(null));
      var parts = key.split(/ (?!$)/).map(function (k) {
        return normalizeKeyName(k, platform);
      });
      var _loop4 = function _loop4() {
        var prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix]) scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [function (view) {
            var ourObj = storedPrefix = {
              view: view,
              prefix: prefix,
              scope: scope
            };
            setTimeout(function () {
              if (storedPrefix == ourObj) storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
      };
      for (var i = 1; i < parts.length; i++) {
        _loop4();
      }
      var full = parts.join(" ");
      checkPrefix(full, false);
      var binding = scopeObj[full] || (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
      });
      if (command) binding.run.push(command);
      if (preventDefault) binding.preventDefault = true;
      if (stopPropagation) binding.stopPropagation = true;
    };
    var _iterator57 = _createForOfIteratorHelper(bindings),
      _step57;
    try {
      for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
        var b = _step57.value;
        var scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any) {
          var _iterator58 = _createForOfIteratorHelper(scopes),
            _step58;
          try {
            for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
              var scope = _step58.value;
              var scopeObj = bound[scope] || (bound[scope] = Object.create(null));
              if (!scopeObj._any) scopeObj._any = {
                preventDefault: false,
                stopPropagation: false,
                run: []
              };
              for (var key in scopeObj) scopeObj[key].run.push(b.any);
            }
          } catch (err) {
            _iterator58.e(err);
          } finally {
            _iterator58.f();
          }
        }
        var name = b[platform] || b.key;
        if (!name) continue;
        var _iterator59 = _createForOfIteratorHelper(scopes),
          _step59;
        try {
          for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
            var _scope = _step59.value;
            add(_scope, name, b.run, b.preventDefault, b.stopPropagation);
            if (b.shift) add(_scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
          }
        } catch (err) {
          _iterator59.e(err);
        } finally {
          _iterator59.f();
        }
      }
    } catch (err) {
      _iterator57.e(err);
    } finally {
      _iterator57.f();
    }
    return bound;
  }
  function runHandlers(map, event, view, scope) {
    var name = keyName(event);
    var charCode = codePointAt(name, 0),
      isChar = codePointSize(charCode) == name.length && name != " ";
    var prefix = "",
      handled = false,
      prevented = false,
      stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (modifierCodes.indexOf(event.keyCode) < 0) {
        prevented = true;
        storedPrefix = null;
      }
    }
    var ran = new Set();
    var runFor = function runFor(binding) {
      if (binding) {
        var _iterator60 = _createForOfIteratorHelper(binding.run),
          _step60;
        try {
          for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
            var cmd = _step60.value;
            if (!ran.has(cmd)) {
              ran.add(cmd);
              if (cmd(view, event)) {
                if (binding.stopPropagation) stopPropagation = true;
                return true;
              }
            }
          }
        } catch (err) {
          _iterator60.e(err);
        } finally {
          _iterator60.f();
        }
        if (binding.preventDefault) {
          if (binding.stopPropagation) stopPropagation = true;
          prevented = true;
        }
      }
      return false;
    };
    var scopeObj = map[scope],
      baseName,
      shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
        handled = true;
      } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&
      // Ctrl-Alt may be used for AltGr on Windows
      !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
          handled = true;
        } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
          handled = true;
        }
      } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {
        handled = true;
      }
      if (!handled && runFor(scopeObj._any)) handled = true;
    }
    if (prevented) handled = true;
    if (handled && stopPropagation) event.stopPropagation();
    return handled;
  }
  var CanHidePrimary = !browser.ios; // FIXME test IE
  var themeSpec = {
    ".cm-line": {
      "& ::selection": {
        backgroundColor: "transparent !important"
      },
      "&::selection": {
        backgroundColor: "transparent !important"
      }
    }
  };
  if (CanHidePrimary) themeSpec[".cm-line"].caretColor = "transparent !important";
  var Outside = "-10000px";
  var TooltipViewManager = /*#__PURE__*/function () {
    function TooltipViewManager(view, facet, createTooltipView) {
      _classCallCheck(this, TooltipViewManager);
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter(function (t) {
        return t;
      });
      this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    _createClass(TooltipViewManager, [{
      key: "update",
      value: function update(_update14) {
        var _a;
        var input = _update14.state.facet(this.facet);
        var tooltips = input.filter(function (x) {
          return x;
        });
        if (input === this.input) {
          var _iterator70 = _createForOfIteratorHelper(this.tooltipViews),
            _step70;
          try {
            for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {
              var t = _step70.value;
              if (t.update) t.update(_update14);
            }
          } catch (err) {
            _iterator70.e(err);
          } finally {
            _iterator70.f();
          }
          return false;
        }
        var tooltipViews = [];
        for (var i = 0; i < tooltips.length; i++) {
          var tip = tooltips[i],
            known = -1;
          if (!tip) continue;
          for (var _i10 = 0; _i10 < this.tooltips.length; _i10++) {
            var other = this.tooltips[_i10];
            if (other && other.create == tip.create) known = _i10;
          }
          if (known < 0) {
            tooltipViews[i] = this.createTooltipView(tip);
          } else {
            var tooltipView = tooltipViews[i] = this.tooltipViews[known];
            if (tooltipView.update) tooltipView.update(_update14);
          }
        }
        var _iterator71 = _createForOfIteratorHelper(this.tooltipViews),
          _step71;
        try {
          for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {
            var _t2 = _step71.value;
            if (tooltipViews.indexOf(_t2) < 0) {
              _t2.dom.remove();
              (_a = _t2.destroy) === null || _a === void 0 ? void 0 : _a.call(_t2);
            }
          }
        } catch (err) {
          _iterator71.e(err);
        } finally {
          _iterator71.f();
        }
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
      }
    }]);
    return TooltipViewManager;
  }();
  /**
  Creates an extension that configures tooltip behavior.
  */
  function tooltips() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return tooltipConfig.of(config);
  }
  function windowSpace(view) {
    var win = view.win;
    return {
      top: 0,
      left: 0,
      bottom: win.innerHeight,
      right: win.innerWidth
    };
  }
  var tooltipConfig = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      var _a, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a = values.find(function (conf) {
          return conf.position;
        })) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
        parent: ((_b = values.find(function (conf) {
          return conf.parent;
        })) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find(function (conf) {
          return conf.tooltipSpace;
        })) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var knownHeight = /*@__PURE__*/new WeakMap();
  var tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {
    function _class7(view) {
      var _this51 = this;
      _classCallCheck(this, _class7);
      this.view = view;
      this.inView = true;
      this.madeAbsolute = false;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      var config = view.state.facet(tooltipConfig);
      this.position = config.position;
      this.parent = config.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = {
        read: this.readMeasure.bind(this),
        write: this.writeMeasure.bind(this),
        key: this
      };
      this.manager = new TooltipViewManager(view, showTooltip, function (t) {
        return _this51.createTooltip(t);
      });
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(function (entries) {
        if (Date.now() > _this51.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) _this51.measureSoon();
      }, {
        threshold: [1]
      }) : null;
      this.observeIntersection();
      view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    _createClass(_class7, [{
      key: "createContainer",
      value: function createContainer() {
        if (this.parent) {
          this.container = document.createElement("div");
          this.container.style.position = "relative";
          this.container.className = this.view.themeClasses;
          this.parent.appendChild(this.container);
        } else {
          this.container = this.view.dom;
        }
      }
    }, {
      key: "observeIntersection",
      value: function observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          var _iterator72 = _createForOfIteratorHelper(this.manager.tooltipViews),
            _step72;
          try {
            for (_iterator72.s(); !(_step72 = _iterator72.n()).done;) {
              var tooltip = _step72.value;
              this.intersectionObserver.observe(tooltip.dom);
            }
          } catch (err) {
            _iterator72.e(err);
          } finally {
            _iterator72.f();
          }
        }
      }
    }, {
      key: "measureSoon",
      value: function measureSoon() {
        var _this52 = this;
        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(function () {
          _this52.measureTimeout = -1;
          _this52.maybeMeasure();
        }, 50);
      }
    }, {
      key: "update",
      value: function update(_update15) {
        if (_update15.transactions.length) this.lastTransaction = Date.now();
        var updated = this.manager.update(_update15);
        if (updated) this.observeIntersection();
        var shouldMeasure = updated || _update15.geometryChanged;
        var newConfig = _update15.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
          this.position = newConfig.position;
          var _iterator73 = _createForOfIteratorHelper(this.manager.tooltipViews),
            _step73;
          try {
            for (_iterator73.s(); !(_step73 = _iterator73.n()).done;) {
              var t = _step73.value;
              t.dom.style.position = this.position;
            }
          } catch (err) {
            _iterator73.e(err);
          } finally {
            _iterator73.f();
          }
          shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
          if (this.parent) this.container.remove();
          this.parent = newConfig.parent;
          this.createContainer();
          var _iterator74 = _createForOfIteratorHelper(this.manager.tooltipViews),
            _step74;
          try {
            for (_iterator74.s(); !(_step74 = _iterator74.n()).done;) {
              var _t3 = _step74.value;
              this.container.appendChild(_t3.dom);
            }
          } catch (err) {
            _iterator74.e(err);
          } finally {
            _iterator74.f();
          }
          shouldMeasure = true;
        } else if (this.parent && this.view.themeClasses != this.classes) {
          this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure) this.maybeMeasure();
      }
    }, {
      key: "createTooltip",
      value: function createTooltip(tooltip) {
        var tooltipView = tooltip.create(this.view);
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
          var arrow = document.createElement("div");
          arrow.className = "cm-tooltip-arrow";
          tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        this.container.appendChild(tooltipView.dom);
        if (tooltipView.mount) tooltipView.mount(this.view);
        return tooltipView;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _a, _b;
        this.view.win.removeEventListener("resize", this.measureSoon);
        var _iterator75 = _createForOfIteratorHelper(this.manager.tooltipViews),
          _step75;
        try {
          for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {
            var tooltipView = _step75.value;
            tooltipView.dom.remove();
            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
          }
        } catch (err) {
          _iterator75.e(err);
        } finally {
          _iterator75.f();
        }
        if (this.parent) this.container.remove();
        (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        clearTimeout(this.measureTimeout);
      }
    }, {
      key: "readMeasure",
      value: function readMeasure() {
        var _this53 = this;
        var editor = this.view.dom.getBoundingClientRect();
        var scaleX = 1,
          scaleY = 1,
          makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
          // When the dialog's offset parent isn't the body (Firefox) or
          // null (Webkit), we are probably in a transformed container,
          // and should use absolute positioning instead, since fixed
          // positioning inside a transform works in a very broken way.
          var offsetParent = this.manager.tooltipViews[0].dom.offsetParent;
          makeAbsolute = !!(offsetParent && offsetParent != this.container.ownerDocument.body);
        }
        if (makeAbsolute || this.position == "absolute") {
          if (this.parent) {
            var rect = this.parent.getBoundingClientRect();
            if (rect.width && rect.height) {
              scaleX = rect.width / this.parent.offsetWidth;
              scaleY = rect.height / this.parent.offsetHeight;
            }
          } else {
            var _this$view$viewState = this.view.viewState;
            scaleX = _this$view$viewState.scaleX;
            scaleY = _this$view$viewState.scaleY;
          }
        }
        return {
          editor: editor,
          parent: this.parent ? this.container.getBoundingClientRect() : editor,
          pos: this.manager.tooltips.map(function (t, i) {
            var tv = _this53.manager.tooltipViews[i];
            return tv.getCoords ? tv.getCoords(t.pos) : _this53.view.coordsAtPos(t.pos);
          }),
          size: this.manager.tooltipViews.map(function (_ref11) {
            var dom = _ref11.dom;
            return dom.getBoundingClientRect();
          }),
          space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
          scaleX: scaleX,
          scaleY: scaleY,
          makeAbsolute: makeAbsolute
        };
      }
    }, {
      key: "writeMeasure",
      value: function writeMeasure(measured) {
        var _a;
        if (measured.makeAbsolute) {
          this.madeAbsolute = true;
          this.position = "absolute";
          var _iterator76 = _createForOfIteratorHelper(this.manager.tooltipViews),
            _step76;
          try {
            for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {
              var t = _step76.value;
              t.dom.style.position = "absolute";
            }
          } catch (err) {
            _iterator76.e(err);
          } finally {
            _iterator76.f();
          }
        }
        var editor = measured.editor,
          space = measured.space,
          scaleX = measured.scaleX,
          scaleY = measured.scaleY;
        var others = [];
        for (var i = 0; i < this.manager.tooltips.length; i++) {
          var tooltip = this.manager.tooltips[i],
            tView = this.manager.tooltipViews[i],
            dom = tView.dom;
          var pos = measured.pos[i],
            size = measured.size[i];
          // Hide tooltips that are outside of the editor.
          if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - .1 || pos.left > Math.min(editor.right, space.right) + .1) {
            dom.style.top = Outside;
            continue;
          }
          var arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
          var arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;
          var width = size.right - size.left,
            height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
          var offset = tView.offset || noOffset,
            ltr = this.view.textDirection == Direction.LTR;
          var left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);
          var above = !!tooltip.above;
          if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = !above;
          var spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
          if (spaceVert < height && tView.resize !== false) {
            if (spaceVert < this.view.defaultLineHeight) {
              dom.style.top = Outside;
              continue;
            }
            knownHeight.set(tView, height);
            dom.style.height = (height = spaceVert) / scaleY + "px";
          } else if (dom.style.height) {
            dom.style.height = "";
          }
          var top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
          var right = left + width;
          if (tView.overlap !== true) {
            var _iterator77 = _createForOfIteratorHelper(others),
              _step77;
            try {
              for (_iterator77.s(); !(_step77 = _iterator77.n()).done;) {
                var _r4 = _step77.value;
                if (_r4.left < right && _r4.right > left && _r4.top < top + height && _r4.bottom > top) top = above ? _r4.top - height - 2 - arrowHeight : _r4.bottom + arrowHeight + 2;
              }
            } catch (err) {
              _iterator77.e(err);
            } finally {
              _iterator77.f();
            }
          }
          if (this.position == "absolute") {
            dom.style.top = (top - measured.parent.top) / scaleY + "px";
            dom.style.left = (left - measured.parent.left) / scaleX + "px";
          } else {
            dom.style.top = top / scaleY + "px";
            dom.style.left = left / scaleX + "px";
          }
          if (arrow) {
            var arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);
            arrow.style.left = arrowLeft / scaleX + "px";
          }
          if (tView.overlap !== true) others.push({
            left: left,
            top: top,
            right: right,
            bottom: top + height
          });
          dom.classList.toggle("cm-tooltip-above", above);
          dom.classList.toggle("cm-tooltip-below", !above);
          if (tView.positioned) tView.positioned(measured.space);
        }
      }
    }, {
      key: "maybeMeasure",
      value: function maybeMeasure() {
        if (this.manager.tooltips.length) {
          if (this.view.inView) this.view.requestMeasure(this.measureReq);
          if (this.inView != this.view.inView) {
            this.inView = this.view.inView;
            if (!this.inView) {
              var _iterator78 = _createForOfIteratorHelper(this.manager.tooltipViews),
                _step78;
              try {
                for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {
                  var tv = _step78.value;
                  tv.dom.style.top = Outside;
                }
              } catch (err) {
                _iterator78.e(err);
              } finally {
                _iterator78.f();
              }
            }
          }
        }
      }
    }]);
    return _class7;
  }(), {
    eventObservers: {
      scroll: function scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme$4 = /*@__PURE__*/EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: "".concat(7 /* Arrow.Size */, "px"),
      width: "".concat(7 /* Arrow.Size */ * 2, "px"),
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: "".concat(7 /* Arrow.Size */, "px solid transparent"),
        borderRight: "".concat(7 /* Arrow.Size */, "px solid transparent")
      },
      ".cm-tooltip-above &": {
        bottom: "-".concat(7 /* Arrow.Size */, "px"),
        "&:before": {
          borderTop: "".concat(7 /* Arrow.Size */, "px solid #bbb")
        },
        "&:after": {
          borderTop: "".concat(7 /* Arrow.Size */, "px solid #f5f5f5"),
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: "-".concat(7 /* Arrow.Size */, "px"),
        "&:before": {
          borderBottom: "".concat(7 /* Arrow.Size */, "px solid #bbb")
        },
        "&:after": {
          borderBottom: "".concat(7 /* Arrow.Size */, "px solid #f5f5f5"),
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = {
    x: 0,
    y: 0
  };
  /**
  Facet to which an extension can add a value to show a tooltip.
  */
  var showTooltip = /*@__PURE__*/Facet.define({
    enables: [tooltipPlugin, baseTheme$4]
  });
  var showHoverTooltip = /*@__PURE__*/Facet.define();
  var HoverTooltipHost = /*#__PURE__*/function () {
    function HoverTooltipHost(view) {
      var _this54 = this;
      _classCallCheck(this, HoverTooltipHost);
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, function (t) {
        return _this54.createHostedView(t);
      });
    }
    _createClass(HoverTooltipHost, [{
      key: "createHostedView",
      value: function createHostedView(tooltip) {
        var hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.appendChild(hostedView.dom);
        if (this.mounted && hostedView.mount) hostedView.mount(this.view);
        return hostedView;
      }
    }, {
      key: "mount",
      value: function mount(view) {
        var _iterator79 = _createForOfIteratorHelper(this.manager.tooltipViews),
          _step79;
        try {
          for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {
            var hostedView = _step79.value;
            if (hostedView.mount) hostedView.mount(view);
          }
        } catch (err) {
          _iterator79.e(err);
        } finally {
          _iterator79.f();
        }
        this.mounted = true;
      }
    }, {
      key: "positioned",
      value: function positioned(space) {
        var _iterator80 = _createForOfIteratorHelper(this.manager.tooltipViews),
          _step80;
        try {
          for (_iterator80.s(); !(_step80 = _iterator80.n()).done;) {
            var hostedView = _step80.value;
            if (hostedView.positioned) hostedView.positioned(space);
          }
        } catch (err) {
          _iterator80.e(err);
        } finally {
          _iterator80.f();
        }
      }
    }, {
      key: "update",
      value: function update(_update16) {
        this.manager.update(_update16);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _a;
        var _iterator81 = _createForOfIteratorHelper(this.manager.tooltipViews),
          _step81;
        try {
          for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {
            var t = _step81.value;
            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
          }
        } catch (err) {
          _iterator81.e(err);
        } finally {
          _iterator81.f();
        }
      }
    }], [{
      key: "create",
      value:
      // Needs to be static so that host tooltip instances always match
      function create(view) {
        return new HoverTooltipHost(view);
      }
    }]);
    return HoverTooltipHost;
  }();
  var showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], function (state) {
    var tooltips = state.facet(showHoverTooltip).filter(function (t) {
      return t;
    });
    if (tooltips.length === 0) return null;
    return {
      pos: Math.min.apply(Math, _toConsumableArray(tooltips.map(function (t) {
        return t.pos;
      }))),
      end: Math.max.apply(Math, _toConsumableArray(tooltips.filter(function (t) {
        return t.end != null;
      }).map(function (t) {
        return t.end;
      }))),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some(function (t) {
        return t.arrow;
      })
    };
  });
  var HoverPlugin = /*#__PURE__*/function () {
    function HoverPlugin(view, source, field, setHover, hoverTime) {
      _classCallCheck(this, HoverPlugin);
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = {
        x: 0,
        y: 0,
        target: view.dom,
        time: 0
      };
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    _createClass(HoverPlugin, [{
      key: "update",
      value: function update() {
        var _this55 = this;
        if (this.pending) {
          this.pending = null;
          clearTimeout(this.restartTimeout);
          this.restartTimeout = setTimeout(function () {
            return _this55.startHover();
          }, 20);
        }
      }
    }, {
      key: "active",
      get: function get() {
        return this.view.state.field(this.field);
      }
    }, {
      key: "checkHover",
      value: function checkHover() {
        this.hoverTimeout = -1;
        if (this.active) return;
        var hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);else this.startHover();
      }
    }, {
      key: "startHover",
      value: function startHover() {
        var _this56 = this;
        clearTimeout(this.restartTimeout);
        var view = this.view,
          lastMove = this.lastMove;
        var desc = view.docView.nearest(lastMove.target);
        if (!desc) return;
        var pos,
          side = 1;
        if (desc instanceof WidgetView) {
          pos = desc.posAtStart;
        } else {
          pos = view.posAtCoords(lastMove);
          if (pos == null) return;
          var posCoords = view.coordsAtPos(pos);
          if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;
          var bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(function (s) {
            return s.from <= pos && s.to >= pos;
          });
          var rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
          side = lastMove.x < posCoords.left ? -rtl : rtl;
        }
        var open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
          var pending = this.pending = {
            pos: pos
          };
          open.then(function (result) {
            if (_this56.pending == pending) {
              _this56.pending = null;
              if (result) view.dispatch({
                effects: _this56.setHover.of(result)
              });
            }
          }, function (e) {
            return logException(view.state, e, "hover tooltip");
          });
        } else if (open) {
          view.dispatch({
            effects: this.setHover.of(open)
          });
        }
      }
    }, {
      key: "mousemove",
      value: function mousemove(event) {
        var _a;
        this.lastMove = {
          x: event.clientX,
          y: event.clientY,
          target: event.target,
          time: Date.now()
        };
        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        var tooltip = this.active;
        if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
          var _ref12 = tooltip || this.pending,
            pos = _ref12.pos,
            end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
          if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
            this.view.dispatch({
              effects: this.setHover.of(null)
            });
            this.pending = null;
          }
        }
      }
    }, {
      key: "mouseleave",
      value: function mouseleave(e) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        if (this.active && !isInTooltip(e.relatedTarget)) this.view.dispatch({
          effects: this.setHover.of(null)
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
      }
    }]);
    return HoverPlugin;
  }();
  function isInTooltip(elt) {
    for (var cur = elt; cur; cur = cur.parentNode) if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip")) return true;
    return false;
  }
  function isOverRange(view, from, to, x, y, margin) {
    var rect = view.scrollDOM.getBoundingClientRect();
    var docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;
    var pos = view.posAtCoords({
      x: x,
      y: y
    }, false);
    return pos >= from && pos <= to;
  }
  /**
  Set up a hover tooltip, which shows up when the pointer hovers
  over ranges of text. The callback is called when the mouse hovers
  over the document text. It should, if there is a tooltip
  associated with position `pos`, return the tooltip description
  (either directly or in a promise). The `side` argument indicates
  on which side of the position the pointer isit will be -1 if the
  pointer is before the position, 1 if after the position.

  Note that all hover tooltips are hosted within a single tooltip
  container element. This allows multiple tooltips over the same
  range to be "merged" together without overlapping.
  */
  function hoverTooltip(source) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var setHover = StateEffect.define();
    var hoverState = StateField.define({
      create: function create() {
        return null;
      },
      update: function update(value, tr) {
        if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value))) return null;
        if (value && tr.docChanged) {
          var newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
          if (newPos == null) return null;
          var copy = Object.assign(Object.create(null), value);
          copy.pos = newPos;
          if (value.end != null) copy.end = tr.changes.mapPos(value.end);
          value = copy;
        }
        var _iterator82 = _createForOfIteratorHelper(tr.effects),
          _step82;
        try {
          for (_iterator82.s(); !(_step82 = _iterator82.n()).done;) {
            var effect = _step82.value;
            if (effect.is(setHover)) value = effect.value;
            if (effect.is(closeHoverTooltipEffect)) value = null;
          }
        } catch (err) {
          _iterator82.e(err);
        } finally {
          _iterator82.f();
        }
        return value;
      },
      provide: function provide(f) {
        return showHoverTooltip.from(f);
      }
    });
    return [hoverState, ViewPlugin.define(function (view) {
      return new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */);
    }), showHoverTooltipHost];
  }
  /**
  Get the active tooltip view for a given tooltip, if available.
  */
  function getTooltip(view, tooltip) {
    var plugin = view.plugin(tooltipPlugin);
    if (!plugin) return null;
    var found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /*@__PURE__*/StateEffect.define();
  var panelConfig = /*@__PURE__*/Facet.define({
    combine: function combine(configs) {
      var topContainer, bottomContainer;
      var _iterator83 = _createForOfIteratorHelper(configs),
        _step83;
      try {
        for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {
          var c = _step83.value;
          topContainer = topContainer || c.topContainer;
          bottomContainer = bottomContainer || c.bottomContainer;
        }
      } catch (err) {
        _iterator83.e(err);
      } finally {
        _iterator83.f();
      }
      return {
        topContainer: topContainer,
        bottomContainer: bottomContainer
      };
    }
  });
  var panelPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {
    function _class8(view) {
      _classCallCheck(this, _class8);
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter(function (s) {
        return s;
      });
      this.panels = this.specs.map(function (spec) {
        return spec(view);
      });
      var conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter(function (p) {
        return p.top;
      }));
      this.bottom.sync(this.panels.filter(function (p) {
        return !p.top;
      }));
      var _iterator84 = _createForOfIteratorHelper(this.panels),
        _step84;
      try {
        for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {
          var _p2 = _step84.value;
          _p2.dom.classList.add("cm-panel");
          if (_p2.mount) _p2.mount();
        }
      } catch (err) {
        _iterator84.e(err);
      } finally {
        _iterator84.f();
      }
    }
    _createClass(_class8, [{
      key: "update",
      value: function update(_update17) {
        var conf = _update17.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
          this.top.sync([]);
          this.top = new PanelGroup(_update17.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
          this.bottom.sync([]);
          this.bottom = new PanelGroup(_update17.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        var input = _update17.state.facet(showPanel);
        if (input != this.input) {
          var specs = input.filter(function (x) {
            return x;
          });
          var _panels = [],
            top = [],
            bottom = [],
            mount = [];
          var _iterator85 = _createForOfIteratorHelper(specs),
            _step85;
          try {
            for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {
              var spec = _step85.value;
              var known = this.specs.indexOf(spec),
                panel = void 0;
              if (known < 0) {
                panel = spec(_update17.view);
                mount.push(panel);
              } else {
                panel = this.panels[known];
                if (panel.update) panel.update(_update17);
              }
              _panels.push(panel);
              (panel.top ? top : bottom).push(panel);
            }
          } catch (err) {
            _iterator85.e(err);
          } finally {
            _iterator85.f();
          }
          this.specs = specs;
          this.panels = _panels;
          this.top.sync(top);
          this.bottom.sync(bottom);
          for (var _i11 = 0, _mount = mount; _i11 < _mount.length; _i11++) {
            var _p3 = _mount[_i11];
            _p3.dom.classList.add("cm-panel");
            if (_p3.mount) _p3.mount();
          }
        } else {
          var _iterator86 = _createForOfIteratorHelper(this.panels),
            _step86;
          try {
            for (_iterator86.s(); !(_step86 = _iterator86.n()).done;) {
              var _p4 = _step86.value;
              if (_p4.update) _p4.update(_update17);
            }
          } catch (err) {
            _iterator86.e(err);
          } finally {
            _iterator86.f();
          }
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
      }
    }]);
    return _class8;
  }(), {
    provide: function provide(plugin) {
      return EditorView.scrollMargins.of(function (view) {
        var value = view.plugin(plugin);
        return value && {
          top: value.top.scrollMargin(),
          bottom: value.bottom.scrollMargin()
        };
      });
    }
  });
  var PanelGroup = /*#__PURE__*/function () {
    function PanelGroup(view, top, container) {
      _classCallCheck(this, PanelGroup);
      this.view = view;
      this.top = top;
      this.container = container;
      this.dom = undefined;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    _createClass(PanelGroup, [{
      key: "sync",
      value: function sync(panels) {
        var _iterator87 = _createForOfIteratorHelper(this.panels),
          _step87;
        try {
          for (_iterator87.s(); !(_step87 = _iterator87.n()).done;) {
            var _p5 = _step87.value;
            if (_p5.destroy && panels.indexOf(_p5) < 0) _p5.destroy();
          }
        } catch (err) {
          _iterator87.e(err);
        } finally {
          _iterator87.f();
        }
        this.panels = panels;
        this.syncDOM();
      }
    }, {
      key: "syncDOM",
      value: function syncDOM() {
        if (this.panels.length == 0) {
          if (this.dom) {
            this.dom.remove();
            this.dom = undefined;
          }
          return;
        }
        if (!this.dom) {
          this.dom = document.createElement("div");
          this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
          this.dom.style[this.top ? "top" : "bottom"] = "0";
          var parent = this.container || this.view.dom;
          parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        var curDOM = this.dom.firstChild;
        var _iterator88 = _createForOfIteratorHelper(this.panels),
          _step88;
        try {
          for (_iterator88.s(); !(_step88 = _iterator88.n()).done;) {
            var panel = _step88.value;
            if (panel.dom.parentNode == this.dom) {
              while (curDOM != panel.dom) curDOM = rm(curDOM);
              curDOM = curDOM.nextSibling;
            } else {
              this.dom.insertBefore(panel.dom, curDOM);
            }
          }
        } catch (err) {
          _iterator88.e(err);
        } finally {
          _iterator88.f();
        }
        while (curDOM) curDOM = rm(curDOM);
      }
    }, {
      key: "scrollMargin",
      value: function scrollMargin() {
        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
      }
    }, {
      key: "syncClasses",
      value: function syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses) return;
        var _iterator89 = _createForOfIteratorHelper(this.classes.split(" ")),
          _step89;
        try {
          for (_iterator89.s(); !(_step89 = _iterator89.n()).done;) {
            var cls = _step89.value;
            if (cls) this.container.classList.remove(cls);
          }
        } catch (err) {
          _iterator89.e(err);
        } finally {
          _iterator89.f();
        }
        var _iterator90 = _createForOfIteratorHelper((this.classes = this.view.themeClasses).split(" ")),
          _step90;
        try {
          for (_iterator90.s(); !(_step90 = _iterator90.n()).done;) {
            var _cls = _step90.value;
            if (_cls) this.container.classList.add(_cls);
          }
        } catch (err) {
          _iterator90.e(err);
        } finally {
          _iterator90.f();
        }
      }
    }]);
    return PanelGroup;
  }();
  function rm(node) {
    var next = node.nextSibling;
    node.remove();
    return next;
  }
  /**
  Opening a panel is done by providing a constructor function for
  the panel through this facet. (The panel is closed again when its
  constructor is no longer provided.) Values of `null` are ignored.
  */
  var showPanel = /*@__PURE__*/Facet.define({
    enables: panelPlugin
  });
  MapMode.TrackBefore;

  // FIXME profile adding a per-Tree TreeNode cache, validating it by
  // parent pointer
  /// The default maximum length of a `TreeBuffer` node.
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range = /*#__PURE__*/_createClass(function Range(from, to) {
    _classCallCheck(this, Range);
    this.from = from;
    this.to = to;
  }); /// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
  /// can have metadata associated with it in props. Instances of this
  /// class represent prop names.
  var NodeProp = /*#__PURE__*/function () {
    /// Create a new node prop type.
    function NodeProp() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, NodeProp);
      this.id = nextPropID++;
      this.perNode = !!config.perNode;
      this.deserialize = config.deserialize || function () {
        throw new Error("This node type doesn't define a deserialize function");
      };
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    _createClass(NodeProp, [{
      key: "add",
      value: function add(match) {
        var _this = this;
        if (this.perNode) throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function") match = NodeType.match(match);
        return function (type) {
          var result = match(type);
          return result === undefined ? null : [_this, result];
        };
      }
    }]);
    return NodeProp;
  }(); /// Prop that is used to describe matching delimiters. For opening
  /// delimiters, this holds an array of node names (written as a
  /// space-separated string when declaring this prop in a grammar)
  /// for the node types of closing delimiters that match it.
  NodeProp.closedBy = new NodeProp({
    deserialize: function deserialize(str) {
      return str.split(" ");
    }
  });
  /// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
  /// attached to closing delimiters, holding an array of node names
  /// of types of matching opening delimiters.
  NodeProp.openedBy = new NodeProp({
    deserialize: function deserialize(str) {
      return str.split(" ");
    }
  });
  /// Used to assign node types to groups (for example, all node
  /// types that represent an expression could be tagged with an
  /// `"Expression"` group).
  NodeProp.group = new NodeProp({
    deserialize: function deserialize(str) {
      return str.split(" ");
    }
  });
  /// The hash of the [context](#lr.ContextTracker.constructor)
  /// that the node was parsed in, if any. Used to limit reuse of
  /// contextual nodes.
  NodeProp.contextHash = new NodeProp({
    perNode: true
  });
  /// The distance beyond the end of the node that the tokenizer
  /// looked ahead for any of the tokens inside the node. (The LR
  /// parser only stores this when it is larger than 25, for
  /// efficiency reasons.)
  NodeProp.lookAhead = new NodeProp({
    perNode: true
  });
  /// This per-node prop is used to replace a given node, or part of a
  /// node, with another tree. This is useful to include trees from
  /// different languages in mixed-language parsers.
  NodeProp.mounted = new NodeProp({
    perNode: true
  });
  var noProps = Object.create(null);
  /// Each node in a syntax tree has a node type associated with it.
  var NodeType = /*#__PURE__*/function () {
    /// @internal
    function NodeType(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name,
    /// @internal
    props,
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id) {
      var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      _classCallCheck(this, NodeType);
      this.name = name;
      this.props = props;
      this.id = id;
      this.flags = flags;
    }
    /// Define a node type.
    _createClass(NodeType, [{
      key: "prop",
      value:
      /// Retrieves a node prop for this type. Will return `undefined` if
      /// the prop isn't present on this node.
      function prop(_prop) {
        return this.props[_prop.id];
      }
      /// True when this is the top node of a grammar.
    }, {
      key: "isTop",
      get: function get() {
        return (this.flags & 1 /* NodeFlag.Top */) > 0;
      }
      /// True when this node is produced by a skip rule.
    }, {
      key: "isSkipped",
      get: function get() {
        return (this.flags & 2 /* NodeFlag.Skipped */) > 0;
      }
      /// Indicates whether this is an error node.
    }, {
      key: "isError",
      get: function get() {
        return (this.flags & 4 /* NodeFlag.Error */) > 0;
      }
      /// When true, this node type doesn't correspond to a user-declared
      /// named node, for example because it is used to cache repetition.
    }, {
      key: "isAnonymous",
      get: function get() {
        return (this.flags & 8 /* NodeFlag.Anonymous */) > 0;
      }
      /// Returns true when this node's name or one of its
      /// [groups](#common.NodeProp^group) matches the given string.
    }, {
      key: "is",
      value: function is(name) {
        if (typeof name == 'string') {
          if (this.name == name) return true;
          var group = this.prop(NodeProp.group);
          return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
      }
      /// Create a function from node types to arbitrary values by
      /// specifying an object whose property names are node or
      /// [group](#common.NodeProp^group) names. Often useful with
      /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
      /// names, separated by spaces, in a single property name to map
      /// multiple node names to a single value.
    }], [{
      key: "define",
      value: function define(spec) {
        var props = spec.props && spec.props.length ? Object.create(null) : noProps;
        var flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) | (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);
        var type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props) {
          var _iterator = _createForOfIteratorHelper(spec.props),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var src = _step.value;
              if (!Array.isArray(src)) src = src(type);
              if (src) {
                if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
                props[src[0].id] = src[1];
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        return type;
      }
    }, {
      key: "match",
      value: function match(map) {
        var direct = Object.create(null);
        for (var prop in map) {
          var _iterator2 = _createForOfIteratorHelper(prop.split(" ")),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var name = _step2.value;
              direct[name] = map[prop];
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return function (node) {
          for (var groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
            var found = direct[i < 0 ? node.name : groups[i]];
            if (found) return found;
          }
        };
      }
    }]);
    return NodeType;
  }(); /// An empty dummy node type to use when no actual type is available.
  NodeType.none = new NodeType("", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);
  /// A node set holds a collection of node types. It is used to
  /// compactly represent trees by storing their type ids, rather than a
  /// full pointer to the type object, in a numeric array. Each parser
  /// [has](#lr.LRParser.nodeSet) a node set, and [tree
  /// buffers](#common.TreeBuffer) can only store collections of nodes
  /// from the same set. A set can have a maximum of 2**16 (65536) node
  /// types in it, so that the ids fit into 16-bit typed array slots.
  var NodeSet = /*#__PURE__*/function () {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    function NodeSet(
    /// The node types in this set, by id.
    types) {
      _classCallCheck(this, NodeSet);
      this.types = types;
      for (var i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method can be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    _createClass(NodeSet, [{
      key: "extend",
      value: function extend() {
        var newTypes = [];
        for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {
          props[_key] = arguments[_key];
        }
        var _iterator3 = _createForOfIteratorHelper(this.types),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var type = _step3.value;
            var newProps = null;
            var _iterator4 = _createForOfIteratorHelper(props),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var source = _step4.value;
                var add = source(type);
                if (add) {
                  if (!newProps) newProps = Object.assign({}, type.props);
                  newProps[add[0].id] = add[1];
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return new NodeSet(newTypes);
      }
    }]);
    return NodeSet;
  }();
  var CachedNode = new WeakMap(),
    CachedInnerNode = new WeakMap();
  /// Options that control iteration. Can be combined with the `|`
  /// operator to enable multiple ones.
  var IterMode;
  (function (IterMode) {
    /// When enabled, iteration will only visit [`Tree`](#common.Tree)
    /// objects, not nodes packed into
    /// [`TreeBuffer`](#common.TreeBuffer)s.
    IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    /// Enable this to make iteration include anonymous nodes (such as
    /// the nodes that wrap repeated grammar constructs into a balanced
    /// tree).
    IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    /// By default, regular [mounted](#common.NodeProp^mounted) nodes
    /// replace their base node in iteration. Enable this to ignore them
    /// instead.
    IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
    /// This option only applies in
    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
    /// library to not enter mounted overlays if one covers the given
    /// position.
    IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  /// A piece of syntax tree. There are two ways to approach these
  /// trees: the way they are actually stored in memory, and the
  /// convenient way.
  ///
  /// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
  /// objects. By packing detail information into `TreeBuffer` leaf
  /// nodes, the representation is made a lot more memory-efficient.
  ///
  /// However, when you want to actually work with tree nodes, this
  /// representation is very awkward, so most client code will want to
  /// use the [`TreeCursor`](#common.TreeCursor) or
  /// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
  /// a view on some part of this data structure, and can be used to
  /// move around to adjacent nodes.
  var Tree = /*#__PURE__*/function () {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    function Tree(
    /// The type of the top node.
    type,
    /// This node's child nodes.
    children,
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions,
    /// The total length of this tree
    length,
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
      _classCallCheck(this, Tree);
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length;
      /// @internal
      this.props = null;
      if (props && props.length) {
        this.props = Object.create(null);
        var _iterator5 = _createForOfIteratorHelper(props),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray$1(_step5.value, 2),
              prop = _step5$value[0],
              value = _step5$value[1];
            this.props[typeof prop == "number" ? prop : prop.id] = value;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    }
    /// @internal
    _createClass(Tree, [{
      key: "toString",
      value: function toString() {
        var mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay) return mounted.tree.toString();
        var children = "";
        var _iterator6 = _createForOfIteratorHelper(this.children),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var ch = _step6.value;
            var str = ch.toString();
            if (str) {
              if (children) children += ",";
              children += str;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
      }
      /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
      /// the tree. Mode can be used to [control](#common.IterMode) which
      /// nodes the cursor visits.
    }, {
      key: "cursor",
      value: function cursor() {
        var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return new TreeCursor(this.topNode, mode);
      }
      /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
      /// at the given position and side (see
      /// [`moveTo`](#common.TreeCursor.moveTo).
    }, {
      key: "cursorAt",
      value: function cursorAt(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var scope = CachedNode.get(this) || this.topNode;
        var cursor = new TreeCursor(scope);
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
        return cursor;
      }
      /// Get a [syntax node](#common.SyntaxNode) object for the top of the
      /// tree.
    }, {
      key: "topNode",
      get: function get() {
        return new TreeNode(this, 0, 0, null);
      }
      /// Get the [syntax node](#common.SyntaxNode) at the given position.
      /// If `side` is -1, this will move into nodes that end at the
      /// position. If 1, it'll move into nodes that start at the
      /// position. With 0, it'll only enter nodes that cover the position
      /// from both sides.
      ///
      /// Note that this will not enter
      /// [overlays](#common.MountedTree.overlay), and you often want
      /// [`resolveInner`](#common.Tree.resolveInner) instead.
    }, {
      key: "resolve",
      value: function resolve(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
      }
      /// Like [`resolve`](#common.Tree.resolve), but will enter
      /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
      /// pointing into the innermost overlaid tree at the given position
      /// (with parent links going through all parent structure, including
      /// the host trees).
    }, {
      key: "resolveInner",
      value: function resolveInner(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
      }
      /// Iterate over the tree and its children, calling `enter` for any
      /// node that touches the `from`/`to` region (if given) before
      /// running over such a node's children, and `leave` (if given) when
      /// leaving the node. When `enter` returns `false`, that node will
      /// not have its children iterated over (or `leave` called).
    }, {
      key: "iterate",
      value: function iterate(spec) {
        var enter = spec.enter,
          leave = spec.leave,
          _spec$from = spec.from,
          from = _spec$from === void 0 ? 0 : _spec$from,
          _spec$to = spec.to,
          to = _spec$to === void 0 ? this.length : _spec$to;
        var mode = spec.mode || 0,
          anon = (mode & IterMode.IncludeAnonymous) > 0;
        for (var c = this.cursor(mode | IterMode.IncludeAnonymous);;) {
          var entered = false;
          if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
            if (c.firstChild()) continue;
            entered = true;
          }
          for (;;) {
            if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);
            if (c.nextSibling()) break;
            if (!c.parent()) return;
            entered = true;
          }
        }
      }
      /// Get the value of the given [node prop](#common.NodeProp) for this
      /// node. Works with both per-node and per-type props.
    }, {
      key: "prop",
      value: function prop(_prop2) {
        return !_prop2.perNode ? this.type.prop(_prop2) : this.props ? this.props[_prop2.id] : undefined;
      }
      /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
      /// format that can be passed to the [`Tree`](#common.Tree)
      /// constructor.
    }, {
      key: "propValues",
      get: function get() {
        var result = [];
        if (this.props) for (var id in this.props) result.push([+id, this.props[id]]);
        return result;
      }
      /// Balance the direct children of this tree, producing a copy of
      /// which may have children grouped into subtrees with type
      /// [`NodeType.none`](#common.NodeType^none).
    }, {
      key: "balance",
      value: function balance() {
        var _this2 = this;
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.children.length <= 8 /* Balance.BranchFactor */ ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, function (children, positions, length) {
          return new Tree(_this2.type, children, positions, length, _this2.propValues);
        }, config.makeTree || function (children, positions, length) {
          return new Tree(NodeType.none, children, positions, length);
        });
      }
      /// Build a tree from a postfix-ordered buffer of node information,
      /// or a cursor over such a buffer.
    }], [{
      key: "build",
      value: function build(data) {
        return buildTree(data);
      }
    }]);
    return Tree;
  }(); /// The empty tree
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = /*#__PURE__*/function () {
    function FlatBufferCursor(buffer, index) {
      _classCallCheck(this, FlatBufferCursor);
      this.buffer = buffer;
      this.index = index;
    }
    _createClass(FlatBufferCursor, [{
      key: "id",
      get: function get() {
        return this.buffer[this.index - 4];
      }
    }, {
      key: "start",
      get: function get() {
        return this.buffer[this.index - 3];
      }
    }, {
      key: "end",
      get: function get() {
        return this.buffer[this.index - 2];
      }
    }, {
      key: "size",
      get: function get() {
        return this.buffer[this.index - 1];
      }
    }, {
      key: "pos",
      get: function get() {
        return this.index;
      }
    }, {
      key: "next",
      value: function next() {
        this.index -= 4;
      }
    }, {
      key: "fork",
      value: function fork() {
        return new FlatBufferCursor(this.buffer, this.index);
      }
    }]);
    return FlatBufferCursor;
  }(); /// Tree buffers contain (type, start, end, endIndex) quads for each
  /// node. In such a buffer, nodes are stored in prefix order (parents
  /// before children, with the endIndex of the parent indicating which
  /// children belong to it).
  var TreeBuffer = /*#__PURE__*/function () {
    /// Create a tree buffer.
    function TreeBuffer(
    /// The buffer's content.
    buffer,
    /// The total length of the group of nodes in the buffer.
    length,
    /// The node set used in this buffer.
    set) {
      _classCallCheck(this, TreeBuffer);
      this.buffer = buffer;
      this.length = length;
      this.set = set;
    }
    /// @internal
    _createClass(TreeBuffer, [{
      key: "type",
      get: function get() {
        return NodeType.none;
      }
      /// @internal
    }, {
      key: "toString",
      value: function toString() {
        var result = [];
        for (var index = 0; index < this.buffer.length;) {
          result.push(this.childString(index));
          index = this.buffer[index + 3];
        }
        return result.join(",");
      }
      /// @internal
    }, {
      key: "childString",
      value: function childString(index) {
        var id = this.buffer[index],
          endIndex = this.buffer[index + 3];
        var type = this.set.types[id],
          result = type.name;
        if (/\W/.test(result) && !type.isError) result = JSON.stringify(result);
        index += 4;
        if (endIndex == index) return result;
        var children = [];
        while (index < endIndex) {
          children.push(this.childString(index));
          index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
      }
      /// @internal
    }, {
      key: "findChild",
      value: function findChild(startIndex, endIndex, dir, pos, side) {
        var buffer = this.buffer,
          pick = -1;
        for (var i = startIndex; i != endIndex; i = buffer[i + 3]) {
          if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
            pick = i;
            if (dir > 0) break;
          }
        }
        return pick;
      }
      /// @internal
    }, {
      key: "slice",
      value: function slice(startI, endI, from) {
        var b = this.buffer;
        var copy = new Uint16Array(endI - startI),
          len = 0;
        for (var i = startI, j = 0; i < endI;) {
          copy[j++] = b[i++];
          copy[j++] = b[i++] - from;
          var to = copy[j++] = b[i++] - from;
          copy[j++] = b[i++] - startI;
          len = Math.max(len, to);
        }
        return new TreeBuffer(copy, len, this.set);
      }
    }]);
    return TreeBuffer;
  }();
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2 /* Side.Before */:
        return from < pos;
      case -1 /* Side.AtOrBefore */:
        return to >= pos && from < pos;
      case 0 /* Side.Around */:
        return from < pos && to > pos;
      case 1 /* Side.AtOrAfter */:
        return from <= pos && to > pos;
      case 2 /* Side.After */:
        return to > pos;
      case 4 /* Side.DontCare */:
        return true;
    }
  }
  function _enterUnfinishedNodesBefore(node, pos) {
    var scan = node.childBefore(pos);
    while (scan) {
      var last = scan.lastChild;
      if (!last || last.to != scan.to) break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      var parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent) return node;
      node = parent;
    }
    var mode = overlays ? 0 : IterMode.IgnoreOverlays;
    // Must go up out of overlays when those do not overlap with pos
    if (overlays) for (var scan = node, _parent2 = scan.parent; _parent2; scan = _parent2, _parent2 = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = _parent2.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = _parent2;
    }
    for (;;) {
      var inner = node.enter(pos, side, mode);
      if (!inner) return node;
      node = inner;
    }
  }
  var TreeNode = /*#__PURE__*/function () {
    function TreeNode(_tree, from,
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
      _classCallCheck(this, TreeNode);
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
    _createClass(TreeNode, [{
      key: "type",
      get: function get() {
        return this._tree.type;
      }
    }, {
      key: "name",
      get: function get() {
        return this._tree.type.name;
      }
    }, {
      key: "to",
      get: function get() {
        return this.from + this._tree.length;
      }
    }, {
      key: "nextChild",
      value: function nextChild(i, dir, pos, side) {
        var mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        for (var parent = this;;) {
          for (var _parent$_tree = parent._tree, children = _parent$_tree.children, positions = _parent$_tree.positions, e = dir > 0 ? children.length : -1; i != e; i += dir) {
            var next = children[i],
              start = positions[i] + parent.from;
            if (!checkSide(side, pos, start, start + next.length)) continue;
            if (next instanceof TreeBuffer) {
              if (mode & IterMode.ExcludeBuffers) continue;
              var index = next.findChild(0, next.buffer.length, dir, pos - start, side);
              if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);
            } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {
              var mounted = void 0;
              if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);
              var inner = new TreeNode(next, start, i, parent);
              return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
            }
          }
          if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;
          if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent._tree.children.length;
          parent = parent._parent;
          if (!parent) return null;
        }
      }
    }, {
      key: "firstChild",
      get: function get() {
        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */);
      }
    }, {
      key: "lastChild",
      get: function get() {
        return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */);
      }
    }, {
      key: "childAfter",
      value: function childAfter(pos) {
        return this.nextChild(0, 1, pos, 2 /* Side.After */);
      }
    }, {
      key: "childBefore",
      value: function childBefore(pos) {
        return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */);
      }
    }, {
      key: "enter",
      value: function enter(pos, side) {
        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var mounted;
        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
          var rPos = pos - this.from;
          var _iterator7 = _createForOfIteratorHelper(mounted.overlay),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var _step7$value = _step7.value,
                from = _step7$value.from,
                to = _step7$value.to;
              if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        }
        return this.nextChild(0, 1, pos, side, mode);
      }
    }, {
      key: "nextSignificantParent",
      value: function nextSignificantParent() {
        var val = this;
        while (val.type.isAnonymous && val._parent) val = val._parent;
        return val;
      }
    }, {
      key: "parent",
      get: function get() {
        return this._parent ? this._parent.nextSignificantParent() : null;
      }
    }, {
      key: "nextSibling",
      get: function get() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;
      }
    }, {
      key: "prevSibling",
      get: function get() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;
      }
    }, {
      key: "cursor",
      value: function cursor() {
        var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return new TreeCursor(this, mode);
      }
    }, {
      key: "tree",
      get: function get() {
        return this._tree;
      }
    }, {
      key: "toTree",
      value: function toTree() {
        return this._tree;
      }
    }, {
      key: "resolve",
      value: function resolve(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return resolveNode(this, pos, side, false);
      }
    }, {
      key: "resolveInner",
      value: function resolveInner(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return resolveNode(this, pos, side, true);
      }
    }, {
      key: "enterUnfinishedNodesBefore",
      value: function enterUnfinishedNodesBefore(pos) {
        return _enterUnfinishedNodesBefore(this, pos);
      }
    }, {
      key: "getChild",
      value: function getChild(type) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var r = _getChildren(this, type, before, after);
        return r.length ? r[0] : null;
      }
    }, {
      key: "getChildren",
      value: function getChildren(type) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        return _getChildren(this, type, before, after);
      }
      /// @internal
    }, {
      key: "toString",
      value: function toString() {
        return this._tree.toString();
      }
    }, {
      key: "node",
      get: function get() {
        return this;
      }
    }, {
      key: "matchContext",
      value: function matchContext(context) {
        return matchNodeContext(this, context);
      }
    }]);
    return TreeNode;
  }();
  function _getChildren(node, type, before, after) {
    var cur = node.cursor(),
      result = [];
    if (!cur.firstChild()) return result;
    if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result;
    for (;;) {
      if (after != null && cur.type.is(after)) return result;
      if (cur.type.is(type)) result.push(cur.node);
      if (!cur.nextSibling()) return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context) {
    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;
    for (var p = node.parent; i >= 0; p = p.parent) {
      if (!p) return false;
      if (!p.type.isAnonymous) {
        if (context[i] && context[i] != p.name) return false;
        i--;
      }
    }
    return true;
  }
  var BufferContext = /*#__PURE__*/_createClass(function BufferContext(parent, buffer, index, start) {
    _classCallCheck(this, BufferContext);
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  });
  var BufferNode = /*#__PURE__*/function () {
    function BufferNode(context, _parent, index) {
      _classCallCheck(this, BufferNode);
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    _createClass(BufferNode, [{
      key: "name",
      get: function get() {
        return this.type.name;
      }
    }, {
      key: "from",
      get: function get() {
        return this.context.start + this.context.buffer.buffer[this.index + 1];
      }
    }, {
      key: "to",
      get: function get() {
        return this.context.start + this.context.buffer.buffer[this.index + 2];
      }
    }, {
      key: "child",
      value: function child(dir, pos, side) {
        var buffer = this.context.buffer;
        var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
      }
    }, {
      key: "firstChild",
      get: function get() {
        return this.child(1, 0, 4 /* Side.DontCare */);
      }
    }, {
      key: "lastChild",
      get: function get() {
        return this.child(-1, 0, 4 /* Side.DontCare */);
      }
    }, {
      key: "childAfter",
      value: function childAfter(pos) {
        return this.child(1, pos, 2 /* Side.After */);
      }
    }, {
      key: "childBefore",
      value: function childBefore(pos) {
        return this.child(-1, pos, -2 /* Side.Before */);
      }
    }, {
      key: "enter",
      value: function enter(pos, side) {
        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        if (mode & IterMode.ExcludeBuffers) return null;
        var buffer = this.context.buffer;
        var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
      }
    }, {
      key: "parent",
      get: function get() {
        return this._parent || this.context.parent.nextSignificantParent();
      }
    }, {
      key: "externalSibling",
      value: function externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);
      }
    }, {
      key: "nextSibling",
      get: function get() {
        var buffer = this.context.buffer;
        var after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
      }
    }, {
      key: "prevSibling",
      get: function get() {
        var buffer = this.context.buffer;
        var parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart) return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
      }
    }, {
      key: "cursor",
      value: function cursor() {
        var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return new TreeCursor(this, mode);
      }
    }, {
      key: "tree",
      get: function get() {
        return null;
      }
    }, {
      key: "toTree",
      value: function toTree() {
        var children = [],
          positions = [];
        var buffer = this.context.buffer;
        var startI = this.index + 4,
          endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
          var from = buffer.buffer[this.index + 1];
          children.push(buffer.slice(startI, endI, from));
          positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
      }
    }, {
      key: "resolve",
      value: function resolve(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return resolveNode(this, pos, side, false);
      }
    }, {
      key: "resolveInner",
      value: function resolveInner(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return resolveNode(this, pos, side, true);
      }
    }, {
      key: "enterUnfinishedNodesBefore",
      value: function enterUnfinishedNodesBefore(pos) {
        return _enterUnfinishedNodesBefore(this, pos);
      }
      /// @internal
    }, {
      key: "toString",
      value: function toString() {
        return this.context.buffer.childString(this.index);
      }
    }, {
      key: "getChild",
      value: function getChild(type) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var r = _getChildren(this, type, before, after);
        return r.length ? r[0] : null;
      }
    }, {
      key: "getChildren",
      value: function getChildren(type) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        return _getChildren(this, type, before, after);
      }
    }, {
      key: "node",
      get: function get() {
        return this;
      }
    }, {
      key: "matchContext",
      value: function matchContext(context) {
        return matchNodeContext(this, context);
      }
    }]);
    return BufferNode;
  }(); /// A tree cursor object focuses on a given node in a syntax tree, and
  /// allows you to move to adjacent nodes.
  var TreeCursor = /*#__PURE__*/function () {
    /// @internal
    function TreeCursor(node) {
      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      _classCallCheck(this, TreeCursor);
      this.mode = mode;
      /// @internal
      this.buffer = null;
      this.stack = [];
      /// @internal
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (var n = node._parent; n; n = n._parent) this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    _createClass(TreeCursor, [{
      key: "name",
      get:
      /// Shorthand for `.type.name`.
      function get() {
        return this.type.name;
      }
    }, {
      key: "yieldNode",
      value: function yieldNode(node) {
        if (!node) return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
      }
    }, {
      key: "yieldBuf",
      value: function yieldBuf(index, type) {
        this.index = index;
        var _this$buffer = this.buffer,
          start = _this$buffer.start,
          buffer = _this$buffer.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
      }
    }, {
      key: "yield",
      value: function _yield(node) {
        if (!node) return false;
        if (node instanceof TreeNode) {
          this.buffer = null;
          return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
      }
      /// @internal
    }, {
      key: "toString",
      value: function toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
      }
      /// @internal
    }, {
      key: "enterChild",
      value: function enterChild(dir, pos, side) {
        if (!this.buffer) return this["yield"](this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        var buffer = this.buffer.buffer;
        var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0) return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
      }
      /// Move the cursor to this node's first child. When this returns
      /// false, the node has no child, and the cursor has not been moved.
    }, {
      key: "firstChild",
      value: function firstChild() {
        return this.enterChild(1, 0, 4 /* Side.DontCare */);
      }
      /// Move the cursor to this node's last child.
    }, {
      key: "lastChild",
      value: function lastChild() {
        return this.enterChild(-1, 0, 4 /* Side.DontCare */);
      }
      /// Move the cursor to the first child that ends after `pos`.
    }, {
      key: "childAfter",
      value: function childAfter(pos) {
        return this.enterChild(1, pos, 2 /* Side.After */);
      }
      /// Move to the last child that starts before `pos`.
    }, {
      key: "childBefore",
      value: function childBefore(pos) {
        return this.enterChild(-1, pos, -2 /* Side.Before */);
      }
      /// Move the cursor to the child around `pos`. If side is -1 the
      /// child may end at that position, when 1 it may start there. This
      /// will also enter [overlaid](#common.MountedTree.overlay)
      /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
      /// set to false.
    }, {
      key: "enter",
      value: function enter(pos, side) {
        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.mode;
        if (!this.buffer) return this["yield"](this._tree.enter(pos, side, mode));
        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
      }
      /// Move to the node's parent node, if this isn't the top node.
    }, {
      key: "parent",
      value: function parent() {
        if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
        if (this.stack.length) return this.yieldBuf(this.stack.pop());
        var parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
      }
      /// @internal
    }, {
      key: "sibling",
      value: function sibling(dir) {
        if (!this.buffer) return !this._tree._parent ? false : this["yield"](this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));
        var buffer = this.buffer.buffer,
          d = this.stack.length - 1;
        if (dir < 0) {
          var parentStart = d < 0 ? 0 : this.stack[d] + 4;
          if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
        } else {
          var after = buffer.buffer[this.index + 3];
          if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);
        }
        return d < 0 ? this["yield"](this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;
      }
      /// Move to this node's next sibling, if any.
    }, {
      key: "nextSibling",
      value: function nextSibling() {
        return this.sibling(1);
      }
      /// Move to this node's previous sibling, if any.
    }, {
      key: "prevSibling",
      value: function prevSibling() {
        return this.sibling(-1);
      }
    }, {
      key: "atLastNode",
      value: function atLastNode(dir) {
        var index,
          parent,
          buffer = this.buffer;
        if (buffer) {
          if (dir > 0) {
            if (this.index < buffer.buffer.buffer.length) return false;
          } else {
            for (var i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;
          }
          index = buffer.index;
          parent = buffer.parent;
        } else {
          var _this$_tree = this._tree;
          index = _this$_tree.index;
          parent = _this$_tree._parent;
        }
        for (; parent; _parent3 = parent, index = _parent3.index, parent = _parent3._parent, _parent3) {
          var _parent3;
          if (index > -1) for (var _i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; _i != e; _i += dir) {
            var child = parent._tree.children[_i];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
          }
        }
        return true;
      }
    }, {
      key: "move",
      value: function move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */)) return true;
        for (;;) {
          if (this.sibling(dir)) return true;
          if (this.atLastNode(dir) || !this.parent()) return false;
        }
      }
      /// Move to the next node in a
      /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
      /// traversal, going from a node to its first child or, if the
      /// current node is empty or `enter` is false, its next sibling or
      /// the next sibling of the first parent node that has one.
    }, {
      key: "next",
      value: function next() {
        var enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return this.move(1, enter);
      }
      /// Move to the next node in a last-to-first pre-order traveral. A
      /// node is followed by its last child or, if it has none, its
      /// previous sibling or the previous sibling of the first parent
      /// node that has one.
    }, {
      key: "prev",
      value: function prev() {
        var enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return this.move(-1, enter);
      }
      /// Move the cursor to the innermost node that covers `pos`. If
      /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
      /// it will enter nodes that start at `pos`.
    }, {
      key: "moveTo",
      value: function moveTo(pos) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) {}
        return this;
      }
      /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
      /// position.
    }, {
      key: "node",
      get: function get() {
        if (!this.buffer) return this._tree;
        var cache = this.bufferNode,
          result = null,
          depth = 0;
        if (cache && cache.context == this.buffer) {
          scan: for (var index = this.index, d = this.stack.length; d >= 0;) {
            for (var c = cache; c; c = c._parent) if (c.index == index) {
              if (index == this.index) return c;
              result = c;
              depth = d + 1;
              break scan;
            }
            index = this.stack[--d];
          }
        }
        for (var i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
      }
      /// Get the [tree](#common.Tree) that represents the current node, if
      /// any. Will return null when the node is in a [tree
      /// buffer](#common.TreeBuffer).
    }, {
      key: "tree",
      get: function get() {
        return this.buffer ? null : this._tree._tree;
      }
      /// Iterate over the current node and all its descendants, calling
      /// `enter` when entering a node and `leave`, if given, when leaving
      /// one. When `enter` returns `false`, any children of that node are
      /// skipped, and `leave` isn't called for it.
    }, {
      key: "iterate",
      value: function iterate(enter, leave) {
        for (var depth = 0;;) {
          var mustLeave = false;
          if (this.type.isAnonymous || enter(this) !== false) {
            if (this.firstChild()) {
              depth++;
              continue;
            }
            if (!this.type.isAnonymous) mustLeave = true;
          }
          for (;;) {
            if (mustLeave && leave) leave(this);
            mustLeave = this.type.isAnonymous;
            if (this.nextSibling()) break;
            if (!depth) return;
            this.parent();
            depth--;
            mustLeave = true;
          }
        }
      }
      /// Test whether the current node matches a given contexta sequence
      /// of direct parent node names. Empty strings in the context array
      /// are treated as wildcards.
    }, {
      key: "matchContext",
      value: function matchContext(context) {
        if (!this.buffer) return matchNodeContext(this.node, context);
        var buffer = this.buffer.buffer,
          types = buffer.set.types;
        for (var i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
          if (d < 0) return matchNodeContext(this.node, context, i);
          var type = types[buffer.buffer[this.stack[d]]];
          if (!type.isAnonymous) {
            if (context[i] && context[i] != type.name) return false;
            i--;
          }
        }
        return true;
      }
    }]);
    return TreeCursor;
  }();
  function hasChild(tree) {
    return tree.children.some(function (ch) {
      return ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch);
    });
  }
  function buildTree(data) {
    var _a;
    var buffer = data.buffer,
      nodeSet = data.nodeSet,
      _data$maxBufferLength = data.maxBufferLength,
      maxBufferLength = _data$maxBufferLength === void 0 ? DefaultBufferLength : _data$maxBufferLength,
      _data$reused = data.reused,
      reused = _data$reused === void 0 ? [] : _data$reused,
      _data$minRepeatType = data.minRepeatType,
      minRepeatType = _data$minRepeatType === void 0 ? nodeSet.types.length : _data$minRepeatType;
    var cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    var types = nodeSet.types;
    var contextHash = 0,
      lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
      var id = cursor.id,
        start = cursor.start,
        end = cursor.end,
        size = cursor.size;
      var lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1 /* SpecialRecord.Reuse */) {
          var _node = reused[id];
          children.push(_node);
          positions.push(start - parentStart);
          return;
        } else if (size == -3 /* SpecialRecord.ContextChange */) {
          // Context change
          contextHash = id;
          return;
        } else if (size == -4 /* SpecialRecord.LookAhead */) {
          lookAhead = id;
          return;
        } else {
          throw new RangeError("Unrecognized record size: ".concat(size));
        }
      }
      var type = types[id],
        node,
        buffer;
      var startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
        // Small enough for a buffer, and no reused nodes inside
        var _data = new Uint16Array(buffer.size - buffer.skip);
        var endPos = cursor.pos - buffer.size,
          index = _data.length;
        while (cursor.pos > endPos) index = copyToBuffer(buffer.start, _data, index);
        node = new TreeBuffer(_data, end - buffer.start, nodeSet);
        startPos = buffer.start - parentStart;
      } else {
        // Make it a node
        var _endPos = cursor.pos - size;
        cursor.next();
        var localChildren = [],
          localPositions = [];
        var localInRepeat = id >= minRepeatType ? id : -1;
        var lastGroup = 0,
          lastEnd = end;
        while (cursor.pos > _endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start, _endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          var make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
        }
      }
      children.push(node);
      positions.push(startPos);
    }
    function makeBalanced(type) {
      return function (children, positions, length) {
        var lookAhead = 0,
          lastI = children.length - 1,
          last,
          lookAheadProp;
        if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
          if (!lastI && last.type == type && last.length == length) return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children, positions, length, lookAhead);
      };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
      var localChildren = [],
        localPositions = [];
      while (children.length > i) {
        localChildren.push(children.pop());
        localPositions.push(positions.pop() + base - from);
      }
      children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
      positions.push(from - base);
    }
    function makeTree(type, children, positions, length) {
      var lookAhead = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var props = arguments.length > 5 ? arguments[5] : undefined;
      if (contextHash) {
        var pair = [NodeProp.contextHash, contextHash];
        props = props ? [pair].concat(props) : [pair];
      }
      if (lookAhead > 25) {
        var _pair = [NodeProp.lookAhead, lookAhead];
        props = props ? [_pair].concat(props) : [_pair];
      }
      return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      // Scan through the buffer to find previous siblings that fit
      // together in a TreeBuffer, and don't contain any reused nodes
      // (which can't be stored in a buffer).
      // If `inRepeat` is > -1, ignore node boundaries of that type for
      // nesting, but make sure the end falls either at the start
      // (`maxSize`) or before such a node.
      var fork = cursor.fork();
      var size = 0,
        start = 0,
        skip = 0,
        minStart = fork.end - maxBufferLength;
      var result = {
        size: 0,
        start: 0,
        skip: 0
      };
      scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos;) {
        var _nodeSize = fork.size;
        // Pretend nested repeat nodes of the same type don't exist
        if (fork.id == inRepeat && _nodeSize >= 0) {
          // Except that we store the current state as a valid return
          // value.
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        var startPos = fork.pos - _nodeSize;
        if (_nodeSize < 0 || startPos < minPos || fork.start < minStart) break;
        var localSkipped = fork.id >= minRepeatType ? 4 : 0;
        var nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3 /* SpecialRecord.ContextChange */) localSkipped += 4;else break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += _nodeSize;
        skip += localSkipped;
      }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
      var id = cursor.id,
        start = cursor.start,
        end = cursor.end,
        size = cursor.size;
      cursor.next();
      if (size >= 0 && id < minRepeatType) {
        var startIndex = index;
        if (size > 4) {
          var endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);
        }
        buffer[--index] = startIndex;
        buffer[--index] = end - bufferStart;
        buffer[--index] = start - bufferStart;
        buffer[--index] = id;
      } else if (size == -3 /* SpecialRecord.ContextChange */) {
        contextHash = id;
      } else if (size == -4 /* SpecialRecord.LookAhead */) {
        lookAhead = id;
      }
      return index;
    }
    var children = [],
      positions = [];
    while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    var length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;
    var size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      var _iterator8 = _createForOfIteratorHelper(node.children),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var child = _step8.value;
          if (child.type != balanceType || !(child instanceof Tree)) {
            size = 1;
            break;
          }
          size += nodeSize(balanceType, child);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(
  // The type the balanced tree's inner nodes.
  balanceType,
  // The direct children and their positions
  children, positions,
  // The index range in children/positions to use
  from, to,
  // The start position of the nodes, relative to their parent.
  start,
  // Length of the outer node
  length,
  // Function to build the top node of the balanced tree
  mkTop,
  // Function to build internal nodes for the balanced tree
  mkTree) {
    var total = 0;
    for (var i = from; i < to; i++) total += nodeSize(balanceType, children[i]);
    var maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */);
    var localChildren = [],
      localPositions = [];
    function divide(children, positions, from, to, offset) {
      for (var _i2 = from; _i2 < to;) {
        var groupFrom = _i2,
          groupStart = positions[_i2],
          groupSize = nodeSize(balanceType, children[_i2]);
        _i2++;
        for (; _i2 < to; _i2++) {
          var nextSize = nodeSize(balanceType, children[_i2]);
          if (groupSize + nextSize >= maxChild) break;
          groupSize += nextSize;
        }
        if (_i2 == groupFrom + 1) {
          if (groupSize > maxChild) {
            var only = children[groupFrom]; // Only trees can have a size > 1
            divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
            continue;
          }
          localChildren.push(children[groupFrom]);
        } else {
          var _length = positions[_i2 - 1] + children[_i2 - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children, positions, groupFrom, _i2, groupStart, _length, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  /// parsing](#common.Parser.startParse) to track parts of old trees
  /// that can be reused in a new parse. An array of fragments is used
  /// to track regions of an old tree whose nodes might be reused in new
  /// parses. Use the static
  /// [`applyChanges`](#common.TreeFragment^applyChanges) method to
  /// update fragments for document changes.
  var TreeFragment = /*#__PURE__*/function () {
    /// Construct a tree fragment. You'll usually want to use
    /// [`addTree`](#common.TreeFragment^addTree) and
    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    /// calling this directly.
    function TreeFragment(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from,
    /// The end of the unchanged range.
    to,
    /// The tree that this fragment is based on.
    tree,
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset) {
      var openStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var openEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      _classCallCheck(this, TreeFragment);
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    _createClass(TreeFragment, [{
      key: "openStart",
      get: function get() {
        return (this.open & 1 /* Open.Start */) > 0;
      }
      /// Whether the end of the fragment represents the end of a
      /// full-document parse, or the start of a change.
    }, {
      key: "openEnd",
      get: function get() {
        return (this.open & 2 /* Open.End */) > 0;
      }
      /// Create a set of fragments from a freshly parsed tree, or update
      /// an existing set of fragments by replacing the ones that overlap
      /// with a tree with content from the new tree. When `partial` is
      /// true, the parse is treated as incomplete, and the resulting
      /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
      /// true.
    }], [{
      key: "addTree",
      value: function addTree(tree) {
        var fragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var partial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        var _iterator9 = _createForOfIteratorHelper(fragments),
          _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var f = _step9.value;
            if (f.to > tree.length) result.push(f);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
        return result;
      }
      /// Apply a set of edits to an array of fragments, removing or
      /// splitting fragments as necessary to remove edited ranges, and
      /// adjusting offsets for fragments that moved.
    }, {
      key: "applyChanges",
      value: function applyChanges(fragments, changes) {
        var minGap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 128;
        if (!changes.length) return fragments;
        var result = [];
        var fI = 1,
          nextF = fragments.length ? fragments[0] : null;
        for (var cI = 0, pos = 0, off = 0;; cI++) {
          var nextC = cI < changes.length ? changes[cI] : null;
          var nextPos = nextC ? nextC.fromA : 1e9;
          if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {
            var cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              var fFrom = Math.max(cut.from, pos) - off,
                fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut) result.push(cut);
            if (nextF.to > nextPos) break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
          if (!nextC) break;
          pos = nextC.toA;
          off = nextC.toA - nextC.toB;
        }
        return result;
      }
    }]);
    return TreeFragment;
  }(); /// A superclass that parsers should extend.
  var Parser = /*#__PURE__*/function () {
    function Parser() {
      _classCallCheck(this, Parser);
    }
    _createClass(Parser, [{
      key: "startParse",
      value:
      /// Start a parse, returning a [partial parse](#common.PartialParse)
      /// object. [`fragments`](#common.TreeFragment) can be passed in to
      /// make the parse incremental.
      ///
      /// By default, the entire input is parsed. You can pass `ranges`,
      /// which should be a sorted array of non-empty, non-overlapping
      /// ranges, to parse only those ranges. The tree returned in that
      /// case will start at `ranges[0].from`.
      function startParse(input, fragments, ranges) {
        if (typeof input == "string") input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(function (r) {
          return new Range(r.from, r.to);
        }) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
      }
      /// Run a full parse, returning the resulting tree.
    }, {
      key: "parse",
      value: function parse(input, fragments, ranges) {
        var parse = this.startParse(input, fragments, ranges);
        for (;;) {
          var done = parse.advance();
          if (done) return done;
        }
      }
    }]);
    return Parser;
  }();
  var StringInput = /*#__PURE__*/function () {
    function StringInput(string) {
      _classCallCheck(this, StringInput);
      this.string = string;
    }
    _createClass(StringInput, [{
      key: "length",
      get: function get() {
        return this.string.length;
      }
    }, {
      key: "chunk",
      value: function chunk(from) {
        return this.string.slice(from);
      }
    }, {
      key: "lineChunks",
      get: function get() {
        return false;
      }
    }, {
      key: "read",
      value: function read(from, to) {
        return this.string.slice(from, to);
      }
    }]);
    return StringInput;
  }(); /// Create a parse wrapper that, after the inner parse completes,
  new NodeProp({
    perNode: true
  });

  var nextTagID = 0;
  /**
  Highlighting tags are markers that denote a highlighting category.
  They are [associated](#highlight.styleTags) with parts of a syntax
  tree by a language mode, and then mapped to an actual CSS style by
  a [highlighter](#highlight.Highlighter).

  Because syntax tree node types and highlight styles have to be
  able to talk the same language, CodeMirror uses a mostly _closed_
  [vocabulary](#highlight.tags) of syntax tags (as opposed to
  traditional open string-based systems, which make it hard for
  highlighting themes to cover all the tokens produced by the
  various languages).

  It _is_ possible to [define](#highlight.Tag^define) your own
  highlighting tags for system-internal use (where you control both
  the language package and the highlighter), but such tags will not
  be picked up by regular highlighters (though you can derive them
  from standard tags to allow highlighters to fall back to those).
  */
  var Tag = /*#__PURE__*/function () {
    /**
    @internal
    */
    function Tag(
    /**
    The set of this tag and all its parent tags, starting with
    this one itself and sorted in order of decreasing specificity.
    */
    set,
    /**
    The base unmodified tag that this one is based on, if it's
    modified @internal
    */
    base,
    /**
    The modifiers applied to this.base @internal
    */
    modified) {
      _classCallCheck(this, Tag);
      this.set = set;
      this.base = base;
      this.modified = modified;
      /**
      @internal
      */
      this.id = nextTagID++;
    }
    /**
    Define a new tag. If `parent` is given, the tag is treated as a
    sub-tag of that parent, and
    [highlighters](#highlight.tagHighlighter) that don't mention
    this tag will try to fall back to the parent tag (or grandparent
    tag, etc).
    */
    _createClass(Tag, null, [{
      key: "define",
      value: function define(parent) {
        if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error("Can not derive from a modified tag");
        var tag = new Tag([], null, []);
        tag.set.push(tag);
        if (parent) {
          var _iterator = _createForOfIteratorHelper(parent.set),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _t = _step.value;
              tag.set.push(_t);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        return tag;
      }
      /**
      Define a tag _modifier_, which is a function that, given a tag,
      will return a tag that is a subtag of the original. Applying the
      same modifier to a twice tag will return the same value (`m1(t1)
      == m1(t1)`) and applying multiple modifiers will, regardless or
      order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
      
      When multiple modifiers are applied to a given base tag, each
      smaller set of modifiers is registered as a parent, so that for
      example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
      `m1(m3(t1)`, and so on.
      */
    }, {
      key: "defineModifier",
      value: function defineModifier() {
        var mod = new Modifier();
        return function (tag) {
          if (tag.modified.indexOf(mod) > -1) return tag;
          return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort(function (a, b) {
            return a.id - b.id;
          }));
        };
      }
    }]);
    return Tag;
  }();
  var nextModifierID = 0;
  var Modifier = /*#__PURE__*/function () {
    function Modifier() {
      _classCallCheck(this, Modifier);
      this.instances = [];
      this.id = nextModifierID++;
    }
    _createClass(Modifier, null, [{
      key: "get",
      value: function get(base, mods) {
        if (!mods.length) return base;
        var exists = mods[0].instances.find(function (t) {
          return t.base == base && sameArray(mods, t.modified);
        });
        if (exists) return exists;
        var set = [],
          tag = new Tag(set, base, mods);
        var _iterator2 = _createForOfIteratorHelper(mods),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var m = _step2.value;
            m.instances.push(tag);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        var configs = powerSet(mods);
        var _iterator3 = _createForOfIteratorHelper(base.set),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var parent = _step3.value;
            if (!parent.modified.length) {
              var _iterator4 = _createForOfIteratorHelper(configs),
                _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var config = _step4.value;
                  set.push(Modifier.get(parent, config));
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return tag;
      }
    }]);
    return Modifier;
  }();
  function sameArray(a, b) {
    return a.length == b.length && a.every(function (x, i) {
      return x == b[i];
    });
  }
  function powerSet(array) {
    var sets = [[]];
    for (var i = 0; i < array.length; i++) {
      for (var j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array[i]));
      }
    }
    return sets.sort(function (a, b) {
      return b.length - a.length;
    });
  }
  /**
  This function is used to add a set of tags to a language syntax
  via [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.LRParser.configure).

  The argument object maps node selectors to [highlighting
  tags](#highlight.Tag) or arrays of tags.

  Node selectors may hold one or more (space-separated) node paths.
  Such a path can be a [node name](#common.NodeType.name), or
  multiple node names (or `*` wildcards) separated by slash
  characters, as in `"Block/Declaration/VariableName"`. Such a path
  matches the final node but only if its direct parent nodes are the
  other nodes mentioned. A `*` in such a path matches any parent,
  but only a single levelwildcards that match multiple parents
  aren't supported, both for efficiency reasons and because Lezer
  trees make it rather hard to reason about what they would match.)

  A path can be ended with `/...` to indicate that the tag assigned
  to the node should also apply to all child nodes, even if they
  match their own style (by default, only the innermost style is
  used).

  When a path ends in `!`, as in `Attribute!`, no further matching
  happens for the node's child nodes, and the entire node gets the
  given style.

  In this notation, node names that contain `/`, `!`, `*`, or `...`
  must be quoted as JSON strings.

  For example:

  ```javascript
  parser.withProps(
    styleTags({
      // Style Number and BigNumber nodes
      "Number BigNumber": tags.number,
      // Style Escape nodes whose parent is String
      "String/Escape": tags.escape,
      // Style anything inside Attributes nodes
      "Attributes!": tags.meta,
      // Add a style to all content inside Italic nodes
      "Italic/...": tags.emphasis,
      // Style InvalidString nodes as both `string` and `invalid`
      "InvalidString": [tags.string, tags.invalid],
      // Style the node named "/" as punctuation
      '"/"': tags.punctuation
    })
  )
  ```
  */
  function styleTags(spec) {
    var byName = Object.create(null);
    for (var prop in spec) {
      var _tags = spec[prop];
      if (!Array.isArray(_tags)) _tags = [_tags];
      var _iterator5 = _createForOfIteratorHelper(prop.split(" ")),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var part = _step5.value;
          if (part) {
            var pieces = [],
              mode = 2 /* Normal */,
              rest = part;
            for (var pos = 0;;) {
              if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                mode = 1 /* Inherit */;
                break;
              }
              var m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
              if (!m) throw new RangeError("Invalid path: " + part);
              pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
              pos += m[0].length;
              if (pos == part.length) break;
              var next = part[pos++];
              if (pos == part.length && next == "!") {
                mode = 0 /* Opaque */;
                break;
              }
              if (next != "/") throw new RangeError("Invalid path: " + part);
              rest = part.slice(pos);
            }
            var last = pieces.length - 1,
              inner = pieces[last];
            if (!inner) throw new RangeError("Invalid path: " + part);
            var rule = new Rule(_tags, mode, last > 0 ? pieces.slice(0, last) : null);
            byName[inner] = rule.sort(byName[inner]);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = /*#__PURE__*/function () {
    function Rule(tags, mode, context, next) {
      _classCallCheck(this, Rule);
      this.tags = tags;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    _createClass(Rule, [{
      key: "opaque",
      get: function get() {
        return this.mode == 0 /* Opaque */;
      }
    }, {
      key: "inherit",
      get: function get() {
        return this.mode == 1 /* Inherit */;
      }
    }, {
      key: "sort",
      value: function sort(other) {
        if (!other || other.depth < this.depth) {
          this.next = other;
          return this;
        }
        other.next = this.sort(other.next);
        return other;
      }
    }, {
      key: "depth",
      get: function get() {
        return this.context ? this.context.length : 0;
      }
    }]);
    return Rule;
  }();
  Rule.empty = new Rule([], 2 /* Normal */, null);
  /**
  Define a [highlighter](#highlight.Highlighter) from an array of
  tag/class pairs. Classes associated with more specific tags will
  take precedence.
  */
  function tagHighlighter(tags, options) {
    var map = Object.create(null);
    var _iterator6 = _createForOfIteratorHelper(tags),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var style = _step6.value;
        if (!Array.isArray(style.tag)) map[style.tag.id] = style["class"];else {
          var _iterator9 = _createForOfIteratorHelper(style.tag),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var tag = _step9.value;
              map[tag.id] = style["class"];
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    var _ref = options || {},
      scope = _ref.scope,
      _ref$all = _ref.all,
      all = _ref$all === void 0 ? null : _ref$all;
    return {
      style: function style(tags) {
        var cls = all;
        var _iterator7 = _createForOfIteratorHelper(tags),
          _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var tag = _step7.value;
            var _iterator8 = _createForOfIteratorHelper(tag.set),
              _step8;
            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var sub = _step8.value;
                var tagClass = map[sub.id];
                if (tagClass) {
                  cls = cls ? cls + " " + tagClass : tagClass;
                  break;
                }
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
        return cls;
      },
      scope: scope
    };
  }
  function highlightTags(highlighters, tags) {
    var result = null;
    var _iterator10 = _createForOfIteratorHelper(highlighters),
      _step10;
    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var highlighter = _step10.value;
        var value = highlighter.style(tags);
        if (value) result = result ? result + " " + value : value;
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }
    return result;
  }
  /**
  Highlight the given [tree](#common.Tree) with the given
  [highlighter](#highlight.Highlighter).
  */
  function highlightTree(tree, highlighter,
  /**
  Assign styling to a region of the text. Will be called, in order
  of position, for any ranges where more than zero classes apply.
  `classes` is a space separated string of CSS classes.
  */
  putStyle) {
    var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tree.length;
    var builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  var HighlightBuilder = /*#__PURE__*/function () {
    function HighlightBuilder(at, highlighters, span) {
      _classCallCheck(this, HighlightBuilder);
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this["class"] = "";
    }
    _createClass(HighlightBuilder, [{
      key: "startSpan",
      value: function startSpan(at, cls) {
        if (cls != this["class"]) {
          this.flush(at);
          if (at > this.at) this.at = at;
          this["class"] = cls;
        }
      }
    }, {
      key: "flush",
      value: function flush(to) {
        if (to > this.at && this["class"]) this.span(this.at, to, this["class"]);
      }
    }, {
      key: "highlightRange",
      value: function highlightRange(cursor, from, to, inheritedClass, highlighters) {
        var type = cursor.type,
          start = cursor.from,
          end = cursor.to;
        if (start >= to || end <= from) return;
        if (type.isTop) highlighters = this.highlighters.filter(function (h) {
          return !h.scope || h.scope(type);
        });
        var cls = inheritedClass;
        var rule = getStyleTags(cursor) || Rule.empty;
        var tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
          if (cls) cls += " ";
          cls += tagCls;
          if (rule.mode == 1 /* Inherit */) inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(Math.max(from, start), cls);
        if (rule.opaque) return;
        var mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
        if (mounted && mounted.overlay) {
          var inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
          var innerHighlighters = this.highlighters.filter(function (h) {
            return !h.scope || h.scope(mounted.tree.type);
          });
          var hasChild = cursor.firstChild();
          for (var i = 0, pos = start;; i++) {
            var next = i < mounted.overlay.length ? mounted.overlay[i] : null;
            var nextPos = next ? next.from + start : end;
            var rangeFrom = Math.max(from, pos),
              rangeTo = Math.min(to, nextPos);
            if (rangeFrom < rangeTo && hasChild) {
              while (cursor.from < rangeTo) {
                this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                this.startSpan(Math.min(rangeTo, cursor.to), cls);
                if (cursor.to >= nextPos || !cursor.nextSibling()) break;
              }
            }
            if (!next || nextPos > to) break;
            pos = next.to + start;
            if (pos > from) {
              this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
              this.startSpan(Math.min(to, pos), cls);
            }
          }
          if (hasChild) cursor.parent();
        } else if (cursor.firstChild()) {
          if (mounted) inheritedClass = "";
          do {
            if (cursor.to <= from) continue;
            if (cursor.from >= to) break;
            this.highlightRange(cursor, from, to, inheritedClass, highlighters);
            this.startSpan(Math.min(to, cursor.to), cls);
          } while (cursor.nextSibling());
          cursor.parent();
        }
      }
    }]);
    return HighlightBuilder;
  }();
  /**
  Match a syntax node's [highlight rules](#highlight.styleTags). If
  there's a match, return its set of tags, and whether it is
  opaque (uses a `!`) or applies to all child nodes (`/...`).
  */
  function getStyleTags(node) {
    var rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;
    return rule || null;
  }
  var t = Tag.define;
  var comment = t(),
    name$1 = t(),
    typeName = t(name$1),
    propertyName = t(name$1),
    literal = t(),
    string = t(literal),
    number = t(literal),
    content = t(),
    heading = t(content),
    keyword = t(),
    operator = t(),
    punctuation = t(),
    bracket = t(punctuation),
    meta = t();
  /**
  The default set of highlighting [tags](#highlight.Tag).

  This collection is heavily biased towards programming languages,
  and necessarily incomplete. A full ontology of syntactic
  constructs would fill a stack of books, and be impractical to
  write themes for. So try to make do with this set. If all else
  fails, [open an
  issue](https://github.com/codemirror/codemirror.next) to propose a
  new tag, or [define](#highlight.Tag^define) a local custom tag for
  your use case.

  Note that it is not obligatory to always attach the most specific
  tag possible to an elementif your grammar can't easily
  distinguish a certain type of element (such as a local variable),
  it is okay to style it as its more general variant (a variable).

  For tags that extend some parent tag, the documentation links to
  the parent.
  */
  var tags$1 = {
    /**
    A comment.
    */
    comment: comment,
    /**
    A line [comment](#highlight.tags.comment).
    */
    lineComment: t(comment),
    /**
    A block [comment](#highlight.tags.comment).
    */
    blockComment: t(comment),
    /**
    A documentation [comment](#highlight.tags.comment).
    */
    docComment: t(comment),
    /**
    Any kind of identifier.
    */
    name: name$1,
    /**
    The [name](#highlight.tags.name) of a variable.
    */
    variableName: t(name$1),
    /**
    A type [name](#highlight.tags.name).
    */
    typeName: typeName,
    /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
    tagName: t(typeName),
    /**
    A property or field [name](#highlight.tags.name).
    */
    propertyName: propertyName,
    /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
    attributeName: t(propertyName),
    /**
    The [name](#highlight.tags.name) of a class.
    */
    className: t(name$1),
    /**
    A label [name](#highlight.tags.name).
    */
    labelName: t(name$1),
    /**
    A namespace [name](#highlight.tags.name).
    */
    namespace: t(name$1),
    /**
    The [name](#highlight.tags.name) of a macro.
    */
    macroName: t(name$1),
    /**
    A literal value.
    */
    literal: literal,
    /**
    A string [literal](#highlight.tags.literal).
    */
    string: string,
    /**
    A documentation [string](#highlight.tags.string).
    */
    docString: t(string),
    /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
    character: t(string),
    /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
    attributeValue: t(string),
    /**
    A number [literal](#highlight.tags.literal).
    */
    number: number,
    /**
    An integer [number](#highlight.tags.number) literal.
    */
    integer: t(number),
    /**
    A floating-point [number](#highlight.tags.number) literal.
    */
    "float": t(number),
    /**
    A boolean [literal](#highlight.tags.literal).
    */
    bool: t(literal),
    /**
    Regular expression [literal](#highlight.tags.literal).
    */
    regexp: t(literal),
    /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
    escape: t(literal),
    /**
    A color [literal](#highlight.tags.literal).
    */
    color: t(literal),
    /**
    A URL [literal](#highlight.tags.literal).
    */
    url: t(literal),
    /**
    A language keyword.
    */
    keyword: keyword,
    /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
    self: t(keyword),
    /**
    The [keyword](#highlight.tags.keyword) for null.
    */
    "null": t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
    atom: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
    unit: t(keyword),
    /**
    A modifier [keyword](#highlight.tags.keyword).
    */
    modifier: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
    operatorKeyword: t(keyword),
    /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
    controlKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
    definitionKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
    moduleKeyword: t(keyword),
    /**
    An operator.
    */
    operator: operator,
    /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
    derefOperator: t(operator),
    /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
    arithmeticOperator: t(operator),
    /**
    Logical [operator](#highlight.tags.operator).
    */
    logicOperator: t(operator),
    /**
    Bit [operator](#highlight.tags.operator).
    */
    bitwiseOperator: t(operator),
    /**
    Comparison [operator](#highlight.tags.operator).
    */
    compareOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
    updateOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that defines something.
    */
    definitionOperator: t(operator),
    /**
    Type-related [operator](#highlight.tags.operator).
    */
    typeOperator: t(operator),
    /**
    Control-flow [operator](#highlight.tags.operator).
    */
    controlOperator: t(operator),
    /**
    Program or markup punctuation.
    */
    punctuation: punctuation,
    /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
    separator: t(punctuation),
    /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
    bracket: bracket,
    /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
    angleBracket: t(bracket),
    /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
    squareBracket: t(bracket),
    /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    paren: t(bracket),
    /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    brace: t(bracket),
    /**
    Content, for example plain text in XML or markup documents.
    */
    content: content,
    /**
    [Content](#highlight.tags.content) that represents a heading.
    */
    heading: heading,
    /**
    A level 1 [heading](#highlight.tags.heading).
    */
    heading1: t(heading),
    /**
    A level 2 [heading](#highlight.tags.heading).
    */
    heading2: t(heading),
    /**
    A level 3 [heading](#highlight.tags.heading).
    */
    heading3: t(heading),
    /**
    A level 4 [heading](#highlight.tags.heading).
    */
    heading4: t(heading),
    /**
    A level 5 [heading](#highlight.tags.heading).
    */
    heading5: t(heading),
    /**
    A level 6 [heading](#highlight.tags.heading).
    */
    heading6: t(heading),
    /**
    A prose separator (such as a horizontal rule).
    */
    contentSeparator: t(content),
    /**
    [Content](#highlight.tags.content) that represents a list.
    */
    list: t(content),
    /**
    [Content](#highlight.tags.content) that represents a quote.
    */
    quote: t(content),
    /**
    [Content](#highlight.tags.content) that is emphasized.
    */
    emphasis: t(content),
    /**
    [Content](#highlight.tags.content) that is styled strong.
    */
    strong: t(content),
    /**
    [Content](#highlight.tags.content) that is part of a link.
    */
    link: t(content),
    /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
    monospace: t(content),
    /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
    strikethrough: t(content),
    /**
    Inserted text in a change-tracking format.
    */
    inserted: t(),
    /**
    Deleted text.
    */
    deleted: t(),
    /**
    Changed text.
    */
    changed: t(),
    /**
    An invalid or unsyntactic element.
    */
    invalid: t(),
    /**
    Metadata or meta-instruction.
    */
    meta: meta,
    /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
    documentMeta: t(meta),
    /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
    annotation: t(meta),
    /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
    processingInstruction: t(meta),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
    definition: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
    constant: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
    "function": Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
    standard: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
    local: Tag.defineModifier(),
    /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
    special: Tag.defineModifier()
  };
  /**
  This is a highlighter that adds stable, predictable classes to
  tokens, for styling with external CSS.

  The following tags are mapped to their name prefixed with `"tok-"`
  (for example `"tok-comment"`):

  * [`link`](#highlight.tags.link)
  * [`heading`](#highlight.tags.heading)
  * [`emphasis`](#highlight.tags.emphasis)
  * [`strong`](#highlight.tags.strong)
  * [`keyword`](#highlight.tags.keyword)
  * [`atom`](#highlight.tags.atom)
  * [`bool`](#highlight.tags.bool)
  * [`url`](#highlight.tags.url)
  * [`labelName`](#highlight.tags.labelName)
  * [`inserted`](#highlight.tags.inserted)
  * [`deleted`](#highlight.tags.deleted)
  * [`literal`](#highlight.tags.literal)
  * [`string`](#highlight.tags.string)
  * [`number`](#highlight.tags.number)
  * [`variableName`](#highlight.tags.variableName)
  * [`typeName`](#highlight.tags.typeName)
  * [`namespace`](#highlight.tags.namespace)
  * [`className`](#highlight.tags.className)
  * [`macroName`](#highlight.tags.macroName)
  * [`propertyName`](#highlight.tags.propertyName)
  * [`operator`](#highlight.tags.operator)
  * [`comment`](#highlight.tags.comment)
  * [`meta`](#highlight.tags.meta)
  * [`punctuation`](#highlight.tags.punctuation)
  * [`invalid`](#highlight.tags.invalid)

  In addition, these mappings are provided:

  * [`regexp`](#highlight.tags.regexp),
    [`escape`](#highlight.tags.escape), and
    [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
    are mapped to `"tok-string2"`
  * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
    to `"tok-variableName2"`
  * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
    to `"tok-variableName tok-local"`
  * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
    to `"tok-variableName tok-definition"`
  * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
    to `"tok-propertyName tok-definition"`
  */
  tagHighlighter([{
    tag: tags$1.link,
    "class": "tok-link"
  }, {
    tag: tags$1.heading,
    "class": "tok-heading"
  }, {
    tag: tags$1.emphasis,
    "class": "tok-emphasis"
  }, {
    tag: tags$1.strong,
    "class": "tok-strong"
  }, {
    tag: tags$1.keyword,
    "class": "tok-keyword"
  }, {
    tag: tags$1.atom,
    "class": "tok-atom"
  }, {
    tag: tags$1.bool,
    "class": "tok-bool"
  }, {
    tag: tags$1.url,
    "class": "tok-url"
  }, {
    tag: tags$1.labelName,
    "class": "tok-labelName"
  }, {
    tag: tags$1.inserted,
    "class": "tok-inserted"
  }, {
    tag: tags$1.deleted,
    "class": "tok-deleted"
  }, {
    tag: tags$1.literal,
    "class": "tok-literal"
  }, {
    tag: tags$1.string,
    "class": "tok-string"
  }, {
    tag: tags$1.number,
    "class": "tok-number"
  }, {
    tag: [tags$1.regexp, tags$1.escape, tags$1.special(tags$1.string)],
    "class": "tok-string2"
  }, {
    tag: tags$1.variableName,
    "class": "tok-variableName"
  }, {
    tag: tags$1.local(tags$1.variableName),
    "class": "tok-variableName tok-local"
  }, {
    tag: tags$1.definition(tags$1.variableName),
    "class": "tok-variableName tok-definition"
  }, {
    tag: tags$1.special(tags$1.variableName),
    "class": "tok-variableName2"
  }, {
    tag: tags$1.definition(tags$1.propertyName),
    "class": "tok-propertyName tok-definition"
  }, {
    tag: tags$1.typeName,
    "class": "tok-typeName"
  }, {
    tag: tags$1.namespace,
    "class": "tok-namespace"
  }, {
    tag: tags$1.className,
    "class": "tok-className"
  }, {
    tag: tags$1.macroName,
    "class": "tok-macroName"
  }, {
    tag: tags$1.propertyName,
    "class": "tok-propertyName"
  }, {
    tag: tags$1.operator,
    "class": "tok-operator"
  }, {
    tag: tags$1.comment,
    "class": "tok-comment"
  }, {
    tag: tags$1.meta,
    "class": "tok-meta"
  }, {
    tag: tags$1.invalid,
    "class": "tok-invalid"
  }, {
    tag: tags$1.punctuation,
    "class": "tok-punctuation"
  }]);

  var _a;
  /**
  Node prop stored in a parser's top syntax node to provide the
  facet that stores language-specific data for that language.
  */
  var languageDataProp = /*@__PURE__*/new NodeProp();
  /**
  Helper function to define a facet (to be added to the top syntax
  node(s) for a language via
  [`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
  used to associate language data with the language. You
  probably only need this when subclassing
  [`Language`](https://codemirror.net/6/docs/ref/#language.Language).
  */
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? function (values) {
        return values.concat(baseData);
      } : undefined
    });
  }
  /**
  Syntax node prop used to register sublanguages. Should be added to
  the top level node type for the language.
  */
  var sublanguageProp = /*@__PURE__*/new NodeProp();
  /**
  A language object manages parsing and per-language
  [metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
  managed as a [Lezer](https://lezer.codemirror.net) tree. The class
  can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)
  subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or
  via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass
  for stream parsers.
  */
  var Language = /*#__PURE__*/function () {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    function Language(
    /**
    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet
    used for this language.
    */
    data, parser) {
      var extraExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
      _classCallCheck(this, Language);
      this.data = data;
      this.name = name;
      // Kludge to define EditorState.tree as a debugging helper,
      // without the EditorState package actually knowing about
      // languages and lezer trees.
      if (!EditorState.prototype.hasOwnProperty("tree")) Object.defineProperty(EditorState.prototype, "tree", {
        get: function get() {
          return syntaxTree(this);
        }
      });
      this.parser = parser;
      this.extension = [language$1.of(this), EditorState.languageData.of(function (state, pos, side) {
        var top = topNodeAt(state, pos, side),
          data = top.type.prop(languageDataProp);
        if (!data) return [];
        var base = state.facet(data),
          sub = top.type.prop(sublanguageProp);
        if (sub) {
          var innerNode = top.resolve(pos - top.from, side);
          var _iterator = _createForOfIteratorHelper(sub),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var sublang = _step.value;
              if (sublang.test(innerNode, state)) {
                var _data = state.facet(sublang.facet);
                return sublang.type == "replace" ? _data : _data.concat(base);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        return base;
      })].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    _createClass(Language, [{
      key: "isActiveAt",
      value: function isActiveAt(state, pos) {
        var side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
      }
      /**
      Find the document regions that were parsed using this language.
      The returned regions will _include_ any nested languages rooted
      in this language, when those exist.
      */
    }, {
      key: "findRegions",
      value: function findRegions(state) {
        var _this = this;
        var lang = state.facet(language$1);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{
          from: 0,
          to: state.doc.length
        }];
        if (!lang || !lang.allowsNesting) return [];
        var result = [];
        var explore = function explore(tree, from) {
          if (tree.prop(languageDataProp) == _this.data) {
            result.push({
              from: from,
              to: from + tree.length
            });
            return;
          }
          var mount = tree.prop(NodeProp.mounted);
          if (mount) {
            if (mount.tree.prop(languageDataProp) == _this.data) {
              if (mount.overlay) {
                var _iterator2 = _createForOfIteratorHelper(mount.overlay),
                  _step2;
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var r = _step2.value;
                    result.push({
                      from: r.from + from,
                      to: r.to + from
                    });
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
              } else result.push({
                from: from,
                to: from + tree.length
              });
              return;
            } else if (mount.overlay) {
              var size = result.length;
              explore(mount.tree, mount.overlay[0].from + from);
              if (result.length > size) return;
            }
          }
          for (var i = 0; i < tree.children.length; i++) {
            var ch = tree.children[i];
            if (ch instanceof Tree) explore(ch, tree.positions[i] + from);
          }
        };
        explore(syntaxTree(state), 0);
        return result;
      }
      /**
      Indicates whether this language allows nested languages. The
      default implementation returns true.
      */
    }, {
      key: "allowsNesting",
      get: function get() {
        return true;
      }
    }]);
    return Language;
  }();
  /**
  @internal
  */
  Language.setState = /*@__PURE__*/StateEffect.define();
  function topNodeAt(state, pos, side) {
    var topLang = state.facet(language$1),
      tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (var node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers)) if (node.type.isTop) tree = node;
    }
    return tree;
  }
  /**
  A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
  [LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
  parsers.
  */
  var LRLanguage = /*#__PURE__*/function (_Language) {
    _inherits$1(LRLanguage, _Language);
    var _super = _createSuper(LRLanguage);
    function LRLanguage(data, parser, name) {
      var _this2;
      _classCallCheck(this, LRLanguage);
      _this2 = _super.call(this, data, parser, [], name);
      _this2.parser = parser;
      return _this2;
    }
    /**
    Define a language from a parser.
    */
    _createClass(LRLanguage, [{
      key: "configure",
      value:
      /**
      Create a new instance of this language with a reconfigured
      version of its parser and optionally a new name.
      */
      function configure(options, name) {
        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
      }
    }, {
      key: "allowsNesting",
      get: function get() {
        return this.parser.hasWrappers();
      }
    }], [{
      key: "define",
      value: function define(spec) {
        var data = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data, spec.parser.configure({
          props: [languageDataProp.add(function (type) {
            return type.isTop ? data : undefined;
          })]
        }), spec.name);
      }
    }]);
    return LRLanguage;
  }(Language);
  /**
  Get the syntax tree for a state, which is the current (possibly
  incomplete) parse tree of the active
  [language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no
  language available.
  */
  function syntaxTree(state) {
    var field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  /**
  Lezer-style
  [`Input`](https://lezer.codemirror.net/docs/ref#common.Input)
  object for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.
  */
  var DocInput = /*#__PURE__*/function () {
    /**
    Create an input object for the given document.
    */
    function DocInput(doc) {
      _classCallCheck(this, DocInput);
      this.doc = doc;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc.iter();
    }
    _createClass(DocInput, [{
      key: "length",
      get: function get() {
        return this.doc.length;
      }
    }, {
      key: "syncTo",
      value: function syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
      }
    }, {
      key: "chunk",
      value: function chunk(pos) {
        this.syncTo(pos);
        return this.string;
      }
    }, {
      key: "lineChunks",
      get: function get() {
        return true;
      }
    }, {
      key: "read",
      value: function read(from, to) {
        var stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);else return this.string.slice(from - stringStart, to - stringStart);
      }
    }]);
    return DocInput;
  }();
  var currentContext = null;
  /**
  A parse context provided to parsers working on the editor content.
  */
  var ParseContext = /*#__PURE__*/function () {
    function ParseContext(parser,
    /**
    The current editor state.
    */
    state) {
      var fragments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var
      /**
      @internal
      */
      tree = arguments.length > 3 ? arguments[3] : undefined;
      var
      /**
      @internal
      */
      treeLen = arguments.length > 4 ? arguments[4] : undefined;
      var
      /**
      The current editor viewport (or some overapproximation
      thereof). Intended to be used for opportunistically avoiding
      work (in which case
      [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
      should be called to make sure the parser is restarted when the
      skipped region becomes visible).
      */
      viewport = arguments.length > 5 ? arguments[5] : undefined;
      var
      /**
      @internal
      */
      skipped = arguments.length > 6 ? arguments[6] : undefined;
      var
      /**
      This is where skipping parsers can register a promise that,
      when resolved, will schedule a new parse. It is cleared when
      the parse worker picks up the promise. @internal
      */
      scheduleOn = arguments.length > 7 ? arguments[7] : undefined;
      _classCallCheck(this, ParseContext);
      this.parser = parser;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      /**
      @internal
      */
      this.tempSkipped = [];
    }
    /**
    @internal
    */
    _createClass(ParseContext, [{
      key: "startParse",
      value: function startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
      }
      /**
      @internal
      */
    }, {
      key: "work",
      value: function work(until, upto) {
        var _this3 = this;
        if (upto != null && upto >= this.state.doc.length) upto = undefined;
        if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
          this.takeTree();
          return true;
        }
        return this.withContext(function () {
          var _a;
          if (typeof until == "number") {
            var endTime = Date.now() + until;
            until = function until() {
              return Date.now() > endTime;
            };
          }
          if (!_this3.parse) _this3.parse = _this3.startParse();
          if (upto != null && (_this3.parse.stoppedAt == null || _this3.parse.stoppedAt > upto) && upto < _this3.state.doc.length) _this3.parse.stopAt(upto);
          for (;;) {
            var done = _this3.parse.advance();
            if (done) {
              _this3.fragments = _this3.withoutTempSkipped(TreeFragment.addTree(done, _this3.fragments, _this3.parse.stoppedAt != null));
              _this3.treeLen = (_a = _this3.parse.stoppedAt) !== null && _a !== void 0 ? _a : _this3.state.doc.length;
              _this3.tree = done;
              _this3.parse = null;
              if (_this3.treeLen < (upto !== null && upto !== void 0 ? upto : _this3.state.doc.length)) _this3.parse = _this3.startParse();else return true;
            }
            if (until()) return false;
          }
        });
      }
      /**
      @internal
      */
    }, {
      key: "takeTree",
      value: function takeTree() {
        var _this4 = this;
        var pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
          if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);
          this.withContext(function () {
            while (!(tree = _this4.parse.advance())) {}
          });
          this.treeLen = pos;
          this.tree = tree;
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
          this.parse = null;
        }
      }
    }, {
      key: "withContext",
      value: function withContext(f) {
        var prev = currentContext;
        currentContext = this;
        try {
          return f();
        } finally {
          currentContext = prev;
        }
      }
    }, {
      key: "withoutTempSkipped",
      value: function withoutTempSkipped(fragments) {
        for (var r; r = this.tempSkipped.pop();) fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
      }
      /**
      @internal
      */
    }, {
      key: "changes",
      value: function changes(_changes, newState) {
        var fragments = this.fragments,
          tree = this.tree,
          treeLen = this.treeLen,
          viewport = this.viewport,
          skipped = this.skipped;
        this.takeTree();
        if (!_changes.empty) {
          var ranges = [];
          _changes.iterChangedRanges(function (fromA, toA, fromB, toB) {
            return ranges.push({
              fromA: fromA,
              toA: toA,
              fromB: fromB,
              toB: toB
            });
          });
          fragments = TreeFragment.applyChanges(fragments, ranges);
          tree = Tree.empty;
          treeLen = 0;
          viewport = {
            from: _changes.mapPos(viewport.from, -1),
            to: _changes.mapPos(viewport.to, 1)
          };
          if (this.skipped.length) {
            skipped = [];
            var _iterator3 = _createForOfIteratorHelper(this.skipped),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var r = _step3.value;
                var from = _changes.mapPos(r.from, 1),
                  to = _changes.mapPos(r.to, -1);
                if (from < to) skipped.push({
                  from: from,
                  to: to
                });
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
      }
      /**
      @internal
      */
    }, {
      key: "updateViewport",
      value: function updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;
        this.viewport = viewport;
        var startLen = this.skipped.length;
        for (var i = 0; i < this.skipped.length; i++) {
          var _this$skipped$i = this.skipped[i],
            from = _this$skipped$i.from,
            to = _this$skipped$i.to;
          if (from < viewport.to && to > viewport.from) {
            this.fragments = cutFragments(this.fragments, from, to);
            this.skipped.splice(i--, 1);
          }
        }
        if (this.skipped.length >= startLen) return false;
        this.reset();
        return true;
      }
      /**
      @internal
      */
    }, {
      key: "reset",
      value: function reset() {
        if (this.parse) {
          this.takeTree();
          this.parse = null;
        }
      }
      /**
      Notify the parse scheduler that the given region was skipped
      because it wasn't in view, and the parse should be restarted
      when it comes into view.
      */
    }, {
      key: "skipUntilInView",
      value: function skipUntilInView(from, to) {
        this.skipped.push({
          from: from,
          to: to
        });
      }
      /**
      Returns a parser intended to be used as placeholder when
      asynchronously loading a nested parser. It'll skip its input and
      mark it as not-really-parsed, so that the next update will parse
      it again.
      
      When `until` is given, a reparse will be scheduled when that
      promise resolves.
      */
    }, {
      key: "isDone",
      value:
      /**
      @internal
      */
      function isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        var frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
      }
      /**
      Get the context for the current parse, or `null` if no editor
      parse is in progress.
      */
    }], [{
      key: "create",
      value: function create(parser, state, viewport) {
        return new ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);
      }
    }, {
      key: "getSkippingParser",
      value: function getSkippingParser(until) {
        return new ( /*#__PURE__*/function (_Parser) {
          _inherits$1(_class, _Parser);
          var _super2 = _createSuper(_class);
          function _class() {
            _classCallCheck(this, _class);
            return _super2.apply(this, arguments);
          }
          _createClass(_class, [{
            key: "createParse",
            value: function createParse(input, fragments, ranges) {
              var from = ranges[0].from,
                to = ranges[ranges.length - 1].to;
              var parser = {
                parsedPos: from,
                advance: function advance() {
                  var cx = currentContext;
                  if (cx) {
                    var _iterator4 = _createForOfIteratorHelper(ranges),
                      _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                        var r = _step4.value;
                        cx.tempSkipped.push(r);
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                  }
                  this.parsedPos = to;
                  return new Tree(NodeType.none, [], [], to - from);
                },
                stoppedAt: null,
                stopAt: function stopAt() {}
              };
              return parser;
            }
          }]);
          return _class;
        }(Parser))();
      }
    }, {
      key: "get",
      value: function get() {
        return currentContext;
      }
    }]);
    return ParseContext;
  }();
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{
      fromA: from,
      toA: to,
      fromB: from,
      toB: to
    }]);
  }
  var LanguageState = /*#__PURE__*/function () {
    function LanguageState(
    // A mutable parse state that is used to preserve work done during
    // the lifetime of a state when moving to the next state.
    context) {
      _classCallCheck(this, LanguageState);
      this.context = context;
      this.tree = context.tree;
    }
    _createClass(LanguageState, [{
      key: "apply",
      value: function apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree) return this;
        var newCx = this.context.changes(tr.changes, tr.state);
        // If the previous parse wasn't done, go forward only up to its
        // end position or the end of the viewport, to avoid slowing down
        // state updates with parse work beyond the viewport.
        var upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20 /* Apply */, upto)) newCx.takeTree();
        return new LanguageState(newCx);
      }
    }], [{
      key: "init",
      value: function init(state) {
        var vpTo = Math.min(3000 /* InitViewport */, state.doc.length);
        var parseState = ParseContext.create(state.facet(language$1).parser, state, {
          from: 0,
          to: vpTo
        });
        if (!parseState.work(20 /* Apply */, vpTo)) parseState.takeTree();
        return new LanguageState(parseState);
      }
    }]);
    return LanguageState;
  }();
  Language.state = /*@__PURE__*/StateField.define({
    create: LanguageState.init,
    update: function update(value, tr) {
      var _iterator5 = _createForOfIteratorHelper(tr.effects),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var e = _step5.value;
          if (e.is(Language.setState)) return e.value;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (tr.startState.facet(language$1) != tr.state.facet(language$1)) return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = function requestIdle(callback) {
    var timeout = setTimeout(function () {
      return callback();
    }, 500 /* MaxPause */);
    return function () {
      return clearTimeout(timeout);
    };
  };
  if (typeof requestIdleCallback != "undefined") requestIdle = function requestIdle(callback) {
    var idle = -1,
      timeout = setTimeout(function () {
        idle = requestIdleCallback(callback, {
          timeout: 500 /* MaxPause */ - 100 /* MinPause */
        });
      }, 100 /* MinPause */);
    return function () {
      return idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? function () {
    return navigator.scheduling.isInputPending();
  } : null;
  var parseWorker = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {
    function ParseWorker(view) {
      _classCallCheck(this, ParseWorker);
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      // End of the current time chunk
      this.chunkEnd = -1;
      // Milliseconds of budget left for this chunk
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    _createClass(ParseWorker, [{
      key: "update",
      value: function update(_update) {
        var cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(_update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();
        if (_update.docChanged) {
          if (this.view.hasFocus) this.chunkBudget += 50 /* ChangeBonus */;
          this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
      }
    }, {
      key: "scheduleWork",
      value: function scheduleWork() {
        if (this.working) return;
        var state = this.view.state,
          field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);
      }
    }, {
      key: "work",
      value: function work(deadline) {
        this.working = null;
        var now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
          // Start a new chunk
          this.chunkEnd = now + 30000 /* ChunkTime */;
          this.chunkBudget = 3000 /* ChunkBudget */;
        }

        if (this.chunkBudget <= 0) return; // No more budget
        var _this$view = this.view,
          state = _this$view.state,
          vpTo = _this$view.viewport.to,
          field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* MaxParseAhead */)) return;
        var endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Slice */, deadline && !isInputPending ? Math.max(25 /* MinSlice */, deadline.timeRemaining() - 5) : 1e9);
        var viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
        var done = field.context.work(function () {
          return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 100000 /* MaxParseAhead */));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
          field.context.takeTree();
          this.view.dispatch({
            effects: Language.setState.of(new LanguageState(field.context))
          });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();
        this.checkAsyncSchedule(field.context);
      }
    }, {
      key: "checkAsyncSchedule",
      value: function checkAsyncSchedule(cx) {
        var _this5 = this;
        if (cx.scheduleOn) {
          this.workScheduled++;
          cx.scheduleOn.then(function () {
            return _this5.scheduleWork();
          })["catch"](function (err) {
            return logException(_this5.view.state, err);
          }).then(function () {
            return _this5.workScheduled--;
          });
          cx.scheduleOn = null;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.working) this.working();
      }
    }, {
      key: "isWorking",
      value: function isWorking() {
        return !!(this.working || this.workScheduled > 0);
      }
    }]);
    return ParseWorker;
  }(), {
    eventHandlers: {
      focus: function focus() {
        this.scheduleWork();
      }
    }
  });
  /**
  The facet used to associate a language with an editor state. Used
  by `Language` object's `extension` property (so you don't need to
  manually wrap your languages in this). Can be used to access the
  current language on a state.
  */
  var language$1 = /*@__PURE__*/Facet.define({
    combine: function combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: function enables(language) {
      return [Language.state, parseWorker, EditorView.contentAttributes.compute([language], function (state) {
        var lang = state.facet(language);
        return lang && lang.name ? {
          "data-language": lang.name
        } : {};
      })];
    }
  });
  /**
  This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an
  optional set of supporting extensions. Language packages are
  encouraged to export a function that optionally takes a
  configuration object and returns a `LanguageSupport` instance, as
  the main way for client code to use the package.
  */
  var LanguageSupport = /*#__PURE__*/_createClass(
  /**
  Create a language support object.
  */
  function LanguageSupport(
  /**
  The language object.
  */
  language) {
    var support = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    _classCallCheck(this, LanguageSupport);
    this.language = language;
    this.support = support;
    this.extension = [language, support];
  });
  /**
  Facet that defines a way to provide a function that computes the
  appropriate indentation depth, as a column number (see
  [`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given
  line. A return value of `null` indicates no indentation can be
  determined, and the line should inherit the indentation of the one
  above it. A return value of `undefined` defers to the next indent
  service.
  */
  var indentService = /*@__PURE__*/Facet.define();
  /**
  Facet for overriding the unit by which indentation happens. Should
  be a string consisting either entirely of the same whitespace
  character. When not set, this defaults to 2 spaces.
  */
  var indentUnit = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      if (!values.length) return "  ";
      var unit = values[0];
      if (!unit || /\S/.test(unit) || Array.from(unit).some(function (e) {
        return e != unit[0];
      })) throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return unit;
    }
  });
  /**
  Return the _column width_ of an indent unit in the state.
  Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
  facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
  contains tabs.
  */
  function getIndentUnit(state) {
    var unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  /**
  Create an indentation string that covers columns 0 to `cols`.
  Will use tabs for as much of the columns as possible when the
  [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
  tabs.
  */
  function indentString(state, cols) {
    var result = "",
      ts = state.tabSize,
      ch = state.facet(indentUnit)[0];
    if (ch == "\t") {
      while (cols >= ts) {
        result += "\t";
        cols -= ts;
      }
      ch = " ";
    }
    for (var i = 0; i < cols; i++) result += ch;
    return result;
  }
  /**
  Get the indentation, as a column number, at the given position.
  Will first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)
  that are registered, and if none of those return an indentation,
  this will check the syntax tree for the [indent node
  prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a
  number when an indentation could be determined, and null
  otherwise.
  */
  function getIndentation(context, pos) {
    if (context instanceof EditorState) context = new IndentContext(context);
    var _iterator11 = _createForOfIteratorHelper(context.state.facet(indentService)),
      _step11;
    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var service = _step11.value;
        var result = service(context, pos);
        if (result !== undefined) return result;
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }
    var tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
  }
  /**
  Indentation contexts are used when calling [indentation
  services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
  useful in indentation logic, and can selectively override the
  indentation reported for some lines.
  */
  var IndentContext = /*#__PURE__*/function () {
    /**
    Create an indent context.
    */
    function IndentContext(
    /**
    The editor state.
    */
    state) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, IndentContext);
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    _createClass(IndentContext, [{
      key: "lineAt",
      value: function lineAt(pos) {
        var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var line = this.state.doc.lineAt(pos);
        var _this$options = this.options,
          simulateBreak = _this$options.simulateBreak,
          simulateDoubleBreak = _this$options.simulateDoubleBreak;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
          if (simulateDoubleBreak && simulateBreak == pos) return {
            text: "",
            from: pos
          };else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {
            text: line.text.slice(simulateBreak - line.from),
            from: simulateBreak
          };else return {
            text: line.text.slice(0, simulateBreak - line.from),
            from: line.from
          };
        }
        return line;
      }
      /**
      Get the text directly after `pos`, either the entire line
      or the next 100 characters, whichever is shorter.
      */
    }, {
      key: "textAfterPos",
      value: function textAfterPos(pos) {
        var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return "";
        var _this$lineAt = this.lineAt(pos, bias),
          text = _this$lineAt.text,
          from = _this$lineAt.from;
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
      }
      /**
      Find the column for the given position.
      */
    }, {
      key: "column",
      value: function column(pos) {
        var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var _this$lineAt2 = this.lineAt(pos, bias),
          text = _this$lineAt2.text,
          from = _this$lineAt2.from;
        var result = this.countColumn(text, pos - from);
        var override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
        if (override > -1) result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
      }
      /**
      Find the column position (taking tabs into account) of the given
      position in the given string.
      */
    }, {
      key: "countColumn",
      value: function countColumn$1(line) {
        var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : line.length;
        return countColumn(line, this.state.tabSize, pos);
      }
      /**
      Find the indentation column of the line at the given point.
      */
    }, {
      key: "lineIndent",
      value: function lineIndent(pos) {
        var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var _this$lineAt3 = this.lineAt(pos, bias),
          text = _this$lineAt3.text,
          from = _this$lineAt3.from;
        var override = this.options.overrideIndentation;
        if (override) {
          var overriden = override(from);
          if (overriden > -1) return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
      }
      /**
      Returns the [simulated line
      break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
      for this context, if any.
      */
    }, {
      key: "simulatedBreak",
      get: function get() {
        return this.options.simulateBreak || null;
      }
    }]);
    return IndentContext;
  }();
  /**
  A syntax tree node prop used to associate indentation strategies
  with node types. Such a strategy is a function from an indentation
  context to a column number (see also
  [`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null
  indicates that no definitive indentation can be determined.
  */
  var indentNodeProp = /*@__PURE__*/new NodeProp();
  // Compute the indentation for a given position from the syntax tree.
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    var strategy = tree.type.prop(indentNodeProp);
    if (strategy) return strategy;
    var first = tree.firstChild,
      close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      var last = tree.lastChild,
        closed = last && close.indexOf(last.name) > -1;
      return function (cx) {
        return delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
      };
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base) {
    for (; node; node = node.parent) {
      var strategy = indentStrategy(node);
      if (strategy) return strategy(TreeIndentContext.create(base, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  /**
  Objects of this type provide context information and helper
  methods to indentation functions registered on syntax nodes.
  */
  var TreeIndentContext = /*#__PURE__*/function (_IndentContext) {
    _inherits$1(TreeIndentContext, _IndentContext);
    var _super3 = _createSuper(TreeIndentContext);
    function TreeIndentContext(base,
    /**
    The position at which indentation is being computed.
    */
    pos,
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    node) {
      var _this7;
      _classCallCheck(this, TreeIndentContext);
      _this7 = _super3.call(this, base.state, base.options);
      _this7.base = base;
      _this7.pos = pos;
      _this7.node = node;
      return _this7;
    }
    /**
    @internal
    */
    _createClass(TreeIndentContext, [{
      key: "textAfter",
      get:
      /**
      Get the text directly after `this.pos`, either the entire line
      or the next 100 characters, whichever is shorter.
      */
      function get() {
        return this.textAfterPos(this.pos);
      }
      /**
      Get the indentation at the reference line for `this.node`, which
      is the line on which it starts, unless there is a node that is
      _not_ a parent of this node covering the start of that line. If
      so, the line at the start of that node is tried, again skipping
      on if it is covered by another such node.
      */
    }, {
      key: "baseIndent",
      get: function get() {
        return this.baseIndentFor(this.node);
      }
      /**
      Get the indentation for the reference line of the given node
      (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
      */
    }, {
      key: "baseIndentFor",
      value: function baseIndentFor(node) {
        var line = this.state.doc.lineAt(node.from);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
          var atBreak = node.resolve(line.from);
          while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;
          if (isParent(atBreak, node)) break;
          line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
      }
      /**
      Continue looking for indentations in the node's parent nodes,
      and return the result of that.
      */
    }, {
      key: "continue",
      value: function _continue() {
        var parent = this.node.parent;
        return parent ? indentFrom(parent, this.pos, this.base) : 0;
      }
    }], [{
      key: "create",
      value: function create(base, pos, node) {
        return new TreeIndentContext(base, pos, node);
      }
    }]);
    return TreeIndentContext;
  }(IndentContext);
  function isParent(parent, of) {
    for (var cur = of; cur; cur = cur.parent) if (parent == cur) return true;
    return false;
  }
  // Check whether a delimited node is aligned (meaning there are
  // non-skipped nodes on the same line as the opening delimiter). And
  // if so, return the opening token.
  function bracketedAligned(context) {
    var tree = context.node;
    var openToken = tree.childAfter(tree.from),
      last = tree.lastChild;
    if (!openToken) return null;
    var sim = context.options.simulateBreak;
    var openLine = context.state.doc.lineAt(openToken.from);
    var lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (var pos = openToken.to;;) {
      var next = tree.childAfter(pos);
      if (!next || next == last) return null;
      if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  /**
  An indentation strategy for delimited (usually bracketed) nodes.
  Will, by default, indent one unit more than the parent's base
  indent unless the line starts with a closing token. When `align`
  is true and there are non-skipped nodes on the node's opening
  line, the content of the node will be aligned with the end of the
  opening node, like this:

      foo(bar,
          baz)
  */
  function delimitedIndent(_ref) {
    var closing = _ref.closing,
      _ref$align = _ref.align,
      align = _ref$align === void 0 ? true : _ref$align,
      _ref$units = _ref.units,
      units = _ref$units === void 0 ? 1 : _ref$units;
    return function (context) {
      return delimitedStrategy(context, align, units, closing);
    };
  }
  function delimitedStrategy(context, align, units, closing, closedAt) {
    var after = context.textAfter,
      space = after.match(/^\s*/)[0].length;
    var closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    var aligned = align ? bracketedAligned(context) : null;
    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  /**
  Creates an indentation strategy that, by default, indents
  continued lines one unit more than the node's base indentation.
  You can provide `except` to prevent indentation of lines that
  match a pattern (for example `/^else\b/` in `if`/`else`
  constructs), and you can change the amount of units used with the
  `units` option.
  */
  function continuedIndent() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      except = _ref2.except,
      _ref2$units = _ref2.units,
      units = _ref2$units === void 0 ? 1 : _ref2$units;
    return function (context) {
      var matchExcept = except && except.test(context.textAfter);
      return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
  }
  var DontIndentBeyond = 200;
  /**
  Enables reindentation on input. When a language defines an
  `indentOnInput` field in its [language
  data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
  expression, the line at the cursor will be reindented whenever new
  text is typed and the input from the start of the line up to the
  cursor matches that regexp.

  To avoid unneccesary reindents, it is recommended to start the
  regexp with `^` (usually followed by `\s*`), and end it with `$`.
  For example, `/^\s*\}$/` will reindent when a closing brace is
  added at the start of a line.
  */
  function indentOnInput() {
    return EditorState.transactionFilter.of(function (tr) {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete")) return tr;
      var rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length) return tr;
      var doc = tr.newDoc,
        head = tr.newSelection.main.head,
        line = doc.lineAt(head);
      if (head > line.from + DontIndentBeyond) return tr;
      var lineStart = doc.sliceString(line.from, head);
      if (!rules.some(function (r) {
        return r.test(lineStart);
      })) return tr;
      var state = tr.state,
        last = -1,
        changes = [];
      var _iterator12 = _createForOfIteratorHelper(state.selection.ranges),
        _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var _head = _step12.value.head;
          var _line = state.doc.lineAt(_head);
          if (_line.from == last) continue;
          last = _line.from;
          var indent = getIndentation(state, _line.from);
          if (indent == null) continue;
          var cur = /^\s*/.exec(_line.text)[0];
          var norm = indentString(state, indent);
          if (cur != norm) changes.push({
            from: _line.from,
            to: _line.from + cur.length,
            insert: norm
          });
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
      return changes.length ? [tr, {
        changes: changes,
        sequential: true
      }] : tr;
    });
  }
  /**
  This node prop is used to associate folding information with
  syntax node types. Given a syntax node, it should check whether
  that tree is foldable and return the range that can be collapsed
  when it is.
  */
  var foldNodeProp = /*@__PURE__*/new NodeProp();
  /**
  [Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
  the first and the last child of a syntax node. Useful for nodes
  that start and end with delimiters.
  */
  function foldInside(node) {
    var first = node.firstChild,
      last = node.lastChild;
    return first && first.to < last.from ? {
      from: first.to,
      to: last.type.isError ? node.to : last.from
    } : null;
  }

  /**
  A highlight style associates CSS styles with higlighting
  [tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).
  */
  var HighlightStyle = /*#__PURE__*/function () {
    function HighlightStyle(
    /**
    The tag styles used to create this highlight style.
    */
    specs, options) {
      _classCallCheck(this, HighlightStyle);
      this.specs = specs;
      var modSpec;
      function def(spec) {
        var cls = StyleModule.newName();
        (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
        return cls;
      }
      var all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
      var scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? function (type) {
        return type.prop(languageDataProp) == scopeOpt.data;
      } : scopeOpt ? function (type) {
        return type == scopeOpt;
      } : undefined;
      this.style = tagHighlighter(specs.map(function (style) {
        return {
          tag: style.tag,
          "class": style["class"] || def(Object.assign({}, style, {
            tag: null
          }))
        };
      }), {
        all: all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    _createClass(HighlightStyle, null, [{
      key: "define",
      value: function define(specs, options) {
        return new HighlightStyle(specs, options || {});
      }
    }]);
    return HighlightStyle;
  }();
  var highlighterFacet = /*@__PURE__*/Facet.define();
  var fallbackHighlighter = /*@__PURE__*/Facet.define({
    combine: function combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state) {
    var main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  /**
  Wrap a highlighter in an editor extension that uses it to apply
  syntax highlighting to the editor content.

  When multiple (non-fallback) styles are provided, the styling
  applied is the union of the classes they emit.
  */
  function syntaxHighlighting(highlighter, options) {
    var ext = [treeHighlighter],
      themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module) ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));else if (themeType) ext.push(highlighterFacet.computeN([EditorView.darkTheme], function (state) {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));else ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = /*#__PURE__*/function () {
    function TreeHighlighter(view) {
      _classCallCheck(this, TreeHighlighter);
      this.markCache = Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    _createClass(TreeHighlighter, [{
      key: "update",
      value: function update(_update3) {
        var tree = syntaxTree(_update3.state),
          highlighters = getHighlighters(_update3.state);
        var styleChange = highlighters != getHighlighters(_update3.startState);
        if (tree.length < _update3.view.viewport.to && !styleChange && tree.type == this.tree.type) {
          this.decorations = this.decorations.map(_update3.changes);
        } else if (tree != this.tree || _update3.viewportChanged || styleChange) {
          this.tree = tree;
          this.decorations = this.buildDeco(_update3.view, highlighters);
        }
      }
    }, {
      key: "buildDeco",
      value: function buildDeco(view, highlighters) {
        var _this9 = this;
        if (!highlighters || !this.tree.length) return Decoration.none;
        var builder = new RangeSetBuilder();
        var _iterator21 = _createForOfIteratorHelper(view.visibleRanges),
          _step21;
        try {
          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
            var _step21$value = _step21.value,
              from = _step21$value.from,
              to = _step21$value.to;
            highlightTree(this.tree, highlighters, function (from, to, style) {
              builder.add(from, to, _this9.markCache[style] || (_this9.markCache[style] = Decoration.mark({
                "class": style
              })));
            }, from, to);
          }
        } catch (err) {
          _iterator21.e(err);
        } finally {
          _iterator21.f();
        }
        return builder.finish();
      }
    }]);
    return TreeHighlighter;
  }();
  var treeHighlighter = /*@__PURE__*/Prec.high( /*@__PURE__*/ViewPlugin.fromClass(TreeHighlighter, {
    decorations: function decorations(v) {
      return v.decorations;
    }
  }));
  /**
  A default highlight style (works well with light themes).
  */
  /*@__PURE__*/HighlightStyle.define([{
    tag: tags$1.meta,
    color: "#404740"
  }, {
    tag: tags$1.link,
    textDecoration: "underline"
  }, {
    tag: tags$1.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  }, {
    tag: tags$1.emphasis,
    fontStyle: "italic"
  }, {
    tag: tags$1.strong,
    fontWeight: "bold"
  }, {
    tag: tags$1.strikethrough,
    textDecoration: "line-through"
  }, {
    tag: tags$1.keyword,
    color: "#708"
  }, {
    tag: [tags$1.atom, tags$1.bool, tags$1.url, tags$1.contentSeparator, tags$1.labelName],
    color: "#219"
  }, {
    tag: [tags$1.literal, tags$1.inserted],
    color: "#164"
  }, {
    tag: [tags$1.string, tags$1.deleted],
    color: "#a11"
  }, {
    tag: [tags$1.regexp, tags$1.escape, /*@__PURE__*/tags$1.special(tags$1.string)],
    color: "#e40"
  }, {
    tag: /*@__PURE__*/tags$1.definition(tags$1.variableName),
    color: "#00f"
  }, {
    tag: /*@__PURE__*/tags$1.local(tags$1.variableName),
    color: "#30a"
  }, {
    tag: [tags$1.typeName, tags$1.namespace],
    color: "#085"
  }, {
    tag: tags$1.className,
    color: "#167"
  }, {
    tag: [/*@__PURE__*/tags$1.special(tags$1.variableName), tags$1.macroName],
    color: "#256"
  }, {
    tag: /*@__PURE__*/tags$1.definition(tags$1.propertyName),
    color: "#00c"
  }, {
    tag: tags$1.comment,
    color: "#940"
  }, {
    tag: tags$1.invalid,
    color: "#f00"
  }]);
  var baseTheme$3 = /*@__PURE__*/EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: "#328c8252"
    },
    "&.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bb555544"
    }
  });
  var DefaultScanDist = 10000,
    DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /*@__PURE__*/Facet.define({
    combine: function combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /*@__PURE__*/Decoration.mark({
      "class": "cm-matchingBracket"
    }),
    nonmatchingMark = /*@__PURE__*/Decoration.mark({
      "class": "cm-nonmatchingBracket"
    });
  function defaultRenderMatch(match) {
    var decorations = [];
    var mark = match.matched ? matchingMark : nonmatchingMark;
    decorations.push(mark.range(match.start.from, match.start.to));
    if (match.end) decorations.push(mark.range(match.end.from, match.end.to));
    return decorations;
  }
  var bracketMatchingState = /*@__PURE__*/StateField.define({
    create: function create() {
      return Decoration.none;
    },
    update: function update(deco, tr) {
      if (!tr.docChanged && !tr.selection) return deco;
      var decorations = [];
      var config = tr.state.facet(bracketMatchingConfig);
      var _iterator22 = _createForOfIteratorHelper(tr.state.selection.ranges),
        _step22;
      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var range = _step22.value;
          if (!range.empty) continue;
          var match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));
          if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
      return Decoration.set(decorations, true);
    },
    provide: function provide(f) {
      return EditorView.decorations.from(f);
    }
  });
  var bracketMatchingUnique = [bracketMatchingState, baseTheme$3];
  /**
  Create an extension that enables bracket matching. Whenever the
  cursor is next to a bracket, that bracket and the one it matches
  are highlighted. Or, when no matching bracket is found, another
  highlighting style is used to indicate this.
  */
  function bracketMatching() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
  }
  /**
  When larger syntax nodes, such as HTML tags, are marked as
  opening/closing, it can be a bit messy to treat the whole node as
  a matchable bracket. This node prop allows you to define, for such
  a node, a handlethe part of the node that is highlighted, and
  that the cursor must be on to activate highlighting in the first
  place.
  */
  var bracketMatchingHandle = /*@__PURE__*/new NodeProp();
  function matchingNodes(node, dir, brackets) {
    var byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp) return byProp;
    if (node.name.length == 1) {
      var index = brackets.indexOf(node.name);
      if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];
    }
    return null;
  }
  function findHandle(node) {
    var hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
  }
  /**
  Find the matching bracket for the token at `pos`, scanning
  direction `dir`. Only the `brackets` and `maxScanDistance`
  properties are used from `config`, if given. Returns null if no
  bracket was found at `pos`, or a match result otherwise.
  */
  function matchBrackets(state, pos, dir) {
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var maxScanDistance = config.maxScanDistance || DefaultScanDist,
      brackets = config.brackets || DefaultBrackets;
    var tree = syntaxTree(state),
      node = tree.resolveInner(pos, dir);
    for (var cur = node; cur; cur = cur.parent) {
      var matches = matchingNodes(cur.type, dir, brackets);
      if (matches && cur.from < cur.to) {
        var handle = findHandle(cur);
        if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
      }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    var parent = token.parent,
      firstToken = {
        from: handle.from,
        to: handle.to
      };
    var depth = 0,
      cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {
      if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
          var endHandle = findHandle(cursor);
          return {
            start: firstToken,
            end: endHandle ? {
              from: endHandle.from,
              to: endHandle.to
            } : undefined,
            matched: true
          };
        } else if (matchingNodes(cursor.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor.type, -dir, brackets)) {
          if (depth == 0) {
            var _endHandle = findHandle(cursor);
            return {
              start: firstToken,
              end: _endHandle && _endHandle.from < _endHandle.to ? {
                from: _endHandle.from,
                to: _endHandle.to
              } : undefined,
              matched: false
            };
          }
          depth--;
        }
      }
    } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return {
      start: firstToken,
      matched: false
    };
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    var startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    var bracket = brackets.indexOf(startCh);
    if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;
    var startToken = {
      from: dir < 0 ? pos - 1 : pos,
      to: dir > 0 ? pos + 1 : pos
    };
    var iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),
      depth = 0;
    for (var distance = 0; !iter.next().done && distance <= maxScanDistance;) {
      var text = iter.value;
      if (dir < 0) distance += text.length;
      var basePos = pos + distance * dir;
      for (var _pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; _pos2 != end; _pos2 += dir) {
        var found = brackets.indexOf(text[_pos2]);
        if (found < 0 || tree.resolveInner(basePos + _pos2, 1).type != tokenType) continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          // Closing
          return {
            start: startToken,
            end: {
              from: basePos + _pos2,
              to: basePos + _pos2 + 1
            },
            matched: found >> 1 == bracket >> 1
          };
        } else {
          depth--;
        }
      }
      if (dir > 0) distance += text.length;
    }
    return iter.done ? {
      start: startToken,
      matched: false
    } : null;
  }
  var noTokens = /*@__PURE__*/Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /*@__PURE__*/Object.create(null);
  for (var _i = 0, _arr = [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]]; _i < _arr.length; _i++) {
    var _arr$_i = _slicedToArray$1(_arr[_i], 2),
      legacyName = _arr$_i[0],
      name = _arr$_i[1];
    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);
  }
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1) return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    var tag = null;
    var _iterator24 = _createForOfIteratorHelper(tagStr.split(".")),
      _step24;
    try {
      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
        var part = _step24.value;
        var value = extra[part] || tags$1[part];
        if (!value) {
          warnForPart(part, "Unknown highlighting tag ".concat(part));
        } else if (typeof value == "function") {
          if (!tag) warnForPart(part, "Modifier ".concat(part, " used at start of tag"));else tag = value(tag);
        } else {
          if (tag) warnForPart(part, "Tag ".concat(part, " used as modifier"));else tag = value;
        }
      }
    } catch (err) {
      _iterator24.e(err);
    } finally {
      _iterator24.f();
    }
    if (!tag) return 0;
    var name = tagStr.replace(/ /g, "_"),
      type = NodeType.define({
        id: typeArray.length,
        name: name,
        props: [styleTags(_defineProperty$M({}, name, tag))]
      });
    typeArray.push(type);
    return type.id;
  }

  /**
  An instance of this is passed to completion source functions.
  */
  var CompletionContext = /*#__PURE__*/function () {
    /**
    Create a new completion context. (Mostly useful for testing
    completion sourcesin the editor, the extension will create
    these for you.)
    */
    function CompletionContext(
    /**
    The editor state that the completion happens in.
    */
    state,
    /**
    The position at which the completion is happening.
    */
    pos,
    /**
    Indicates whether completion was activated explicitly, or
    implicitly by typing. The usual way to respond to this is to
    only return completions when either there is part of a
    completable entity before the cursor, or `explicit` is true.
    */
    explicit) {
      _classCallCheck(this, CompletionContext);
      this.state = state;
      this.pos = pos;
      this.explicit = explicit;
      /**
      @internal
      */
      this.abortListeners = [];
    }
    /**
    Get the extent, content, and (if there is a token) type of the
    token before `this.pos`.
    */
    _createClass(CompletionContext, [{
      key: "tokenBefore",
      value: function tokenBefore(types) {
        var token = syntaxTree(this.state).resolveInner(this.pos, -1);
        while (token && types.indexOf(token.name) < 0) token = token.parent;
        return token ? {
          from: token.from,
          to: this.pos,
          text: this.state.sliceDoc(token.from, this.pos),
          type: token.type
        } : null;
      }
      /**
      Get the match of the given expression directly before the
      cursor.
      */
    }, {
      key: "matchBefore",
      value: function matchBefore(expr) {
        var line = this.state.doc.lineAt(this.pos);
        var start = Math.max(line.from, this.pos - 250);
        var str = line.text.slice(start - line.from, this.pos - line.from);
        var found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : {
          from: start + found,
          to: this.pos,
          text: str.slice(found)
        };
      }
      /**
      Yields true when the query has been aborted. Can be useful in
      asynchronous queries to avoid doing work that will be ignored.
      */
    }, {
      key: "aborted",
      get: function get() {
        return this.abortListeners == null;
      }
      /**
      Allows you to register abort handlers, which will be called when
      the query is
      [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
      */
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        if (type == "abort" && this.abortListeners) this.abortListeners.push(listener);
      }
    }]);
    return CompletionContext;
  }();
  function toSet(chars) {
    var flat = Object.keys(chars).join("");
    var words = /\w/.test(flat);
    if (words) flat = flat.replace(/\w/g, "");
    return "[".concat(words ? "\\w" : "").concat(flat.replace(/[^\w\s]/g, "\\$&"), "]");
  }
  function prefixMatch(options) {
    var first = Object.create(null),
      rest = Object.create(null);
    var _iterator = _createForOfIteratorHelper(options),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var label = _step.value.label;
        first[label[0]] = true;
        for (var i = 1; i < label.length; i++) rest[label[i]] = true;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
  }
  /**
  Given a a fixed array of options, return an autocompleter that
  completes them.
  */
  function completeFromList(list) {
    var options = list.map(function (o) {
      return typeof o == "string" ? {
        label: o
      } : o;
    });
    var _ref = options.every(function (o) {
        return /^\w+$/.test(o.label);
      }) ? [/\w*$/, /\w+$/] : prefixMatch(options),
      _ref2 = _slicedToArray$1(_ref, 2),
      validFor = _ref2[0],
      match = _ref2[1];
    return function (context) {
      var token = context.matchBefore(match);
      return token || context.explicit ? {
        from: token ? token.from : context.pos,
        options: options,
        validFor: validFor
      } : null;
    };
  }
  var Option = /*#__PURE__*/_createClass(function Option(completion, source, match, score) {
    _classCallCheck(this, Option);
    this.completion = completion;
    this.source = source;
    this.match = match;
    this.score = score;
  });
  function cur(state) {
    return state.selection.main.from;
  }
  // Make sure the given regexp has a $ at its end and, if `start` is
  // true, a ^ at its start.
  function ensureAnchor(expr, start) {
    var _a;
    var source = expr.source;
    var addStart = start && source[0] != "^",
      addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd) return expr;
    return new RegExp("".concat(addStart ? "^" : "", "(?:").concat(source, ")").concat(addEnd ? "$" : ""), (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
  }
  /**
  This annotation is added to transactions that are produced by
  picking a completion.
  */
  var pickedCompletion = /*@__PURE__*/Annotation.define();
  /**
  Helper function that returns a transaction spec which inserts a
  completion's text in the main selection range, and any other
  selection range that has the same text in front of it.
  */
  function insertCompletionText(state, text, from, to) {
    var main = state.selection.main,
      fromOff = from - main.from,
      toOff = to - main.from;
    return Object.assign(Object.assign({}, state.changeByRange(function (range) {
      if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {
        range: range
      };
      return {
        changes: {
          from: range.from + fromOff,
          to: to == main.from ? range.to : range.from + toOff,
          insert: text
        },
        range: EditorSelection.cursor(range.from + fromOff + text.length)
      };
    })), {
      scrollIntoView: true,
      userEvent: "input.complete"
    });
  }
  var SourceCache = /*@__PURE__*/new WeakMap();
  function asSource(source) {
    if (!Array.isArray(source)) return source;
    var known = SourceCache.get(source);
    if (!known) SourceCache.set(source, known = completeFromList(source));
    return known;
  }
  var startCompletionEffect = /*@__PURE__*/StateEffect.define();
  var closeCompletionEffect = /*@__PURE__*/StateEffect.define();

  // A pattern matcher for fuzzy completion matching. Create an instance
  // once for a pattern, and then use that to match any number of
  // completions.
  var FuzzyMatcher = /*#__PURE__*/function () {
    function FuzzyMatcher(pattern) {
      _classCallCheck(this, FuzzyMatcher);
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      // Buffers reused by calls to `match` to track matched character
      // positions.
      this.any = [];
      this.precise = [];
      this.byWord = [];
      this.score = 0;
      this.matched = [];
      for (var p = 0; p < pattern.length;) {
        var _char = codePointAt(pattern, p),
          size = codePointSize(_char);
        this.chars.push(_char);
        var part = pattern.slice(p, p + size),
          upper = part.toUpperCase();
        this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
        p += size;
      }
      this.astral = pattern.length != this.chars.length;
    }
    _createClass(FuzzyMatcher, [{
      key: "ret",
      value: function ret(score, matched) {
        this.score = score;
        this.matched = matched;
        return true;
      }
      // Matches a given word (completion) against the pattern (input).
      // Will return a boolean indicating whether there was a match and,
      // on success, set `this.score` to the score, `this.matched` to an
      // array of `from, to` pairs indicating the matched parts of `word`.
      //
      // The score is a number that is more negative the worse the match
      // is. See `Penalty` above.
    }, {
      key: "match",
      value: function match(word) {
        if (this.pattern.length == 0) return this.ret(-100 /* Penalty.NotFull */, []);
        if (word.length < this.pattern.length) return false;
        var chars = this.chars,
          folded = this.folded,
          any = this.any,
          precise = this.precise,
          byWord = this.byWord;
        // For single-character queries, only match when they occur right
        // at the start
        if (chars.length == 1) {
          var first = codePointAt(word, 0),
            firstSize = codePointSize(first);
          var _score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */;
          if (first == chars[0]) ;else if (first == folded[0]) _score += -200 /* Penalty.CaseFold */;else return false;
          return this.ret(_score, [0, firstSize]);
        }
        var direct = word.indexOf(this.pattern);
        if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */, [0, this.pattern.length]);
        var len = chars.length,
          anyTo = 0;
        if (direct < 0) {
          for (var i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
            var next = codePointAt(word, i);
            if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;
            i += codePointSize(next);
          }
          // No match, exit immediately
          if (anyTo < len) return false;
        }
        // This tracks the extent of the precise (non-folded, not
        // necessarily adjacent) match
        var preciseTo = 0;
        // Tracks whether there is a match that hits only characters that
        // appear to be starting words. `byWordFolded` is set to true when
        // a case folded character is encountered in such a match
        var byWordTo = 0,
          byWordFolded = false;
        // If we've found a partial adjacent match, these track its state
        var adjacentTo = 0,
          adjacentStart = -1,
          adjacentEnd = -1;
        var hasLower = /[a-z]/.test(word),
          wordAdjacent = true;
        // Go over the option's text, scanning for the various kinds of matches
        for (var _i = 0, _e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */; _i < _e && byWordTo < len;) {
          var _next = codePointAt(word, _i);
          if (direct < 0) {
            if (preciseTo < len && _next == chars[preciseTo]) precise[preciseTo++] = _i;
            if (adjacentTo < len) {
              if (_next == chars[adjacentTo] || _next == folded[adjacentTo]) {
                if (adjacentTo == 0) adjacentStart = _i;
                adjacentEnd = _i + 1;
                adjacentTo++;
              } else {
                adjacentTo = 0;
              }
            }
          }
          var ch = void 0,
            type = _next < 0xff ? _next >= 48 && _next <= 57 || _next >= 97 && _next <= 122 ? 2 /* Tp.Lower */ : _next >= 65 && _next <= 90 ? 1 /* Tp.Upper */ : 0 /* Tp.NonWord */ : (ch = fromCodePoint(_next)) != ch.toLowerCase() ? 1 /* Tp.Upper */ : ch != ch.toUpperCase() ? 2 /* Tp.Lower */ : 0 /* Tp.NonWord */;
          if (!_i || type == 1 /* Tp.Upper */ && hasLower || prevType == 0 /* Tp.NonWord */ && type != 0 /* Tp.NonWord */) {
            if (chars[byWordTo] == _next || folded[byWordTo] == _next && (byWordFolded = true)) byWord[byWordTo++] = _i;else if (byWord.length) wordAdjacent = false;
          }
          prevType = type;
          _i += codePointSize(_next);
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 /* Penalty.CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */), [0, adjacentEnd]);
        if (direct > -1) return this.ret(-700 /* Penalty.NotStart */ - word.length, [direct, direct + this.pattern.length]);
        if (adjacentTo == len) return this.ret(-200 /* Penalty.CaseFold */ + -700 /* Penalty.NotStart */ - word.length, [adjacentStart, adjacentEnd]);
        if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) + -700 /* Penalty.NotStart */ + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */), byWord, word);
        return chars.length == 2 ? false : this.result((any[0] ? -700 /* Penalty.NotStart */ : 0) + -200 /* Penalty.CaseFold */ + -1100 /* Penalty.Gap */, any, word);
      }
    }, {
      key: "result",
      value: function result(score, positions, word) {
        var result = [],
          i = 0;
        var _iterator2 = _createForOfIteratorHelper(positions),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pos = _step2.value;
            var to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
            if (i && result[i - 1] == pos) result[i - 1] = to;else {
              result[i++] = pos;
              result[i++] = to;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return this.ret(score - word.length, result);
      }
    }]);
    return FuzzyMatcher;
  }();
  var completionConfig = /*@__PURE__*/Facet.define({
    combine: function combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        tooltipClass: function tooltipClass() {
          return "";
        },
        optionClass: function optionClass() {
          return "";
        },
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        positionInfo: defaultPositionInfo,
        compareCompletions: function compareCompletions(a, b) {
          return a.label.localeCompare(b.label);
        },
        interactionDelay: 75
      }, {
        defaultKeymap: function defaultKeymap(a, b) {
          return a && b;
        },
        closeOnBlur: function closeOnBlur(a, b) {
          return a && b;
        },
        icons: function icons(a, b) {
          return a && b;
        },
        tooltipClass: function tooltipClass(a, b) {
          return function (c) {
            return joinClass(a(c), b(c));
          };
        },
        optionClass: function optionClass(a, b) {
          return function (c) {
            return joinClass(a(c), b(c));
          };
        },
        addToOptions: function addToOptions(a, b) {
          return a.concat(b);
        }
      });
    }
  });
  function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
  }
  function defaultPositionInfo(view, list, option, info, space, tooltip) {
    var rtl = view.textDirection == Direction.RTL,
      left = rtl,
      narrow = false;
    var side = "top",
      offset,
      maxWidth;
    var spaceLeft = list.left - space.left,
      spaceRight = space.right - list.right;
    var infoWidth = info.right - info.left,
      infoHeight = info.bottom - info.top;
    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;
    if (infoWidth <= (left ? spaceLeft : spaceRight)) {
      offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
      maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight);
    } else {
      narrow = true;
      maxWidth = Math.min(400 /* Info.Width */, (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */);
      var spaceBelow = space.bottom - list.bottom;
      if (spaceBelow >= infoHeight || spaceBelow > list.top) {
        // Below the completion
        offset = option.bottom - list.top;
      } else {
        // Above it
        side = "bottom";
        offset = list.bottom - option.top;
      }
    }
    var scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
    var scaleX = (list.right - list.left) / tooltip.offsetWidth;
    return {
      style: "".concat(side, ": ").concat(offset / scaleY, "px; max-width: ").concat(maxWidth / scaleX, "px"),
      "class": "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
    };
  }
  function optionContent(config) {
    var content = config.addToOptions.slice();
    if (config.icons) content.push({
      render: function render(completion) {
        var _icon$classList;
        var icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type) (_icon$classList = icon.classList).add.apply(_icon$classList, _toConsumableArray(completion.type.split(/\s+/g).map(function (cls) {
          return "cm-completionIcon-" + cls;
        })));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
    content.push({
      render: function render(completion, _s, match) {
        var labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        var label = completion.displayLabel || completion.label,
          off = 0;
        for (var j = 0; j < match.length;) {
          var from = match[j++],
            to = match[j++];
          if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));
          var span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from, to)));
          span.className = "cm-completionMatchedText";
          off = to;
        }
        if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render: function render(completion) {
        if (!completion.detail) return null;
        var detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content.sort(function (a, b) {
      return a.position - b.position;
    }).map(function (a) {
      return a.render;
    });
  }
  function rangeAroundSelected(total, selected, max) {
    if (total <= max) return {
      from: 0,
      to: total
    };
    if (selected < 0) selected = 0;
    if (selected <= total >> 1) {
      var _off = Math.floor(selected / max);
      return {
        from: _off * max,
        to: (_off + 1) * max
      };
    }
    var off = Math.floor((total - selected) / max);
    return {
      from: total - (off + 1) * max,
      to: total - off * max
    };
  }
  var CompletionTooltip = /*#__PURE__*/function () {
    function CompletionTooltip(view, stateField, applyCompletion) {
      var _this = this;
      _classCallCheck(this, CompletionTooltip);
      this.view = view;
      this.stateField = stateField;
      this.applyCompletion = applyCompletion;
      this.info = null;
      this.infoDestroy = null;
      this.placeInfoReq = {
        read: function read() {
          return _this.measureInfo();
        },
        write: function write(pos) {
          return _this.placeInfo(pos);
        },
        key: this
      };
      this.space = null;
      this.currentClass = "";
      var cState = view.state.field(stateField);
      var _cState$open = cState.open,
        options = _cState$open.options,
        selected = _cState$open.selected;
      var config = view.state.facet(completionConfig);
      this.optionContent = optionContent(config);
      this.optionClass = config.optionClass;
      this.tooltipClass = config.tooltipClass;
      this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.updateTooltipClass(view.state);
      this.dom.addEventListener("mousedown", function (e) {
        for (var dom = e.target, match; dom && dom != _this.dom; dom = dom.parentNode) {
          if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
            _this.applyCompletion(view, options[+match[1]]);
            e.preventDefault();
            return;
          }
        }
      });
      this.dom.addEventListener("focusout", function (e) {
        var state = view.state.field(_this.stateField, false);
        if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({
          effects: closeCompletionEffect.of(null)
        });
      });
      this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
      this.list.addEventListener("scroll", function () {
        if (_this.info) _this.view.requestMeasure(_this.placeInfoReq);
      });
    }
    _createClass(CompletionTooltip, [{
      key: "mount",
      value: function mount() {
        this.updateSel();
      }
    }, {
      key: "update",
      value: function update(_update) {
        var _a, _b, _c;
        var cState = _update.state.field(this.stateField);
        var prevState = _update.startState.field(this.stateField);
        this.updateTooltipClass(_update.state);
        if (cState != prevState) {
          this.updateSel();
          if (((_a = cState.open) === null || _a === void 0 ? void 0 : _a.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled)) this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));
        }
      }
    }, {
      key: "updateTooltipClass",
      value: function updateTooltipClass(state) {
        var cls = this.tooltipClass(state);
        if (cls != this.currentClass) {
          var _iterator3 = _createForOfIteratorHelper(this.currentClass.split(" ")),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var c = _step3.value;
              if (c) this.dom.classList.remove(c);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          var _iterator4 = _createForOfIteratorHelper(cls.split(" ")),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _c2 = _step4.value;
              if (_c2) this.dom.classList.add(_c2);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          this.currentClass = cls;
        }
      }
    }, {
      key: "positioned",
      value: function positioned(space) {
        this.space = space;
        if (this.info) this.view.requestMeasure(this.placeInfoReq);
      }
    }, {
      key: "updateSel",
      value: function updateSel() {
        var _this2 = this;
        var cState = this.view.state.field(this.stateField),
          open = cState.open;
        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
          this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
          this.list.remove();
          this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
          this.list.addEventListener("scroll", function () {
            if (_this2.info) _this2.view.requestMeasure(_this2.placeInfoReq);
          });
        }
        if (this.updateSelectedOption(open.selected)) {
          this.destroyInfo();
          var completion = open.options[open.selected].completion;
          var info = completion.info;
          if (!info) return;
          var infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
          if (!infoResult) return;
          if ("then" in infoResult) {
            infoResult.then(function (obj) {
              if (obj && _this2.view.state.field(_this2.stateField, false) == cState) _this2.addInfoPane(obj, completion);
            })["catch"](function (e) {
              return logException(_this2.view.state, e, "completion info");
            });
          } else {
            this.addInfoPane(infoResult, completion);
          }
        }
      }
    }, {
      key: "addInfoPane",
      value: function addInfoPane(content, completion) {
        this.destroyInfo();
        var wrap = this.info = document.createElement("div");
        wrap.className = "cm-tooltip cm-completionInfo";
        if (content.nodeType != null) {
          wrap.appendChild(content);
          this.infoDestroy = null;
        } else {
          var dom = content.dom,
            destroy = content.destroy;
          wrap.appendChild(dom);
          this.infoDestroy = destroy || null;
        }
        this.dom.appendChild(wrap);
        this.view.requestMeasure(this.placeInfoReq);
      }
    }, {
      key: "updateSelectedOption",
      value: function updateSelectedOption(selected) {
        var set = null;
        for (var opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
          if (opt.nodeName != "LI" || !opt.id) {
            i--; // A section header
          } else if (i == selected) {
            if (!opt.hasAttribute("aria-selected")) {
              opt.setAttribute("aria-selected", "true");
              set = opt;
            }
          } else {
            if (opt.hasAttribute("aria-selected")) opt.removeAttribute("aria-selected");
          }
        }
        if (set) scrollIntoView(this.list, set);
        return set;
      }
    }, {
      key: "measureInfo",
      value: function measureInfo() {
        var sel = this.dom.querySelector("[aria-selected]");
        if (!sel || !this.info) return null;
        var listRect = this.dom.getBoundingClientRect();
        var infoRect = this.info.getBoundingClientRect();
        var selRect = sel.getBoundingClientRect();
        var space = this.space;
        if (!space) {
          var win = this.dom.ownerDocument.defaultView || window;
          space = {
            left: 0,
            top: 0,
            right: win.innerWidth,
            bottom: win.innerHeight
          };
        }
        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;
        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
      }
    }, {
      key: "placeInfo",
      value: function placeInfo(pos) {
        if (this.info) {
          if (pos) {
            if (pos.style) this.info.style.cssText = pos.style;
            this.info.className = "cm-tooltip cm-completionInfo " + (pos["class"] || "");
          } else {
            this.info.style.cssText = "top: -1e6px";
          }
        }
      }
    }, {
      key: "createListBox",
      value: function createListBox(options, id, range) {
        var ul = document.createElement("ul");
        ul.id = id;
        ul.setAttribute("role", "listbox");
        ul.setAttribute("aria-expanded", "true");
        ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
        var curSection = null;
        for (var i = range.from; i < range.to; i++) {
          var _options$i = options[i],
            completion = _options$i.completion,
            match = _options$i.match,
            section = completion.section;
          if (section) {
            var name = typeof section == "string" ? section : section.name;
            if (name != curSection && (i > range.from || range.from == 0)) {
              curSection = name;
              if (typeof section != "string" && section.header) {
                ul.appendChild(section.header(section));
              } else {
                var header = ul.appendChild(document.createElement("completion-section"));
                header.textContent = name;
              }
            }
          }
          var li = ul.appendChild(document.createElement("li"));
          li.id = id + "-" + i;
          li.setAttribute("role", "option");
          var cls = this.optionClass(completion);
          if (cls) li.className = cls;
          var _iterator5 = _createForOfIteratorHelper(this.optionContent),
            _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var source = _step5.value;
              var node = source(completion, this.view.state, match);
              if (node) li.appendChild(node);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
        if (range.from) ul.classList.add("cm-completionListIncompleteTop");
        if (range.to < options.length) ul.classList.add("cm-completionListIncompleteBottom");
        return ul;
      }
    }, {
      key: "destroyInfo",
      value: function destroyInfo() {
        if (this.info) {
          if (this.infoDestroy) this.infoDestroy();
          this.info.remove();
          this.info = null;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.destroyInfo();
      }
    }]);
    return CompletionTooltip;
  }(); // We allocate a new function instance every time the completion
  // changes to force redrawing/repositioning of the tooltip
  function completionTooltip(stateField, applyCompletion) {
    return function (view) {
      return new CompletionTooltip(view, stateField, applyCompletion);
    };
  }
  function scrollIntoView(container, element) {
    var parent = container.getBoundingClientRect();
    var self = element.getBoundingClientRect();
    var scaleY = parent.height / container.offsetHeight;
    if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;
  }

  // Used to pick a preferred option when two options with the same
  // label occur in the result.
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state) {
    var options = [];
    var sections = null;
    var addOption = function addOption(option) {
      options.push(option);
      var section = option.completion.section;
      if (section) {
        if (!sections) sections = [];
        var name = typeof section == "string" ? section : section.name;
        if (!sections.some(function (s) {
          return s.name == name;
        })) sections.push(typeof section == "string" ? {
          name: name
        } : section);
      }
    };
    var _iterator6 = _createForOfIteratorHelper(active),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var a = _step6.value;
        if (a.hasResult()) {
          var getMatch = a.result.getMatch;
          if (a.result.filter === false) {
            var _iterator10 = _createForOfIteratorHelper(a.result.options),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _option = _step10.value;
                addOption(new Option(_option, a.source, getMatch ? getMatch(_option) : [], 1e9 - options.length));
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          } else {
            var matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));
            var _iterator11 = _createForOfIteratorHelper(a.result.options),
              _step11;
            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                var _option2 = _step11.value;
                if (matcher.match(_option2.label)) {
                  var matched = !_option2.displayLabel ? matcher.matched : getMatch ? getMatch(_option2, matcher.matched) : [];
                  addOption(new Option(_option2, a.source, matched, matcher.score + (_option2.boost || 0)));
                }
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
          }
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    if (sections) {
      var sectionOrder = Object.create(null),
        pos = 0;
      var cmp = function cmp(a, b) {
        var _a, _b;
        return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);
      };
      var _iterator7 = _createForOfIteratorHelper(sections.sort(cmp)),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var s = _step7.value;
          pos -= 1e5;
          sectionOrder[s.name] = pos;
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var _iterator8 = _createForOfIteratorHelper(options),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var option = _step8.value;
          var section = option.completion.section;
          if (section) option.score += sectionOrder[typeof section == "string" ? section : section.name];
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    var result = [],
      prev = null;
    var compare = state.facet(completionConfig).compareCompletions;
    var _iterator9 = _createForOfIteratorHelper(options.sort(function (a, b) {
        return b.score - a.score || compare(a.completion, b.completion);
      })),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var opt = _step9.value;
        var _cur = opt.completion;
        if (!prev || prev.label != _cur.label || prev.detail != _cur.detail || prev.type != null && _cur.type != null && prev.type != _cur.type || prev.apply != _cur.apply || prev.boost != _cur.boost) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;
        prev = opt.completion;
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
    return result;
  }
  var CompletionDialog = /*#__PURE__*/function () {
    function CompletionDialog(options, attrs, tooltip, timestamp, selected, disabled) {
      _classCallCheck(this, CompletionDialog);
      this.options = options;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
      this.disabled = disabled;
    }
    _createClass(CompletionDialog, [{
      key: "setSelected",
      value: function setSelected(selected, id) {
        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
      }
    }, {
      key: "map",
      value: function map(changes) {
        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {
          pos: changes.mapPos(this.tooltip.pos)
        }), this.timestamp, this.selected, this.disabled);
      }
    }], [{
      key: "build",
      value: function build(active, state, id, prev, conf) {
        var options = sortOptions(active, state);
        if (!options.length) {
          return prev && active.some(function (a) {
            return a.state == 1;
          } /* State.Pending */) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
        }
        var selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
        if (prev && prev.selected != selected && prev.selected != -1) {
          var selectedValue = prev.options[prev.selected].completion;
          for (var i = 0; i < options.length; i++) if (options[i].completion == selectedValue) {
            selected = i;
            break;
          }
        }
        return new CompletionDialog(options, makeAttrs(id, selected), {
          pos: active.reduce(function (a, b) {
            return b.hasResult() ? Math.min(a, b.from) : a;
          }, 1e8),
          create: completionTooltip(completionState, applyCompletion),
          above: conf.aboveCursor
        }, prev ? prev.timestamp : Date.now(), selected, false);
      }
    }]);
    return CompletionDialog;
  }();
  var CompletionState = /*#__PURE__*/function () {
    function CompletionState(active, id, open) {
      _classCallCheck(this, CompletionState);
      this.active = active;
      this.id = id;
      this.open = open;
    }
    _createClass(CompletionState, [{
      key: "update",
      value: function update(tr) {
        var _this3 = this;
        var state = tr.state,
          conf = state.facet(completionConfig);
        var sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
        var active = sources.map(function (source) {
          var value = _this3.active.find(function (s) {
            return s.source == source;
          }) || new ActiveSource(source, _this3.active.some(function (a) {
            return a.state != 0;
          } /* State.Inactive */) ? 1 /* State.Pending */ : 0 /* State.Inactive */);
          return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every(function (a, i) {
          return a == _this3.active[i];
        })) active = this.active;
        var open = this.open;
        if (open && tr.docChanged) open = open.map(tr.changes);
        if (tr.selection || active.some(function (a) {
          return a.hasResult() && tr.changes.touchesRange(a.from, a.to);
        }) || !sameResults(active, this.active)) open = CompletionDialog.build(active, state, this.id, open, conf);else if (open && open.disabled && !active.some(function (a) {
          return a.state == 1;
        } /* State.Pending */)) open = null;
        if (!open && active.every(function (a) {
          return a.state != 1;
        } /* State.Pending */) && active.some(function (a) {
          return a.hasResult();
        })) active = active.map(function (a) {
          return a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */) : a;
        });
        var _iterator12 = _createForOfIteratorHelper(tr.effects),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var effect = _step12.value;
            if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
      }
    }, {
      key: "tooltip",
      get: function get() {
        return this.open ? this.open.tooltip : null;
      }
    }, {
      key: "attrs",
      get: function get() {
        return this.open ? this.open.attrs : baseAttrs;
      }
    }], [{
      key: "start",
      value: function start() {
        return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
      }
    }]);
    return CompletionState;
  }();
  function sameResults(a, b) {
    if (a == b) return true;
    for (var iA = 0, iB = 0;;) {
      while (iA < a.length && !a[iA].hasResult) iA++;
      while (iB < b.length && !b[iB].hasResult) iB++;
      var endA = iA == a.length,
        endB = iB == b.length;
      if (endA || endB) return endA == endB;
      if (a[iA++].result != b[iB++].result) return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  function makeAttrs(id, selected) {
    var result = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": id
    };
    if (selected > -1) result["aria-activedescendant"] = id + "-" + selected;
    return result;
  }
  var none = [];
  function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
  }
  var ActiveSource = /*#__PURE__*/function () {
    function ActiveSource(source, state) {
      var explicitPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      _classCallCheck(this, ActiveSource);
      this.source = source;
      this.state = state;
      this.explicitPos = explicitPos;
    }
    _createClass(ActiveSource, [{
      key: "hasResult",
      value: function hasResult() {
        return false;
      }
    }, {
      key: "update",
      value: function update(tr, conf) {
        var event = getUserEvent(tr),
          value = this;
        if (event) value = value.handleUserEvent(tr, event, conf);else if (tr.docChanged) value = value.handleChange(tr);else if (tr.selection && value.state != 0 /* State.Inactive */) value = new ActiveSource(value.source, 0 /* State.Inactive */);
        var _iterator13 = _createForOfIteratorHelper(tr.effects),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var effect = _step13.value;
            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */, effect.value ? cur(tr.state) : -1);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */);else if (effect.is(setActiveEffect)) {
              var _iterator14 = _createForOfIteratorHelper(effect.value),
                _step14;
              try {
                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                  var active = _step14.value;
                  if (active.source == value.source) value = active;
                }
              } catch (err) {
                _iterator14.e(err);
              } finally {
                _iterator14.f();
              }
            }
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
        return value;
      }
    }, {
      key: "handleUserEvent",
      value: function handleUserEvent(tr, type, conf) {
        return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* State.Pending */);
      }
    }, {
      key: "handleChange",
      value: function handleChange(tr) {
        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);
      }
    }, {
      key: "map",
      value: function map(changes) {
        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
      }
    }]);
    return ActiveSource;
  }();
  var ActiveResult = /*#__PURE__*/function (_ActiveSource) {
    _inherits$1(ActiveResult, _ActiveSource);
    var _super = _createSuper(ActiveResult);
    function ActiveResult(source, explicitPos, result, from, to) {
      var _this4;
      _classCallCheck(this, ActiveResult);
      _this4 = _super.call(this, source, 2 /* State.Result */, explicitPos);
      _this4.result = result;
      _this4.from = from;
      _this4.to = to;
      return _this4;
    }
    _createClass(ActiveResult, [{
      key: "hasResult",
      value: function hasResult() {
        return true;
      }
    }, {
      key: "handleUserEvent",
      value: function handleUserEvent(tr, type, conf) {
        var _a;
        var from = tr.changes.mapPos(this.from),
          to = tr.changes.mapPos(this.to, 1);
        var pos = cur(tr.state);
        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from) return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 /* State.Pending */ : 0 /* State.Inactive */);
        var explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos),
          updated;
        if (checkValid(this.result.validFor, tr.state, from, to)) return new ActiveResult(this.source, explicitPos, this.result, from, to);
        if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0)))) return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));
        return new ActiveSource(this.source, 1 /* State.Pending */, explicitPos);
      }
    }, {
      key: "handleChange",
      value: function handleChange(tr) {
        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);
      }
    }, {
      key: "map",
      value: function map(mapping) {
        return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
      }
    }]);
    return ActiveResult;
  }(ActiveSource);
  function checkValid(validFor, state, from, to) {
    if (!validFor) return false;
    var text = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
  }
  var setActiveEffect = /*@__PURE__*/StateEffect.define({
    map: function map(sources, mapping) {
      return sources.map(function (s) {
        return s.map(mapping);
      });
    }
  });
  var setSelectedEffect = /*@__PURE__*/StateEffect.define();
  var completionState = /*@__PURE__*/StateField.define({
    create: function create() {
      return CompletionState.start();
    },
    update: function update(value, tr) {
      return value.update(tr);
    },
    provide: function provide(f) {
      return [showTooltip.from(f, function (val) {
        return val.tooltip;
      }), EditorView.contentAttributes.from(f, function (state) {
        return state.attrs;
      })];
    }
  });
  function applyCompletion(view, option) {
    var apply = option.completion.apply || option.completion.label;
    var result = view.state.field(completionState).active.find(function (a) {
      return a.source == option.source;
    });
    if (!(result instanceof ActiveResult)) return false;
    if (typeof apply == "string") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {
      annotations: pickedCompletion.of(option.completion)
    }));else apply(view, option.completion, result.from, result.to);
    return true;
  }

  /**
  Returns a command that moves the completion selection forward or
  backward by the given amount.
  */
  function moveCompletionSelection(forward) {
    var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "option";
    return function (view) {
      var cState = view.state.field(completionState, false);
      if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;
      var step = 1,
        tooltip;
      if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      var length = cState.open.options.length;
      var selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
      if (selected < 0) selected = by == "page" ? 0 : length - 1;else if (selected >= length) selected = by == "page" ? length - 1 : 0;
      view.dispatch({
        effects: setSelectedEffect.of(selected)
      });
      return true;
    };
  }
  /**
  Accept the current completion.
  */
  var acceptCompletion = function acceptCompletion(view) {
    var cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;
    return applyCompletion(view, cState.open.options[cState.open.selected]);
  };
  /**
  Explicitly start autocompletion.
  */
  var startCompletion = function startCompletion(view) {
    var cState = view.state.field(completionState, false);
    if (!cState) return false;
    view.dispatch({
      effects: startCompletionEffect.of(true)
    });
    return true;
  };
  /**
  Close the currently active completion.
  */
  var closeCompletion = function closeCompletion(view) {
    var cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some(function (a) {
      return a.state != 0;
    } /* State.Inactive */)) return false;
    view.dispatch({
      effects: closeCompletionEffect.of(null)
    });
    return true;
  };
  var RunningQuery = /*#__PURE__*/_createClass(function RunningQuery(active, context) {
    _classCallCheck(this, RunningQuery);
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    // Note that 'undefined' means 'not done yet', whereas 'null' means
    // 'query returned null'.
    this.done = undefined;
  });
  var DebounceTime = 50,
    MaxUpdateCount = 50,
    MinAbortTime = 1000;
  var completionPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {
    function _class(view) {
      _classCallCheck(this, _class);
      this.view = view;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.composing = 0 /* CompositionState.None */;
      var _iterator15 = _createForOfIteratorHelper(view.state.field(completionState).active),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var active = _step15.value;
          if (active.state == 1 /* State.Pending */) this.startQuery(active);
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
    }
    _createClass(_class, [{
      key: "update",
      value: function update(_update2) {
        var _this5 = this;
        var cState = _update2.state.field(completionState);
        if (!_update2.selectionSet && !_update2.docChanged && _update2.startState.field(completionState) == cState) return;
        var doesReset = _update2.transactions.some(function (tr) {
          return (tr.selection || tr.docChanged) && !getUserEvent(tr);
        });
        for (var i = 0; i < this.running.length; i++) {
          var query = this.running[i];
          if (doesReset || query.updates.length + _update2.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
            var _iterator16 = _createForOfIteratorHelper(query.context.abortListeners),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var handler = _step16.value;
                try {
                  handler();
                } catch (e) {
                  logException(this.view.state, e);
                }
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            query.context.abortListeners = null;
            this.running.splice(i--, 1);
          } else {
            var _query$updates;
            (_query$updates = query.updates).push.apply(_query$updates, _toConsumableArray(_update2.transactions));
          }
        }
        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);
        this.debounceUpdate = cState.active.some(function (a) {
          return a.state == 1 /* State.Pending */ && !_this5.running.some(function (q) {
            return q.active.source == a.source;
          });
        }) ? setTimeout(function () {
          return _this5.startUpdate();
        }, DebounceTime) : -1;
        if (this.composing != 0 /* CompositionState.None */) {
          var _iterator17 = _createForOfIteratorHelper(_update2.transactions),
            _step17;
          try {
            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
              var tr = _step17.value;
              if (getUserEvent(tr) == "input") this.composing = 2 /* CompositionState.Changed */;else if (this.composing == 2 /* CompositionState.Changed */ && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */;
            }
          } catch (err) {
            _iterator17.e(err);
          } finally {
            _iterator17.f();
          }
        }
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        var _this6 = this;
        this.debounceUpdate = -1;
        var state = this.view.state,
          cState = state.field(completionState);
        var _iterator18 = _createForOfIteratorHelper(cState.active),
          _step18;
        try {
          var _loop = function _loop() {
            var active = _step18.value;
            if (active.state == 1 /* State.Pending */ && !_this6.running.some(function (r) {
              return r.active.source == active.source;
            })) _this6.startQuery(active);
          };
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }
      }
    }, {
      key: "startQuery",
      value: function startQuery(active) {
        var _this7 = this;
        var state = this.view.state,
          pos = cur(state);
        var context = new CompletionContext(state, pos, active.explicitPos == pos);
        var pending = new RunningQuery(active, context);
        this.running.push(pending);
        Promise.resolve(active.source(context)).then(function (result) {
          if (!pending.context.aborted) {
            pending.done = result || null;
            _this7.scheduleAccept();
          }
        }, function (err) {
          _this7.view.dispatch({
            effects: closeCompletionEffect.of(null)
          });
          logException(_this7.view.state, err);
        });
      }
    }, {
      key: "scheduleAccept",
      value: function scheduleAccept() {
        var _this8 = this;
        if (this.running.every(function (q) {
          return q.done !== undefined;
        })) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(function () {
          return _this8.accept();
        }, DebounceTime);
      }
      // For each finished query in this.running, try to create a result
      // or, if appropriate, restart the query.
    }, {
      key: "accept",
      value: function accept() {
        var _this9 = this;
        var _a;
        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        var updated = [];
        var conf = this.view.state.facet(completionConfig);
        var _loop2 = function _loop2() {
          var query = _this9.running[i];
          if (query.done === undefined) return "continue";
          _this9.running.splice(i--, 1);
          if (query.done) {
            var active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : _this9.view.state));
            // Replay the transactions that happened since the start of
            // the request and see if that preserves the result
            var _iterator19 = _createForOfIteratorHelper(query.updates),
              _step19;
            try {
              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                var tr = _step19.value;
                active = active.update(tr, conf);
              }
            } catch (err) {
              _iterator19.e(err);
            } finally {
              _iterator19.f();
            }
            if (active.hasResult()) {
              updated.push(active);
              return "continue";
            }
          }
          var current = _this9.view.state.field(completionState).active.find(function (a) {
            return a.source == query.active.source;
          });
          if (current && current.state == 1 /* State.Pending */) {
            if (query.done == null) {
              // Explicitly failed. Should clear the pending status if it
              // hasn't been re-set in the meantime.
              var _active = new ActiveSource(query.active.source, 0 /* State.Inactive */);
              var _iterator20 = _createForOfIteratorHelper(query.updates),
                _step20;
              try {
                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                  var _tr = _step20.value;
                  _active = _active.update(_tr, conf);
                }
              } catch (err) {
                _iterator20.e(err);
              } finally {
                _iterator20.f();
              }
              if (_active.state != 1 /* State.Pending */) updated.push(_active);
            } else {
              // Cleared by subsequent transactions. Restart.
              _this9.startQuery(current);
            }
          }
        };
        for (var i = 0; i < this.running.length; i++) {
          var _ret = _loop2();
          if (_ret === "continue") continue;
        }
        if (updated.length) this.view.dispatch({
          effects: setActiveEffect.of(updated)
        });
      }
    }]);
    return _class;
  }(), {
    eventHandlers: {
      blur: function blur(event) {
        var state = this.view.state.field(completionState, false);
        if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
          var dialog = state.open && getTooltip(this.view, state.open.tooltip);
          if (!dialog || !dialog.dom.contains(event.relatedTarget)) this.view.dispatch({
            effects: closeCompletionEffect.of(null)
          });
        }
      },
      compositionstart: function compositionstart() {
        this.composing = 1 /* CompositionState.Started */;
      },
      compositionend: function compositionend() {
        var _this10 = this;
        if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {
          // Safari fires compositionend events synchronously, possibly
          // from inside an update, so dispatch asynchronously to avoid reentrancy
          setTimeout(function () {
            return _this10.view.dispatch({
              effects: startCompletionEffect.of(false)
            });
          }, 20);
        }
        this.composing = 0 /* CompositionState.None */;
      }
    }
  });

  var baseTheme$2 = /*@__PURE__*/EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": {
          padding: "1px 3px",
          lineHeight: 1.2
        },
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer"
        },
        "& > completion-section": {
          display: "list-item",
          borderBottom: "1px solid silver",
          paddingLeft: "0.5em",
          opacity: 0.7
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '""',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: "".concat(400 /* Info.Width */, "px"),
      boxSizing: "border-box"
    },
    ".cm-completionInfo.cm-completionInfo-left": {
      right: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-right": {
      left: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-left-narrow": {
      right: "".concat(30 /* Info.Margin */, "px")
    },
    ".cm-completionInfo.cm-completionInfo-right-narrow": {
      left: "".concat(30 /* Info.Margin */, "px")
    },
    "&light .cm-snippetField": {
      backgroundColor: "#00000022"
    },
    "&dark .cm-snippetField": {
      backgroundColor: "#ffffff22"
    },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-class": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-interface": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-variable": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-constant": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-type": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-enum": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-property": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-keyword": {
      "&:after": {
        content: "'\uD83D\uDD11\uFE0E'"
      } // Disable emoji rendering
    },

    ".cm-completionIcon-namespace": {
      "&:after": {
        content: "''"
      }
    },
    ".cm-completionIcon-text": {
      "&:after": {
        content: "'abc'",
        fontSize: "50%",
        verticalAlign: "middle"
      }
    }
  });
  var FieldPos = /*#__PURE__*/_createClass(function FieldPos(field, line, from, to) {
    _classCallCheck(this, FieldPos);
    this.field = field;
    this.line = line;
    this.from = from;
    this.to = to;
  });
  var FieldRange = /*#__PURE__*/function () {
    function FieldRange(field, from, to) {
      _classCallCheck(this, FieldRange);
      this.field = field;
      this.from = from;
      this.to = to;
    }
    _createClass(FieldRange, [{
      key: "map",
      value: function map(changes) {
        var from = changes.mapPos(this.from, -1, MapMode.TrackDel);
        var to = changes.mapPos(this.to, 1, MapMode.TrackDel);
        return from == null || to == null ? null : new FieldRange(this.field, from, to);
      }
    }]);
    return FieldRange;
  }();
  var Snippet = /*#__PURE__*/function () {
    function Snippet(lines, fieldPositions) {
      _classCallCheck(this, Snippet);
      this.lines = lines;
      this.fieldPositions = fieldPositions;
    }
    _createClass(Snippet, [{
      key: "instantiate",
      value: function instantiate(state, pos) {
        var text = [],
          lineStart = [pos];
        var lineObj = state.doc.lineAt(pos),
          baseIndent = /^\s*/.exec(lineObj.text)[0];
        var _iterator21 = _createForOfIteratorHelper(this.lines),
          _step21;
        try {
          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
            var line = _step21.value;
            if (text.length) {
              var indent = baseIndent,
                tabs = /^\t*/.exec(line)[0].length;
              for (var i = 0; i < tabs; i++) indent += state.facet(indentUnit);
              lineStart.push(pos + indent.length - tabs);
              line = indent + line.slice(tabs);
            }
            text.push(line);
            pos += line.length + 1;
          }
        } catch (err) {
          _iterator21.e(err);
        } finally {
          _iterator21.f();
        }
        var ranges = this.fieldPositions.map(function (pos) {
          return new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to);
        });
        return {
          text: text,
          ranges: ranges
        };
      }
    }], [{
      key: "parse",
      value: function parse(template) {
        var fields = [];
        var lines = [],
          positions = [],
          m;
        var _iterator22 = _createForOfIteratorHelper(template.split(/\r\n?|\n/)),
          _step22;
        try {
          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
            var line = _step22.value;
            while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
              var seq = m[1] ? +m[1] : null,
                name = m[2] || m[3] || "",
                found = -1;
              for (var i = 0; i < fields.length; i++) {
                if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;
              }
              if (found < 0) {
                var _i2 = 0;
                while (_i2 < fields.length && (seq == null || fields[_i2].seq != null && fields[_i2].seq < seq)) _i2++;
                fields.splice(_i2, 0, {
                  seq: seq,
                  name: name
                });
                found = _i2;
                var _iterator23 = _createForOfIteratorHelper(positions),
                  _step23;
                try {
                  for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                    var pos = _step23.value;
                    if (pos.field >= found) pos.field++;
                  }
                } catch (err) {
                  _iterator23.e(err);
                } finally {
                  _iterator23.f();
                }
              }
              positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
              line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);
            }
            for (var esc; esc = /\\([{}])/.exec(line);) {
              line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);
              var _iterator24 = _createForOfIteratorHelper(positions),
                _step24;
              try {
                for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                  var _pos = _step24.value;
                  if (_pos.line == lines.length && _pos.from > esc.index) {
                    _pos.from--;
                    _pos.to--;
                  }
                }
              } catch (err) {
                _iterator24.e(err);
              } finally {
                _iterator24.f();
              }
            }
            lines.push(line);
          }
        } catch (err) {
          _iterator22.e(err);
        } finally {
          _iterator22.f();
        }
        return new Snippet(lines, positions);
      }
    }]);
    return Snippet;
  }();
  var fieldMarker = /*@__PURE__*/Decoration.widget({
    widget: /*@__PURE__*/new ( /*#__PURE__*/function (_WidgetType) {
      _inherits$1(_class2, _WidgetType);
      var _super2 = _createSuper(_class2);
      function _class2() {
        _classCallCheck(this, _class2);
        return _super2.apply(this, arguments);
      }
      _createClass(_class2, [{
        key: "toDOM",
        value: function toDOM() {
          var span = document.createElement("span");
          span.className = "cm-snippetFieldPosition";
          return span;
        }
      }, {
        key: "ignoreEvent",
        value: function ignoreEvent() {
          return false;
        }
      }]);
      return _class2;
    }(WidgetType))()
  });
  var fieldRange = /*@__PURE__*/Decoration.mark({
    "class": "cm-snippetField"
  });
  var ActiveSnippet = /*#__PURE__*/function () {
    function ActiveSnippet(ranges, active) {
      _classCallCheck(this, ActiveSnippet);
      this.ranges = ranges;
      this.active = active;
      this.deco = Decoration.set(ranges.map(function (r) {
        return (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to);
      }));
    }
    _createClass(ActiveSnippet, [{
      key: "map",
      value: function map(changes) {
        var ranges = [];
        var _iterator25 = _createForOfIteratorHelper(this.ranges),
          _step25;
        try {
          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
            var r = _step25.value;
            var mapped = r.map(changes);
            if (!mapped) return null;
            ranges.push(mapped);
          }
        } catch (err) {
          _iterator25.e(err);
        } finally {
          _iterator25.f();
        }
        return new ActiveSnippet(ranges, this.active);
      }
    }, {
      key: "selectionInsideField",
      value: function selectionInsideField(sel) {
        var _this11 = this;
        return sel.ranges.every(function (range) {
          return _this11.ranges.some(function (r) {
            return r.field == _this11.active && r.from <= range.from && r.to >= range.to;
          });
        });
      }
    }]);
    return ActiveSnippet;
  }();
  var setActive = /*@__PURE__*/StateEffect.define({
    map: function map(value, changes) {
      return value && value.map(changes);
    }
  });
  var moveToField = /*@__PURE__*/StateEffect.define();
  var snippetState = /*@__PURE__*/StateField.define({
    create: function create() {
      return null;
    },
    update: function update(value, tr) {
      var _iterator26 = _createForOfIteratorHelper(tr.effects),
        _step26;
      try {
        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
          var effect = _step26.value;
          if (effect.is(setActive)) return effect.value;
          if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);
        }
      } catch (err) {
        _iterator26.e(err);
      } finally {
        _iterator26.f();
      }
      if (value && tr.docChanged) value = value.map(tr.changes);
      if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;
      return value;
    },
    provide: function provide(f) {
      return EditorView.decorations.from(f, function (val) {
        return val ? val.deco : Decoration.none;
      });
    }
  });
  function fieldSelection(ranges, field) {
    return EditorSelection.create(ranges.filter(function (r) {
      return r.field == field;
    }).map(function (r) {
      return EditorSelection.range(r.from, r.to);
    }));
  }
  /**
  Convert a snippet template to a function that can
  [apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written
  using syntax like this:

      "for (let ${index} = 0; ${index} < ${end}; ${index}++) {\n\t${}\n}"

  Each `${}` placeholder (you may also use `#{}`) indicates a field
  that the user can fill in. Its name, if any, will be the default
  content for the field.

  When the snippet is activated by calling the returned function,
  the code is inserted at the given position. Newlines in the
  template are indented by the indentation of the start line, plus
  one [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after
  the newline.

  On activation, (all instances of) the first field are selected.
  The user can move between fields with Tab and Shift-Tab as long as
  the fields are active. Moving to the last field or moving the
  cursor out of the current field deactivates the fields.

  The order of fields defaults to textual order, but you can add
  numbers to placeholders (`${1}` or `${1:defaultText}`) to provide
  a custom order.

  To include a literal `{` or `}` in your template, put a backslash
  in front of it. This will be removed and the brace will not be
  interpreted as indicating a placeholder.
  */
  function snippet(template) {
    var snippet = Snippet.parse(template);
    return function (editor, completion, from, to) {
      var _snippet$instantiate = snippet.instantiate(editor.state, from),
        text = _snippet$instantiate.text,
        ranges = _snippet$instantiate.ranges;
      var spec = {
        changes: {
          from: from,
          to: to,
          insert: Text.of(text)
        },
        scrollIntoView: true,
        annotations: completion ? pickedCompletion.of(completion) : undefined
      };
      if (ranges.length) spec.selection = fieldSelection(ranges, 0);
      if (ranges.length > 1) {
        var active = new ActiveSnippet(ranges, 0);
        var effects = spec.effects = [setActive.of(active)];
        if (editor.state.field(snippetState, false) === undefined) effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme$2]));
      }
      editor.dispatch(editor.state.update(spec));
    };
  }
  function moveField(dir) {
    return function (_ref3) {
      var state = _ref3.state,
        dispatch = _ref3.dispatch;
      var active = state.field(snippetState, false);
      if (!active || dir < 0 && active.active == 0) return false;
      var next = active.active + dir,
        last = dir > 0 && !active.ranges.some(function (r) {
          return r.field == next + dir;
        });
      dispatch(state.update({
        selection: fieldSelection(active.ranges, next),
        effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
        scrollIntoView: true
      }));
      return true;
    };
  }
  /**
  A command that clears the active snippet, if any.
  */
  var clearSnippet = function clearSnippet(_ref4) {
    var state = _ref4.state,
      dispatch = _ref4.dispatch;
    var active = state.field(snippetState, false);
    if (!active) return false;
    dispatch(state.update({
      effects: setActive.of(null)
    }));
    return true;
  };
  /**
  Move to the next snippet field, if available.
  */
  var nextSnippetField = /*@__PURE__*/moveField(1);
  /**
  Move to the previous snippet field, if available.
  */
  var prevSnippetField = /*@__PURE__*/moveField(-1);
  var defaultSnippetKeymap = [{
    key: "Tab",
    run: nextSnippetField,
    shift: prevSnippetField
  }, {
    key: "Escape",
    run: clearSnippet
  }];
  /**
  A facet that can be used to configure the key bindings used by
  snippets. The default binds Tab to
  [`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to
  [`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape
  to [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).
  */
  var snippetKeymap = /*@__PURE__*/Facet.define({
    combine: function combine(maps) {
      return maps.length ? maps[0] : defaultSnippetKeymap;
    }
  });
  var addSnippetKeymap = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.compute([snippetKeymap], function (state) {
    return state.facet(snippetKeymap);
  }));
  /**
  Create a completion from a snippet. Returns an object with the
  properties from `completion`, plus an `apply` function that
  applies the snippet.
  */
  function snippetCompletion(template, completion) {
    return Object.assign(Object.assign({}, completion), {
      apply: snippet(template)
    });
  }
  var snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({
    mousedown: function mousedown(event, view) {
      var active = view.state.field(snippetState, false),
        pos;
      if (!active || (pos = view.posAtCoords({
        x: event.clientX,
        y: event.clientY
      })) == null) return false;
      var match = active.ranges.find(function (r) {
        return r.from <= pos && r.to >= pos;
      });
      if (!match || match.field == active.active) return false;
      view.dispatch({
        selection: fieldSelection(active.ranges, match.field),
        effects: setActive.of(active.ranges.some(function (r) {
          return r.field > match.field;
        }) ? new ActiveSnippet(active.ranges, match.field) : null),
        scrollIntoView: true
      });
      return true;
    }
  });
  var defaults = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
  };
  var closeBracketEffect = /*@__PURE__*/StateEffect.define({
    map: function map(value, mapping) {
      var mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? undefined : mapped;
    }
  });
  var closedBracket = /*@__PURE__*/new ( /*#__PURE__*/function (_RangeValue) {
    _inherits$1(_class3, _RangeValue);
    var _super3 = _createSuper(_class3);
    function _class3() {
      _classCallCheck(this, _class3);
      return _super3.apply(this, arguments);
    }
    return _createClass(_class3);
  }(RangeValue))();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /*@__PURE__*/StateField.define({
    create: function create() {
      return RangeSet.empty;
    },
    update: function update(value, tr) {
      if (tr.selection) {
        var lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
        var prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
        if (lineStart != tr.changes.mapPos(prevLineStart, -1)) value = RangeSet.empty;
      }
      value = value.map(tr.changes);
      var _iterator29 = _createForOfIteratorHelper(tr.effects),
        _step29;
      try {
        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
          var effect = _step29.value;
          if (effect.is(closeBracketEffect)) value = value.update({
            add: [closedBracket.range(effect.value, effect.value + 1)]
          });
        }
      } catch (err) {
        _iterator29.e(err);
      } finally {
        _iterator29.f();
      }
      return value;
    }
  });
  /**
  Extension to enable bracket-closing behavior. When a closeable
  bracket is typed, its closing bracket is immediately inserted
  after the cursor. When closing a bracket directly in front of a
  closing bracket inserted by the extension, the cursor moves over
  that bracket.
  */
  function closeBrackets() {
    return [inputHandler, bracketState];
  }
  var definedClosing = "()[]{}<>";
  function closing(ch) {
    for (var i = 0; i < definedClosing.length; i += 2) if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults;
  }
  var android = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) == "object" && /*@__PURE__*/ /Android\b/.test(navigator.userAgent);
  var inputHandler = /*@__PURE__*/EditorView.inputHandler.of(function (view, from, to, insert) {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;
    var sel = view.state.selection.main;
    if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;
    var tr = insertBracket(view.state, insert);
    if (!tr) return false;
    view.dispatch(tr);
    return true;
  });
  /**
  Implements the extension's behavior on text insertion. If the
  given string counts as a bracket in the language around the
  selection, and replacing the selection with it requires custom
  behavior (inserting a closing version or skipping past a
  previously-closed bracket), this function returns a transaction
  representing that custom behavior. (You only need this if you want
  to programmatically insert bracketsthe
  [`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will
  take care of running this for user input.)
  */
  function insertBracket(state, bracket) {
    var conf = config(state, state.selection.main.head);
    var tokens = conf.brackets || defaults.brackets;
    var _iterator31 = _createForOfIteratorHelper(tokens),
      _step31;
    try {
      for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
        var tok = _step31.value;
        var closed = closing(codePointAt(tok, 0));
        if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);
        if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);
      }
    } catch (err) {
      _iterator31.e(err);
    } finally {
      _iterator31.f();
    }
    return null;
  }
  function closedBracketAt(state, pos) {
    var found = false;
    state.field(bracketState).between(0, state.doc.length, function (from) {
      if (from == pos) found = true;
    });
    return found;
  }
  function nextChar(doc, pos) {
    var next = doc.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
  }
  function handleOpen(state, open, close, closeBefore) {
    var dont = null,
      changes = state.changeByRange(function (range) {
        if (!range.empty) return {
          changes: [{
            insert: open,
            from: range.from
          }, {
            insert: close,
            from: range.to
          }],
          effects: closeBracketEffect.of(range.to + open.length),
          range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
        };
        var next = nextChar(state.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1) return {
          changes: {
            insert: open + close,
            from: range.head
          },
          effects: closeBracketEffect.of(range.head + open.length),
          range: EditorSelection.cursor(range.head + open.length)
        };
        return {
          range: dont = range
        };
      });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state, _open, close) {
    var dont = null,
      changes = state.changeByRange(function (range) {
        if (range.empty && nextChar(state.doc, range.head) == close) return {
          changes: {
            from: range.head,
            to: range.head + close.length,
            insert: close
          },
          range: EditorSelection.cursor(range.head + close.length)
        };
        return dont = {
          range: range
        };
      });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  // Handles cases where the open and close token are the same, and
  // possibly triple quotes (as in `"""abc"""`-style quoting).
  function handleSame(state, token, allowTriple, config) {
    var stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;
    var dont = null,
      changes = state.changeByRange(function (range) {
        if (!range.empty) return {
          changes: [{
            insert: token,
            from: range.from
          }, {
            insert: token,
            from: range.to
          }],
          effects: closeBracketEffect.of(range.to + token.length),
          range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
        };
        var pos = range.head,
          next = nextChar(state.doc, pos),
          start;
        if (next == token) {
          if (nodeStart(state, pos)) {
            return {
              changes: {
                insert: token + token,
                from: pos
              },
              effects: closeBracketEffect.of(pos + token.length),
              range: EditorSelection.cursor(pos + token.length)
            };
          } else if (closedBracketAt(state, pos)) {
            var isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
            var content = isTriple ? token + token + token : token;
            return {
              changes: {
                from: pos,
                to: pos + content.length,
                insert: content
              },
              range: EditorSelection.cursor(pos + content.length)
            };
          }
        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
          return {
            changes: {
              insert: token + token + token + token,
              from: pos
            },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
          if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {
            changes: {
              insert: token + token,
              from: pos
            },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        }
        return {
          range: dont = range
        };
      });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state, pos) {
    var tree = syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state, pos, quoteToken, prefixes) {
    var node = syntaxTree(state).resolveInner(pos, -1);
    var maxPrefix = prefixes.reduce(function (m, p) {
      return Math.max(m, p.length);
    }, 0);
    for (var i = 0; i < 5; i++) {
      var start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
      var quotePos = start.indexOf(quoteToken);
      if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
        var first = node.firstChild;
        while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
          if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;
          first = first.firstChild;
        }
        return true;
      }
      var parent = node.to == pos && node.parent;
      if (!parent) break;
      node = parent;
    }
    return false;
  }
  function canStartStringAt(state, pos, prefixes) {
    var charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word) return pos;
    var _iterator32 = _createForOfIteratorHelper(prefixes),
      _step32;
    try {
      for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
        var prefix = _step32.value;
        var start = pos - prefix.length;
        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word) return start;
      }
    } catch (err) {
      _iterator32.e(err);
    } finally {
      _iterator32.f();
    }
    return -1;
  }

  /**
  Returns an extension that enables autocompletion.
  */
  function autocompletion$1() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme$2];
  }
  /**
  Basic keybindings for autocompletion.

   - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)
   - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)
   - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`
   - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`
   - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
   - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
   - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)
  */
  var completionKeymap = [{
    key: "Ctrl-Space",
    run: startCompletion
  }, {
    key: "Escape",
    run: closeCompletion
  }, {
    key: "ArrowDown",
    run: /*@__PURE__*/moveCompletionSelection(true)
  }, {
    key: "ArrowUp",
    run: /*@__PURE__*/moveCompletionSelection(false)
  }, {
    key: "PageDown",
    run: /*@__PURE__*/moveCompletionSelection(true, "page")
  }, {
    key: "PageUp",
    run: /*@__PURE__*/moveCompletionSelection(false, "page")
  }, {
    key: "Enter",
    run: acceptCompletion
  }];
  var completionKeymapExt = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.computeN([completionConfig], function (state) {
    return state.facet(completionConfig).defaultKeymap ? [completionKeymap] : [];
  }));

  /**
  Comment or uncomment the current selection. Will use line comments
  if available, otherwise falling back to block comments.
  */
  var toggleComment = function toggleComment(target) {
    var state = target.state,
      line = state.doc.lineAt(state.selection.main.from),
      config = getConfig(target.state, line.from);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return function (_ref) {
      var state = _ref.state,
        dispatch = _ref.dispatch;
      if (state.readOnly) return false;
      var tr = f(option, state);
      if (!tr) return false;
      dispatch(state.update(tr));
      return true;
    };
  }
  /**
  Comment or uncomment the current selection using line comments.
  The line comment syntax is taken from the
  [`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
  data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
  */
  var toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);
  /**
  Comment or uncomment the current selection using block comments.
  The block comment syntax is taken from the
  [`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
  data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
  */
  var toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);
  /**
  Comment or uncomment the lines around the current selection using
  block comments.
  */
  var toggleBlockCommentByLine = /*@__PURE__*/command(function (o, s) {
    return changeBlockComment(o, s, selectedLineRanges(s));
  }, 0 /* CommentOption.Toggle */);
  function getConfig(state, pos) {
    var data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  /**
  Determines if the given range is block-commented in the given
  state.
  */
  function findBlockComment(state, _ref2, from, to) {
    var open = _ref2.open,
      close = _ref2.close;
    var textBefore = state.sliceDoc(from - SearchMargin, from);
    var textAfter = state.sliceDoc(to, to + SearchMargin);
    var spaceBefore = /\s*$/.exec(textBefore)[0].length,
      spaceAfter = /^\s*/.exec(textAfter)[0].length;
    var beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: {
          pos: from - spaceBefore,
          margin: spaceBefore && 1
        },
        close: {
          pos: to + spaceAfter,
          margin: spaceAfter && 1
        }
      };
    }
    var startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from, to);
    } else {
      startText = state.sliceDoc(from, from + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    var startSpace = /^\s*/.exec(startText)[0].length,
      endSpace = /\s*$/.exec(endText)[0].length;
    var endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    var ranges = [];
    var _iterator = _createForOfIteratorHelper(state.selection.ranges),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var r = _step.value;
        var fromLine = state.doc.lineAt(r.from);
        var toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
        var last = ranges.length - 1;
        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;else ranges.push({
          from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length,
          to: toLine.to
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return ranges;
  }
  // Performs toggle, comment and uncomment of block comments in
  // languages that support them.
  function changeBlockComment(option, state) {
    var ranges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : state.selection.ranges;
    var tokens = ranges.map(function (r) {
      return getConfig(state, r.from).block;
    });
    if (!tokens.every(function (c) {
      return c;
    })) return null;
    var comments = ranges.map(function (r, i) {
      return findBlockComment(state, tokens[i], r.from, r.to);
    });
    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(function (c) {
      return c;
    })) {
      return {
        changes: state.changes(ranges.map(function (range, i) {
          if (comments[i]) return [];
          return [{
            from: range.from,
            insert: tokens[i].open + " "
          }, {
            from: range.to,
            insert: " " + tokens[i].close
          }];
        }))
      };
    } else if (option != 1 /* CommentOption.Comment */ && comments.some(function (c) {
      return c;
    })) {
      var changes = [];
      for (var i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {
        var token = tokens[i],
          _comment = comment,
          open = _comment.open,
          close = _comment.close;
        changes.push({
          from: open.pos - token.open.length,
          to: open.pos + open.margin
        }, {
          from: close.pos - close.margin,
          to: close.pos + token.close.length
        });
      }
      return {
        changes: changes
      };
    }
    return null;
  }
  // Performs toggle, comment and uncomment of line comments.
  function changeLineComment(option, state) {
    var ranges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : state.selection.ranges;
    var lines = [];
    var prevLine = -1;
    var _iterator2 = _createForOfIteratorHelper(ranges),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _step2.value,
          _from = _step2$value.from,
          _to = _step2$value.to;
        var startI = lines.length,
          minIndent = 1e9;
        var _token2 = getConfig(state, _from).line;
        if (!_token2) continue;
        for (var pos = _from; pos <= _to;) {
          var _line2 = state.doc.lineAt(pos);
          if (_line2.from > prevLine && (_from == _to || _to > _line2.from)) {
            prevLine = _line2.from;
            var _indent = /^\s*/.exec(_line2.text)[0].length;
            var _empty = _indent == _line2.length;
            var _comment2 = _line2.text.slice(_indent, _indent + _token2.length) == _token2 ? _indent : -1;
            if (_indent < _line2.text.length && _indent < minIndent) minIndent = _indent;
            lines.push({
              line: _line2,
              comment: _comment2,
              token: _token2,
              indent: _indent,
              empty: _empty,
              single: false
            });
          }
          pos = _line2.to + 1;
        }
        if (minIndent < 1e9) for (var i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;
        if (lines.length == startI + 1) lines[startI].single = true;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (option != 2 /* CommentOption.Uncomment */ && lines.some(function (l) {
      return l.comment < 0 && (!l.empty || l.single);
    })) {
      var changes = [];
      var _iterator3 = _createForOfIteratorHelper(lines),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _step3.value,
            line = _step3$value.line,
            token = _step3$value.token,
            indent = _step3$value.indent,
            empty = _step3$value.empty,
            single = _step3$value.single;
          if (single || !empty) changes.push({
            from: line.from + indent,
            insert: token + " "
          });
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var changeSet = state.changes(changes);
      return {
        changes: changeSet,
        selection: state.selection.map(changeSet, 1)
      };
    } else if (option != 1 /* CommentOption.Comment */ && lines.some(function (l) {
      return l.comment >= 0;
    })) {
      var _changes = [];
      var _iterator4 = _createForOfIteratorHelper(lines),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = _step4.value,
            _line = _step4$value.line,
            comment = _step4$value.comment,
            _token = _step4$value.token;
          if (comment >= 0) {
            var from = _line.from + comment,
              to = from + _token.length;
            if (_line.text[to - _line.from] == " ") to++;
            _changes.push({
              from: from,
              to: to
            });
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return {
        changes: _changes
      };
    }
    return null;
  }
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection) {
    return state.update({
      selection: selection,
      scrollIntoView: true,
      userEvent: "select"
    });
  }
  function moveSel(_ref4, how) {
    var state = _ref4.state,
      dispatch = _ref4.dispatch;
    var selection = updateSel(state.selection, how);
    if (selection.eq(state.selection)) return false;
    dispatch(setSel(state, selection));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, function (range) {
      return range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward);
    });
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  /**
  Move the selection one character to the left (which is backward in
  left-to-right text, forward in right-to-left text).
  */
  var cursorCharLeft = function cursorCharLeft(view) {
    return cursorByChar(view, !ltrAtCursor(view));
  };
  /**
  Move the selection one character to the right.
  */
  var cursorCharRight = function cursorCharRight(view) {
    return cursorByChar(view, ltrAtCursor(view));
  };
  function cursorByGroup(view, forward) {
    return moveSel(view, function (range) {
      return range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward);
    });
  }
  /**
  Move the selection to the left across one group of word or
  non-word (but also non-space) characters.
  */
  var cursorGroupLeft = function cursorGroupLeft(view) {
    return cursorByGroup(view, !ltrAtCursor(view));
  };
  /**
  Move the selection one group to the right.
  */
  var cursorGroupRight = function cursorGroupRight(view) {
    return cursorByGroup(view, ltrAtCursor(view));
  };
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp)) return true;
    var len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start, forward) {
    var pos = syntaxTree(state).resolveInner(start.head);
    var bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    // Scan forward through child nodes to see if there's an interesting
    // node ahead.
    for (var at = start.head;;) {
      var next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next) break;
      if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;
    }
    var bracket = pos.type.prop(bracketProp),
      match,
      newPos;
    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  /**
  Move the cursor over the next syntactic element to the left.
  */
  var cursorSyntaxLeft = function cursorSyntaxLeft(view) {
    return moveSel(view, function (range) {
      return moveBySyntax(view.state, range, !ltrAtCursor(view));
    });
  };
  /**
  Move the cursor over the next syntactic element to the right.
  */
  var cursorSyntaxRight = function cursorSyntaxRight(view) {
    return moveSel(view, function (range) {
      return moveBySyntax(view.state, range, ltrAtCursor(view));
    });
  };
  function cursorByLine(view, forward) {
    return moveSel(view, function (range) {
      if (!range.empty) return rangeEnd(range, forward);
      var moved = view.moveVertically(range, forward);
      return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
  }
  /**
  Move the selection one line up.
  */
  var cursorLineUp = function cursorLineUp(view) {
    return cursorByLine(view, false);
  };
  /**
  Move the selection one line down.
  */
  var cursorLineDown = function cursorLineDown(view) {
    return cursorByLine(view, true);
  };
  function pageInfo(view) {
    var selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
    var marginTop = 0,
      marginBottom = 0,
      height;
    if (selfScroll) {
      var _iterator6 = _createForOfIteratorHelper(view.state.facet(EditorView.scrollMargins)),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var source = _step6.value;
          var margins = source(view);
          if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
          if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      height = view.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height = (view.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop: marginTop,
      marginBottom: marginBottom,
      selfScroll: selfScroll,
      height: Math.max(view.defaultLineHeight, height - 5)
    };
  }
  function cursorByPage(view, forward) {
    var page = pageInfo(view);
    var state = view.state,
      selection = updateSel(state.selection, function (range) {
        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
      });
    if (selection.eq(state.selection)) return false;
    var effect;
    if (page.selfScroll) {
      var startPos = view.coordsAtPos(state.selection.main.head);
      var scrollRect = view.scrollDOM.getBoundingClientRect();
      var scrollTop = scrollRect.top + page.marginTop,
        scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = EditorView.scrollIntoView(selection.main.head, {
        y: "start",
        yMargin: startPos.top - scrollTop
      });
    }
    view.dispatch(setSel(state, selection), {
      effects: effect
    });
    return true;
  }
  /**
  Move the selection one page up.
  */
  var cursorPageUp = function cursorPageUp(view) {
    return cursorByPage(view, false);
  };
  /**
  Move the selection one page down.
  */
  var cursorPageDown = function cursorPageDown(view) {
    return cursorByPage(view, true);
  };
  function moveByLineBoundary(view, start, forward) {
    var line = view.lineBlockAt(start.head),
      moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      var space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start.head != line.from + space) moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  /**
  Move the selection to the next line wrap point, or to the end of
  the line if there isn't one left on this line.
  */
  var cursorLineBoundaryForward = function cursorLineBoundaryForward(view) {
    return moveSel(view, function (range) {
      return moveByLineBoundary(view, range, true);
    });
  };
  /**
  Move the selection to previous line wrap point, or failing that to
  the start of the line. If the line is indented, and the cursor
  isn't already at the end of the indentation, this will move to the
  end of the indentation instead of the start of the line.
  */
  var cursorLineBoundaryBackward = function cursorLineBoundaryBackward(view) {
    return moveSel(view, function (range) {
      return moveByLineBoundary(view, range, false);
    });
  };
  /**
  Move the selection one line wrap point to the left.
  */
  var cursorLineBoundaryLeft = function cursorLineBoundaryLeft(view) {
    return moveSel(view, function (range) {
      return moveByLineBoundary(view, range, !ltrAtCursor(view));
    });
  };
  /**
  Move the selection one line wrap point to the right.
  */
  var cursorLineBoundaryRight = function cursorLineBoundaryRight(view) {
    return moveSel(view, function (range) {
      return moveByLineBoundary(view, range, ltrAtCursor(view));
    });
  };
  /**
  Move the selection to the start of the line.
  */
  var cursorLineStart = function cursorLineStart(view) {
    return moveSel(view, function (range) {
      return EditorSelection.cursor(view.lineBlockAt(range.head).from, 1);
    });
  };
  /**
  Move the selection to the end of the line.
  */
  var cursorLineEnd = function cursorLineEnd(view) {
    return moveSel(view, function (range) {
      return EditorSelection.cursor(view.lineBlockAt(range.head).to, -1);
    });
  };
  function toMatchingBracket(state, dispatch, extend) {
    var found = false,
      selection = updateSel(state.selection, function (range) {
        var matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
        if (!matching || !matching.end) return range;
        found = true;
        var head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
      });
    if (!found) return false;
    dispatch(setSel(state, selection));
    return true;
  }
  /**
  Move the selection to the bracket matching the one it is currently
  on, if any.
  */
  var cursorMatchingBracket = function cursorMatchingBracket(_ref5) {
    var state = _ref5.state,
      dispatch = _ref5.dispatch;
    return toMatchingBracket(state, dispatch, false);
  };
  function extendSel(view, how) {
    var selection = updateSel(view.state.selection, function (range) {
      var head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);
    });
    if (selection.eq(view.state.selection)) return false;
    view.dispatch(setSel(view.state, selection));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, function (range) {
      return view.moveByChar(range, forward);
    });
  }
  /**
  Move the selection head one character to the left, while leaving
  the anchor in place.
  */
  var selectCharLeft = function selectCharLeft(view) {
    return selectByChar(view, !ltrAtCursor(view));
  };
  /**
  Move the selection head one character to the right.
  */
  var selectCharRight = function selectCharRight(view) {
    return selectByChar(view, ltrAtCursor(view));
  };
  function selectByGroup(view, forward) {
    return extendSel(view, function (range) {
      return view.moveByGroup(range, forward);
    });
  }
  /**
  Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
  the left.
  */
  var selectGroupLeft = function selectGroupLeft(view) {
    return selectByGroup(view, !ltrAtCursor(view));
  };
  /**
  Move the selection head one group to the right.
  */
  var selectGroupRight = function selectGroupRight(view) {
    return selectByGroup(view, ltrAtCursor(view));
  };
  /**
  Move the selection head over the next syntactic element to the left.
  */
  var selectSyntaxLeft = function selectSyntaxLeft(view) {
    return extendSel(view, function (range) {
      return moveBySyntax(view.state, range, !ltrAtCursor(view));
    });
  };
  /**
  Move the selection head over the next syntactic element to the right.
  */
  var selectSyntaxRight = function selectSyntaxRight(view) {
    return extendSel(view, function (range) {
      return moveBySyntax(view.state, range, ltrAtCursor(view));
    });
  };
  function selectByLine(view, forward) {
    return extendSel(view, function (range) {
      return view.moveVertically(range, forward);
    });
  }
  /**
  Move the selection head one line up.
  */
  var selectLineUp = function selectLineUp(view) {
    return selectByLine(view, false);
  };
  /**
  Move the selection head one line down.
  */
  var selectLineDown = function selectLineDown(view) {
    return selectByLine(view, true);
  };
  function selectByPage(view, forward) {
    return extendSel(view, function (range) {
      return view.moveVertically(range, forward, pageInfo(view).height);
    });
  }
  /**
  Move the selection head one page up.
  */
  var selectPageUp = function selectPageUp(view) {
    return selectByPage(view, false);
  };
  /**
  Move the selection head one page down.
  */
  var selectPageDown = function selectPageDown(view) {
    return selectByPage(view, true);
  };
  /**
  Move the selection head to the next line boundary.
  */
  var selectLineBoundaryForward = function selectLineBoundaryForward(view) {
    return extendSel(view, function (range) {
      return moveByLineBoundary(view, range, true);
    });
  };
  /**
  Move the selection head to the previous line boundary.
  */
  var selectLineBoundaryBackward = function selectLineBoundaryBackward(view) {
    return extendSel(view, function (range) {
      return moveByLineBoundary(view, range, false);
    });
  };
  /**
  Move the selection head one line boundary to the left.
  */
  var selectLineBoundaryLeft = function selectLineBoundaryLeft(view) {
    return extendSel(view, function (range) {
      return moveByLineBoundary(view, range, !ltrAtCursor(view));
    });
  };
  /**
  Move the selection head one line boundary to the right.
  */
  var selectLineBoundaryRight = function selectLineBoundaryRight(view) {
    return extendSel(view, function (range) {
      return moveByLineBoundary(view, range, ltrAtCursor(view));
    });
  };
  /**
  Move the selection head to the start of the line.
  */
  var selectLineStart = function selectLineStart(view) {
    return extendSel(view, function (range) {
      return EditorSelection.cursor(view.lineBlockAt(range.head).from);
    });
  };
  /**
  Move the selection head to the end of the line.
  */
  var selectLineEnd = function selectLineEnd(view) {
    return extendSel(view, function (range) {
      return EditorSelection.cursor(view.lineBlockAt(range.head).to);
    });
  };
  /**
  Move the selection to the start of the document.
  */
  var cursorDocStart = function cursorDocStart(_ref7) {
    var state = _ref7.state,
      dispatch = _ref7.dispatch;
    dispatch(setSel(state, {
      anchor: 0
    }));
    return true;
  };
  /**
  Move the selection to the end of the document.
  */
  var cursorDocEnd = function cursorDocEnd(_ref8) {
    var state = _ref8.state,
      dispatch = _ref8.dispatch;
    dispatch(setSel(state, {
      anchor: state.doc.length
    }));
    return true;
  };
  /**
  Move the selection head to the start of the document.
  */
  var selectDocStart = function selectDocStart(_ref9) {
    var state = _ref9.state,
      dispatch = _ref9.dispatch;
    dispatch(setSel(state, {
      anchor: state.selection.main.anchor,
      head: 0
    }));
    return true;
  };
  /**
  Move the selection head to the end of the document.
  */
  var selectDocEnd = function selectDocEnd(_ref10) {
    var state = _ref10.state,
      dispatch = _ref10.dispatch;
    dispatch(setSel(state, {
      anchor: state.selection.main.anchor,
      head: state.doc.length
    }));
    return true;
  };
  /**
  Select the entire document.
  */
  var selectAll = function selectAll(_ref11) {
    var state = _ref11.state,
      dispatch = _ref11.dispatch;
    dispatch(state.update({
      selection: {
        anchor: 0,
        head: state.doc.length
      },
      userEvent: "select"
    }));
    return true;
  };
  /**
  Expand the selection to cover entire lines.
  */
  var selectLine = function selectLine(_ref12) {
    var state = _ref12.state,
      dispatch = _ref12.dispatch;
    var ranges = selectedLineBlocks(state).map(function (_ref13) {
      var from = _ref13.from,
        to = _ref13.to;
      return EditorSelection.range(from, Math.min(to + 1, state.doc.length));
    });
    dispatch(state.update({
      selection: EditorSelection.create(ranges),
      userEvent: "select"
    }));
    return true;
  };
  /**
  Select the next syntactic construct that is larger than the
  selection. Note that this will only work insofar as the language
  [provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
  syntax tree.
  */
  var selectParentSyntax = function selectParentSyntax(_ref14) {
    var state = _ref14.state,
      dispatch = _ref14.dispatch;
    var selection = updateSel(state.selection, function (range) {
      var _a;
      var context = syntaxTree(state).resolveInner(range.head, 1);
      while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent))) context = context.parent;
      return EditorSelection.range(context.to, context.from);
    });
    dispatch(setSel(state, selection));
    return true;
  };
  /**
  Simplify the current selection. When multiple ranges are selected,
  reduce it to its main range. Otherwise, if the selection is
  non-empty, convert it to a cursor selection.
  */
  var simplifySelection = function simplifySelection(_ref15) {
    var state = _ref15.state,
      dispatch = _ref15.dispatch;
    var cur = state.selection,
      selection = null;
    if (cur.ranges.length > 1) selection = EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
    if (!selection) return false;
    dispatch(setSel(state, selection));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly) return false;
    var event = "delete.selection",
      state = target.state;
    var changes = state.changeByRange(function (range) {
      var from = range.from,
        to = range.to;
      if (from == to) {
        var towards = by(from);
        if (towards < from) {
          event = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? {
        range: range
      } : {
        changes: {
          from: from,
          to: to
        },
        range: EditorSelection.cursor(from)
      };
    });
    if (changes.changes.empty) return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : undefined
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView) {
      var _iterator7 = _createForOfIteratorHelper(target.state.facet(EditorView.atomicRanges).map(function (f) {
          return f(target);
        })),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var ranges = _step7.value;
          ranges.between(pos, pos, function (from, to) {
            if (from < pos && to > pos) pos = forward ? to : from;
          });
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
    return pos;
  }
  var deleteByChar = function deleteByChar(target, forward) {
    return deleteBy(target, function (pos) {
      var state = target.state,
        line = state.doc.lineAt(pos),
        before,
        targetPos;
      if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "\t") return pos - 1;
        var col = countColumn(before, state.tabSize),
          drop = col % getIndentUnit(state) || getIndentUnit(state);
        for (var i = 0; i < drop && before[before.length - 1 - i] == " "; i++) pos--;
        targetPos = pos;
      } else {
        targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;
      }
      return targetPos;
    });
  };
  /**
  Delete the selection, or, for cursor selections, the character
  before the cursor.
  */
  var deleteCharBackward = function deleteCharBackward(view) {
    return deleteByChar(view, false);
  };
  /**
  Delete the selection or the character after the cursor.
  */
  var deleteCharForward = function deleteCharForward(view) {
    return deleteByChar(view, true);
  };
  var deleteByGroup = function deleteByGroup(target, forward) {
    return deleteBy(target, function (start) {
      var pos = start,
        state = target.state,
        line = state.doc.lineAt(pos);
      var categorize = state.charCategorizer(pos);
      for (var cat = null;;) {
        if (pos == (forward ? line.to : line.from)) {
          if (pos == start && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;
          break;
        }
        var next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
        var nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        var nextCat = categorize(nextChar);
        if (cat != null && nextCat != cat) break;
        if (nextChar != " " || pos != start) cat = nextCat;
        pos = next;
      }
      return pos;
    });
  };
  /**
  Delete the selection or backward until the end of the next
  [group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
  whitespace when they consist of a single space.
  */
  var deleteGroupBackward = function deleteGroupBackward(target) {
    return deleteByGroup(target, false);
  };
  /**
  Delete the selection or forward until the end of the next group.
  */
  var deleteGroupForward = function deleteGroupForward(target) {
    return deleteByGroup(target, true);
  };
  /**
  Delete the selection, or, if it is a cursor selection, delete to
  the end of the line. If the cursor is directly at the end of the
  line, delete the line break after it.
  */
  var deleteToLineEnd = function deleteToLineEnd(view) {
    return deleteBy(view, function (pos) {
      var lineEnd = view.lineBlockAt(pos).to;
      return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
    });
  };
  /**
  Delete the selection, or, if it is a cursor selection, delete to
  the start of the line. If the cursor is directly at the start of the
  line, delete the line break before it.
  */
  var deleteToLineStart = function deleteToLineStart(view) {
    return deleteBy(view, function (pos) {
      var lineStart = view.lineBlockAt(pos).from;
      return pos > lineStart ? lineStart : Math.max(0, pos - 1);
    });
  };
  /**
  Replace each selection range with a line break, leaving the cursor
  on the line before the break.
  */
  var splitLine = function splitLine(_ref17) {
    var state = _ref17.state,
      dispatch = _ref17.dispatch;
    if (state.readOnly) return false;
    var changes = state.changeByRange(function (range) {
      return {
        changes: {
          from: range.from,
          to: range.to,
          insert: Text.of(["", ""])
        },
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "input"
    }));
    return true;
  };
  /**
  Flip the characters before and after the cursor(s).
  */
  var transposeChars = function transposeChars(_ref18) {
    var state = _ref18.state,
      dispatch = _ref18.dispatch;
    if (state.readOnly) return false;
    var changes = state.changeByRange(function (range) {
      if (!range.empty || range.from == 0 || range.from == state.doc.length) return {
        range: range
      };
      var pos = range.from,
        line = state.doc.lineAt(pos);
      var from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      var to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: {
          from: from,
          to: to,
          insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))
        },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty) return false;
    dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "move.character"
    }));
    return true;
  };
  function selectedLineBlocks(state) {
    var blocks = [],
      upto = -1;
    var _iterator8 = _createForOfIteratorHelper(state.selection.ranges),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var range = _step8.value;
        var startLine = state.doc.lineAt(range.from),
          endLine = state.doc.lineAt(range.to);
        if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);
        if (upto >= startLine.number) {
          var prev = blocks[blocks.length - 1];
          prev.to = endLine.to;
          prev.ranges.push(range);
        } else {
          blocks.push({
            from: startLine.from,
            to: endLine.to,
            ranges: [range]
          });
        }
        upto = endLine.number + 1;
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
    return blocks;
  }
  function moveLine(state, dispatch, forward) {
    if (state.readOnly) return false;
    var changes = [],
      ranges = [];
    var _iterator9 = _createForOfIteratorHelper(selectedLineBlocks(state)),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var block = _step9.value;
        if (forward ? block.to == state.doc.length : block.from == 0) continue;
        var nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        var size = nextLine.length + 1;
        if (forward) {
          changes.push({
            from: block.to,
            to: nextLine.to
          }, {
            from: block.from,
            insert: nextLine.text + state.lineBreak
          });
          var _iterator10 = _createForOfIteratorHelper(block.ranges),
            _step10;
          try {
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
              var r = _step10.value;
              ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }
        } else {
          changes.push({
            from: nextLine.from,
            to: block.from
          }, {
            from: block.to,
            insert: state.lineBreak + nextLine.text
          });
          var _iterator11 = _createForOfIteratorHelper(block.ranges),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var _r = _step11.value;
              ranges.push(EditorSelection.range(_r.anchor - size, _r.head - size));
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
    if (!changes.length) return false;
    dispatch(state.update({
      changes: changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  /**
  Move the selected lines up one line.
  */
  var moveLineUp = function moveLineUp(_ref19) {
    var state = _ref19.state,
      dispatch = _ref19.dispatch;
    return moveLine(state, dispatch, false);
  };
  /**
  Move the selected lines down one line.
  */
  var moveLineDown = function moveLineDown(_ref20) {
    var state = _ref20.state,
      dispatch = _ref20.dispatch;
    return moveLine(state, dispatch, true);
  };
  function copyLine(state, dispatch, forward) {
    if (state.readOnly) return false;
    var changes = [];
    var _iterator12 = _createForOfIteratorHelper(selectedLineBlocks(state)),
      _step12;
    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var block = _step12.value;
        if (forward) changes.push({
          from: block.from,
          insert: state.doc.slice(block.from, block.to) + state.lineBreak
        });else changes.push({
          from: block.to,
          insert: state.lineBreak + state.doc.slice(block.from, block.to)
        });
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }
    dispatch(state.update({
      changes: changes,
      scrollIntoView: true,
      userEvent: "input.copyline"
    }));
    return true;
  }
  /**
  Create a copy of the selected lines. Keep the selection in the top copy.
  */
  var copyLineUp = function copyLineUp(_ref21) {
    var state = _ref21.state,
      dispatch = _ref21.dispatch;
    return copyLine(state, dispatch, false);
  };
  /**
  Create a copy of the selected lines. Keep the selection in the bottom copy.
  */
  var copyLineDown = function copyLineDown(_ref22) {
    var state = _ref22.state,
      dispatch = _ref22.dispatch;
    return copyLine(state, dispatch, true);
  };
  /**
  Delete selected lines.
  */
  var deleteLine = function deleteLine(view) {
    if (view.state.readOnly) return false;
    var state = view.state,
      changes = state.changes(selectedLineBlocks(state).map(function (_ref23) {
        var from = _ref23.from,
          to = _ref23.to;
        if (from > 0) from--;else if (to < state.doc.length) to++;
        return {
          from: from,
          to: to
        };
      }));
    var selection = updateSel(state.selection, function (range) {
      return view.moveVertically(range, true);
    }).map(changes);
    view.dispatch({
      changes: changes,
      selection: selection,
      scrollIntoView: true,
      userEvent: "delete.line"
    });
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {
      from: pos,
      to: pos
    };
    var context = syntaxTree(state).resolveInner(pos);
    var before = context.childBefore(pos),
      after = context.childAfter(pos),
      closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from) return {
      from: before.to,
      to: after.from
    };
    return null;
  }
  /**
  Replace the selection with a newline and indent the newly created
  line(s). If the current line consists only of whitespace, this
  will also delete that whitespace. When the cursor is between
  matching brackets, an additional newline will be inserted after
  the cursor.
  */
  var insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);
  /**
  Create a blank, indented line below the current line.
  */
  var insertBlankLine = /*@__PURE__*/newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return function (_ref25) {
      var state = _ref25.state,
        dispatch = _ref25.dispatch;
      if (state.readOnly) return false;
      var changes = state.changeByRange(function (range) {
        var from = range.from,
          to = range.to,
          line = state.doc.lineAt(from);
        var explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        var cx = new IndentContext(state, {
          simulateBreak: from,
          simulateDoubleBreak: !!explode
        });
        var indent = getIndentation(cx, from);
        if (indent == null) indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
        while (to < line.to && /\s/.test(line.text[to - line.from])) to++;
        if (explode) {
          from = explode.from;
          to = explode.to;
        } else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from))) from = line.from;
        var insert = ["", indentString(state, indent)];
        if (explode) insert.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: {
            from: from,
            to: to,
            insert: Text.of(insert)
          },
          range: EditorSelection.cursor(from + 1 + insert[1].length)
        };
      });
      dispatch(state.update(changes, {
        scrollIntoView: true,
        userEvent: "input"
      }));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    var atLine = -1;
    return state.changeByRange(function (range) {
      var changes = [];
      for (var pos = range.from; pos <= range.to;) {
        var line = state.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      var changeSet = state.changes(changes);
      return {
        changes: changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
      };
    });
  }
  /**
  Auto-indent the selected lines. This uses the [indentation service
  facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
  information.
  */
  var indentSelection = function indentSelection(_ref26) {
    var state = _ref26.state,
      dispatch = _ref26.dispatch;
    if (state.readOnly) return false;
    var updated = Object.create(null);
    var context = new IndentContext(state, {
      overrideIndentation: function overrideIndentation(start) {
        var found = updated[start];
        return found == null ? -1 : found;
      }
    });
    var changes = changeBySelectedLine(state, function (line, changes, range) {
      var indent = getIndentation(context, line.from);
      if (indent == null) return;
      if (!/\S/.test(line.text)) indent = 0;
      var cur = /^\s*/.exec(line.text)[0];
      var norm = indentString(state, indent);
      if (cur != norm || range.from < line.from + cur.length) {
        updated[line.from] = indent;
        changes.push({
          from: line.from,
          to: line.from + cur.length,
          insert: norm
        });
      }
    });
    if (!changes.changes.empty) dispatch(state.update(changes, {
      userEvent: "indent"
    }));
    return true;
  };
  /**
  Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
  lines.
  */
  var indentMore = function indentMore(_ref27) {
    var state = _ref27.state,
      dispatch = _ref27.dispatch;
    if (state.readOnly) return false;
    dispatch(state.update(changeBySelectedLine(state, function (line, changes) {
      changes.push({
        from: line.from,
        insert: state.facet(indentUnit)
      });
    }), {
      userEvent: "input.indent"
    }));
    return true;
  };
  /**
  Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
  selected lines.
  */
  var indentLess = function indentLess(_ref28) {
    var state = _ref28.state,
      dispatch = _ref28.dispatch;
    if (state.readOnly) return false;
    dispatch(state.update(changeBySelectedLine(state, function (line, changes) {
      var space = /^\s*/.exec(line.text)[0];
      if (!space) return;
      var col = countColumn(space, state.tabSize),
        keep = 0;
      var insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;
      changes.push({
        from: line.from + keep,
        to: line.from + space.length,
        insert: insert.slice(keep)
      });
    }), {
      userEvent: "delete.dedent"
    }));
    return true;
  };
  /**
  Array of key bindings containing the Emacs-style bindings that are
  available on macOS by default.

   - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
   - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
   - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
   - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
   - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
   - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
   - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
   - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
   - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
   - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
   - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
   - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
   - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
   - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
  */
  var emacsStyleKeymap = [{
    key: "Ctrl-b",
    run: cursorCharLeft,
    shift: selectCharLeft,
    preventDefault: true
  }, {
    key: "Ctrl-f",
    run: cursorCharRight,
    shift: selectCharRight
  }, {
    key: "Ctrl-p",
    run: cursorLineUp,
    shift: selectLineUp
  }, {
    key: "Ctrl-n",
    run: cursorLineDown,
    shift: selectLineDown
  }, {
    key: "Ctrl-a",
    run: cursorLineStart,
    shift: selectLineStart
  }, {
    key: "Ctrl-e",
    run: cursorLineEnd,
    shift: selectLineEnd
  }, {
    key: "Ctrl-d",
    run: deleteCharForward
  }, {
    key: "Ctrl-h",
    run: deleteCharBackward
  }, {
    key: "Ctrl-k",
    run: deleteToLineEnd
  }, {
    key: "Ctrl-Alt-h",
    run: deleteGroupBackward
  }, {
    key: "Ctrl-o",
    run: splitLine
  }, {
    key: "Ctrl-t",
    run: transposeChars
  }, {
    key: "Ctrl-v",
    run: cursorPageDown
  }];
  /**
  An array of key bindings closely sticking to platform-standard or
  widely used bindings. (This includes the bindings from
  [`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
  property changed to `mac`.)

   - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
   - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
   - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
   - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
   - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
   - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
   - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
   - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
   - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
   - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
   - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
   - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
   - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
   - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
   - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
   - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
   - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
   - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
   - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
   - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
   - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
   - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
   - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
   - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
   - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).
   - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).
  */
  var standardKeymap = /*@__PURE__*/[{
    key: "ArrowLeft",
    run: cursorCharLeft,
    shift: selectCharLeft,
    preventDefault: true
  }, {
    key: "Mod-ArrowLeft",
    mac: "Alt-ArrowLeft",
    run: cursorGroupLeft,
    shift: selectGroupLeft,
    preventDefault: true
  }, {
    mac: "Cmd-ArrowLeft",
    run: cursorLineBoundaryLeft,
    shift: selectLineBoundaryLeft,
    preventDefault: true
  }, {
    key: "ArrowRight",
    run: cursorCharRight,
    shift: selectCharRight,
    preventDefault: true
  }, {
    key: "Mod-ArrowRight",
    mac: "Alt-ArrowRight",
    run: cursorGroupRight,
    shift: selectGroupRight,
    preventDefault: true
  }, {
    mac: "Cmd-ArrowRight",
    run: cursorLineBoundaryRight,
    shift: selectLineBoundaryRight,
    preventDefault: true
  }, {
    key: "ArrowUp",
    run: cursorLineUp,
    shift: selectLineUp,
    preventDefault: true
  }, {
    mac: "Cmd-ArrowUp",
    run: cursorDocStart,
    shift: selectDocStart
  }, {
    mac: "Ctrl-ArrowUp",
    run: cursorPageUp,
    shift: selectPageUp
  }, {
    key: "ArrowDown",
    run: cursorLineDown,
    shift: selectLineDown,
    preventDefault: true
  }, {
    mac: "Cmd-ArrowDown",
    run: cursorDocEnd,
    shift: selectDocEnd
  }, {
    mac: "Ctrl-ArrowDown",
    run: cursorPageDown,
    shift: selectPageDown
  }, {
    key: "PageUp",
    run: cursorPageUp,
    shift: selectPageUp
  }, {
    key: "PageDown",
    run: cursorPageDown,
    shift: selectPageDown
  }, {
    key: "Home",
    run: cursorLineBoundaryBackward,
    shift: selectLineBoundaryBackward,
    preventDefault: true
  }, {
    key: "Mod-Home",
    run: cursorDocStart,
    shift: selectDocStart
  }, {
    key: "End",
    run: cursorLineBoundaryForward,
    shift: selectLineBoundaryForward,
    preventDefault: true
  }, {
    key: "Mod-End",
    run: cursorDocEnd,
    shift: selectDocEnd
  }, {
    key: "Enter",
    run: insertNewlineAndIndent
  }, {
    key: "Mod-a",
    run: selectAll
  }, {
    key: "Backspace",
    run: deleteCharBackward,
    shift: deleteCharBackward
  }, {
    key: "Delete",
    run: deleteCharForward
  }, {
    key: "Mod-Backspace",
    mac: "Alt-Backspace",
    run: deleteGroupBackward
  }, {
    key: "Mod-Delete",
    mac: "Alt-Delete",
    run: deleteGroupForward
  }, {
    mac: "Mod-Backspace",
    run: deleteToLineStart
  }, {
    mac: "Mod-Delete",
    run: deleteToLineEnd
  }].concat( /*@__PURE__*/emacsStyleKeymap.map(function (b) {
    return {
      mac: b.key,
      run: b.run,
      shift: b.shift
    };
  }));
  /**
  The default keymap. Includes all bindings from
  [`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

  - Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
  - Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
  - Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
  - Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
  - Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
  - Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
  - Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
  - Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
  - Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
  - Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
  - Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
  - Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
  - Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
  - Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
  - Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
  - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).
  - Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).
  */
  var defaultKeymap = /*@__PURE__*/[{
    key: "Alt-ArrowLeft",
    mac: "Ctrl-ArrowLeft",
    run: cursorSyntaxLeft,
    shift: selectSyntaxLeft
  }, {
    key: "Alt-ArrowRight",
    mac: "Ctrl-ArrowRight",
    run: cursorSyntaxRight,
    shift: selectSyntaxRight
  }, {
    key: "Alt-ArrowUp",
    run: moveLineUp
  }, {
    key: "Shift-Alt-ArrowUp",
    run: copyLineUp
  }, {
    key: "Alt-ArrowDown",
    run: moveLineDown
  }, {
    key: "Shift-Alt-ArrowDown",
    run: copyLineDown
  }, {
    key: "Escape",
    run: simplifySelection
  }, {
    key: "Mod-Enter",
    run: insertBlankLine
  }, {
    key: "Alt-l",
    mac: "Ctrl-l",
    run: selectLine
  }, {
    key: "Mod-i",
    run: selectParentSyntax,
    preventDefault: true
  }, {
    key: "Mod-[",
    run: indentLess
  }, {
    key: "Mod-]",
    run: indentMore
  }, {
    key: "Mod-Alt-\\",
    run: indentSelection
  }, {
    key: "Shift-Mod-k",
    run: deleteLine
  }, {
    key: "Shift-Mod-\\",
    run: cursorMatchingBracket
  }, {
    key: "Mod-/",
    run: toggleComment
  }, {
    key: "Alt-A",
    run: toggleBlockComment
  }].concat(standardKeymap);

  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string") elt = document.createElement(elt);
    var i = 1,
      next = arguments[1];
    if (next && _typeof(next) == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
        var value = next[name];
        if (typeof value == "string") elt.setAttribute(name, value);else if (value != null) elt[name] = value;
      }
      i++;
    }
    for (; i < arguments.length; i++) add(elt, arguments[i]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) ; else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i = 0; i < child.length; i++) add(elt, child[i]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  var SelectedDiagnostic = /*#__PURE__*/_createClass(function SelectedDiagnostic(from, to, diagnostic) {
    _classCallCheck(this, SelectedDiagnostic);
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  });
  var LintState = /*#__PURE__*/function () {
    function LintState(diagnostics, panel, selected) {
      _classCallCheck(this, LintState);
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    _createClass(LintState, null, [{
      key: "init",
      value: function init(diagnostics, panel, state) {
        // Filter the list of diagnostics for which to create markers
        var markedDiagnostics = diagnostics;
        var diagnosticFilter = state.facet(lintConfig).markerFilter;
        if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics);
        var ranges = Decoration.set(markedDiagnostics.map(function (d) {
          // For zero-length ranges or ranges covering only a line break, create a widget
          return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
            widget: new DiagnosticWidget(d),
            diagnostic: d
          }).range(d.from) : Decoration.mark({
            attributes: {
              "class": "cm-lintRange cm-lintRange-" + d.severity + (d.markClass ? " " + d.markClass : "")
            },
            diagnostic: d
          }).range(d.from, d.to);
        }), true);
        return new LintState(ranges, panel, findDiagnostic(ranges));
      }
    }]);
    return LintState;
  }();
  function findDiagnostic(diagnostics) {
    var diagnostic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var found = null;
    diagnostics.between(after, 1e9, function (from, to, _ref) {
      var spec = _ref.spec;
      if (diagnostic && spec.diagnostic != diagnostic) return;
      found = new SelectedDiagnostic(from, to, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    var line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some(function (e) {
      return e.is(setDiagnosticsEffect);
    }) || tr.changes.touchesRange(line.from, line.to));
  }
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
  }
  /**
  Returns a transaction spec which updates the current set of
  diagnostics, and enables the lint extension if if wasn't already
  active.
  */
  function setDiagnostics(state, diagnostics) {
    return {
      effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  /**
  The state effect that updates the set of active diagnostics. Can
  be useful when writing an extension that needs to track these.
  */
  var setDiagnosticsEffect = /*@__PURE__*/StateEffect.define();
  var togglePanel = /*@__PURE__*/StateEffect.define();
  var movePanelSelection = /*@__PURE__*/StateEffect.define();
  var lintState = /*@__PURE__*/StateField.define({
    create: function create() {
      return new LintState(Decoration.none, null, null);
    },
    update: function update(value, tr) {
      if (tr.docChanged) {
        var mapped = value.diagnostics.map(tr.changes),
          selected = null;
        if (value.selected) {
          var selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        value = new LintState(mapped, value.panel, selected);
      }
      var _iterator = _createForOfIteratorHelper(tr.effects),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var effect = _step.value;
          if (effect.is(setDiagnosticsEffect)) {
            value = LintState.init(effect.value, value.panel, tr.state);
          } else if (effect.is(togglePanel)) {
            value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
          } else if (effect.is(movePanelSelection)) {
            value = new LintState(value.diagnostics, value.panel, effect.value);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return value;
    },
    provide: function provide(f) {
      return [showPanel.from(f, function (val) {
        return val.panel;
      }), EditorView.decorations.from(f, function (s) {
        return s.diagnostics;
      })];
    }
  });
  var activeMark = /*@__PURE__*/Decoration.mark({
    "class": "cm-lintRange cm-lintRange-active"
  });
  function lintTooltip(view, pos, side) {
    var _view$state$field = view.state.field(lintState),
      diagnostics = _view$state$field.diagnostics;
    var found = [],
      stackStart = 2e8,
      stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), function (from, to, _ref2) {
      var spec = _ref2.spec;
      if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from, stackStart);
        stackEnd = Math.max(to, stackEnd);
      }
    });
    var diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter) found = diagnosticFilter(found);
    if (!found.length) return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view.state.doc.lineAt(stackStart).to < stackEnd,
      create: function create() {
        return {
          dom: diagnosticsTooltip(view, found)
        };
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", {
      "class": "cm-tooltip-lint"
    }, diagnostics.map(function (d) {
      return renderDiagnostic(view, d, false);
    }));
  }
  /**
  Command to close the lint panel, when open.
  */
  var closeLintPanel = function closeLintPanel(view) {
    var field = view.state.field(lintState, false);
    if (!field || !field.panel) return false;
    view.dispatch({
      effects: togglePanel.of(false)
    });
    return true;
  };
  var lintPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {
    function _class(view) {
      _classCallCheck(this, _class);
      this.view = view;
      this.timeout = -1;
      this.set = true;
      var _view$state$facet = view.state.facet(lintConfig),
        delay = _view$state$facet.delay;
      this.lintTime = Date.now() + delay;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay);
    }
    _createClass(_class, [{
      key: "run",
      value: function run() {
        var _this = this;
        var now = Date.now();
        if (now < this.lintTime - 10) {
          setTimeout(this.run, this.lintTime - now);
        } else {
          this.set = false;
          var state = this.view.state,
            _state$facet = state.facet(lintConfig),
            sources = _state$facet.sources;
          Promise.all(sources.map(function (source) {
            return Promise.resolve(source(_this.view));
          })).then(function (annotations) {
            var all = annotations.reduce(function (a, b) {
              return a.concat(b);
            });
            if (_this.view.state.doc == state.doc) _this.view.dispatch(setDiagnostics(_this.view.state, all));
          }, function (error) {
            logException(_this.view.state, error);
          });
        }
      }
    }, {
      key: "update",
      value: function update(_update) {
        var config = _update.state.facet(lintConfig);
        if (_update.docChanged || config != _update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(_update)) {
          this.lintTime = Date.now() + config.delay;
          if (!this.set) {
            this.set = true;
            this.timeout = setTimeout(this.run, config.delay);
          }
        }
      }
    }, {
      key: "force",
      value: function force() {
        if (this.set) {
          this.lintTime = Date.now();
          this.run();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        clearTimeout(this.timeout);
      }
    }]);
    return _class;
  }());
  var lintConfig = /*@__PURE__*/Facet.define({
    combine: function combine(input) {
      return Object.assign({
        sources: input.map(function (i) {
          return i.source;
        })
      }, combineConfig(input.map(function (i) {
        return i.config;
      }), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null
      }, {
        needsRefresh: function needsRefresh(a, b) {
          return !a ? b : !b ? a : function (u) {
            return a(u) || b(u);
          };
        }
      }));
    }
  });
  /**
  Given a diagnostic source, this function returns an extension that
  enables linting with that source. It will be called whenever the
  editor is idle (after its content changed).
  */
  function linter$1(source) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return [lintConfig.of({
      source: source,
      config: config
    }), lintPlugin, lintExtensions];
  }
  function assignKeys(actions) {
    var assigned = [];
    if (actions) {
      var _iterator2 = _createForOfIteratorHelper(actions),
        _step2;
      try {
        actions: for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var name = _step2.value.name;
          var _loop = function _loop() {
            var ch = name[i];
            if (/[a-zA-Z]/.test(ch) && !assigned.some(function (c) {
              return c.toLowerCase() == ch.toLowerCase();
            })) {
              assigned.push(ch);
              return "continue|actions";
            }
          };
          for (var i = 0; i < name.length; i++) {
            var _ret = _loop();
            if (_ret === "continue|actions") continue actions;
          }
          assigned.push("");
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a;
    var keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", {
      "class": "cm-diagnostic cm-diagnostic-" + diagnostic.severity
    }, crelt("span", {
      "class": "cm-diagnosticText"
    }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map(function (action, i) {
      var fired = false,
        click = function click(e) {
          e.preventDefault();
          if (fired) return;
          fired = true;
          var found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
          if (found) action.apply(view, found.from, found.to);
        };
      var name = action.name,
        keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
      var nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex), crelt("u", name.slice(keyIndex, keyIndex + 1)), name.slice(keyIndex + 1)];
      return crelt("button", {
        type: "button",
        "class": "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": " Action: ".concat(name).concat(keyIndex < 0 ? "" : " (access key \"".concat(keys[i], ")\""), ".")
      }, nameElt);
    }), diagnostic.source && crelt("div", {
      "class": "cm-diagnosticSource"
    }, diagnostic.source));
  }
  var DiagnosticWidget = /*#__PURE__*/function (_WidgetType) {
    _inherits$1(DiagnosticWidget, _WidgetType);
    var _super = _createSuper(DiagnosticWidget);
    function DiagnosticWidget(diagnostic) {
      var _this2;
      _classCallCheck(this, DiagnosticWidget);
      _this2 = _super.call(this);
      _this2.diagnostic = diagnostic;
      return _this2;
    }
    _createClass(DiagnosticWidget, [{
      key: "eq",
      value: function eq(other) {
        return other.diagnostic == this.diagnostic;
      }
    }, {
      key: "toDOM",
      value: function toDOM() {
        return crelt("span", {
          "class": "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity
        });
      }
    }]);
    return DiagnosticWidget;
  }(WidgetType);
  var PanelItem = /*#__PURE__*/_createClass(function PanelItem(view, diagnostic) {
    _classCallCheck(this, PanelItem);
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  });
  var LintPanel = /*#__PURE__*/function () {
    function LintPanel(view) {
      var _this3 = this;
      _classCallCheck(this, LintPanel);
      this.view = view;
      this.items = [];
      var onkeydown = function onkeydown(event) {
        if (event.keyCode == 27) {
          // Escape
          closeLintPanel(_this3.view);
          _this3.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          // ArrowUp, PageUp
          _this3.moveSelection((_this3.selectedIndex - 1 + _this3.items.length) % _this3.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          // ArrowDown, PageDown
          _this3.moveSelection((_this3.selectedIndex + 1) % _this3.items.length);
        } else if (event.keyCode == 36) {
          // Home
          _this3.moveSelection(0);
        } else if (event.keyCode == 35) {
          // End
          _this3.moveSelection(_this3.items.length - 1);
        } else if (event.keyCode == 13) {
          // Enter
          _this3.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && _this3.selectedIndex >= 0) {
          // A-Z
          var diagnostic = _this3.items[_this3.selectedIndex].diagnostic,
            keys = assignKeys(diagnostic.actions);
          for (var i = 0; i < keys.length; i++) if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
            var found = findDiagnostic(_this3.view.state.field(lintState).diagnostics, diagnostic);
            if (found) diagnostic.actions[i].apply(view, found.from, found.to);
          }
        } else {
          return;
        }
        event.preventDefault();
      };
      var onclick = function onclick(event) {
        for (var i = 0; i < _this3.items.length; i++) {
          if (_this3.items[i].dom.contains(event.target)) _this3.moveSelection(i);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown: onkeydown,
        onclick: onclick
      });
      this.dom = crelt("div", {
        "class": "cm-panel-lint"
      }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: function onclick() {
          return closeLintPanel(_this3.view);
        }
      }, ""));
      this.update();
    }
    _createClass(LintPanel, [{
      key: "selectedIndex",
      get: function get() {
        var selected = this.view.state.field(lintState).selected;
        if (!selected) return -1;
        for (var i = 0; i < this.items.length; i++) if (this.items[i].diagnostic == selected.diagnostic) return i;
        return -1;
      }
    }, {
      key: "update",
      value: function update() {
        var _this4 = this;
        var _this$view$state$fiel = this.view.state.field(lintState),
          diagnostics = _this$view$state$fiel.diagnostics,
          selected = _this$view$state$fiel.selected;
        var i = 0,
          needsSync = false,
          newSelectedItem = null;
        diagnostics.between(0, this.view.state.doc.length, function (_start, _end, _ref3) {
          var spec = _ref3.spec;
          var found = -1,
            item;
          for (var j = i; j < _this4.items.length; j++) if (_this4.items[j].diagnostic == spec.diagnostic) {
            found = j;
            break;
          }
          if (found < 0) {
            item = new PanelItem(_this4.view, spec.diagnostic);
            _this4.items.splice(i, 0, item);
            needsSync = true;
          } else {
            item = _this4.items[found];
            if (found > i) {
              _this4.items.splice(i, found - i);
              needsSync = true;
            }
          }
          if (selected && item.diagnostic == selected.diagnostic) {
            if (!item.dom.hasAttribute("aria-selected")) {
              item.dom.setAttribute("aria-selected", "true");
              newSelectedItem = item;
            }
          } else if (item.dom.hasAttribute("aria-selected")) {
            item.dom.removeAttribute("aria-selected");
          }
          i++;
        });
        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
          needsSync = true;
          this.items.pop();
        }
        if (this.items.length == 0) {
          this.items.push(new PanelItem(this.view, {
            from: -1,
            to: -1,
            severity: "info",
            message: this.view.state.phrase("No diagnostics")
          }));
          needsSync = true;
        }
        if (newSelectedItem) {
          this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
          this.view.requestMeasure({
            key: this,
            read: function read() {
              return {
                sel: newSelectedItem.dom.getBoundingClientRect(),
                panel: _this4.list.getBoundingClientRect()
              };
            },
            write: function write(_ref4) {
              var sel = _ref4.sel,
                panel = _ref4.panel;
              if (sel.top < panel.top) _this4.list.scrollTop -= panel.top - sel.top;else if (sel.bottom > panel.bottom) _this4.list.scrollTop += sel.bottom - panel.bottom;
            }
          });
        } else if (this.selectedIndex < 0) {
          this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync) this.sync();
      }
    }, {
      key: "sync",
      value: function sync() {
        var domPos = this.list.firstChild;
        function rm() {
          var prev = domPos;
          domPos = prev.nextSibling;
          prev.remove();
        }
        var _iterator3 = _createForOfIteratorHelper(this.items),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var item = _step3.value;
            if (item.dom.parentNode == this.list) {
              while (domPos != item.dom) rm();
              domPos = item.dom.nextSibling;
            } else {
              this.list.insertBefore(item.dom, domPos);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        while (domPos) rm();
      }
    }, {
      key: "moveSelection",
      value: function moveSelection(selectedIndex) {
        if (this.selectedIndex < 0) return;
        var field = this.view.state.field(lintState);
        var selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection) return;
        this.view.dispatch({
          selection: {
            anchor: selection.from,
            head: selection.to
          },
          scrollIntoView: true,
          effects: movePanelSelection.of(selection)
        });
      }
    }], [{
      key: "open",
      value: function open(view) {
        return new LintPanel(view);
      }
    }]);
    return LintPanel;
  }();
  function svg(content) {
    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "viewBox=\"0 0 40 40\"";
    return "url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ".concat(attrs, ">").concat(encodeURIComponent(content), "</svg>')");
  }
  function underline(color) {
    return svg("<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"".concat(color, "\" fill=\"none\" stroke-width=\".7\"/>"), "width=\"6\" height=\"3\"");
  }
  var baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {
      borderLeft: "5px solid #d11"
    },
    ".cm-diagnostic-warning": {
      borderLeft: "5px solid orange"
    },
    ".cm-diagnostic-info": {
      borderLeft: "5px solid #999"
    },
    ".cm-diagnostic-hint": {
      borderLeft: "5px solid #66d"
    },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: .7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {
      backgroundImage: /*@__PURE__*/underline("#d11")
    },
    ".cm-lintRange-warning": {
      backgroundImage: /*@__PURE__*/underline("orange")
    },
    ".cm-lintRange-info": {
      backgroundImage: /*@__PURE__*/underline("#999")
    },
    ".cm-lintRange-hint": {
      backgroundImage: /*@__PURE__*/underline("#66d")
    },
    ".cm-lintRange-active": {
      backgroundColor: "#ffdd9980"
    },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": {
        borderBottomColor: "orange"
      }
    },
    ".cm-lintPoint-info": {
      "&:after": {
        borderBottomColor: "#999"
      }
    },
    ".cm-lintPoint-hint": {
      "&:after": {
        borderBottomColor: "#66d"
      }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": {
            textDecoration: "underline"
          }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": {
          textDecoration: "none"
        },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });
  var lintExtensions = [lintState, /*@__PURE__*/EditorView.decorations.compute([lintState], function (state) {
    var _state$field = state.field(lintState),
      selected = _state$field.selected,
      panel = _state$field.panel;
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([activeMark.range(selected.from, selected.to)]);
  }), /*@__PURE__*/hoverTooltip(lintTooltip, {
    hideOn: hideTooltip
  }), baseTheme$1];

  /// A parse stack. These are used internally by the parser to track
  /// parsing progress. They also provide some properties and methods
  /// that external code such as a tokenizer can use to get information
  /// about the parse state.
  var Stack = /*#__PURE__*/function () {
    /// @internal
    function Stack(
    /// The parse that this stack is part of @internal
    p,
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack,
    /// The current parse state @internal
    state,
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos,
    /// The input position up to which this stack has parsed.
    pos,
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score,
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer,
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase,
    /// @internal
    curContext) {
      var lookAhead = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var
      // A parent stack from which this was split off, if any. This is
      // set up so that it always points to a stack that has some
      // additional buffer content, never to a stack with an equal
      // `bufferBase`.
      /// @internal
      parent = arguments.length > 10 ? arguments[10] : undefined;
      _classCallCheck(this, Stack);
      this.p = p;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    /// @internal
    _createClass(Stack, [{
      key: "toString",
      value: function toString() {
        return "[".concat(this.stack.filter(function (_, i) {
          return i % 3 == 0;
        }).concat(this.state), "]@").concat(this.pos).concat(this.score ? "!" + this.score : "");
      }
      // Start an empty stack
      /// @internal
    }, {
      key: "context",
      get:
      /// The stack's current [context](#lr.ContextTracker) value, if
      /// any. Its type will depend on the context tracker's type
      /// parameter, or it will be `null` if there is no context
      /// tracker.
      function get() {
        return this.curContext ? this.curContext.context : null;
      }
      // Push a state onto the stack, tracking its start position as well
      // as the buffer base at that point.
      /// @internal
    }, {
      key: "pushState",
      value: function pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
      }
      // Apply a reduce action
      /// @internal
    }, {
      key: "reduce",
      value: function reduce(action) {
        var _a;
        var depth = action >> 19 /* Action.ReduceDepthShift */,
          type = action & 65535 /* Action.ValueMask */;
        var parser = this.p.parser;
        var dPrec = parser.dynamicPrecedence(type);
        if (dPrec) this.score += dPrec;
        if (depth == 0) {
          this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
          // Zero-depth reductions are a special casethey add stuff to
          // the stack without popping anything off.
          if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);
          this.reduceContext(type, this.reducePos);
          return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        var base = this.stack.length - (depth - 1) * 3 - (action & 262144 /* Action.StayFlag */ ? 6 : 0);
        var start = base ? this.stack[base - 2] : this.p.ranges[0].from,
          size = this.reducePos - start;
        // This is a kludge to try and detect overly deep left-associative
        // trees, which will not increase the parse stack depth and thus
        // won't be caught by the regular stack-depth limit check.
        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
          if (start == this.p.lastBigReductionStart) {
            this.p.bigReductionCount++;
            this.p.lastBigReductionSize = size;
          } else if (this.p.lastBigReductionSize < size) {
            this.p.bigReductionCount = 1;
            this.p.lastBigReductionStart = start;
            this.p.lastBigReductionSize = size;
          }
        }
        var bufferBase = base ? this.stack[base - 1] : 0,
          count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || action & 131072 /* Action.RepeatFlag */) {
          var pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;
          this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* Action.StayFlag */) {
          this.state = this.stack[base];
        } else {
          var baseStateID = this.stack[base - 3];
          this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base) this.stack.pop();
        this.reduceContext(type, start);
      }
      // Shift a value into the buffer
      /// @internal
    }, {
      key: "storeNode",
      value: function storeNode(term, start, end) {
        var size = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;
        var isReduce = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        if (term == 0 /* Term.Err */ && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
          // Try to omit/merge adjacent error nodes
          var cur = this,
            top = this.buffer.length;
          if (top == 0 && cur.parent) {
            top = cur.bufferBase - cur.parent.bufferBase;
            cur = cur.parent;
          }
          if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {
            if (start == end) return;
            if (cur.buffer[top - 2] >= start) {
              cur.buffer[top - 2] = end;
              return;
            }
          }
        }
        if (!isReduce || this.pos == end) {
          // Simple case, just append
          this.buffer.push(term, start, end, size);
        } else {
          // There may be skipped nodes that have to be moved forward
          var index = this.buffer.length;
          if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */) while (index > 0 && this.buffer[index - 2] > end) {
            // Move this record forward
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4) size -= 4;
          }
          this.buffer[index] = term;
          this.buffer[index + 1] = start;
          this.buffer[index + 2] = end;
          this.buffer[index + 3] = size;
        }
      }
      // Apply a shift action
      /// @internal
    }, {
      key: "shift",
      value: function shift(action, next, nextEnd) {
        var start = this.pos;
        if (action & 131072 /* Action.GotoFlag */) {
          this.pushState(action & 65535 /* Action.ValueMask */, this.pos);
        } else if ((action & 262144 /* Action.StayFlag */) == 0) {
          // Regular shift
          var nextState = action,
            parser = this.p.parser;
          if (nextEnd > this.pos || next <= parser.maxNode) {
            this.pos = nextEnd;
            if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */)) this.reducePos = nextEnd;
          }
          this.pushState(nextState, start);
          this.shiftContext(next, start);
          if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4);
        } else {
          // Shift-and-stay, which means this is a skipped token
          this.pos = nextEnd;
          this.shiftContext(next, start);
          if (next <= this.p.parser.maxNode) this.buffer.push(next, start, nextEnd, 4);
        }
      }
      // Apply an action
      /// @internal
    }, {
      key: "apply",
      value: function apply(action, next, nextEnd) {
        if (action & 65536 /* Action.ReduceFlag */) this.reduce(action);else this.shift(action, next, nextEnd);
      }
      // Add a prebuilt (reused) node into the buffer.
      /// @internal
    }, {
      key: "useNode",
      value: function useNode(value, next) {
        var index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
          this.p.reused.push(value);
          index++;
        }
        var start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
      }
      // Split the stack. Due to the buffer sharing and the fact
      // that `this.stack` tends to stay quite shallow, this isn't very
      // expensive.
      /// @internal
    }, {
      key: "split",
      value: function split() {
        var parent = this;
        var off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4;
        var buffer = parent.buffer.slice(off),
          base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase) parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
      }
      // Try to recover from an error by 'deleting' (ignoring) one token.
      /// @internal
    }, {
      key: "recoverByDelete",
      value: function recoverByDelete(next, nextEnd) {
        var isNode = next <= this.p.parser.maxNode;
        if (isNode) this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Recover.Delete */;
      }
      /// Check if the given term would be able to be shifted (optionally
      /// after some reductions) on this stack. This can be useful for
      /// external tokenizers that want to make sure they only provide a
      /// given token when it applies.
    }, {
      key: "canShift",
      value: function canShift(term) {
        for (var sim = new SimulatedStack(this);;) {
          var action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
          if (action == 0) return false;
          if ((action & 65536 /* Action.ReduceFlag */) == 0) return true;
          sim.reduce(action);
        }
      }
      // Apply up to Recover.MaxNext recovery actions that conceptually
      // inserts some missing token or rule.
      /// @internal
    }, {
      key: "recoverByInsert",
      value: function recoverByInsert(next) {
        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */) return [];
        var nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {
          var best = [];
          for (var i = 0, s; i < nextStates.length; i += 2) {
            if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);
          }
          if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */) {
            var _loop = function _loop() {
              var s = nextStates[i + 1];
              if (!best.some(function (v, i) {
                return i & 1 && v == s;
              })) best.push(nextStates[i], s);
            };
            for (var _i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && _i < nextStates.length; _i += 2) {
              _loop();
            }
          }
          nextStates = best;
        }
        var result = [];
        for (var _i2 = 0; _i2 < nextStates.length && result.length < 4 /* Recover.MaxNext */; _i2 += 2) {
          var _s = nextStates[_i2 + 1];
          if (_s == this.state) continue;
          var stack = this.split();
          stack.pushState(_s, this.pos);
          stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);
          stack.shiftContext(nextStates[_i2], this.pos);
          stack.score -= 200 /* Recover.Insert */;
          result.push(stack);
        }
        return result;
      }
      // Force a reduce, if possible. Return false if that can't
      // be done.
      /// @internal
    }, {
      key: "forceReduce",
      value: function forceReduce() {
        var parser = this.p.parser;
        var reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);
        if ((reduce & 65536 /* Action.ReduceFlag */) == 0) return false;
        if (!parser.validAction(this.state, reduce)) {
          var depth = reduce >> 19 /* Action.ReduceDepthShift */,
            term = reduce & 65535 /* Action.ValueMask */;
          var target = this.stack.length - depth * 3;
          if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {
            var backup = this.findForcedReduction();
            if (backup == null) return false;
            reduce = backup;
          }
          this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
          this.score -= 100 /* Recover.Reduce */;
        }

        this.reducePos = this.pos;
        this.reduce(reduce);
        return true;
      }
      /// Try to scan through the automaton to find some kind of reduction
      /// that can be applied. Used when the regular ForcedReduce field
      /// isn't a valid action. @internal
    }, {
      key: "findForcedReduction",
      value: function findForcedReduction() {
        var _this = this;
        var parser = this.p.parser,
          seen = [];
        var explore = function explore(state, depth) {
          if (seen.includes(state)) return;
          seen.push(state);
          return parser.allActions(state, function (action) {
            if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;else if (action & 65536 /* Action.ReduceFlag */) {
              var rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;
              if (rDepth > 1) {
                var term = action & 65535 /* Action.ValueMask */,
                  target = _this.stack.length - rDepth * 3;
                if (target >= 0 && parser.getGoto(_this.stack[target], term, false) >= 0) return rDepth << 19 /* Action.ReduceDepthShift */ | 65536 /* Action.ReduceFlag */ | term;
              }
            } else {
              var found = explore(action, depth + 1);
              if (found != null) return found;
            }
          });
        };
        return explore(this.state, 0);
      }
      /// @internal
    }, {
      key: "forceAll",
      value: function forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {
          if (!this.forceReduce()) {
            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
            break;
          }
        }
        return this;
      }
      /// Check whether this state has no further actions (assumed to be a direct descendant of the
      /// top state, since any other states must be able to continue
      /// somehow). @internal
    }, {
      key: "deadEnd",
      get: function get() {
        if (this.stack.length != 3) return false;
        var parser = this.p.parser;
        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ && !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);
      }
      /// Restart the stack (put it back in its start state). Only safe
      /// when this.stack.length == 3 (state is directly below the top
      /// state). @internal
    }, {
      key: "restart",
      value: function restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
      }
      /// @internal
    }, {
      key: "sameState",
      value: function sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length) return false;
        for (var i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false;
        return true;
      }
      /// Get the parser used by this stack.
    }, {
      key: "parser",
      get: function get() {
        return this.p.parser;
      }
      /// Test whether a given dialect (by numeric ID, as exported from
      /// the terms file) is enabled.
    }, {
      key: "dialectEnabled",
      value: function dialectEnabled(dialectID) {
        return this.p.parser.dialect.flags[dialectID];
      }
    }, {
      key: "shiftContext",
      value: function shiftContext(term, start) {
        if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
      }
    }, {
      key: "reduceContext",
      value: function reduceContext(term, start) {
        if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
      }
      /// @internal
    }, {
      key: "emitContext",
      value: function emitContext() {
        var last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
      }
      /// @internal
    }, {
      key: "emitLookAhead",
      value: function emitLookAhead() {
        var last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
      }
    }, {
      key: "updateContext",
      value: function updateContext(context) {
        if (context != this.curContext.context) {
          var newCx = new StackContext(this.curContext.tracker, context);
          if (newCx.hash != this.curContext.hash) this.emitContext();
          this.curContext = newCx;
        }
      }
      /// @internal
    }, {
      key: "setLookAhead",
      value: function setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
          this.emitLookAhead();
          this.lookAhead = lookAhead;
        }
      }
      /// @internal
    }, {
      key: "close",
      value: function close() {
        if (this.curContext && this.curContext.tracker.strict) this.emitContext();
        if (this.lookAhead > 0) this.emitLookAhead();
      }
    }], [{
      key: "start",
      value: function start(p, state) {
        var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
      }
    }]);
    return Stack;
  }();
  var StackContext = /*#__PURE__*/_createClass(function StackContext(tracker, context) {
    _classCallCheck(this, StackContext);
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  });
  var Recover;
  (function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
    Recover[Recover["MinBigReduction"] = 2000] = "MinBigReduction";
  })(Recover || (Recover = {}));
  // Used to cheaply run some reductions to scan ahead without mutating
  // an entire stack
  var SimulatedStack = /*#__PURE__*/function () {
    function SimulatedStack(start) {
      _classCallCheck(this, SimulatedStack);
      this.start = start;
      this.state = start.state;
      this.stack = start.stack;
      this.base = this.stack.length;
    }
    _createClass(SimulatedStack, [{
      key: "reduce",
      value: function reduce(action) {
        var term = action & 65535 /* Action.ValueMask */,
          depth = action >> 19 /* Action.ReduceDepthShift */;
        if (depth == 0) {
          if (this.stack == this.start.stack) this.stack = this.stack.slice();
          this.stack.push(this.state, 0, 0);
          this.base += 3;
        } else {
          this.base -= (depth - 1) * 3;
        }
        var _goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = _goto;
      }
    }]);
    return SimulatedStack;
  }(); // This is given to `Tree.build` to build a buffer, and encapsulates
  // the parent-stack-walking necessary to read the nodes.
  var StackBufferCursor = /*#__PURE__*/function () {
    function StackBufferCursor(stack, pos, index) {
      _classCallCheck(this, StackBufferCursor);
      this.stack = stack;
      this.pos = pos;
      this.index = index;
      this.buffer = stack.buffer;
      if (this.index == 0) this.maybeNext();
    }
    _createClass(StackBufferCursor, [{
      key: "maybeNext",
      value: function maybeNext() {
        var next = this.stack.parent;
        if (next != null) {
          this.index = this.stack.bufferBase - next.bufferBase;
          this.stack = next;
          this.buffer = next.buffer;
        }
      }
    }, {
      key: "id",
      get: function get() {
        return this.buffer[this.index - 4];
      }
    }, {
      key: "start",
      get: function get() {
        return this.buffer[this.index - 3];
      }
    }, {
      key: "end",
      get: function get() {
        return this.buffer[this.index - 2];
      }
    }, {
      key: "size",
      get: function get() {
        return this.buffer[this.index - 1];
      }
    }, {
      key: "next",
      value: function next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0) this.maybeNext();
      }
    }, {
      key: "fork",
      value: function fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
      }
    }], [{
      key: "create",
      value: function create(stack) {
        var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : stack.bufferBase + stack.buffer.length;
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
      }
    }]);
    return StackBufferCursor;
  }(); // See lezer-generator/src/encode.ts for comments about the encoding
  // used here
  function decodeArray(input) {
    var Type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Uint16Array;
    if (typeof input != "string") return input;
    var array = null;
    for (var pos = 0, out = 0; pos < input.length;) {
      var value = 0;
      for (;;) {
        var next = input.charCodeAt(pos++),
          stop = false;
        if (next == 126 /* Encode.BigValCode */) {
          value = 65535 /* Encode.BigVal */;
          break;
        }
        if (next >= 92 /* Encode.Gap2 */) next--;
        if (next >= 34 /* Encode.Gap1 */) next--;
        var digit = next - 32 /* Encode.Start */;
        if (digit >= 46 /* Encode.Base */) {
          digit -= 46 /* Encode.Base */;
          stop = true;
        }
        value += digit;
        if (stop) break;
        value *= 46 /* Encode.Base */;
      }

      if (array) array[out++] = value;else array = new Type(value);
    }
    return array;
  }
  var CachedToken = /*#__PURE__*/_createClass(function CachedToken() {
    _classCallCheck(this, CachedToken);
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  });
  var nullToken = new CachedToken();
  /// [Tokenizers](#lr.ExternalTokenizer) interact with the input
  /// through this interface. It presents the input as a stream of
  /// characters, tracking lookahead and hiding the complexity of
  /// [ranges](#common.Parser.parse^ranges) from tokenizer code.
  var InputStream = /*#__PURE__*/function () {
    /// @internal
    function InputStream(
    /// @internal
    input,
    /// @internal
    ranges) {
      _classCallCheck(this, InputStream);
      this.input = input;
      this.ranges = ranges;
      /// @internal
      this.chunk = "";
      /// @internal
      this.chunkOff = 0;
      /// Backup chunk
      this.chunk2 = "";
      this.chunk2Pos = 0;
      /// The character code of the next code unit in the input, or -1
      /// when the stream is at the end of the input.
      this.next = -1;
      /// @internal
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    /// @internal
    _createClass(InputStream, [{
      key: "resolveOffset",
      value: function resolveOffset(offset, assoc) {
        var range = this.range,
          index = this.rangeIndex;
        var pos = this.pos + offset;
        while (pos < range.from) {
          if (!index) return null;
          var next = this.ranges[--index];
          pos -= range.from - next.to;
          range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
          if (index == this.ranges.length - 1) return null;
          var _next = this.ranges[++index];
          pos += _next.from - range.to;
          range = _next;
        }
        return pos;
      }
      /// @internal
    }, {
      key: "clipPos",
      value: function clipPos(pos) {
        if (pos >= this.range.from && pos < this.range.to) return pos;
        var _iterator = _createForOfIteratorHelper(this.ranges),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var range = _step.value;
            if (range.to > pos) return Math.max(pos, range.from);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return this.end;
      }
      /// Look at a code unit near the stream position. `.peek(0)` equals
      /// `.next`, `.peek(-1)` gives you the previous character, and so
      /// on.
      ///
      /// Note that looking around during tokenizing creates dependencies
      /// on potentially far-away content, which may reduce the
      /// effectiveness incremental parsingwhen looking forwardor even
      /// cause invalid reparses when looking backward more than 25 code
      /// units, since the library does not track lookbehind.
    }, {
      key: "peek",
      value: function peek(offset) {
        var idx = this.chunkOff + offset,
          pos,
          result;
        if (idx >= 0 && idx < this.chunk.length) {
          pos = this.pos + offset;
          result = this.chunk.charCodeAt(idx);
        } else {
          var resolved = this.resolveOffset(offset, 1);
          if (resolved == null) return -1;
          pos = resolved;
          if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
            result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
          } else {
            var i = this.rangeIndex,
              range = this.range;
            while (range.to <= pos) range = this.ranges[++i];
            this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
            if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);
            result = this.chunk2.charCodeAt(0);
          }
        }
        if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;
        return result;
      }
      /// Accept a token. By default, the end of the token is set to the
      /// current stream position, but you can pass an offset (relative to
      /// the stream position) to change that.
    }, {
      key: "acceptToken",
      value: function acceptToken(token) {
        var endOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start) throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
      }
    }, {
      key: "getChunk",
      value: function getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
          var chunk = this.chunk,
            chunkPos = this.chunkPos;
          this.chunk = this.chunk2;
          this.chunkPos = this.chunk2Pos;
          this.chunk2 = chunk;
          this.chunk2Pos = chunkPos;
          this.chunkOff = this.pos - this.chunkPos;
        } else {
          this.chunk2 = this.chunk;
          this.chunk2Pos = this.chunkPos;
          var nextChunk = this.input.chunk(this.pos);
          var end = this.pos + nextChunk.length;
          this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
          this.chunkPos = this.pos;
          this.chunkOff = 0;
        }
      }
    }, {
      key: "readNext",
      value: function readNext() {
        if (this.chunkOff >= this.chunk.length) {
          this.getChunk();
          if (this.chunkOff == this.chunk.length) return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
      }
      /// Move the stream forward N (defaults to 1) code units. Returns
      /// the new value of [`next`](#lr.InputStream.next).
    }, {
      key: "advance",
      value: function advance() {
        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
          if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
          n -= this.range.to - this.pos;
          this.range = this.ranges[++this.rangeIndex];
          this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;
        return this.readNext();
      }
    }, {
      key: "setDone",
      value: function setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
      }
      /// @internal
    }, {
      key: "reset",
      value: function reset(pos, token) {
        if (token) {
          this.token = token;
          token.start = pos;
          token.lookAhead = pos + 1;
          token.value = token.extended = -1;
        } else {
          this.token = nullToken;
        }
        if (this.pos != pos) {
          this.pos = pos;
          if (pos == this.end) {
            this.setDone();
            return this;
          }
          while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex];
          while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex];
          if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
            this.chunkOff = pos - this.chunkPos;
          } else {
            this.chunk = "";
            this.chunkOff = 0;
          }
          this.readNext();
        }
        return this;
      }
      /// @internal
    }, {
      key: "read",
      value: function read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);
        var result = "";
        var _iterator2 = _createForOfIteratorHelper(this.ranges),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var r = _step2.value;
            if (r.from >= to) break;
            if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return result;
      }
    }]);
    return InputStream;
  }(); /// @internal
  var TokenGroup = /*#__PURE__*/function () {
    function TokenGroup(data, id) {
      _classCallCheck(this, TokenGroup);
      this.data = data;
      this.id = id;
    }
    _createClass(TokenGroup, [{
      key: "token",
      value: function token(input, stack) {
        var parser = stack.p.parser;
        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);
      }
    }]);
    return TokenGroup;
  }();
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  /// `@external tokens` declarations in the grammar should resolve to
  /// an instance of this class.
  var ExternalTokenizer = /*#__PURE__*/_createClass(
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  function ExternalTokenizer(
  /// @internal
  token) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, ExternalTokenizer);
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }); // Tokenizer data is stored a big uint16 array containing, for each
  // state:
  //
  //  - A group bitmask, indicating what token groups are reachable from
  //    this state, so that paths that can only lead to tokens not in
  //    any of the current groups can be cut off early.
  //
  //  - The position of the end of the state's sequence of accepting
  //    tokens
  //
  //  - The number of outgoing edges for the state
  //
  //  - The accepting tokens, as (token id, group mask) pairs
  //
  //  - The outgoing edges, as (start character, end character, state
  //    index) triples, with end character being exclusive
  //
  // This function interprets that data, running through a stream as
  // long as new states with the a matching group mask can be reached,
  // and updating `input.token` when it matches a token.
  function readToken(data, input, stack, group, precTable, precOffset) {
    var state = 0,
      groupMask = 1 << group,
      dialect = stack.p.parser.dialect;
    scan: for (;;) {
      if ((groupMask & data[state]) == 0) break;
      var accEnd = data[state + 1];
      // Check whether this state can lead to a token in the current group
      // Accept tokens in this state, possibly overwriting
      // lower-precedence / shorter tokens
      for (var i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {
        var term = data[i];
        if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
          input.acceptToken(term);
          break;
        }
      }
      var next = input.next,
        low = 0,
        high = data[state + 2];
      // Special case for EOF
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      // Do a binary search on the state's edges
      for (; low < high;) {
        var mid = low + high >> 1;
        var index = accEnd + mid + (mid << 1);
        var from = data[index],
          to = data[index + 1] || 0x10000;
        if (next < from) high = mid;else if (next >= to) low = mid + 1;else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
  }
  function findOffset(data, start, term) {
    for (var i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++) if (next == term) return i - start;
    return -1;
  }
  function overrides(token, prev, tableData, tableOffset) {
    var iPrev = findOffset(tableData, tableOffset, prev);
    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
  }

  // Environment variable used to control console output
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  var Safety;
  (function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
  })(Safety || (Safety = {}));
  function cutAt(tree, pos, side) {
    var cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (;;) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;
        if (!cursor.parent()) return side < 0 ? 0 : tree.length;
      }
    }
  }
  var FragmentCursor = /*#__PURE__*/function () {
    function FragmentCursor(fragments, nodeSet) {
      _classCallCheck(this, FragmentCursor);
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    _createClass(FragmentCursor, [{
      key: "nextFragment",
      value: function nextFragment() {
        var fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
          this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
          this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
          while (this.trees.length) {
            this.trees.pop();
            this.start.pop();
            this.index.pop();
          }
          this.trees.push(fr.tree);
          this.start.push(-fr.offset);
          this.index.push(0);
          this.nextStart = this.safeFrom;
        } else {
          this.nextStart = 1e9;
        }
      }
      // `pos` must be >= any previously given `pos` for this cursor
    }, {
      key: "nodeAt",
      value: function nodeAt(pos) {
        if (pos < this.nextStart) return null;
        while (this.fragment && this.safeTo <= pos) this.nextFragment();
        if (!this.fragment) return null;
        for (;;) {
          var last = this.trees.length - 1;
          if (last < 0) {
            // End of tree
            this.nextFragment();
            return null;
          }
          var top = this.trees[last],
            index = this.index[last];
          if (index == top.children.length) {
            this.trees.pop();
            this.start.pop();
            this.index.pop();
            continue;
          }
          var next = top.children[index];
          var start = this.start[last] + top.positions[index];
          if (start > pos) {
            this.nextStart = start;
            return null;
          }
          if (next instanceof Tree) {
            if (start == pos) {
              if (start < this.safeFrom) return null;
              var end = start + next.length;
              if (end <= this.safeTo) {
                var lookAhead = next.prop(NodeProp.lookAhead);
                if (!lookAhead || end + lookAhead < this.fragment.to) return next;
              }
            }
            this.index[last]++;
            if (start + next.length >= Math.max(this.safeFrom, pos)) {
              // Enter this node
              this.trees.push(next);
              this.start.push(start);
              this.index.push(0);
            }
          } else {
            this.index[last]++;
            this.nextStart = start + next.length;
          }
        }
      }
    }]);
    return FragmentCursor;
  }();
  var TokenCache = /*#__PURE__*/function () {
    function TokenCache(parser, stream) {
      _classCallCheck(this, TokenCache);
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser.tokenizers.map(function (_) {
        return new CachedToken();
      });
    }
    _createClass(TokenCache, [{
      key: "getActions",
      value: function getActions(stack) {
        var actionIndex = 0;
        var main = null;
        var parser = stack.p.parser,
          tokenizers = parser.tokenizers;
        var mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);
        var context = stack.curContext ? stack.curContext.hash : 0;
        var lookAhead = 0;
        for (var i = 0; i < tokenizers.length; i++) {
          if ((1 << i & mask) == 0) continue;
          var tokenizer = tokenizers[i],
            token = this.tokens[i];
          if (main && !tokenizer.fallback) continue;
          if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
            this.updateCachedToken(token, tokenizer, stack);
            token.mask = mask;
            token.context = context;
          }
          if (token.lookAhead > token.end + 25 /* Safety.Margin */) lookAhead = Math.max(token.lookAhead, lookAhead);
          if (token.value != 0 /* Term.Err */) {
            var startIndex = actionIndex;
            if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
            actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
            if (!tokenizer.extend) {
              main = token;
              if (actionIndex > startIndex) break;
            }
          }
        }
        while (this.actions.length > actionIndex) this.actions.pop();
        if (lookAhead) stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
          main = new CachedToken();
          main.value = stack.p.parser.eofTerm;
          main.start = main.end = stack.pos;
          actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
      }
    }, {
      key: "getMainToken",
      value: function getMainToken(stack) {
        if (this.mainToken) return this.mainToken;
        var main = new CachedToken(),
          pos = stack.pos,
          p = stack.p;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;
        return main;
      }
    }, {
      key: "updateCachedToken",
      value: function updateCachedToken(token, tokenizer, stack) {
        var start = this.stream.clipPos(stack.pos);
        tokenizer.token(this.stream.reset(start, token), stack);
        if (token.value > -1) {
          var parser = stack.p.parser;
          for (var i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {
            var result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0 /* Specialize.Specialize */) token.value = result >> 1;else token.extended = result >> 1;
              break;
            }
          }
        } else {
          token.value = 0 /* Term.Err */;
          token.end = this.stream.clipPos(start + 1);
        }
      }
    }, {
      key: "putAction",
      value: function putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (var i = 0; i < index; i += 3) if (this.actions[i] == action) return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
      }
    }, {
      key: "addActions",
      value: function addActions(stack, token, end, index) {
        var state = stack.state,
          parser = stack.p.parser,
          data = parser.data;
        for (var set = 0; set < 2; set++) {
          for (var i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {
            if (data[i] == 65535 /* Seq.End */) {
              if (data[i + 1] == 1 /* Seq.Next */) {
                i = pair(data, i + 2);
              } else {
                if (index == 0 && data[i + 1] == 2 /* Seq.Other */) index = this.putAction(pair(data, i + 2), token, end, index);
                break;
              }
            }
            if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);
          }
        }
        return index;
      }
    }]);
    return TokenCache;
  }();
  var Rec;
  (function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
    Rec[Rec["MaxLeftAssociativeReductionCount"] = 300] = "MaxLeftAssociativeReductionCount";
    // The maximum number of non-recovering stacks to explore (to avoid
    // getting bogged down with exponentially multiplying stacks in
    // ambiguous content)
    Rec[Rec["MaxStackCount"] = 12] = "MaxStackCount";
  })(Rec || (Rec = {}));
  var Parse = /*#__PURE__*/function () {
    function Parse(parser, input, fragments, ranges) {
      _classCallCheck(this, Parse);
      this.parser = parser;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 0x2654; // , , , , , , , , , , , , , 
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.lastBigReductionStart = -1;
      this.lastBigReductionSize = 0;
      this.bigReductionCount = 0;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser, this.stream);
      this.topTerm = parser.top[1];
      var from = ranges[0].from;
      this.stacks = [Stack.start(this, parser.top[0], from)];
      this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    _createClass(Parse, [{
      key: "parsedPos",
      get: function get() {
        return this.minStackPos;
      }
      // Move the parser forward. This will process all parse stacks at
      // `this.pos` and try to advance them to a further position. If no
      // stack for such a position is found, it'll start error-recovery.
      //
      // When the parse is finished, this will return a syntax tree. When
      // not, it returns `null`.
    }, {
      key: "advance",
      value: function advance() {
        var stacks = this.stacks,
          pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        var newStacks = this.stacks = [];
        var stopped, stoppedTokens;
        // If a large amount of reductions happened with the same start
        // position, force the stack out of that production in order to
        // avoid creating a tree too deep to recurse through.
        // (This is an ugly kludge, because unfortunately there is no
        // straightforward, cheap way to check for this happening, due to
        // the history of reductions only being available in an
        // expensive-to-access format in the stack buffers.)
        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {
          var _stacks = _slicedToArray$1(stacks, 1),
            s = _stacks[0];
          while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {}
          this.bigReductionCount = this.lastBigReductionSize = 0;
        }
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (var i = 0; i < stacks.length; i++) {
          var stack = stacks[i];
          for (;;) {
            this.tokens.mainToken = null;
            if (stack.pos > pos) {
              newStacks.push(stack);
            } else if (this.advanceStack(stack, newStacks, stacks)) {
              continue;
            } else {
              if (!stopped) {
                stopped = [];
                stoppedTokens = [];
              }
              stopped.push(stack);
              var tok = this.tokens.getMainToken(stack);
              stoppedTokens.push(tok.value, tok.end);
            }
            break;
          }
        }
        if (!newStacks.length) {
          var finished = stopped && findFinished(stopped);
          if (finished) return this.stackToTree(finished);
          if (this.parser.strict) {
            if (verbose && stopped) console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
            throw new SyntaxError("No parse at " + pos);
          }
          if (!this.recovering) this.recovering = 5 /* Rec.Distance */;
        }

        if (this.recovering && stopped) {
          var _finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
          if (_finished) return this.stackToTree(_finished.forceAll());
        }
        if (this.recovering) {
          var maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;
          if (newStacks.length > maxRemaining) {
            newStacks.sort(function (a, b) {
              return b.score - a.score;
            });
            while (newStacks.length > maxRemaining) newStacks.pop();
          }
          if (newStacks.some(function (s) {
            return s.reducePos > pos;
          })) this.recovering--;
        } else if (newStacks.length > 1) {
          // Prune stacks that are in the same state, or that have been
          // running without splitting for a while, to avoid getting stuck
          // with multiple successful stacks running endlessly on.
          outer: for (var _i3 = 0; _i3 < newStacks.length - 1; _i3++) {
            var _stack = newStacks[_i3];
            for (var j = _i3 + 1; j < newStacks.length; j++) {
              var other = newStacks[j];
              if (_stack.sameState(other) || _stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {
                if ((_stack.score - other.score || _stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j--, 1);
                } else {
                  newStacks.splice(_i3--, 1);
                  continue outer;
                }
              }
            }
          }
          if (newStacks.length > 12 /* Rec.MaxStackCount */) newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);
        }

        this.minStackPos = newStacks[0].pos;
        for (var _i4 = 1; _i4 < newStacks.length; _i4++) if (newStacks[_i4].pos < this.minStackPos) this.minStackPos = newStacks[_i4].pos;
        return null;
      }
    }, {
      key: "stopAt",
      value: function stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
      }
      // Returns an updated version of the given stack, or null if the
      // stack can't advance normally. When `split` and `stacks` are
      // given, stacks split off by ambiguous operations will be pushed to
      // `split`, or added to `stacks` if they move `pos` forward.
    }, {
      key: "advanceStack",
      value: function advanceStack(stack, stacks, split) {
        var start = stack.pos,
          parser = this.parser;
        var base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;
        if (this.fragments) {
          var strictCx = stack.curContext && stack.curContext.tracker.strict,
            cxHash = strictCx ? stack.curContext.hash : 0;
          for (var cached = this.fragments.nodeAt(start); cached;) {
            var match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
            if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
              stack.useNode(cached, match);
              if (verbose) console.log(base + this.stackID(stack) + " (via reuse of ".concat(parser.getName(cached.type.id), ")"));
              return true;
            }
            if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;
            var inner = cached.children[0];
            if (inner instanceof Tree && cached.positions[0] == 0) cached = inner;else break;
          }
        }
        var defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);
        if (defaultReduce > 0) {
          stack.reduce(defaultReduce);
          if (verbose) console.log(base + this.stackID(stack) + " (via always-reduce ".concat(parser.getName(defaultReduce & 65535 /* Action.ValueMask */), ")"));
          return true;
        }
        if (stack.stack.length >= 15000 /* Rec.CutDepth */) {
          while (stack.stack.length > 9000 /* Rec.CutTo */ && stack.forceReduce()) {}
        }
        var actions = this.tokens.getActions(stack);
        for (var i = 0; i < actions.length;) {
          var action = actions[i++],
            term = actions[i++],
            end = actions[i++];
          var last = i == actions.length || !split;
          var localStack = last ? stack : stack.split();
          localStack.apply(action, term, end);
          if (verbose) console.log(base + this.stackID(localStack) + " (via ".concat((action & 65536 /* Action.ReduceFlag */) == 0 ? "shift" : "reduce of ".concat(parser.getName(action & 65535 /* Action.ValueMask */)), " for ").concat(parser.getName(term), " @ ").concat(start).concat(localStack == stack ? "" : ", split", ")"));
          if (last) return true;else if (localStack.pos > start) stacks.push(localStack);else split.push(localStack);
        }
        return false;
      }
      // Advance a given stack forward as far as it will go. Returns the
      // (possibly updated) stack if it got stuck, or null if it moved
      // forward and was given to `pushStackDedup`.
    }, {
      key: "advanceFully",
      value: function advanceFully(stack, newStacks) {
        var pos = stack.pos;
        for (;;) {
          if (!this.advanceStack(stack, null, null)) return false;
          if (stack.pos > pos) {
            pushStackDedup(stack, newStacks);
            return true;
          }
        }
      }
    }, {
      key: "runRecovery",
      value: function runRecovery(stacks, tokens, newStacks) {
        var finished = null,
          restarted = false;
        for (var i = 0; i < stacks.length; i++) {
          var stack = stacks[i],
            token = tokens[i << 1],
            tokenEnd = tokens[(i << 1) + 1];
          var base = verbose ? this.stackID(stack) + " -> " : "";
          if (stack.deadEnd) {
            if (restarted) continue;
            restarted = true;
            stack.restart();
            if (verbose) console.log(base + this.stackID(stack) + " (restarted)");
            var done = this.advanceFully(stack, newStacks);
            if (done) continue;
          }
          var force = stack.split(),
            forceBase = base;
          for (var j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {
            if (verbose) console.log(forceBase + this.stackID(force) + " (via force-reduce)");
            var _done = this.advanceFully(force, newStacks);
            if (_done) break;
            if (verbose) forceBase = this.stackID(force) + " -> ";
          }
          var _iterator3 = _createForOfIteratorHelper(stack.recoverByInsert(token)),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var insert = _step3.value;
              if (verbose) console.log(base + this.stackID(insert) + " (via recover-insert)");
              this.advanceFully(insert, newStacks);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          if (this.stream.end > stack.pos) {
            if (tokenEnd == stack.pos) {
              tokenEnd++;
              token = 0 /* Term.Err */;
            }

            stack.recoverByDelete(token, tokenEnd);
            if (verbose) console.log(base + this.stackID(stack) + " (via recover-delete ".concat(this.parser.getName(token), ")"));
            pushStackDedup(stack, newStacks);
          } else if (!finished || finished.score < stack.score) {
            finished = stack;
          }
        }
        return finished;
      }
      // Convert the stack's buffer to a syntax tree.
    }, {
      key: "stackToTree",
      value: function stackToTree(stack) {
        stack.close();
        return Tree.build({
          buffer: StackBufferCursor.create(stack),
          nodeSet: this.parser.nodeSet,
          topID: this.topTerm,
          maxBufferLength: this.parser.bufferLength,
          reused: this.reused,
          start: this.ranges[0].from,
          length: stack.pos - this.ranges[0].from,
          minRepeatType: this.parser.minRepeatTerm
        });
      }
    }, {
      key: "stackID",
      value: function stackID(stack) {
        var id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
        if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
      }
    }]);
    return Parse;
  }();
  function pushStackDedup(stack, newStacks) {
    for (var i = 0; i < newStacks.length; i++) {
      var other = newStacks[i];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i].score < stack.score) newStacks[i] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = /*#__PURE__*/function () {
    function Dialect(source, flags, disabled) {
      _classCallCheck(this, Dialect);
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    _createClass(Dialect, [{
      key: "allows",
      value: function allows(term) {
        return !this.disabled || this.disabled[term] == 0;
      }
    }]);
    return Dialect;
  }();
  var id = function id(x) {
    return x;
  };
  /// Context trackers are used to track stateful context (such as
  /// indentation in the Python grammar, or parent elements in the XML
  /// grammar) needed by external tokenizers. You declare them in a
  /// grammar file as `@context exportName from "module"`.
  ///
  /// Context values should be immutable, and can be updated (replaced)
  /// on shift or reduce actions.
  ///
  /// The export used in a `@context` declaration should be of this
  /// type.
  var ContextTracker = /*#__PURE__*/_createClass(
  /// Define a context tracker.
  function ContextTracker(spec) {
    _classCallCheck(this, ContextTracker);
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || function () {
      return 0;
    };
    this.strict = spec.strict !== false;
  }); /// Holds the parse tables for a given grammar, as generated by
  /// `lezer-generator`, and provides [methods](#common.Parser) to parse
  /// content with.
  var LRParser = /*#__PURE__*/function (_Parser) {
    _inherits$1(LRParser, _Parser);
    var _super = _createSuper(LRParser);
    /// @internal
    function LRParser(spec) {
      var _this2$nodeSet;
      var _this2;
      _classCallCheck(this, LRParser);
      _this2 = _super.call(this);
      /// @internal
      _this2.wrappers = [];
      if (spec.version != 14 /* File.Version */) throw new RangeError("Parser version (".concat(spec.version, ") doesn't match runtime version (", 14 /* File.Version */, ")"));
      var nodeNames = spec.nodeNames.split(" ");
      _this2.minRepeatTerm = nodeNames.length;
      for (var i = 0; i < spec.repeatNodeCount; i++) nodeNames.push("");
      var topTerms = Object.keys(spec.topRules).map(function (r) {
        return spec.topRules[r][1];
      });
      var nodeProps = [];
      for (var _i5 = 0; _i5 < nodeNames.length; _i5++) nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps) {
        var _iterator4 = _createForOfIteratorHelper(spec.nodeProps),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var propSpec = _step4.value;
            var prop = propSpec[0];
            if (typeof prop == "string") prop = NodeProp[prop];
            for (var _i6 = 1; _i6 < propSpec.length;) {
              var next = propSpec[_i6++];
              if (next >= 0) {
                setProp(next, prop, propSpec[_i6++]);
              } else {
                var value = propSpec[_i6 + -next];
                for (var j = -next; j > 0; j--) setProp(propSpec[_i6++], prop, value);
                _i6++;
              }
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
      _this2.nodeSet = new NodeSet(nodeNames.map(function (name, i) {
        return NodeType.define({
          name: i >= _this2.minRepeatTerm ? undefined : name,
          id: i,
          props: nodeProps[i],
          top: topTerms.indexOf(i) > -1,
          error: i == 0,
          skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        });
      }));
      if (spec.propSources) _this2.nodeSet = (_this2$nodeSet = _this2.nodeSet).extend.apply(_this2$nodeSet, _toConsumableArray(spec.propSources));
      _this2.strict = false;
      _this2.bufferLength = DefaultBufferLength;
      var tokenArray = decodeArray(spec.tokenData);
      _this2.context = spec.context;
      _this2.specializerSpecs = spec.specialized || [];
      _this2.specialized = new Uint16Array(_this2.specializerSpecs.length);
      for (var _i7 = 0; _i7 < _this2.specializerSpecs.length; _i7++) _this2.specialized[_i7] = _this2.specializerSpecs[_i7].term;
      _this2.specializers = _this2.specializerSpecs.map(getSpecializer);
      _this2.states = decodeArray(spec.states, Uint32Array);
      _this2.data = decodeArray(spec.stateData);
      _this2["goto"] = decodeArray(spec["goto"]);
      _this2.maxTerm = spec.maxTerm;
      _this2.tokenizers = spec.tokenizers.map(function (value) {
        return typeof value == "number" ? new TokenGroup(tokenArray, value) : value;
      });
      _this2.topRules = spec.topRules;
      _this2.dialects = spec.dialects || {};
      _this2.dynamicPrecedences = spec.dynamicPrecedences || null;
      _this2.tokenPrecTable = spec.tokenPrec;
      _this2.termNames = spec.termNames || null;
      _this2.maxNode = _this2.nodeSet.types.length - 1;
      _this2.dialect = _this2.parseDialect();
      _this2.top = _this2.topRules[Object.keys(_this2.topRules)[0]];
      return _this2;
    }
    _createClass(LRParser, [{
      key: "createParse",
      value: function createParse(input, fragments, ranges) {
        var parse = new Parse(this, input, fragments, ranges);
        var _iterator5 = _createForOfIteratorHelper(this.wrappers),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var w = _step5.value;
            parse = w(parse, input, fragments, ranges);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        return parse;
      }
      /// Get a goto table entry @internal
    }, {
      key: "getGoto",
      value: function getGoto(state, term) {
        var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var table = this["goto"];
        if (term >= table[0]) return -1;
        for (var pos = table[term + 1];;) {
          var groupTag = table[pos++],
            last = groupTag & 1;
          var target = table[pos++];
          if (last && loose) return target;
          for (var end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;
          if (last) return -1;
        }
      }
      /// Check if this state has an action for a given terminal @internal
    }, {
      key: "hasAction",
      value: function hasAction(state, terminal) {
        var data = this.data;
        for (var set = 0; set < 2; set++) {
          for (var i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {
            if ((next = data[i]) == 65535 /* Seq.End */) {
              if (data[i + 1] == 1 /* Seq.Next */) next = data[i = pair(data, i + 2)];else if (data[i + 1] == 2 /* Seq.Other */) return pair(data, i + 2);else break;
            }
            if (next == terminal || next == 0 /* Term.Err */) return pair(data, i + 1);
          }
        }
        return 0;
      }
      /// @internal
    }, {
      key: "stateSlot",
      value: function stateSlot(state, slot) {
        return this.states[state * 6 /* ParseState.Size */ + slot];
      }
      /// @internal
    }, {
      key: "stateFlag",
      value: function stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;
      }
      /// @internal
    }, {
      key: "validAction",
      value: function validAction(state, action) {
        return !!this.allActions(state, function (a) {
          return a == action ? true : null;
        });
      }
      /// @internal
    }, {
      key: "allActions",
      value: function allActions(state, action) {
        var deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);
        var result = deflt ? action(deflt) : undefined;
        for (var i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {
          if (this.data[i] == 65535 /* Seq.End */) {
            if (this.data[i + 1] == 1 /* Seq.Next */) i = pair(this.data, i + 2);else break;
          }
          result = action(pair(this.data, i + 1));
        }
        return result;
      }
      /// Get the states that can follow this one through shift actions or
      /// goto jumps. @internal
    }, {
      key: "nextStates",
      value: function nextStates(state) {
        var _this3 = this;
        var result = [];
        var _loop2 = function _loop2() {
          if (_this3.data[i] == 65535 /* Seq.End */) {
            if (_this3.data[i + 1] == 1 /* Seq.Next */) i = pair(_this3.data, i + 2);else return "break";
          }
          if ((_this3.data[i + 2] & 65536 /* Action.ReduceFlag */ >> 16) == 0) {
            var value = _this3.data[i + 1];
            if (!result.some(function (v, i) {
              return i & 1 && v == value;
            })) result.push(_this3.data[i], value);
          }
        };
        for (var i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {
          var _ret = _loop2();
          if (_ret === "break") break;
        }
        return result;
      }
      /// Configure the parser. Returns a new parser instance that has the
      /// given settings modified. Settings not provided in `config` are
      /// kept from the original parser.
    }, {
      key: "configure",
      value: function configure(config) {
        var _this$nodeSet;
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        var copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props) copy.nodeSet = (_this$nodeSet = this.nodeSet).extend.apply(_this$nodeSet, _toConsumableArray(config.props));
        if (config.top) {
          var info = this.topRules[config.top];
          if (!info) throw new RangeError("Invalid top rule name ".concat(config.top));
          copy.top = info;
        }
        if (config.tokenizers) copy.tokenizers = this.tokenizers.map(function (t) {
          var found = config.tokenizers.find(function (r) {
            return r.from == t;
          });
          return found ? found.to : t;
        });
        if (config.specializers) {
          copy.specializers = this.specializers.slice();
          copy.specializerSpecs = this.specializerSpecs.map(function (s, i) {
            var found = config.specializers.find(function (r) {
              return r.from == s.external;
            });
            if (!found) return s;
            var spec = Object.assign(Object.assign({}, s), {
              external: found.to
            });
            copy.specializers[i] = getSpecializer(spec);
            return spec;
          });
        }
        if (config.contextTracker) copy.context = config.contextTracker;
        if (config.dialect) copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null) copy.strict = config.strict;
        if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null) copy.bufferLength = config.bufferLength;
        return copy;
      }
      /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
      /// are registered for this parser.
    }, {
      key: "hasWrappers",
      value: function hasWrappers() {
        return this.wrappers.length > 0;
      }
      /// Returns the name associated with a given term. This will only
      /// work for all terms when the parser was generated with the
      /// `--names` option. By default, only the names of tagged terms are
      /// stored.
    }, {
      key: "getName",
      value: function getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
      }
      /// The eof term id is always allocated directly after the node
      /// types. @internal
    }, {
      key: "eofTerm",
      get: function get() {
        return this.maxNode + 1;
      }
      /// The type of top node produced by the parser.
    }, {
      key: "topNode",
      get: function get() {
        return this.nodeSet.types[this.top[1]];
      }
      /// @internal
    }, {
      key: "dynamicPrecedence",
      value: function dynamicPrecedence(term) {
        var prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
      }
      /// @internal
    }, {
      key: "parseDialect",
      value: function parseDialect(dialect) {
        var values = Object.keys(this.dialects),
          flags = values.map(function () {
            return false;
          });
        if (dialect) {
          var _iterator6 = _createForOfIteratorHelper(dialect.split(" ")),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var part = _step6.value;
              var _id = values.indexOf(part);
              if (_id >= 0) flags[_id] = true;
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
        var disabled = null;
        for (var i = 0; i < values.length; i++) if (!flags[i]) {
          for (var j = this.dialects[values[i]], _id2; (_id2 = this.data[j++]) != 65535 /* Seq.End */;) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[_id2] = 1;
        }
        return new Dialect(dialect, flags, disabled);
      }
      /// Used by the output of the parser generator. Not available to
      /// user code. @hide
    }], [{
      key: "deserialize",
      value: function deserialize(spec) {
        return new LRParser(spec);
      }
    }]);
    return LRParser;
  }(Parser);
  function pair(data, off) {
    return data[off] | data[off + 1] << 16;
  }
  function findFinished(stacks) {
    var best = null;
    var _iterator7 = _createForOfIteratorHelper(stacks),
      _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var stack = _step7.value;
        var stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) && (!best || best.score < stack.score)) best = stack;
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      var mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;
      return function (value, stack) {
        return spec.external(value, stack) << 1 | mask;
      };
    }
    return spec.get;
  }

  var _identifiersMap, _prefixedContextStart, _contextStarts, _contextEnds;

  // This file was generated by lezer-generator. You probably shouldn't edit it.
  var propertyIdentifier = 120,
    identifier = 121,
    nameIdentifier = 122,
    insertSemi = 123,
    expression0 = 127,
    ForExpression = 4,
    forExpressionStart = 130,
    ForInExpression = 7,
    Name = 8,
    Identifier = 9,
    AdditionalIdentifier = 10,
    forExpressionBodyStart = 138,
    IfExpression = 19,
    ifExpressionStart = 139,
    QuantifiedExpression = 23,
    quantifiedExpressionStart = 140,
    QuantifiedInExpression = 27,
    PositiveUnaryTest = 37,
    ArithmeticExpression = 41,
    arithmeticPlusStart = 144,
    arithmeticTimesStart = 145,
    arithmeticExpStart = 146,
    arithmeticUnaryStart = 147,
    VariableName = 47,
    PathExpression = 67,
    pathExpressionStart = 152,
    FilterExpression = 69,
    filterExpressionStart = 153,
    FunctionInvocation = 71,
    functionInvocationStart = 154,
    ParameterName = 75,
    nil = 159,
    NumericLiteral = 78,
    StringLiteral = 79,
    BooleanLiteral = 80,
    List$1 = 88,
    listStart = 170,
    FunctionDefinition = 89,
    functionDefinitionStart = 172,
    Context = 96,
    contextStart = 174,
    ContextEntry = 97,
    PropertyName = 99,
    PropertyIdentifier = 100;

  /* global console,process */

  var LOG_PARSE = typeof process != 'undefined' && process.env && /\bfparse(:dbg)?\b/.test(process.env.LOG);
  var LOG_PARSE_DEBUG = typeof process != 'undefined' && process.env && /\bfparse:dbg\b/.test(process.env.LOG);
  var LOG_VARS = typeof process != 'undefined' && process.env && /\bcontext\b/.test(process.env.LOG);
  var spaceChars = [9, 11, 12, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];
  var newlineChars = chars('\n\r');
  var asterix = '*'.charCodeAt(0);
  var additionalNameChars = chars("'./-+*^");

  /**
   * @typedef { VariableContext | any } ContextValue
   */

  /**
   * @param { string } str
   * @return { number[] }
   */
  function chars(str) {
    return Array.from(str).map(function (s) {
      return s.charCodeAt(0);
    });
  }

  /**
   * @param { number } ch
   * @return { boolean }
   */
  function isStartChar(ch) {
    return ch === 63 // ?
    || ch === 95 // _
    || ch >= 65 && ch <= 90 // A-Z
    || ch >= 97 && ch <= 122 // a-z
    || ch >= 161 && !isPartChar(ch) && !isSpace(ch);
  }

  /**
   * @param { number } ch
   * @return { boolean }
   */
  function isAdditional(ch) {
    return additionalNameChars.includes(ch);
  }

  /**
   * @param { number } ch
   * @return { boolean }
   */
  function isPartChar(ch) {
    return ch >= 48 && ch <= 57 // 0-9
    || ch === 0xB7 || ch >= 0x0300 && ch <= 0x036F || ch >= 0x203F && ch <= 0x2040;
  }

  /**
   * @param { number } ch
   * @return { boolean }
   */
  function isSpace(ch) {
    return spaceChars.includes(ch);
  }

  // eslint-disable-next-line
  function indent(str, spaces) {
    return spaces.concat(str.split(/\n/g).join('\n' + spaces));
  }

  /**
   * @param { import('@lezer/lr').InputStream } input
   * @param  { number } [offset]
   *
   * @return { { token: string, offset: number } | null }
   */
  function parseAdditionalSymbol(input) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var next = input.peek(offset);
    if (next === asterix && input.peek(offset + 1) === asterix) {
      return {
        offset: 2,
        token: '**'
      };
    }
    if (isAdditional(next)) {
      return {
        offset: 1,
        token: String.fromCharCode(next)
      };
    }
    return null;
  }

  /**
   * @param { import('@lezer/lr').InputStream } input
   * @param { number } [offset]
   * @param { boolean } [namePart]
   *
   * @return { { token: string, offset: number } | null }
   */
  function parseIdentifier(input) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var namePart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    for (var inside = false, _chars = [], i = 0;; i++) {
      var next = input.peek(offset + i);
      if (isStartChar(next) || (inside || namePart) && isPartChar(next)) {
        if (!inside) {
          inside = true;
        }
        _chars.push(next);
      } else {
        if (_chars.length) {
          return {
            token: String.fromCharCode.apply(String, _chars),
            offset: i
          };
        }
        return null;
      }
    }
  }

  /**
   * @param { import('@lezer/lr').InputStream } input
   * @param  { number } offset
   *
   * @return { { token: string, offset: number } | null }
   */
  function parseSpaces(input, offset) {
    for (var inside = false, i = 0;; i++) {
      var next = input.peek(offset + i);
      if (isSpace(next)) {
        if (!inside) {
          inside = true;
        }
      } else {
        if (inside) {
          return {
            token: ' ',
            offset: i
          };
        }
        return null;
      }
    }
  }

  /**
   * Parse a name from the input and return the first match, if any.
   *
   * @param { import('@lezer/lr').InputStream } input
   * @param { Variables } variables
   *
   * @return { { token: string, offset: number, term: number } | null }
   */
  function parseName(input, variables) {
    var contextKeys = variables.contextKeys();
    var start = variables.tokens;
    var _loop = function _loop() {
      var namePart = start.length + tokens.length > 0;
      var maybeSpace = tokens.length > 0;
      var match = parseIdentifier(input, i, namePart) || namePart && parseAdditionalSymbol(input, i) || maybeSpace && parseSpaces(input, i);

      // match is required
      if (!match) {
        return {
          v: nextMatch
        };
      }
      var token = match.token,
        offset = match.offset;
      i += offset;
      if (token === ' ') {
        return "continue";
      }
      tokens = [].concat(_toConsumableArray(tokens), [token]);
      var name = [].concat(_toConsumableArray(start), _toConsumableArray(tokens)).join(' ');
      if (contextKeys.some(function (el) {
        return el === name;
      })) {
        var _token = tokens[0];
        nextMatch = {
          token: _token,
          offset: _token.length,
          term: nameIdentifier
        };
      }
      if (dateTimeIdentifiers.some(function (el) {
        return el === name;
      })) {
        var _token2 = tokens[0];

        // parse date time identifiers as normal
        // identifiers to allow specialization to kick in
        //
        // cf. https://github.com/nikku/lezer-feel/issues/8
        nextMatch = {
          token: _token2,
          offset: _token2.length,
          term: identifier
        };
      }
      if (!contextKeys.some(function (el) {
        return el.startsWith(name);
      }) && !dateTimeIdentifiers.some(function (el) {
        return el.startsWith(name);
      })) {
        return {
          v: nextMatch
        };
      }
    };
    for (var i = 0, tokens = [], nextMatch = null;;) {
      var _ret = _loop();
      if (_ret === "continue") continue;
      if (_typeof(_ret) === "object") return _ret.v;
    }
  }
  var identifiersMap = (_identifiersMap = {}, _defineProperty$M(_identifiersMap, identifier, 'identifier'), _defineProperty$M(_identifiersMap, nameIdentifier, 'nameIdentifier'), _identifiersMap);
  var identifiers = new ExternalTokenizer(function (input, stack) {
    LOG_PARSE_DEBUG && console.log('%s: T <identifier | nameIdentifier>', input.pos);
    var nameMatch = parseName(input, stack.context);
    var start = stack.context.tokens;
    var match = nameMatch || parseIdentifier(input, 0, start.length > 0);
    if (match) {
      input.advance(match.offset);
      input.acceptToken(nameMatch ? nameMatch.term : identifier);
      LOG_PARSE && console.log('%s: MATCH <%s> <%s>', input.pos, nameMatch ? identifiersMap[nameMatch.term] : 'identifier', match.token);
    }
  }, {
    contextual: true
  });
  var propertyIdentifiers = new ExternalTokenizer(function (input, stack) {
    LOG_PARSE_DEBUG && console.log('%s: T <propertyIdentifier>', input.pos);
    var start = stack.context.tokens;
    var match = parseIdentifier(input, 0, start.length > 0);
    if (match) {
      input.advance(match.offset);
      input.acceptToken(propertyIdentifier);
      LOG_PARSE && console.log('%s: MATCH <propertyIdentifier> <%s>', input.pos, match.token);
    }
  });
  var insertSemicolon = new ExternalTokenizer(function (input, stack) {
    LOG_PARSE_DEBUG && console.log('%s: T <insertSemi>', input.pos);
    var offset;
    var insert = false;
    for (offset = 0;; offset++) {
      var _char = input.peek(offset);
      if (spaceChars.includes(_char)) {
        continue;
      }
      if (newlineChars.includes(_char)) {
        insert = true;
      }
      break;
    }
    if (insert) {
      var _identifier = parseIdentifier(input, offset + 1);
      var spaces = parseSpaces(input, offset + 1);
      if (spaces || _identifier && /^(then|else|return|satisfies)$/.test(_identifier.token)) {
        return;
      }
      LOG_PARSE && console.log('%s: MATCH <insertSemi>', input.pos);
      input.acceptToken(insertSemi);
    }
  });
  var prefixedContextStarts = (_prefixedContextStart = {}, _defineProperty$M(_prefixedContextStart, functionInvocationStart, 'FunctionInvocation'), _defineProperty$M(_prefixedContextStart, filterExpressionStart, 'FilterExpression'), _defineProperty$M(_prefixedContextStart, pathExpressionStart, 'PathExpression'), _prefixedContextStart);
  var contextStarts = (_contextStarts = {}, _defineProperty$M(_contextStarts, contextStart, 'Context'), _defineProperty$M(_contextStarts, functionDefinitionStart, 'FunctionDefinition'), _defineProperty$M(_contextStarts, forExpressionStart, 'ForExpression'), _defineProperty$M(_contextStarts, listStart, 'List'), _defineProperty$M(_contextStarts, ifExpressionStart, 'IfExpression'), _defineProperty$M(_contextStarts, quantifiedExpressionStart, 'QuantifiedExpression'), _contextStarts);
  var contextEnds = (_contextEnds = {}, _defineProperty$M(_contextEnds, Context, 'Context'), _defineProperty$M(_contextEnds, FunctionDefinition, 'FunctionDefinition'), _defineProperty$M(_contextEnds, ForExpression, 'ForExpression'), _defineProperty$M(_contextEnds, List$1, 'List'), _defineProperty$M(_contextEnds, IfExpression, 'IfExpression'), _defineProperty$M(_contextEnds, QuantifiedExpression, 'QuantifiedExpression'), _defineProperty$M(_contextEnds, PathExpression, 'PathExpression'), _defineProperty$M(_contextEnds, FunctionInvocation, 'FunctionInvocation'), _defineProperty$M(_contextEnds, FilterExpression, 'FilterExpression'), _defineProperty$M(_contextEnds, ArithmeticExpression, 'ArithmeticExpression'), _contextEnds);
  var ValueProducer = /*#__PURE__*/function () {
    /**
     * @param { Function } fn
     */
    function ValueProducer(fn) {
      _classCallCheck(this, ValueProducer);
      this.fn = fn;
    }
    _createClass(ValueProducer, [{
      key: "get",
      value: function get(variables) {
        return this.fn(variables);
      }

      /**
       * @param { Function }
       *
       * @return { ValueProducer }
       */
    }], [{
      key: "of",
      value: function of(fn) {
        return new ValueProducer(fn);
      }
    }]);
    return ValueProducer;
  }();
  var dateTimeLiterals = {
    'date and time': 1,
    'date': 1,
    'time': 1,
    'duration': 1
  };
  var dateTimeIdentifiers = Object.keys(dateTimeLiterals);

  /**
   * A basic key-value store to hold context values.
   */
  var VariableContext = /*#__PURE__*/function () {
    /**
     * Creates a new context from a JavaScript object.
     *
     * @param {any} value
     */
    function VariableContext() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VariableContext);
      /**
       * @protected
       */
      this.value = value;
    }

    /**
     * Return all defined keys of the context.
     *
     * @returns {Array<string>} the keys of the context
     */
    _createClass(VariableContext, [{
      key: "getKeys",
      value: function getKeys() {
        return Object.keys(this.value);
      }

      /**
       * Returns the value of the given key.
       *
       * If the value represents a context itself, it should be wrapped in a
       * context class.
       *
       * @param {String} key
       * @returns {VariableContext|ValueProducer|null}
       */
    }, {
      key: "get",
      value: function get(key) {
        var result = this.value[key];
        if (this.constructor.isAtomic(result)) {
          return result;
        }
        return this.constructor.of(result);
      }

      /**
       * Creates a new context with the given key added.
       *
       * @param {String} key
       * @param {any} value
       * @returns {VariableContext} new context with the given key added
       */
    }, {
      key: "set",
      value: function set(key, value) {
        return this.constructor.of(_objectSpread2(_objectSpread2({}, this.value), {}, _defineProperty$M({}, key, value)));
      }

      /**
       * Wether the given value is atomic. Non-atomic values need to be wrapped in a
       * context Class.
       *
       * @param {any} value
       * @returns {Boolean}
       */
    }], [{
      key: "isAtomic",
      value: function isAtomic(value) {
        return !value || value instanceof this || value instanceof ValueProducer || _typeof(value) !== 'object';
      }

      /**
       * Takes any number of Contexts and merges them into a single Context.
       *
       * @param  {...Context} contexts
       * @returns {VariableContext}
       */
    }, {
      key: "of",
      value: function of() {
        var _this = this;
        var unwrap = function unwrap(context) {
          if (!context || _typeof(context) !== 'object') {
            return {};
          }
          if (context instanceof _this) {
            return context.value;
          }
          return _objectSpread2({}, context);
        };
        for (var _len = arguments.length, contexts = new Array(_len), _key = 0; _key < _len; _key++) {
          contexts[_key] = arguments[_key];
        }
        var merged = contexts.reduce(function (merged, context) {
          return _objectSpread2(_objectSpread2({}, merged), unwrap(context));
        }, {});
        return new this(merged);
      }
    }]);
    return VariableContext;
  }();
  var Variables = /*#__PURE__*/function () {
    function Variables() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Expressions' : _ref$name,
        _ref$tokens = _ref.tokens,
        tokens = _ref$tokens === void 0 ? [] : _ref$tokens,
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        _ref$parent = _ref.parent,
        parent = _ref$parent === void 0 ? null : _ref$parent,
        context = _ref.context,
        value = _ref.value,
        raw = _ref.raw;
      _classCallCheck(this, Variables);
      this.name = name;
      this.tokens = tokens;
      this.children = children;
      this.parent = parent;
      this.context = context;
      this.value = value;
      this.raw = raw;
    }
    _createClass(Variables, [{
      key: "enterScope",
      value: function enterScope(name) {
        var childScope = this.of({
          name: name,
          parent: this
        });
        LOG_VARS && console.log('[%s] enter', childScope.path, childScope.context);
        return childScope;
      }
    }, {
      key: "exitScope",
      value: function exitScope(str) {
        if (!this.parent) {
          LOG_VARS && console.log('[%s] NO exit %o\n%s', this.path, this.context, indent(str, '  '));
          return this;
        }
        LOG_VARS && console.log('[%s] exit %o\n%s', this.path, this.context, indent(str, '  '));
        return this.parent.pushChild(this);
      }
    }, {
      key: "token",
      value: function token(part) {
        LOG_VARS && console.log('[%s] token <%s> + <%s>', this.path, this.tokens.join(' '), part);
        return this.assign({
          tokens: [].concat(_toConsumableArray(this.tokens), [part])
        });
      }
    }, {
      key: "literal",
      value: function literal(value) {
        LOG_VARS && console.log('[%s] literal %o', this.path, value);
        return this.pushChild(this.of({
          name: 'Literal',
          value: value
        }));
      }

      /**
       * Return computed scope value
       *
       * @return {any}
       */
    }, {
      key: "computedValue",
      value: function computedValue() {
        for (var scope = this;; scope = last(scope.children)) {
          if (!scope) {
            return null;
          }
          if (scope.value) {
            return scope.value;
          }
        }
      }
    }, {
      key: "contextKeys",
      value: function contextKeys() {
        return this.context.getKeys().map(normalizeContextKey);
      }
    }, {
      key: "path",
      get: function get() {
        var _this$parent, _this$parent$path;
        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : (_this$parent$path = _this$parent.path) === null || _this$parent$path === void 0 ? void 0 : _this$parent$path.concat(' > ', this.name)) || this.name;
      }

      /**
       * Return value of variable.
       *
       * @param { string } variable
       * @return { any } value
       */
    }, {
      key: "get",
      value: function get(variable) {
        var names = [variable, variable && normalizeContextKey(variable)];
        var contextKey = this.context.getKeys().find(function (key) {
          return names.includes(normalizeContextKey(key));
        });
        if (typeof contextKey === 'undefined') {
          return undefined;
        }
        var val = this.context.get(contextKey);
        if (val instanceof ValueProducer) {
          return val.get(this);
        } else {
          return val;
        }
      }
    }, {
      key: "resolveName",
      value: function resolveName() {
        var variable = this.tokens.join(' ');
        var tokens = [];
        var parentScope = this.assign({
          tokens: tokens
        });
        var variableScope = this.of({
          name: 'VariableName',
          parent: parentScope,
          value: this.get(variable),
          raw: variable
        });
        LOG_VARS && console.log('[%s] resolve name <%s=%s>', variableScope.path, variable, this.get(variable));
        return parentScope.pushChild(variableScope);
      }
    }, {
      key: "pushChild",
      value: function pushChild(child) {
        if (!child) {
          return this;
        }
        var parent = this.assign({
          children: [].concat(_toConsumableArray(this.children), [child])
        });
        child.parent = parent;
        return parent;
      }
    }, {
      key: "pushChildren",
      value: function pushChildren(children) {
        var parent = this;
        var _iterator = _createForOfIteratorHelper(children),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;
            parent = parent.pushChild(child);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return parent;
      }
    }, {
      key: "declareName",
      value: function declareName() {
        if (this.tokens.length === 0) {
          throw Error('no tokens to declare name');
        }
        var variableName = this.tokens.join(' ');
        LOG_VARS && console.log('[%s] declareName <%s>', this.path, variableName);
        return this.assign({
          tokens: []
        }).pushChild(this.of({
          name: 'Name',
          value: variableName
        }));
      }
    }, {
      key: "define",
      value: function define(name, value) {
        if (typeof name !== 'string') {
          LOG_VARS && console.log('[%s] no define <%s=%s>', this.path, name, value);
          return this;
        }
        LOG_VARS && console.log('[%s] define <%s=%s>', this.path, name, value);
        var context = this.context.set(name, value);
        return this.assign({
          context: context
        });
      }

      /**
       * @param { Record<string, any> } [options]
       *
       * @return { Variables }
       */
    }, {
      key: "assign",
      value: function assign() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return Variables.of(_objectSpread2(_objectSpread2({}, this), options));
      }

      /**
       * @param { Record<string, any> } [options]
       *
       * @return { Variables }
       */
    }, {
      key: "of",
      value: function of() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          context: this.context,
          parent: this.parent
        };
        return Variables.of(_objectSpread2(_objectSpread2({}, defaultOptions), options));
      }
    }], [{
      key: "of",
      value: function of(options) {
        var name = options.name,
          _options$tokens = options.tokens,
          tokens = _options$tokens === void 0 ? [] : _options$tokens,
          _options$children = options.children,
          children = _options$children === void 0 ? [] : _options$children,
          _options$parent = options.parent,
          parent = _options$parent === void 0 ? null : _options$parent,
          context = options.context,
          value = options.value,
          raw = options.raw;
        if (!context) {
          throw new Error('must provide <context>');
        }
        return new Variables({
          name: name,
          tokens: _toConsumableArray(tokens),
          children: _toConsumableArray(children),
          context: context,
          parent: parent,
          value: value,
          raw: raw
        });
      }
    }]);
    return Variables;
  }();
  /**
   * @param { string } name
   *
   * @return { string } normalizedName
   */
  function normalizeContextKey(name) {
    return name.replace(/\s*([./\-'+]|\*\*?)\s*/g, ' $1 ').replace(/\s{2,}/g, ' ').trim();
  }

  /**
   * Wrap children of variables under the given named child.
   *
   * @param { Variables } variables
   * @param { string } name
   * @param { string } code
   * @return { Variables }
   */
  function wrap(variables, scopeName, code) {
    var parts = variables.children.filter(function (c) {
      return c.name !== scopeName;
    });
    var children = variables.children.filter(function (c) {
      return c.name === scopeName;
    });
    var namePart = parts[0];
    var valuePart = parts[Math.max(1, parts.length - 1)];
    var name = namePart.computedValue();
    var value = (valuePart === null || valuePart === void 0 ? void 0 : valuePart.computedValue()) || null;
    return variables.assign({
      children: children
    }).enterScope(scopeName).pushChildren(parts).exitScope(code).define(name, value);
  }

  /**
   * @param { ContextValue } [context]
   * @param { typeof VariableContext } [Context]
   *
   * @return { ContextTracker<Variables> }
   */
  function trackVariables() {
    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var Context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VariableContext;
    var start = Variables.of({
      context: Context.of(context)
    });
    return new ContextTracker({
      start: start,
      reduce: function reduce(variables, term, stack, input) {
        if (term === IfExpression) {
          var _variables$children$s = variables.children.slice(-2),
            _variables$children$s2 = _slicedToArray$1(_variables$children$s, 2),
            thenPart = _variables$children$s2[0],
            elsePart = _variables$children$s2[1];
          variables = variables.assign({
            value: Context.of(thenPart === null || thenPart === void 0 ? void 0 : thenPart.computedValue(), elsePart === null || elsePart === void 0 ? void 0 : elsePart.computedValue())
          });
        }
        if (term === List$1) {
          variables = variables.assign({
            value: Context.of.apply(Context, _toConsumableArray(variables.children.map(function (c) {
              return c === null || c === void 0 ? void 0 : c.computedValue();
            })))
          });
        }
        if (term === FilterExpression) {
          var _variables$children$s3 = variables.children.slice(-2),
            _variables$children$s4 = _slicedToArray$1(_variables$children$s3, 2),
            sourcePart = _variables$children$s4[0];
            _variables$children$s4[1];
          variables = variables.assign({
            value: sourcePart === null || sourcePart === void 0 ? void 0 : sourcePart.computedValue()
          });
        }
        if (term === FunctionInvocation) {
          var _variables$children = _toArray(variables.children),
            name = _variables$children[0],
            args = _variables$children.slice(1);

          // preserve type information through `get value(context, key)` utility
          if ((name === null || name === void 0 ? void 0 : name.raw) === 'get value') {
            variables = getContextValue(variables, args);
          }
        }
        var start = contextStarts[term];
        if (start) {
          return variables.enterScope(start);
        }
        var prefixedStart = prefixedContextStarts[term];

        // pull <expression> into new <prefixedStart> context
        if (prefixedStart) {
          var _variables = variables,
            currentChildren = _variables.children,
            currentContext = _variables.context;
          var children = currentChildren.slice(0, -1);
          var lastChild = last(currentChildren);
          var newContext = null;
          if (term === pathExpressionStart) {
            newContext = Context.of(lastChild === null || lastChild === void 0 ? void 0 : lastChild.computedValue());
          }
          if (term === filterExpressionStart) {
            newContext = Context.of(currentContext, lastChild === null || lastChild === void 0 ? void 0 : lastChild.computedValue()).set('item', lastChild === null || lastChild === void 0 ? void 0 : lastChild.computedValue());
          }
          return variables.assign({
            children: children
          }).enterScope(prefixedStart).pushChild(lastChild).assign({
            context: newContext || currentContext
          });
        }
        var code = input.read(input.pos, stack.pos);
        var end = contextEnds[term];
        if (end) {
          return variables.exitScope(code);
        }
        if (term === ContextEntry) {
          var parts = variables.children.filter(function (c) {
            return c.name !== 'ContextEntry';
          });
          var _name = parts[0];
          var value = last(parts);
          return wrap(variables, 'ContextEntry', code).assign({
            value: Context.of(variables.value).set(_name.computedValue(), value === null || value === void 0 ? void 0 : value.computedValue())
          });
        }
        if (term === ForInExpression || term === QuantifiedInExpression) {
          return wrap(variables, 'InExpression', code);
        }

        // define <partial> within ForExpression body
        if (term === forExpressionBodyStart) {
          return variables.define('partial', ValueProducer.of(function (variables) {
            var _last;
            return (_last = last(variables.children)) === null || _last === void 0 ? void 0 : _last.computedValue();
          }));
        }
        if (term === ParameterName) {
          var _name2 = last(variables.children).computedValue();

          // TODO: attach type information
          return variables.define(_name2, 1);
        }

        // pull <expression> into ArithmeticExpression child
        if (term === arithmeticPlusStart || term === arithmeticTimesStart || term === arithmeticExpStart) {
          var _children = variables.children.slice(0, -1);
          var _lastChild = last(variables.children);
          return variables.assign({
            children: _children
          }).enterScope('ArithmeticExpression').pushChild(_lastChild);
        }
        if (term === arithmeticUnaryStart) {
          return variables.enterScope('ArithmeticExpression');
        }
        if (term === Identifier || term === AdditionalIdentifier || term === PropertyIdentifier) {
          return variables.token(code);
        }
        if (term === StringLiteral) {
          return variables.literal(code.replace(/^"|"$/g, ''));
        }
        if (term === BooleanLiteral) {
          return variables.literal(code === 'true' ? true : false);
        }
        if (term === NumericLiteral) {
          return variables.literal(parseFloat(code));
        }
        if (term === nil) {
          return variables.literal(null);
        }
        if (term === VariableName) {
          return variables.resolveName();
        }
        if (term === Name || term === PropertyName) {
          return variables.declareName();
        }
        if (term === expression0 || term === PositiveUnaryTest) {
          if (variables.tokens.length > 0) {
            throw new Error('uncleared name');
          }
        }
        if (term === expression0) {
          var parent = variables;
          while (parent.parent) {
            parent = parent.exitScope(code);
          }
          return parent;
        }
        return variables;
      }
    });
  }
  var variableTracker = trackVariables({});

  // helpers //////////////

  function getContextValue(variables, args) {
    if (!args.length) {
      return variables.assign({
        value: null
      });
    }
    if (args[0].name === 'Name') {
      args = extractNamedArgs(args, ['m', 'key']);
    }
    if (args.length !== 2) {
      return variables.assign({
        value: null
      });
    }
    var _args = args,
      _args2 = _slicedToArray$1(_args, 2),
      context = _args2[0],
      key = _args2[1];
    var keyValue = key === null || key === void 0 ? void 0 : key.computedValue();
    var contextValue = context === null || context === void 0 ? void 0 : context.computedValue();
    if (!contextValue || _typeof(contextValue) !== 'object' || typeof keyValue !== 'string') {
      return variables.assign({
        value: null
      });
    }
    return variables.assign({
      value: [normalizeContextKey(keyValue), keyValue].reduce(function (value, keyValue) {
        return contextValue.get(keyValue) || value;
      }, null)
    });
  }
  function extractNamedArgs(args, argNames) {
    var context = {};
    for (var i = 0; i < args.length; i += 2) {
      var _args$slice = args.slice(i, i + 2),
        _args$slice2 = _slicedToArray$1(_args$slice, 2),
        name = _args$slice2[0],
        value = _args$slice2[1];
      context[name.value] = value;
    }
    return argNames.map(function (name) {
      return context[name];
    });
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  var feelHighlighting = styleTags({
    StringLiteral: tags$1.string,
    NumericLiteral: tags$1.number,
    BooleanLiteral: tags$1.bool,
    'AtLiteral!': tags$1.special(tags$1.string),
    CompareOp: tags$1.compareOperator,
    ArithOp: tags$1.arithmeticOperator,
    'for if then else some every satisfies between return': tags$1.controlKeyword,
    'in instance of and or': tags$1.operatorKeyword,
    "function": tags$1.definitionKeyword,
    as: tags$1.keyword,
    'Type/...': tags$1.typeName,
    Wildcard: tags$1.special,
    "null": tags$1["null"],
    LineComment: tags$1.lineComment,
    BlockComment: tags$1.blockComment,
    'VariableName! "?"': tags$1.variableName,
    'DateTimeConstructor! SpecialFunctionName!': tags$1["function"](tags$1.special(tags$1.variableName)),
    'List Interval': tags$1.list,
    Context: tags$1.definition(tags$1.literal),
    'Name!': tags$1.definition(tags$1.variableName),
    'Key/Name! ContextEntryType/Name!': tags$1.definition(tags$1.propertyName),
    'PathExpression/VariableName!': tags$1["function"](tags$1.propertyName),
    'FormalParameter/ParameterName!': tags$1["function"](tags$1.definition(tags$1.variableName)),
    '( )': tags$1.paren,
    '[ ]': tags$1.squareBracket,
    '{ }': tags$1.brace,
    '.': tags$1.derefOperator,
    ', ;': tags$1.separator,
    '..': tags$1.punctuation
  });

  // This file was generated by lezer-generator. You probably shouldn't edit it.
  var spec_identifier = {
    __proto__: null,
    "for": 10,
    "in": 32,
    "return": 36,
    "if": 40,
    then: 42,
    "else": 44,
    some: 48,
    every: 50,
    satisfies: 57,
    or: 60,
    and: 64,
    between: 72,
    instance: 86,
    of: 89,
    days: 99,
    time: 101,
    duration: 103,
    years: 105,
    months: 107,
    date: 109,
    list: 115,
    context: 121,
    "function": 128,
    "null": 154,
    "true": 326,
    "false": 326,
    "?": 168,
    external: 184,
    not: 209
  };
  var parser = LRParser.deserialize({
    version: 14,
    states: "DSO`QYOOO`QYOOO$gQYOOOOQU'#Ce'#CeO$qQYO'#C`O%zQYO'#FPOOQQ'#Fe'#FeO&UQYO'#FeO`QYO'#DVOOQU'#Em'#EmO'rQ^O'#D]OOQO'#Fl'#FlO)oQWO'#DuOOQQ'#D|'#D|OOQQ'#D}'#D}OOQQ'#EO'#EOO)tOWO'#ERO)oQWO'#EPOOQQ'#EP'#EPOOQQ'#Fr'#FrOOQQ'#Fp'#FpOOQQ'#Fw'#FwO,iQYO'#FwO.gQYO'#FwOOQQ'#ET'#ETO`QYO'#EVOOQQ'#FR'#FRO0cQ^O'#FRO2YQYO'#EWO2aQWO'#EXOOQP'#GQ'#GQO2fQXO'#E`OOQQ'#F{'#F{OOQQ'#FQ'#FQQOQWOOOOQQ'#FS'#FSOOQQ'#F]'#F]O`QYO'#CoOOQQ'#F^'#F^O$qQYO'#CsO2qQYO'#DvOOQQ'#Fq'#FqO2vQYO'#EQOOQO'#EQ'#EQO`QYO'#EUO`QYO'#ETOOQO'#GO'#GOQ3OQWOOO3TQYO'#DRO3zQWO'#FaOOQO'#DT'#DTO4VQYO'#FeO4^QWOOO5TQYO'#CdO5bQYO'#FUOOQQ'#Cc'#CcO5gQYO'#FTOOQQ'#Cb'#CbO5oQYO,58zO`QYO,59iOOQQ'#Fb'#FbOOQQ'#Fc'#FcOOQQ'#Fd'#FdO`QYO,59qO`QYO,59qO`QYO,59qOOQQ'#Fj'#FjO$qQYO,5:]OOQQ'#Fk'#FkO`QYO,5:_O`QYO,59eO`QYO,59gO`QYO,59iO7_QYO,59iO7fQYO,59rOOQQ,5:h,5:hO7kQYO,59qOOQU-E8k-E8kO9_QYO'#FmOOQQ,5:a,5:aOOQQ,5:m,5:mOOQQ,5:k,5:kO9fQYO,5:qOOQQ,5;m,5;mO9mQYO'#FoO9zQWO,5:rO:PQYO,5:sOOQP'#Ed'#EdO:vQXO'#EcOOQO'#Eb'#EbO:}QWO'#EaO;SQWO'#GRO;[QWO,5:zO;aQYO,59ZO5bQYO'#F`OOQQ'#Cw'#CwO;hQYO'#F_OOQQ'#Cv'#CvO;pQYO,59_O;uQYO,5:bO;zQYO,5:lO<PQYO,5:pO<WQYO,5:oO`QYO'#EvQ3OQWOOO`QYO'#ElO<}QWO,5;{O`QYOOOOQR'#Cf'#CfOOQQ'#Ei'#EiO=wQYO,59OO`QYO,5;pOOQQ'#FX'#FXO$qQYO'#EjO>XQYO,5;oO`QYO1G.fOOQQ'#F['#F[O?OQYO1G/TOAuQYO1G/]OBPQYO1G/]OBZQYO1G/]OOQQ1G/w1G/wOC}QYO1G/yODUQYO1G/POE_QYO1G/ROFhQYO1G/TOGOQYO1G/TOOQQ1G/T1G/TOHnQYO1G/^OIYQ^O'#CdOOQO'#Dy'#DyOJlQWO'#DxOJqQWO'#FnOOQO'#Dw'#DwOOQO'#Dz'#DzOJyQWO,5<XOOQQ'#Fz'#FzOOQQ1G0]1G0]O`QYO'#ErOKOQWO,5<ZOOQQ'#F}'#F}OOQQ1G0^1G0^OKZQWO'#EZOKfQWO'#GPOOQO'#EY'#EYOKnQWO1G0_OOQP'#Et'#EtOKsQXO,5:}O`QYO,5:{OKzQXO'#EuOLSQWO,5<mOOQQ1G0f1G0fO`QYO1G.uO`QYO,5;zO$qQYO'#EkOL[QYO,5;yO`QYO1G.yOLdQYO1G/|OOQO1G0W1G0WO`QYO1G0[OOQO,5;b,5;bOOQO-E8t-E8tOOQO,5;W,5;WOOQO-E8j-E8jOLiQWOOOOQQ-E8g-E8gOLnQYO'#CmOOQQ1G1[1G1[OOQQ,5;U,5;UOOQQ-E8h-E8hOL{QYO7+$QOOQQ7+%e7+%eO`QYO7+$oOMrQWO7+$oOMwQYO'#D[OOQQ'#DZ'#DZO! kQYO'#D^O! pQYO'#D^O! uQYO'#D^O! zQ`O'#DfO!!PQ`O'#DiO!!UQ`O'#DmOOQQ7+$x7+$xO`QYO,5:dO$qQYO'#EqO!!ZQWO,5<YOOQQ1G1s1G1sO!!cQYO,5;^OOQO-E8p-E8pOHnQYO,5:uO$qQYO'#EsO!!pQWO,5<kO!!xQYO7+%yOOQP-E8r-E8rO!#PQYO1G0gOOQO,5;a,5;aOOQO-E8s-E8sO!#ZQYO7+$aO!#bQYO1G1fOOQQ,5;V,5;VOOQQ-E8i-E8iO!#lQYO7+$eOOQO7+%h7+%hO!%aQYO7+%vO`QYO,59XO!%nQYO<<HZOOQQ<<HZ<<HZO$qQYO'#EnO!&wQYO,59vO!(kQYO,59xO!(pQYO,59xO!(uQYO,59xO!(zQYO,5:QO$qQYO,5:TO!)fQbO,5:XO!)mQYO1G0OOOQO,5;],5;]OOQO-E8o-E8oOOQO1G0a1G0aOOQO,5;_,5;_OOQO-E8q-E8qO!)wQYO'#E]OOQQ<<Ie<<IeO`QYO<<IeO`QYO<<G{O!*nQYO'#FkOOQQ'#Fx'#FxOOQQ<<Ib<<IbO!-jQYO1G.sOOQQ,5;Y,5;YOOQQ-E8l-E8lO!-tQYO1G/dOOQQ1G/d1G/dO!-yQbO'#D]O!.[Q`O'#D[O!.gQ`O1G/lO!.lQWO'#DlO!.qQ`O'#FfOOQO'#Dk'#DkO!.yQ`O1G/oOOQO'#Dp'#DpO!/OQ`O'#FhOOQO'#Do'#DoO!/WQ`O1G/sOOQQAN?PAN?PO!/]QYOAN=gOOQQ7+%O7+%OO!0SQ`O,59vOOQQ7+%W7+%WO!(zQYO,5:WO$qQYO'#EoO!0_Q`O,5<QOOQQ7+%Z7+%ZO!(zQYO'#EpO!0gQ`O,5<SO!0oQ`O7+%_OOQO1G/r1G/rOOQO,5;Z,5;ZOOQO-E8m-E8mOOQO,5;[,5;[OOQO-E8n-E8nOHnQYO<<HyOOQQAN>eAN>eO$qQYO'#EnO!(zQYO<<HyO!0tQ`O7+%_O!0yQ`O1G/sO!)fQbO,5:XO!1OQ`O'#Dm",
    stateData: "!1]~O#qOS#rOSPOSQOS~OTsOZVO[UOdtOhvOivOs}OvfO!S{O!T{O!UxO!WzO!b!OO!feO!hgO!oyO!vjO#RnO#mRO#nRO$g]O$h^O$i_O$j`O~OTsO[UOdtOhvOivOs}OvfO!S{O!T{O!UxO!WzO!b!OO!feO!hgO!oyO!vjO#RnO#mRO#nRO$g]O$h^O$i_O$j`O~OZ!TO#[!UO~P!|O#mRO#nRO~OZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO!h!fO#y!dOv$`X~O#k#sX$v#sX~P$yO$g!mOT$XXZ$XX[$XXd$XXh$XXi$XXs$XXv$XX!S$XX!T$XX!U$XX!W$XX!b$XX!f$XX!h$XX!o$XX!v$XX#R$XX#m$XX#n$XX$h$XX$i$XX$j$XX~O#mRO#nROZ!PX[!PX]!PX^!PX_!PX`!PXn!PXp!PXr!PXs!PXt!PXv!PX{!PX!h!PX#k!PX#o!PX#y!PX$v!PX#}!PXx!PX!f!PXe!PX#|!PXb!PX#Q!PXf!PXl!PX~Ov!pO~O$h^O~OT$kXT$mXd$kXd$mXh$kXh$mXi$kXi$mXs$kXs$mXv$kXv$mX!S$kX!S$mX!T$kX!T$mX!U$kX!U$mX!W$kX!W$mX!b$kX!b$mX!f$kX!f$mX!h$kX!h$mX!o$kX!o$mX!v$kX!v$mX#R$kX#R$mX$g$kX$g$mX$h$kX$h$mX$i$kX$i$mX$j$kX$j$mX~OZ$kXZ$mX[$kX[$mX#m$kX#m$mX#n$kX#n$mX~P)yOT$kXd$kXh$kXi$kXs$kXv$kX!S$kX!T$kX!U$kX!W$kX!b$kX!f$kX!h$kX!o$kX!v$kX#R$kX$g$kX$h$kX$i$kX$j$kX~OT$pXZ$kXZ$pX[$kX[$pXd$pXh$pXi$pXs$pXv$pX!S$pX!T$pX!U$pX!W$pX!b$pX!f$pX!h$pX!o$pX!v$pX#R$pX#m$kX#m$pX#n$kX#n$pX$g$pX$h$pX$i$pX$j$pX~P-VO#o!uOZ#uX[#uX]#uX^#uX_#uX`#uXn#uXp#uXr#uXs#uXt#uXv#uX{#uX!h#uX#k#uX#y#uX$v#uX#}#uXx#uX!f#uXe#uX#|#uXb#uX#Q#uXf#uXl#uX~O!f$cP~P`Ov!xO~O#l!yO$h^O#Q$uP~Op#VO~Op#WOv!tX~O$v#ZO~O#kuX#}uX$vuXxuX!fuXeuX#|uXbuX#QuXfuXluX~P$yO#}#]O#k$TXx$TX~O#k#ZX~P&UOv#_O~OZ#`O[#`O]#`O^#`O_#`O#mRO#nRO#y#`O#z#`O$ZWX~O`WXxWX#}WX~P4cO`#dO~O#}#eOb#wX~Ob#hO~OTsOZVO[UOdtOhvOivOs}O!S{O!T{O!UxO!WzO!b!OO!feO!hgO!oyO!vjO#RnO#mRO#nRO$g]O$h^O$i_O$j`O~Ov#rO~P5tO|#tO~O{!lO!h!fO#y!dOZya[ya]ya^ya_ya`yanyapyaryasyatyav$`X#kya$vya#}yaxya!fyaeya#|yabya#Qyafyalya~Ox$cP~P`Ox#|O~P$yO#}$OO!f$cXx$cX~P$yO!f$QO~O#mRO#nROx$sP~OZ#`O[#`O]#`O^#`O_#`O#l!yO#y#`O#z#`O~O$Z#VX~P:[O$Z$YO~O#}$ZO#Q$uX~O#Q$]O~Oe$^O~P$yO#}$`Ol$RX~Ol$bO~O!V$cO~O!S$dO~O#|$eO~P$yO#k!wa$v!wa#}!wax!wa!f!wae!wa#|!wab!wa#Q!waf!wal!wa~P$yO#}#]O#k$Tax$Ta~OZ#`O[#`O]#`O^#`O_#`O#mRO#nRO#y#`O#z#`O~O`Wa$ZWaxWa#}Wa~P=YO#}#eOb#wa~OZ!^O[!^O]!_O^!_O_!`O{!lO!h!fO#y!dOv$`X~O`qinqipqirqisqitqi#kqi$vqi#}qixqi!fqieqi#|qibqi#Qqifqilqi~P>aO_!`O{!lO!h!fO#y!dOZyi[yi`yinyipyiryisyityiv$`X#kyi$vyi#}yixyi!fyieyi#|yibyi#Qyifyilyi~O]!_O^!_O~P@XO]yi^yi~P@XO{!lO!h!fO#y!dOZyi[yi]yi^yi_yi`yinyipyiryisyityiv$`X#kyi$vyi#}yixyi!fyieyi#|yibyi#Qyifyilyi~O!f$qO~P$yO`!kOp!iOr!]Os!]Ot!jOnmi#kmi$vmi#}mixmi!fmiemi#|mibmi#Qmifmilmi~P>aO`!kOr!]Os!]Ot!jOnoipoi#koi$voi#}oixoi!foieoi#|oiboi#Qoifoiloi~P>aO`!kOn!hOp$rOr!]Os!]Ot!jO~P>aOTsOZVO[UOdtOhvOivOs}OvfO!S{O!T{O!UxO!WzO!b!OO!feO!hgO!oyO!vjO#RnO#mRO#nRO$g]O$h^O$i_O$j`O~P)yO!R$vO!U$wO!W$xO!Z$yO!^$zO!b${O#mRO#nRO~OZ#aX[#aX]#aX^#aX_#aX`#aXn#aXp#aXr#aXs#aXt#aXv#aXx#aX{#aX!h#aX#m#aX#n#aX#o#aX#y#aX#}#aX~P4cO$Z$}O~O#}%OOx$bX~Ox%QO~O#}$OO!f$cax$ca~O$Z%TOx!}X#}!}X~O#}%UOx$sX~Ox%WO~O$Z#Va~P:[O#l!yO$h^O~O#}$ZO#Q$ua~O#}$`Ol$Ra~O!T%bO~OxrO~O#|%dObaX#}aX~P$yO#kSq$vSq#}SqxSq!fSqeSq#|SqbSq#QSqfSqlSq~P$yOx%fO~O#y%gOZ!OX[!OX]!OX^!OX_!OX`!OXn!OXp!OXr!OXs!OXt!OXv!OX{!OX!h!OX#k!OX$v!OX#}!OXx!OX!f!OXe!OX#|!OXb!OX#Q!OXf!OXl!OX~Op%iO~Op%jO~Op%kO~O![%lO~O![%mO~O![%nO~O#}%OOx$ba~O!f#fa#}#fax#fa~P$yO#}%UOx$sa~O#O%wO~P`O#Q#Ti#}#Ti~P$yOf%xO~P$yOl$Si#}$Si~P$yO#kgq$vgq#}gqxgq!fgqegq#|gqbgq#Qgqfgqlgq~P$yOZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO#y!dOv$`X~Ox%zO!f%zO!h%yO~P!$cO`qynqypqyrqysqytqy#kqy$vqy#}qyxqy!fqyeqy#|qybqy#Qqyfqylqy~P>aO#y%gOZ!Oa[!Oa]!Oa^!Oa_!Oa`!Oan!Oap!Oar!Oas!Oat!Oav!Oa{!Oa!h!Oa#k!Oa$v!Oa#}!Oax!Oa!f!Oae!Oa#|!Oab!Oa#Q!Oaf!Oal!Oa~O!S&PO~O!V&PO~O!S&QO~O!R$vO!U$wO!W$xO!Z$yO!^$zO!b&vO#mRO#nRO~O!X$[P~P!(zOx!li#}!li~P$yO#k#PX$v#PX#}#PXx#PX!f#PXe#PX#|#PXb#PX#Q#PXf#PXl#PX~P$yOT$_XZ$_X[$_X]$lX^$lX_$lX`$lXd$_Xh$_Xi$_Xn$lXp$lXr$lXs$_Xt$lXv$_X{$lX!S$_X!T$_X!U$_X!W$_X!b$_X!f$_X!h$_X!o$_X!v$_X#R$_X#k$lX#m$_X#n$_X#y$lX$g$_X$h$_X$i$_X$j$_X$v$lX#}$lXx$lXe$lX#|$lXb$lX#Q$lXf$lXl$lX~Obai#}ai~P$yO!T&`O~O#mRO#nRO!X!PX#y!PX#}!PX~O#y&qO!X!OX#}!OX~O!X&bO~O$Z&cO~O#}&dO!X$YX~O!X&fO~O#}&gO!X$[X~O!X&iO~O#kc!R$vc!R#}c!Rxc!R!fc!Rec!R#|c!Rbc!R#Qc!Rfc!Rlc!R~P$yO#y&qO!X!Oa#}!Oa~O#}&dO!X$Ya~O#}&gO!X$[a~O$]&oO~O$]&rO~O!X&sO~O![&uO~OQP_^$g]#y~",
    "goto": "Ff$vPPPP$wP%p%s%y&]'vPPPPPP(PP$wPPP$wPP(S(VP$wP$wP$wPPP(]P(hP$w$wPP(q)W)c)WPPPPPPP)WPP)WP*p*s)WP*y+P$wP$wP$w+W,P,S,Y,PP,b-Z,b,b.Z/SP$w/{$w0t0t1m1pP1vPP0t1|2S.V2WPP2`P2c2j2p2v2|4X4c4i4o4u4{5R5X5_PPPPPPPP5e5n7q8j9c9fPP9jPP9p9s:l;e;h;l;q<^<z=i>bP>eP>i?Y?y@r@x@{$wARARPPPPAzBsBvCo7qCrDkDnEgEjFc!mjOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR![SQ!YSR$n#eS!WS#eS#Qw$`W#v!p!x%O%UT&U%m&d#WXOPQWYilu|}!]!a!b!c!e!g!h!i!j!k#Z#]#_#c#g#r#t$O$Y$^$_$b$e$r$}%T%W%d%g%l%n%w%x&R&c&g&o&q&r&ub!VSw!x#e$`%O%U%m&dU#a!V#b#uR#u!pU#a!V#b#uT$W!z$XR$m#cR#UwQ#SwR%_$`U!RQ#_#rQ#s!kR$h#]QrQQ$j#_R$s#rQ$|#tQ%r%TQ&T%lU&Y%n&g&uQ&j&cT&p&o&rc$u#t%T%l%n&c&g&o&r&u!lkOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xQ#m!eU$t#t%T&oS%}%g&q]&S%l%n&c&g&r&uR&X%mQ&V%mR&k&dQ&]%nR&t&uS&Z%n&uR&m&g!mZOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR#{!pQ#x!pR%p%OS#w!p%OT$S!x%U!mcOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%x!lcOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xQ!r`T!{o$Z!maOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%x!mbOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%x!mhOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%x!mpOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR$V!xQ$T!xR%s%UQ%v%WR&^%wQ!}oR%Z$ZT!|o$ZS!zo$ZT$W!z$XRrQS#b!V#uR$k#bQ#f!YR$o#fQ$a#SR%`$aQ#^!RR$i#^!vYOPQWilu|}!]!a!b!c!e!g!h!i!j!k!p#Z#]#_#c#g#r#t$O$Y$^$_$b$e$r$}%T%W%d%g%w%x&oS!oY&R_&R%l%n&c&g&q&r&uQ%h$tS&O%h&aR&a&SQ&e&VR&l&eQ&h&ZR&n&hQ%P#xR%q%PQ$P!vR%S$PQ%V$TR%t%VQ$X!zR%X$XQ$[!}R%[$[Q#[!PR$g#[QrOQ!PPR$f#ZUTOP#ZY!QQ!k#]#_#rQ!nWQ!tiS!vl!pQ#PuQ#X|Q#Y}Q#i!]Q#j!aQ#k!bQ#l!cQ#n!gQ#o!hQ#p!iQ#q!jQ$l#cQ$p#gQ%R$OQ%Y$YQ%]$^Q%^$_Q%a$bQ%c$eQ%e$rQ%o$}S%u%W%wQ%|%dR&_%x!mqOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%x!mSOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR!ZST!XS#eQ#c!WR$_#QR#g![!muOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%x!mwOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR#TwT#Rw$`V!SQ#_#r!T!aT!Q!t!v#P#X#Y#i#n#o#p#q$l$p%R%Y%]%^%a%c%e%o%u%|&_!V!bT!Q!t!v#P#X#Y#i#j#n#o#p#q$l$p%R%Y%]%^%a%c%e%o%u%|&_!X!cT!Q!t!v#P#X#Y#i#j#k#n#o#p#q$l$p%R%Y%]%^%a%c%e%o%u%|&_!mWOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR&W%mT&[%n&u!]!eT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q$l$p%R%Y%]%^%a%c%e%o%u%|&_!]!gT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q$l$p%R%Y%]%^%a%c%e%o%u%|&_!m[OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xQ!q[R!saR#y!pQ!wlR#z!p!mdOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%x!m|OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR%{%c!miOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR#}!t!mlOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR$R!w!mmOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR$U!x!moOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$Y$^$_$b$e$r$}%W%d%w%xR#Oo",
    nodeNames: " LineComment BlockComment Expression ForExpression for InExpressions InExpression Name Identifier Identifier ArithOp ArithOp ArithOp ArithOp ArithOp in IterationContext return IfExpression if then else QuantifiedExpression some every InExpressions InExpression satisfies Disjunction or Conjunction and Comparison CompareOp CompareOp between PositiveUnaryTest ( PositiveUnaryTests ) ArithmeticExpression InstanceOfExpression instance of Type QualifiedName VariableName SpecialType days time duration years months date > ListType list < ContextType context ContextEntryTypes ContextEntryType FunctionType function ArgumentTypes ArgumentType PathExpression ] FilterExpression [ FunctionInvocation SpecialFunctionName NamedParameters NamedParameter ParameterName PositionalParameters null NumericLiteral StringLiteral BooleanLiteral DateTimeLiteral DateTimeConstructor AtLiteral ? SimplePositiveUnaryTest Interval ParenthesizedExpression List FunctionDefinition FormalParameters FormalParameter external FunctionBody } { Context ContextEntry Key Name Identifier Expressions UnaryTests Wildcard not",
    maxTerm: 176,
    context: variableTracker,
    nodeProps: [["closedBy", 38, ")", 70, "]", 95, "}"], ["openedBy", 40, "(", 68, "[", 94, "{"], ["group", -5, 77, 78, 79, 80, 81, "Literal"]],
    propSources: [feelHighlighting],
    skippedNodes: [0, 1, 2],
    repeatNodeCount: 14,
    tokenData: "+l~RuXY#fYZ$ZZ[#f]^$Zpq#fqr$`rs$kwx&cxy&hyz&mz{&r{|'P|}'U}!O'Z!O!P'h!P!Q(Q!Q![){![!]*^!]!^*c!^!_*h!_!`$f!`!a*w!b!c+R!}#O+W#P#Q+]#Q#R&z#o#p+b#q#r+g$f$g#f#BY#BZ#f$IS$I_#f$I|$I}$Z$I}$JO$Z$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~#kY#q~XY#fZ[#fpq#f$f$g#f#BY#BZ#f$IS$I_#f$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~$`O#r~~$cP!_!`$f~$kOr~~$pW$h~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&]<%lO$k~%_O$h~~%bRO;'S$k;'S;=`%k;=`O$k~%pX$h~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&];=`<%l$k<%lO$k~&`P;=`<%l$k~&hO#z~~&mOv~~&rOx~~&wP^~z{&z~'PO_~~'UO[~~'ZO#}~R'`PZP!`!a'cQ'hO$]Q~'mQ#y~!O!P's!Q!['x~'xO#|~~'}P$g~!Q!['x~(VQ]~z{(]!P!Q)d~(`TOz(]z{(o{;'S(];'S;=`)^<%lO(]~(rVOz(]z{(o{!P(]!P!Q)X!Q;'S(];'S;=`)^<%lO(]~)^OQ~~)aP;=`<%l(]~)iSP~OY)dZ;'S)d;'S;=`)u<%lO)d~)xP;=`<%l)d~*QQ$g~!O!P*W!Q![){~*ZP!Q!['x~*cO$Z~~*hO$v~R*oP![QsP!_!`*rP*wOsPR+OP!XQsP!_!`*r~+WO$j~~+]O!h~~+bO!f~~+gO#R~~+lO#Q~",
    tokenizers: [propertyIdentifiers, identifiers, insertSemicolon, 0, 1],
    topRules: {
      "Expression": [0, 3],
      "Expressions": [1, 101],
      "UnaryTests": [2, 102]
    },
    dynamicPrecedences: {
      "31": -1,
      "71": -1,
      "73": -1
    },
    specialized: [{
      term: 121,
      get: function get(value) {
        return spec_identifier[value] || -1;
      }
    }],
    tokenPrec: 2857
  });

  // / A collection of FEEL-related
  // / [snippets](#autocomplete.snippet).
  var snippets = [/*@__PURE__*/snippetCompletion('function(${params}) ${body}', {
    label: 'function',
    detail: 'definition',
    type: 'keyword'
  }), /*@__PURE__*/snippetCompletion('for ${var} in ${collection} return ${value}', {
    label: 'for',
    detail: 'expression',
    type: 'keyword'
  }), /*@__PURE__*/snippetCompletion('every ${var} in ${collection} satisfies ${condition}', {
    label: 'every',
    detail: 'quantified expression',
    type: 'keyword'
  }), /*@__PURE__*/snippetCompletion('some ${var} in ${collection} satisfies ${condition}', {
    label: 'some',
    detail: 'quantified expression',
    type: 'keyword'
  }), /*@__PURE__*/snippetCompletion('if ${condition} then ${value} else ${other value}', {
    label: 'if',
    detail: 'block',
    type: 'keyword'
  })];

  // / A language provider based on the [Lezer FEEL
  // / parser](https://github.com/nikku/lezer-feel), extended with
  // / highlighting and indentation information.
  var feelLanguage = /*@__PURE__*/LRLanguage.define({
    parser: /*@__PURE__*/parser.configure({
      props: [/*@__PURE__*/indentNodeProp.add({
        'Context': /*@__PURE__*/delimitedIndent({
          closing: '}'
        }),
        'List FilterExpression': /*@__PURE__*/delimitedIndent({
          closing: ']'
        }),
        'ParenthesizedExpression FunctionInvocation': /*@__PURE__*/continuedIndent({
          except: /^\s*\)/
        }),
        'ForExpression QuantifiedExpression IfExpression': /*@__PURE__*/continuedIndent({
          except: /^\s*(then|else|return|satisfies)\b/
        }),
        'FunctionDefinition': /*@__PURE__*/continuedIndent({
          except: /^\s*(\(|\))/
        })
      }), /*@__PURE__*/foldNodeProp.add({
        Context: foldInside,
        List: foldInside,
        ParenthesizedExpression: foldInside,
        FunctionDefinition: function FunctionDefinition(node) {
          var last = node.getChild(')');
          if (!last) return null;
          return {
            from: last.to,
            to: node.to
          };
        }
      })]
    }),
    languageData: {
      indentOnInput: /^\s*(\)|\}|\]|then|else|return|satisfies)$/,
      commentTokens: {
        line: '//',
        block: {
          open: '/*',
          close: '*/'
        }
      }
    }
  });

  /**
   * Create an array of syntax errors in the given tree.
   *
   * @param {Tree} syntaxTree
   * @returns {LintMessage[]} array of syntax errors
   */
  function lintSyntax(syntaxTree) {
    var lintMessages = [];
    syntaxTree.iterate({
      enter: function enter(node) {
        if (node.type.isError) {
          var error = node.toString();

          /* The error has the pattern [ || (NodeType)]. The regex extracts the node type from inside the brackets */
          var match = /\((.*?)\)/.exec(error);
          var nodeType = match && match[1];
          var message;
          if (nodeType) {
            message = 'unexpected ' + nodeType;
          } else {
            message = 'expression expected';
          }
          lintMessages.push({
            from: node.from,
            to: node.to,
            severity: 'error',
            message: message,
            type: 'syntaxError'
          });
        }
      }
    });
    return lintMessages;
  }

  /**
   * Generates lint messages for the given syntax tree.
   *
   * @param {Tree} syntaxTree
   * @returns {LintMessage[]} array of all lint messages
   */
  function lintAll(syntaxTree) {
    var lintMessages = _toConsumableArray(lintSyntax(syntaxTree));
    return lintMessages;
  }

  /**
   * CodeMirror extension that provides linting for FEEL expressions.
   *
   * @param {EditorView} editorView
   * @returns {Source} CodeMirror linting source
   */
  var cmFeelLinter = function cmFeelLinter() {
    return function (editorView) {
      // don't lint if the Editor is empty
      if (editorView.state.doc.length === 0) {
        return [];
      }
      var tree = syntaxTree(editorView.state);
      var messages = lintAll(tree);
      return messages.map(function (message) {
        return _objectSpread2(_objectSpread2({}, message), {}, {
          source: 'syntaxError'
        });
      });
    };
  };

  // helpers ///////////////////////////////

  function isNodeEmpty(node) {
    return node.from === node.to;
  }
  function isPathExpression(node) {
    if (!node) {
      return false;
    }
    if (node.name === 'PathExpression') {
      return true;
    }
    return isPathExpression(node.parent);
  }
  var tags = [{
    name: "not(negand)",
    description: "<p>Returns the logical negation of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">not(negand: boolean): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">not(true)\n// false\n\nnot(null)\n// null\n</code></pre>\n"
  }, {
    name: "is defined(value)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Checks if a given value is not <code>null</code>. If the value is <code>null</code> then the function returns <code>false</code>.\nOtherwise, the function returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">is defined(value: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">is defined(1)\n// true\n\nis defined(null)\n// false\n\nis defined(x)\n// false - if no variable &quot;x&quot; exists\n\nis defined(x.y)\n// false - if no variable &quot;x&quot; exists or it doesn&#39;t have a property &quot;y&quot;\n</code></pre>\n<p>:::caution Breaking change</p>\n<p>This function worked differently in previous versions. It returned <code>true</code> if the value was <code>null</code>.\nSince this version, the function returns <code>false</code> if the value is <code>null</code>.</p>\n<p>:::</p>\n"
  }, {
    name: "get or else(value, default)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Return the provided value parameter if not <code>null</code>, otherwise return the default parameter</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">get or else(value: Any, default: Any): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">get or else(&quot;this&quot;, &quot;default&quot;)\n// &quot;this&quot;\n\nget or else(null, &quot;default&quot;)\n// &quot;default&quot;\n\nget or else(null, null)\n// null\n</code></pre>\n"
  }, {
    name: "assert(value, condition)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">assert(value: Any, condition: Any)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">assert(x, x != null)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0)\n// 4 - if x is 4\n// error - if x is less than zero\n</code></pre>\n"
  }, {
    name: "assert(value, condition, cause)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error containing the given message.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">assert(value: Any, condition: Any, cause: String)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">assert(x, x != null, &quot;&#39;x&#39; should not be null&quot;)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error(&#39;x&#39; should not be null) - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0, &quot;&#39;x&#39; should be positive&quot;)\n// 4 - if x is 4\n// error(&#39;x&#39; should be positive) - if x is less than zero\n</code></pre>\n"
  }, {
    name: "get value(context, key)",
    description: "<p>Returns the value of the context entry with the given key.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">get value(context: context, key: string): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">get value({foo: 123}, &quot;foo&quot;)\n// 123\n\nget value({a: 1}, &quot;b&quot;)\n// null\n</code></pre>\n"
  }, {
    name: "get value(context, keys)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Returns the value of the context entry for a context path defined by the given keys.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it returns the value at the nested entry <code>k1.k2</code> of the context.</p>\n<p>If <code>keys</code> are empty or the nested entry defined by the keys doesn&#39;t exist in the context, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">get value(context: context, keys: list&lt;string&gt;): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">get value({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;])\n// 0\n\nget value({x: {y: {z:0}}}, [&quot;x&quot;, &quot;y&quot;])\n// {z:0}\n\nget value({a: {b: 3}}, [&quot;b&quot;])\n// null\n</code></pre>\n"
  }, {
    name: "get entries(context)",
    description: "<p>Returns the entries of the context as a list of key-value-pairs.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">get entries(context: context): list&lt;context&gt;\n</code></pre>\n<p>The return value is a list of contexts. Each context contains two entries for &quot;key&quot; and &quot;value&quot;.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">get entries({foo: 123})\n// [{key: &quot;foo&quot;, value: 123}]\n</code></pre>\n"
  }, {
    name: "context put(context, key, value)",
    description: "<p>Adds a new entry with the given key and value to the context. Returns a new context that includes the entry.</p>\n<p>If an entry for the same key already exists in the context, it overrides the value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">context put(context: context, key: string, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">context put({x:1}, &quot;y&quot;, 2)\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context put()</code> replaced the previous function <code>put()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n"
  }, {
    name: "context put(context, keys, value)",
    description: "<p>Adds a new entry with the given value to the context. The path of the entry is defined by the keys. Returns a new context that includes the entry.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it adds the nested entry <code>k1.k2 = value</code> to the context.</p>\n<p>If an entry for the same keys already exists in the context, it overrides the value.</p>\n<p>If <code>keys</code> are empty, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">context put(context: context, keys: list&lt;string&gt;, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">context put({x:1}, [&quot;y&quot;], 2)\n// {x:1, y:2}\n\ncontext put({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n\ncontext put({x:1}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n</code></pre>\n"
  }, {
    name: "context merge(contexts)",
    description: "<p>Union the given contexts. Returns a new context that includes all entries of the given contexts.</p>\n<p>If an entry for the same key already exists in a context, it overrides the value. The entries are overridden in the same order as in the list of contexts.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">context merge(contexts: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">context merge([{x:1}, {y:2}])\n// {x:1, y:2}\n\ncontext merge([{x:1, y: 0}, {y:2}])\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context merge()</code> replaced the previous function <code>put all()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n"
  }, {
    name: "string(from)",
    description: "<p>Returns the given value as a string representation.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">string(from: Any): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">string(1.1)\n// &quot;1.1&quot;\n\nstring(date(&quot;2012-12-25&quot;))\n// &quot;2012-12-25&quot;\n</code></pre>\n"
  }, {
    name: "number(from)",
    description: "<p>Parses the given string to a number.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">number(from: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">number(&quot;1500.5&quot;)\n// 1500.5\n</code></pre>\n"
  }, {
    name: "context(entries)",
    description: "<p>Constructs a context of the given list of key-value pairs. It is the reverse function to <a href=\"feel-built-in-functions-context.md#get-entriescontext\">get entries()</a>.</p>\n<p>Each key-value pair must be a context with two entries: <code>key</code> and <code>value</code>. The entry with name <code>key</code> must have a value of the type <code>string</code>.</p>\n<p>It might override context entries if the keys are equal. The entries are overridden in the same order as the contexts in the given list.</p>\n<p>Returns <code>null</code> if one of the entries is not a context or if a context doesn&#39;t contain the required entries.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">context(entries: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">context([{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1}, {&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}])\n// {a:1, b:2}\n</code></pre>\n"
  }, {
    name: "date(from)",
    description: "<p>Returns a date from the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">date(from: string): date\n</code></pre>\n<p>Parses the given string into a date.</p>\n<pre><code class=\"language-feel\">date(from: date and time): date\n</code></pre>\n<p>Extracts the date component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">date(&quot;2018-04-29&quot;)\n// date(&quot;2018-04-29&quot;)\n\ndate(date and time(&quot;2012-12-25T11:00:00&quot;))\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n"
  }, {
    name: "date(year, month, day)",
    description: "<p>Returns a date from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">date(year: number, month: number, day: number): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">date(2012, 12, 25)\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n"
  }, {
    name: "time(from)",
    description: "<p>Returns a time from the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">time(from: string): time\n</code></pre>\n<p>Parses the given string into a time.</p>\n<pre><code class=\"language-feel\">time(from: date and time): time\n</code></pre>\n<p>Extracts the time component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">time(&quot;12:00:00&quot;)\n// time(&quot;12:00:00&quot;)\n\ntime(date and time(&quot;2012-12-25T11:00:00&quot;))\n// time(&quot;11:00:00&quot;)\n</code></pre>\n"
  }, {
    name: "time(hour, minute, second)",
    description: "<p>Returns a time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">time(hour: number, minute: number, second: number): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">time(23, 59, 0)\n// time(&quot;23:59:00&quot;)\n</code></pre>\n"
  }, {
    name: "time(hour, minute, second, offset)",
    description: "<p>Returns a time from the given components, including a timezone offset.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">time(hour: number, minute: number, second: number, offset: days and time duration): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">time(14, 30, 0, duration(&quot;PT1H&quot;))\n// time(&quot;14:30:00+01:00&quot;)\n</code></pre>\n"
  }, {
    name: "date and time(from)",
    description: "<p>Parses the given string into a date and time.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">date and time(from: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">date and time(&quot;2018-04-29T009:30:00&quot;)\n// date and time(&quot;2018-04-29T009:30:00&quot;)\n</code></pre>\n"
  }, {
    name: "date and time(date, time)",
    description: "<p>Returns a date and time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">date and time(date: date, time: time): date and time\n</code></pre>\n<pre><code class=\"language-feel\">date and time(date: date and time, time: time): date and time\n</code></pre>\n<p>Returns a date and time value that consists of the date component of <code>date</code> combined with <code>time</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">date and time(date(&quot;2012-12-24&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-24T23:59:00&quot;)\n\ndate and time(date and time(&quot;2012-12-25T11:00:00&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-25T23:59:00&quot;)\n</code></pre>\n"
  }, {
    name: "date and time(date, timezone)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Returns the given date and time value at the given timezone.</p>\n<p>If <code>date</code> has a different timezone than <code>timezone</code> then it adjusts the time to match the local time of <code>timezone</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">date and time(date: date and time, timezone: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">date and time(@&quot;2020-07-31T14:27:30@Europe/Berlin&quot;, &quot;America/Los_Angeles&quot;)\n// date and time(&quot;2020-07-31T05:27:30@America/Los_Angeles&quot;)\n\ndate and time(@&quot;2020-07-31T14:27:30&quot;, &quot;Z&quot;)\n// date and time(&quot;2020-07-31T12:27:30Z&quot;)\n</code></pre>\n"
  }, {
    name: "duration(from)",
    description: "<p>Parses the given string into a duration. The duration is either a days and time duration or a years and months duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">duration(from: string): days and time duration\n</code></pre>\n<pre><code class=\"language-feel\">duration(from: string): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">duration(&quot;P5D&quot;)\n// duration(&quot;P5D&quot;)\n\nduration(&quot;P32Y&quot;)\n// duration(&quot;P32Y&quot;)\n</code></pre>\n"
  }, {
    name: "years and months duration(from, to)",
    description: "<p>Returns the years and months duration between <code>from</code> and <code>to</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">years and months duration(from: date, to: date): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">years and months duration(date(&quot;2011-12-22&quot;), date(&quot;2013-08-24&quot;))\n// duration(&quot;P1Y8M&quot;)\n</code></pre>\n"
  }, {
    name: "list contains(list, element)",
    description: "<p>Returns <code>true</code> if the given list contains the element. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">list contains(list: list, element: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">list contains([1,2,3], 2)\n// true\n</code></pre>\n"
  }, {
    name: "count(list)",
    description: "<p>Returns the number of elements of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">count(list: list): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">count([1,2,3])\n// 3\n</code></pre>\n"
  }, {
    name: "min(list)",
    description: "<p>Returns the minimum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">min(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">min([1,2,3])\n// 1\n\nmin(1,2,3)\n// 1\n</code></pre>\n"
  }, {
    name: "max(list)",
    description: "<p>Returns the maximum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">max(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">max([1,2,3])\n// 3\n\nmax(1,2,3)\n// 3\n</code></pre>\n"
  }, {
    name: "sum(list)",
    description: "<p>Returns the sum of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">sum(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">sum([1,2,3])\n// 6\n\nsum(1,2,3)\n// 6\n</code></pre>\n"
  }, {
    name: "product(list)",
    description: "<p>Returns the product of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">product(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">product([2, 3, 4])\n// 24\n\nproduct(2, 3, 4)\n// 24\n</code></pre>\n"
  }, {
    name: "mean(list)",
    description: "<p>Returns the arithmetic mean (i.e. average) of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">mean(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">mean([1,2,3])\n// 2\n\nmean(1,2,3)\n// 2\n</code></pre>\n"
  }, {
    name: "median(list)",
    description: "<p>Returns the median element of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">median(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">median(8, 2, 5, 3, 4)\n// 4\n\nmedian([6, 1, 2, 3])\n// 2.5\n</code></pre>\n"
  }, {
    name: "stddev(list)",
    description: "<p>Returns the standard deviation of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">stddev(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">stddev(2, 4, 7, 5)\n// 2.0816659994661326\n\nstddev([2, 4, 7, 5])\n// 2.0816659994661326\n</code></pre>\n"
  }, {
    name: "mode(list)",
    description: "<p>Returns the mode of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">mode(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">mode(6, 3, 9, 6, 6)\n// [6]\n\nmode([6, 1, 9, 6, 1])\n// [1, 6]\n</code></pre>\n"
  }, {
    name: "all(list)",
    description: "<p>Returns <code>false</code> if any element of the given list is <code>false</code>. Otherwise, returns <code>true</code>.</p>\n<p>If the given list is empty, it returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">all(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">all([true,false])\n// false\n\nall(false,null,true)\n// false\n</code></pre>\n<p>:::info\nThe function <code>all()</code> replaced the previous function <code>and()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n"
  }, {
    name: "any(list)",
    description: "<p>Returns <code>true</code> if any element of the given list is <code>true</code>. Otherwise, returns <code>false</code>.</p>\n<p>If the given list is empty, it returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">any(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">any([false,true])\n// true\n\nany(false,null,true)\n// true\n</code></pre>\n<p>:::info\nThe function <code>any()</code> replaced the previous function <code>or()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n"
  }, {
    name: "sublist(list, start position)",
    description: "<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">sublist(list: list, start position: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">sublist([1,2,3], 2)\n// [2,3]\n</code></pre>\n"
  }, {
    name: "sublist(list, start position, length)",
    description: "<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">sublist(list: list, start position: number, length: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">sublist([1,2,3], 1, 2)\n// [1,2]\n</code></pre>\n"
  }, {
    name: "append(list, items)",
    description: "<p>Returns the given list with all <code>items</code> appended.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">append(list: list, items: Any): list\n</code></pre>\n<p>The parameter <code>items</code> can be a single element or a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">append([1], 2, 3)\n// [1,2,3]\n</code></pre>\n"
  }, {
    name: "concatenate(lists)",
    description: "<p>Returns a list that includes all elements of the given lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">concatenate(lists: list): list\n</code></pre>\n<p>The parameter <code>lists</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">concatenate([1,2],[3])\n// [1,2,3]\n\nconcatenate([1],[2],[3])\n// [1,2,3]\n</code></pre>\n"
  }, {
    name: "insert before(list, position, newItem)",
    description: "<p>Returns the given list with <code>newItem</code> inserted at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">insert before(list: list, position: number, newItem: Any): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">insert before([1,3],1,2)\n// [2,1,3]\n</code></pre>\n"
  }, {
    name: "remove(list, position)",
    description: "<p>Returns the given list without the element at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">remove(list: list, position: number): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">remove([1,2,3], 2)\n// [1,3]\n</code></pre>\n"
  }, {
    name: "reverse(list)",
    description: "<p>Returns the given list in revered order.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">reverse(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">reverse([1,2,3])\n// [3,2,1]\n</code></pre>\n"
  }, {
    name: "index of(list, match)",
    description: "<p>Returns an ascending list of positions containing <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">index of(list: list, match: Any): list&lt;number&gt;\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">index of([1,2,3,2],2)\n// [2,4]\n</code></pre>\n"
  }, {
    name: "union(list)",
    description: "<p>Returns a list that includes all elements of the given lists without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">union(list: list): list\n</code></pre>\n<p>The parameter <code>list</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">union([1,2],[2,3])\n// [1,2,3]\n</code></pre>\n"
  }, {
    name: "distinct values(list)",
    description: "<p>Returns the given list without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">distinct values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">distinct values([1,2,3,2,1])\n// [1,2,3]\n</code></pre>\n"
  }, {
    name: "duplicate values(list)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Returns all duplicate values of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">duplicate values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">duplicate values([1,2,3,2,1])\n// [1,2]\n</code></pre>\n"
  }, {
    name: "flatten(list)",
    description: "<p>Returns a list that includes all elements of the given list without nested lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">flatten(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">flatten([[1,2],[[3]], 4])\n// [1,2,3,4]\n</code></pre>\n"
  }, {
    name: "sort(list, precedes)",
    description: "<p>Returns the given list sorted by the <code>precedes</code> function.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">sort(list: list, precedes: function&lt;(Any, Any) -&gt; boolean&gt;): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">sort(list: [3,1,4,5,2], precedes: function(x,y) x &lt; y)\n// [1,2,3,4,5]\n</code></pre>\n"
  }, {
    name: "string join(list)",
    description: "<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)\">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">string join(list: list&lt;string&gt;): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])\n// &quot;abc&quot;\n\nstring join([&quot;a&quot;,null,&quot;c&quot;])\n// &quot;ac&quot;\n\nstring join([])\n// &quot;&quot;\n</code></pre>\n"
  }, {
    name: "string join(list, delimiter)",
    description: "<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)\">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string contains a <code>delimiter</code> between each element.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">string join(list: list&lt;string&gt;, delimiter: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">string join([&quot;a&quot;], &quot;X&quot;)\n// &quot;a&quot;\n\nstring join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;)\n// &quot;a, b, c&quot;\n</code></pre>\n"
  }, {
    name: "string join(list, delimiter, prefix, suffix)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)\">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string starts with <code>prefix</code>, contains a <code>delimiter</code> between each element, and ends\nwith <code>suffix</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">string join(list: list&lt;string&gt;, delimiter: string, prefix: string, suffix: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;, &quot;[&quot;, &quot;]&quot;)\n// &quot;[a, b, c]&quot;\n</code></pre>\n"
  }, {
    name: "decimal(n, scale)",
    description: "<p>Rounds the given value at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">decimal(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">decimal(1/3, 2)\n// .33\n\ndecimal(1.5, 0)\n// 2\n</code></pre>\n"
  }, {
    name: "floor(n)",
    description: "<p>Rounds the given value with rounding mode flooring.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">floor(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">floor(1.5)\n// 1\n\nfloor(-1.5)\n// -2\n</code></pre>\n"
  }, {
    name: "floor(n, scale)",
    description: "<p>Rounds the given value with rounding mode flooring at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">floor(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">floor(-1.56, 1)\n// -1.6\n</code></pre>\n"
  }, {
    name: "ceiling(n)",
    description: "<p>Rounds the given value with rounding mode ceiling.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">ceiling(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">ceiling(1.5)\n// 2\n\nceiling(-1.5)\n// -1\n</code></pre>\n"
  }, {
    name: "ceiling(n, scale)",
    description: "<p>Rounds the given value with rounding mode ceiling at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">ceiling(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">ceiling(-1.56, 1)\n// -1.5\n</code></pre>\n"
  }, {
    name: "round up(n, scale)",
    description: "<p>Rounds the given value with the rounding mode round-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">round up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">round up(5.5)\n// 6\n\nround up(-5.5)\n// -6\n\nround up(1.121, 2)\n// 1.13\n\nround up(-1.126, 2)\n// -1.13\n</code></pre>\n"
  }, {
    name: "round down(n, scale)",
    description: "<p>Rounds the given value with the rounding mode round-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">round down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">round down(5.5, 0)\n// 5\n\nround down (-5.5, 0)\n// -5\n\nround down (1.121, 2)\n// 1.12\n\nround down (-1.126, 2)\n// -1.12\n</code></pre>\n"
  }, {
    name: "round half up(n, scale)",
    description: "<p>Rounds the given value with the rounding mode round-half-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">round half up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">round half up(5.5, 0)\n// 6\n\nround half up(-5.5, 0)\n// -6\n\nround half up(1.121, 2)\n// 1.12\n\nround half up(-1.126, 2)\n// -1.13\n</code></pre>\n"
  }, {
    name: "round half down(n, scale)",
    description: "<p>Rounds the given value with the rounding mode round-half-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">round half down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">round half down (5.5, 0)\n// 5\n\nround half down (-5.5, 0)\n// -5\n\nround half down (1.121, 2)\n// 1.12\n\nround half down (-1.126, 2)\n// -1.13\n</code></pre>\n"
  }, {
    name: "abs(number)",
    description: "<p>Returns the absolute value of the given numeric value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">abs(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">abs(10)\n// 10\n\nabs(-10)\n// 10\n</code></pre>\n"
  }, {
    name: "modulo(dividend, divisor)",
    description: "<p>Returns the remainder of the division of dividend by divisor.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">modulo(dividend: number, divisor: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">modulo(12, 5)\n// 2\n</code></pre>\n"
  }, {
    name: "sqrt(number)",
    description: "<p>Returns the square root of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">sqrt(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">sqrt(16)\n// 4\n</code></pre>\n"
  }, {
    name: "log(number)",
    description: "<p>Returns the natural logarithm (base e) of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">log(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">log(10)\n// 2.302585092994046\n</code></pre>\n"
  }, {
    name: "exp(number)",
    description: "<p>Returns the Eulers number e raised to the power of the given number .</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">exp(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">exp(5)\n// 148.4131591025766\n</code></pre>\n"
  }, {
    name: "odd(number)",
    description: "<p>Returns <code>true</code> if the given value is odd. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">odd(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">odd(5)\n// true\n\nodd(2)\n// false\n</code></pre>\n"
  }, {
    name: "even(number)",
    description: "<p>Returns <code>true</code> if the given is even. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">even(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">even(5)\n// false\n\neven(2)\n// true\n</code></pre>\n"
  }, {
    name: "random number()",
    description: "<p><em>Camunda Extension</em></p>\n<p>Returns a random number between <code>0</code> and <code>1</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">random number(): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">random number()\n// 0.9701618132579795\n</code></pre>\n"
  }, {
    name: "before(point1, point2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">before(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">before(1, 10)\n// true\n\nbefore(10, 1)\n// false\n</code></pre>\n"
  }, {
    name: "before(range, point)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">before(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">before([1..5], 10)\n// true\n</code></pre>\n"
  }, {
    name: "before(point, range)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">before(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">before(1, [2..5])\n// true\n</code></pre>\n"
  }, {
    name: "before(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">before([1..5], [6..10])\n// true\n\nbefore([1..5),[5..10])\n// true\n</code></pre>\n"
  }, {
    name: "after(point1, point2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">after(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">after(10, 1)\n// true\n\nafter(1, 10)\n// false\n</code></pre>\n"
  }, {
    name: "after(range, point)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">after(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">after([1..5], 10)\n// false\n</code></pre>\n"
  }, {
    name: "after(point, range)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">after(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">after(12, [2..5])\n// true\n</code></pre>\n"
  }, {
    name: "after(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">after([6..10], [1..5])\n// true\n\nafter([5..10], [1..5))\n// true\n</code></pre>\n"
  }, {
    name: "meets(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">meets(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">meets([1..5], [5..10])\n// true\n\nmeets([1..3], [4..6])\n// false\n\nmeets([1..3], [3..5])\n// true\n\nmeets([1..5], (5..8])\n// false\n</code></pre>\n"
  }, {
    name: "met by(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">met by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">met by([5..10], [1..5])\n// true\n\nmet by([3..4], [1..2])\n// false\n\nmet by([3..5], [1..3])\n// true\n\nmet by((5..8], [1..5))\n// false\n\nmet by([5..10], [1..5))\n// false\n</code></pre>\n"
  }, {
    name: "overlaps(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">overlaps(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">overlaps([5..10], [1..6])\n// true\n\noverlaps((3..7], [1..4])\n// true\n\noverlaps([1..3], (3..6])\n// false\n\noverlaps((5..8], [1..5))\n// false\n\noverlaps([4..10], [1..5))\n// true\n</code></pre>\n"
  }, {
    name: "overlaps before(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">overlaps before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">overlaps before([1..5], [4..10])\n// true\n\noverlaps before([3..4], [1..2])\n// false\n\noverlaps before([1..3], (3..5])\n// false\n\noverlaps before([1..5), (3..8])\n// true\n\noverlaps before([1..5), [5..10])\n// false\n</code></pre>\n"
  }, {
    name: "overlaps after(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">overlaps after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">overlaps after([4..10], [1..5])\n// true\n\noverlaps after([3..4], [1..2])\n// false\n\noverlaps after([3..5], [1..3))\n// false\n\noverlaps after((5..8], [1..5))\n// false\n\noverlaps after([4..10], [1..5))\n// true\n</code></pre>\n"
  }, {
    name: "finishes(point, range)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">finishes(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">finishes(5, [1..5])\n// true\n\nfinishes(10, [1..7])\n// false\n</code></pre>\n"
  }, {
    name: "finishes(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">finishes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">finishes([3..5], [1..5])\n// true\n\nfinishes((1..5], [1..5))\n// false\n\nfinishes([5..10], [1..10))\n// false\n</code></pre>\n"
  }, {
    name: "finished by(range, point)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">finished by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">finished by([5..10], 10)\n// true\n\nfinished by([3..4], 2)\n// false\n</code></pre>\n"
  }, {
    name: "finished by(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">finished by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">finished by([1..5], [3..5])\n// true\n\nfinished by((5..8], [1..5))\n// false\n\nfinished by([5..10], (1..10))\n// false\n</code></pre>\n"
  }, {
    name: "includes(range, point)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">includes(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">includes([5..10], 6)\n// true\n\nincludes([3..4], 5)\n// false\n</code></pre>\n"
  }, {
    name: "includes(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">includes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">includes([1..10], [4..6])\n// true\n\nincludes((5..8], [1..5))\n// false\n\nincludes([1..10], [1..5))\n// true\n</code></pre>\n"
  }, {
    name: "during(point, range)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">during(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">during(5, [1..10])\n// true\n\nduring(12, [1..10])\n// false\n\nduring(1, (1..10])\n// false\n</code></pre>\n"
  }, {
    name: "during(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">during(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">during([4..6], [1..10))\n// true\n\nduring((1..5], (1..10])\n// true\n</code></pre>\n"
  }, {
    name: "starts(point, range)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">starts(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">starts(1, [1..5])\n// true\n\nstarts(1, (1..8])\n// false\n</code></pre>\n"
  }, {
    name: "starts(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">starts(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">starts((1..5], [1..5])\n// false\n\nstarts([1..10], [1..5])\n// false\n\nstarts((1..5), (1..10))\n// true\n</code></pre>\n"
  }, {
    name: "started by(range, point)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">started by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">started by([1..10], 1)\n// true\n\nstarted by((1..10], 1)\n// false\n</code></pre>\n"
  }, {
    name: "started by(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">started by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">started by([1..10], [1..5])\n// true\n\nstarted by((1..10], [1..5))\n// false\n\nstarted by([1..10], [1..10))\n// true\n</code></pre>\n"
  }, {
    name: "coincides(point1, point2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">coincides(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">coincides(5, 5)\n// true\n\ncoincides(3, 4)\n// false\n</code></pre>\n"
  }, {
    name: "coincides(range1, range2)",
    description: "<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">coincides(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">coincides([1..5], [1..5])\n// true\n\ncoincides((1..5], [1..5))\n// false\n\ncoincides([1..5], [2..6])\n// false\n</code></pre>\n"
  }, {
    name: "substring(string, start position)",
    description: "<p>Returns a substring of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">substring(string: string, start position: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">substring(&quot;foobar&quot;, 3)\n// &quot;obar&quot;\n</code></pre>\n"
  }, {
    name: "substring(string, start position, length)",
    description: "<p>Returns a substring of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">substring(string: string, start position: number, length: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">substring(&quot;foobar&quot;, 3, 3)\n// &quot;oba&quot;\n</code></pre>\n"
  }, {
    name: "string length(string)",
    description: "<p>Returns the number of characters in the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">string length(string: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">string length(&quot;foo&quot;)\n// 3\n</code></pre>\n"
  }, {
    name: "upper case(string)",
    description: "<p>Returns the given value with all characters are uppercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">upper case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">upper case(&quot;aBc4&quot;)\n// &quot;ABC4&quot;\n</code></pre>\n"
  }, {
    name: "lower case(string)",
    description: "<p>Returns the given value with all characters are lowercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">lower case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">lower case(&quot;aBc4&quot;)\n// &quot;abc4&quot;\n</code></pre>\n"
  }, {
    name: "substring before(string, match)",
    description: "<p>Returns a substring of the given value that contains all characters before <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">substring before(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">substring before(&quot;foobar&quot;, &quot;bar&quot;)\n// &quot;foo&quot;\n</code></pre>\n"
  }, {
    name: "substring after(string, match)",
    description: "<p>Returns a substring of the given value that contains all characters after <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">substring after(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">substring after(&quot;foobar&quot;, &quot;ob&quot;)\n// &quot;ar&quot;\n</code></pre>\n"
  }, {
    name: "contains(string, match)",
    description: "<p>Returns <code>true</code> if the given value contains the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">contains(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">contains(&quot;foobar&quot;, &quot;of&quot;)\n// false\n</code></pre>\n"
  }, {
    name: "starts with(string, match)",
    description: "<p>Returns <code>true</code> if the given value starts with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">starts with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">starts with(&quot;foobar&quot;, &quot;fo&quot;)\n// true\n</code></pre>\n"
  }, {
    name: "ends with(string, match)",
    description: "<p>Returns <code>true</code> if the given value ends with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">ends with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">ends with(&quot;foobar&quot;, &quot;r&quot;)\n// true\n</code></pre>\n"
  }, {
    name: "matches(input, pattern)",
    description: "<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">matches(input: string, pattern: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">matches(&quot;foobar&quot;, &quot;^fo*bar&quot;)\n// true\n</code></pre>\n"
  }, {
    name: "matches(input, pattern, flags)",
    description: "<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">matches(input: string, pattern: string, flags: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">matches(&quot;FooBar&quot;, &quot;foo&quot;, &quot;i&quot;)\n// true\n</code></pre>\n"
  }, {
    name: "replace(input, pattern, replacement)",
    description: "<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">replace(input: string, pattern: string, replacement: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">replace(&quot;abcd&quot;, &quot;(ab)|(a)&quot;, &quot;[1=$1][2=$2]&quot;)\n// &quot;[1=ab][2=]cd&quot;\n\nreplace(&quot;0123456789&quot;, &quot;(\\d{3})(\\d{3})(\\d{4})&quot;, &quot;($1) $2-$3&quot;)\n// &quot;(012) 345-6789&quot;\n</code></pre>\n"
  }, {
    name: "replace(input, pattern, replacement, flags)",
    description: "<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">replace(input: string, pattern: string, replacement: string, flags: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">replace(&quot;How do you feel?&quot;, &quot;Feel&quot;, &quot;FEEL&quot;, &quot;i&quot;)\n// &quot;How do you FEEL?&quot;\n</code></pre>\n"
  }, {
    name: "split(string, delimiter)",
    description: "<p>Splits the given value into a list of substrings, breaking at each occurrence of the <code>delimiter</code> pattern.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">split(string: string, delimiter: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>delimiter</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">split(&quot;John Doe&quot;, &quot;\\s&quot; )\n// [&quot;John&quot;, &quot;Doe&quot;]\n\nsplit(&quot;a;b;c;;&quot;, &quot;;&quot;)\n// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]\n</code></pre>\n"
  }, {
    name: "extract(string, pattern)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Returns all matches of the pattern in the given string. Returns an empty list if the pattern doesn&#39;t\nmatch.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">extract(string: string, pattern: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">extract(&quot;references are 1234, 1256, 1378&quot;, &quot;12[0-9]*&quot;)\n// [&quot;1234&quot;,&quot;1256&quot;]\n</code></pre>\n"
  }, {
    name: "now()",
    description: "<p>Returns the current date and time including the timezone.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">now(): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">now()\n// date and time(&quot;2020-07-31T14:27:30@Europe/Berlin&quot;)\n</code></pre>\n"
  }, {
    name: "today()",
    description: "<p>Returns the current date.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">today(): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">today()\n// date(&quot;2020-07-31&quot;)\n</code></pre>\n"
  }, {
    name: "day of week(date)",
    description: "<p>Returns the day of the week according to the Gregorian calendar. Note that it always returns the English name of the day.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">day of week(date: date): string\n</code></pre>\n<pre><code class=\"language-feel\">day of week(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">day of week(date(&quot;2019-09-17&quot;))\n// &quot;Tuesday&quot;\n\nday of week(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;Tuesday&quot;\n</code></pre>\n"
  }, {
    name: "day of year(date)",
    description: "<p>Returns the Gregorian number of the day within the year.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">day of year(date: date): number\n</code></pre>\n<pre><code class=\"language-feel\">day of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">day of year(date(&quot;2019-09-17&quot;))\n// 260\n\nday of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 260\n</code></pre>\n"
  }, {
    name: "week of year(date)",
    description: "<p>Returns the Gregorian number of the week within the year, according to ISO 8601.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">week of year(date: date): number\n</code></pre>\n<pre><code class=\"language-feel\">week of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">week of year(date(&quot;2019-09-17&quot;))\n// 38\n\nweek of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 38\n</code></pre>\n"
  }, {
    name: "month of year(date)",
    description: "<p>Returns the month of the year according to the Gregorian calendar. Note that it always returns the English name of the month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">month of year(date: date): string\n</code></pre>\n<pre><code class=\"language-feel\">month of year(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">month of year(date(&quot;2019-09-17&quot;))\n// &quot;September&quot;\n\nmonth of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;September&quot;\n</code></pre>\n"
  }, {
    name: "abs(n)",
    description: "<p>Returns the absolute value of a given duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">abs(n: days and time duration): days and time duration\n</code></pre>\n<pre><code class=\"language-feel\">abs(n: years and months duration): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">abs(duration(&quot;-PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;-P2M&quot;))\n// duration(&quot;P2M&quot;)\n</code></pre>\n"
  }, {
    name: "last day of month(date)",
    description: "<p><em>Camunda Extension</em></p>\n<p>Takes the month of the given date or date-time value and returns the last day of this month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class=\"language-feel\">last day of month(date: date): date\n</code></pre>\n<pre><code class=\"language-feel\">last day of month(date: date and time): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class=\"language-feel\">last day of month(date(&quot;2022-10-01&quot;))\n// date(&quot;2022-10-31&quot;))\n\nlast day of month(date and time(&quot;2022-10-16T12:00:00&quot;))\n// date(&quot;2022-10-31&quot;))\n</code></pre>\n"
  }];
  var options = tags.map(function (tag) {
    return snippetCompletion(tag.name.replace('()', '(#{1})'), {
      label: tag.name,
      type: 'function',
      info: function info() {
        var html = domify$1("<div class=\"description\">".concat(tag.description, "<div>"));
        return html;
      },
      boost: -1
    });
  });
  var builtins = function builtins(context) {
    var nodeBefore = syntaxTree(context.state).resolve(context.pos, -1);

    // For the special case of empty nodes, we need to check the current node
    // as well. The previous node could be part of another token, e.g.
    // when typing functions "abs(".
    var nextNode = nodeBefore.nextSibling;
    var isInEmptyNode = isNodeEmpty(nodeBefore) || nextNode && nextNode.from === context.pos && isNodeEmpty(nextNode);
    if (isInEmptyNode) {
      return context.explicit ? {
        from: context.pos,
        options: options
      } : null;
    }

    // Don't auto-complete on path expressions/context keys/...
    if (nodeBefore.parent && nodeBefore.parent.name !== 'VariableName' || isPathExpression(nodeBefore)) {
      return null;
    }
    return {
      from: nodeBefore.from,
      options: options
    };
  };

  /**
   * @type {Facet<import('..').Variable[]>} Variable
   */
  var variablesFacet = Facet.define();
  var pathExpression = function pathExpression(context) {
    var variables = context.state.facet(variablesFacet)[0];
    var nodeBefore = syntaxTree(context.state).resolve(context.pos, -1);
    if (!isPathExpression(nodeBefore)) {
      return;
    }
    var expression = findPathExpression(nodeBefore);

    // if the cursor is directly after the `.`, variable starts at the cursor position
    var from = nodeBefore === expression ? context.pos : nodeBefore.from;
    var path = getPath(expression, context);
    var options = variables;
    for (var i = 0; i < path.length - 1; i++) {
      var childVar = options.find(function (val) {
        return val.name === path[i].name;
      });
      if (!childVar) {
        return null;
      }

      // only suggest if variable type matches
      if (childVar.isList !== 'optional' && !!childVar.isList !== path[i].isList) {
        return;
      }
      options = childVar.entries;
    }
    if (!options) return;
    options = options.map(function (v) {
      return {
        label: v.name,
        type: 'variable',
        info: v.info,
        detail: v.detail
      };
    });
    var result = {
      from: from,
      options: options
    };
    return result;
  };
  function findPathExpression(node) {
    while (node) {
      if (node.name === 'PathExpression') {
        return node;
      }
      node = node.parent;
    }
  }

  // parses the path expression into a list of variable names with type information
  // e.g. foo[0].bar => [ { name: 'foo', isList: true }, { name: 'bar', isList: false } ]
  function getPath(node, context) {
    var path = [];
    for (var child = node.firstChild; child; child = child.nextSibling) {
      if (child.name === 'PathExpression') {
        path.push.apply(path, _toConsumableArray(getPath(child, context)));
      } else if (child.name === 'FilterExpression') {
        path.push.apply(path, _toConsumableArray(getFilter(child, context)));
      } else {
        path.push({
          name: getNodeContent(child, context),
          isList: false
        });
      }
    }
    return path;
  }
  function getFilter(node, context) {
    var list = node.firstChild;
    if (list.name === 'PathExpression') {
      var path = getPath(list, context);
      var last = path[path.length - 1];
      last.isList = true;
      return path;
    }
    return [{
      name: getNodeContent(list, context),
      isList: true
    }];
  }
  function getNodeContent(node, context) {
    return context.state.sliceDoc(node.from, node.to);
  }

  /**
   * @type {import('@codemirror/autocomplete').CompletionSource}
   */
  var variables = function variables(context) {
    var variables = context.state.facet(variablesFacet)[0];
    var options = variables.map(function (v) {
      return {
        label: v.name,
        type: 'variable',
        info: v.info,
        detail: v.detail
      };
    });

    // In most cases, use what is typed before the cursor
    var nodeBefore = syntaxTree(context.state).resolve(context.pos, -1);

    // For the special case of empty nodes, we need to check the current node
    // as well. The previous node could be part of another token, e.g.
    // when typing functions "abs(".
    var nextNode = nodeBefore.nextSibling;
    var isInEmptyNode = isNodeEmpty(nodeBefore) || nextNode && nextNode.from === context.pos && isNodeEmpty(nextNode);
    if (isInEmptyNode) {
      return context.explicit ? {
        from: context.pos,
        options: options
      } : null;
    }
    var result = {
      from: nodeBefore.from,
      options: options
    };

    // Only auto-complete variables
    if (nodeBefore.parent && nodeBefore.parent.name !== 'VariableName' || isPathExpression(nodeBefore)) {
      return null;
    }
    return result;
  };
  function autocompletion() {
    return [autocompletion$1({
      override: [variables, builtins, completeFromList(snippets.map(function (s) {
        return _objectSpread2(_objectSpread2({}, s), {}, {
          boost: -1
        });
      })), pathExpression]
    })];
  }
  function language() {
    return new LanguageSupport(feelLanguage, []);
  }
  var linter = [linter$1(cmFeelLinter())];
  var baseTheme = EditorView.theme({
    '& .cm-content': {
      padding: '0px'
    },
    '& .cm-line': {
      padding: '0px'
    },
    '&.cm-editor.cm-focused': {
      outline: 'none'
    },
    '& .cm-completionInfo': {
      whiteSpace: 'pre-wrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis'
    },
    // Don't wrap whitespace for custom HTML
    '& .cm-completionInfo > *': {
      whiteSpace: 'normal'
    },
    '& .cm-completionInfo ul': {
      margin: 0,
      paddingLeft: '15px'
    },
    '& .cm-completionInfo pre': {
      marginBottom: 0,
      whiteSpace: 'pre-wrap'
    },
    '& .cm-completionInfo p': {
      marginTop: 0
    },
    '& .cm-completionInfo p:not(:last-of-type)': {
      marginBottom: 0
    }
  });
  var highlightTheme = EditorView.baseTheme({
    '& .variableName': {
      color: '#10f'
    },
    '& .number': {
      color: '#164'
    },
    '& .string': {
      color: '#a11'
    },
    '& .bool': {
      color: '#219'
    },
    '& .function': {
      color: '#aa3731',
      fontWeight: 'bold'
    },
    '& .control': {
      color: '#708'
    }
  });
  var syntaxClasses = syntaxHighlighting(HighlightStyle.define([{
    tag: tags$1.variableName,
    "class": 'variableName'
  }, {
    tag: tags$1.name,
    "class": 'variableName'
  }, {
    tag: tags$1.number,
    "class": 'number'
  }, {
    tag: tags$1.string,
    "class": 'string'
  }, {
    tag: tags$1.bool,
    "class": 'bool'
  }, {
    tag: tags$1["function"](tags$1.variableName),
    "class": 'function'
  }, {
    tag: tags$1["function"](tags$1.special(tags$1.variableName)),
    "class": 'function'
  }, {
    tag: tags$1.controlKeyword,
    "class": 'control'
  }, {
    tag: tags$1.operatorKeyword,
    "class": 'control'
  }]));
  var theme = [baseTheme, highlightTheme, syntaxClasses];

  /**
   * @typedef {object} Variable
   * @typedef {import('@codemirror/state').Extension} Extension
   * @property {string} name name or key of the variable
   * @property {string} [info] short information about the variable, e.g. type
   * @property {string} [detail] longer description of the variable content
   * @property {boolean} [isList] whether the variable is a list
   * @property {array<Variable>} [schema] array of child variables if the variable is a context or list
   */

  var autocompletionConf = new Compartment();

  /**
   * Creates a FEEL editor in the supplied container
   *
   * @param {Object} config
   * @param {DOMNode} config.container
   * @param {Extension[]} [config.extensions]
   * @param {DOMNode|String} [config.tooltipContainer]
   * @param {Function} [config.onChange]
   * @param {Function} [config.onKeyDown]
   * @param {Function} [config.onLint]
   * @param {Boolean} [config.readOnly]
   * @param {String} [config.value]
   * @param {Variable[]} [config.variables]
   *
   * @returns {Object} editor
   */
  function FeelEditor$2(_ref) {
    var _ref$extensions = _ref.extensions,
      editorExtensions = _ref$extensions === void 0 ? [] : _ref$extensions,
      container = _ref.container,
      tooltipContainer = _ref.tooltipContainer,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$onKeyDown = _ref.onKeyDown,
      onKeyDown = _ref$onKeyDown === void 0 ? function () {} : _ref$onKeyDown,
      _ref$onLint = _ref.onLint,
      onLint = _ref$onLint === void 0 ? function () {} : _ref$onLint,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      _ref$variables = _ref.variables,
      variables = _ref$variables === void 0 ? [] : _ref$variables;
    var changeHandler = EditorView.updateListener.of(function (update) {
      if (update.docChanged) {
        onChange(update.state.doc.toString());
      }
    });
    var lintHandler = EditorView.updateListener.of(function (update) {
      var diagnosticEffects = update.transactions.flatMap(function (t) {
        return t.effects;
      }).filter(function (effect) {
        return effect.is(setDiagnosticsEffect);
      });
      if (!diagnosticEffects.length) {
        return;
      }
      var messages = diagnosticEffects.flatMap(function (effect) {
        return effect.value;
      });
      onLint(messages);
    });
    var keyHandler = EditorView.domEventHandlers({
      keydown: onKeyDown
    });
    if (typeof tooltipContainer === 'string') {
      tooltipContainer = document.querySelector(tooltipContainer);
    }
    var tooltipLayout = tooltipContainer ? tooltips({
      tooltipSpace: function tooltipSpace() {
        return tooltipContainer.getBoundingClientRect();
      }
    }) : [];
    var extensions = [autocompletionConf.of(variablesFacet.of(variables)), autocompletion(), bracketMatching(), changeHandler, closeBrackets(), indentOnInput(), keyHandler, keymap.of(_toConsumableArray(defaultKeymap)), language(), linter, lintHandler, tooltipLayout, theme].concat(_toConsumableArray(editorExtensions));
    if (readOnly) {
      extensions.push(EditorView.editable.of(false));
    }
    this._cmEditor = new EditorView({
      state: EditorState.create({
        doc: value,
        extensions: extensions
      }),
      parent: container
    });
    return this;
  }

  /**
   * Replaces the content of the Editor
   *
   * @param {String} value
   */
  FeelEditor$2.prototype.setValue = function (value) {
    this._cmEditor.dispatch({
      changes: {
        from: 0,
        to: this._cmEditor.state.doc.length,
        insert: value
      }
    });
  };

  /**
   * Sets the focus in the editor.
   */
  FeelEditor$2.prototype.focus = function (position) {
    var cmEditor = this._cmEditor;

    // the Codemirror `focus` method always calls `focus` with `preventScroll`,
    // so we have to focus + scroll manually
    cmEditor.contentDOM.focus();
    cmEditor.focus();
    if (typeof position === 'number') {
      var end = cmEditor.state.doc.length;
      cmEditor.dispatch({
        selection: {
          anchor: position <= end ? position : end
        }
      });
    }
  };

  /**
   * Returns the current selection ranges. If no text is selected, a single
   * range with the start and end index at the cursor position will be returned.
   *
   * @returns {Object} selection
   * @returns {Array} selection.ranges
   */
  FeelEditor$2.prototype.getSelection = function () {
    return this._cmEditor.state.selection;
  };

  /**
   * Set variables to be used for autocompletion.
   * @param {Variable[]} variables
   * @returns {void}
   */
  FeelEditor$2.prototype.setVariables = function (variables) {
    this._cmEditor.dispatch({
      effects: autocompletionConf.reconfigure(variablesFacet.of(variables))
    });
  };

  function _defineProperty$o(obj, key, value) {
    key = _toPropertyKey$n(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$n(arg) {
    var key = _toPrimitive$n(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$n(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * A drop-in replacement for ContentEditable which uses FEEL editor under the hood.
   * It does not support placeholder.
   *
   * The callback `onInput(text)` receives text (including line breaks)
   * only. Updating the value via props will update the selection
   * if needed, too.
   *
   * @example
   *
   * class SomeComponent extends Component {
   *
   *   render() {
   *     return (
   *       <LiteralExpression
   *         className="some classes"
   *         value={ this.state.text }
   *         onInput={ this.handleInput }
   *         onFocus={ ... }
   *         onBlur={ ... } />
   *     );
   *   }
   *
   * }
   *
   */
  var LiteralExpression = /*#__PURE__*/function (_Component) {
    _inherits$1(LiteralExpression, _Component);
    var _super = _createSuper(LiteralExpression);
    function LiteralExpression(props, context) {
      var _this;
      _classCallCheck(this, LiteralExpression);
      _this = _super.call(this, props, context);

      /** @type {HTMLElement} */
      _defineProperty$o(_assertThisInitialized(_this), "handleMouseEvent", function (event) {
        event.stopPropagation();
      });
      _defineProperty$o(_assertThisInitialized(_this), "handleKeyDownCapture", function (event) {
        if (event.key === 'Enter') {
          if (isAutocompleteOpen(_this.node)) {
            event.triggeredFromAutocomplete = true;
            return;
          }

          // supress non cmd+enter newline
          if (_this.props.ctrlForNewline && !isCmd$2(event)) {
            event.preventDefault();
          }
          if (_this.props.singleLine) {
            event.preventDefault();
          }
        }
      });
      _defineProperty$o(_assertThisInitialized(_this), "handleKeyDown", function (event) {
        // contain the event in the component to not trigger global handlers
        if (['Enter', 'Escape'].includes(event.key) && event.triggeredFromAutocomplete) {
          event.stopPropagation();
        }
      });
      _defineProperty$o(_assertThisInitialized(_this), "handleChange", function (value) {
        var onInput = _this.props.onInput;
        _this.setState({
          value: value
        });
        if (onInput) {
          onInput(value);
        }
      });
      _defineProperty$o(_assertThisInitialized(_this), "setNode", function (node) {
        _this.node = node;
      });
      _this.node = null;
      _this.editor = null;
      _this.state = {
        value: props.value
      };
      return _this;
    }
    _createClass(LiteralExpression, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.editor = new FeelEditor$2({
          container: this.node,
          onChange: this.handleChange,
          value: this.state.value,
          variables: this.props.variables || []
        });
        this.node.addEventListener('mousedown', this.handleMouseEvent);

        // `capture: true` is needed to precede Keyboard handlers
        this.node.addEventListener('keydown', this.handleKeyDownCapture, true);
        this.node.addEventListener('keydown', this.handleKeyDown);
        if (this.props.autoFocus) {
          this.editor.focus(this.state.value.length);
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this2 = this;
        var value = this.props.value;
        if (prevProps.value !== value && value !== this.state.value) {
          this.setState({
            value: value
          }, function () {
            _this2.editor.setValue(value);
          });
        }
        if (!deepEqual(prevProps.variables, this.props.variables)) {
          this.editor.setVariables(this.props.variables);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.node.removeEventListener('mousedown', this.handleMouseEvent);

        // `capture: true` is needed to precede FEEL editor default handling
        this.node.removeEventListener('keydown', this.handleKeyDownCapture, true);
        this.node.removeEventListener('keydown', this.handleKeyDown);
      }
    }, {
      key: "render",
      value: function render() {
        return createVNode(1, "div", ['literal-expression', this.props.className || ''].join(' '), null, 1, {
          "onClick": this.handleMouseEvent,
          "onFocusIn": this.props.onFocus,
          "onFocusOut": this.props.onBlur
        }, null, this.setNode);
      }
    }]);
    return LiteralExpression;
  }(Component);
  function isCmd$2(event) {
    return event.metaKey || event.ctrlKey;
  }
  function isAutocompleteOpen(node) {
    return node.querySelector('.cm-tooltip-autocomplete');
  }
  function deepEqual(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  }

  function _defineProperty$n(obj, key, value) {
    key = _toPropertyKey$m(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$m(arg) {
    var key = _toPrimitive$m(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$m(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var InputEditor = /*#__PURE__*/function (_Component) {
    _inherits$1(InputEditor, _Component);
    var _super = _createSuper(InputEditor);
    function InputEditor(props, context) {
      var _this;
      _classCallCheck(this, InputEditor);
      _this = _super.call(this, props, context);
      _defineProperty$n(_assertThisInitialized(_this), "handleKeyDown", function (event) {
        if (event.key === 'Enter') {
          event.stopPropagation();
        }
      });
      _this.translate = context.injector ? context.injector.get('translate') : noopTranslate;
      _this.expressionLanguages = context.injector.get('expressionLanguages', false);
      _this.variableResolver = context.injector.get('variableResolver', false);
      _this.handleValue = function (text) {
        var change = {
          text: text
        };
        _this.handleChange(change);
      };
      _this.handleLabelChange = function (value) {
        // default to <undefined> for empty string
        var label = value || undefined;
        _this.handleChange({
          label: label
        });
      };
      return _this;
    }
    _createClass(InputEditor, [{
      key: "handleChange",
      value: function handleChange(changes) {
        var onChange = this.props.onChange;
        if (typeof onChange === 'function') {
          onChange(changes);
        }
      }
    }, {
      key: "getExpressionEditorComponent",
      value: function getExpressionEditorComponent() {
        if (this.expressionLanguages && this.expressionLanguages.getDefault('inputCell').value !== 'feel') {
          return ContentEditable;
        }
        return LiteralExpression;
      }

      /**
       * Supress default menu closure on enter.
       * @param {KeyboardEvent} event
       */
    }, {
      key: "_getVariables",
      value: function _getVariables() {
        return this.variableResolver && this.variableResolver.getVariables(this.props.element);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          label = _this$props.label,
          text = _this$props.text;
        var ExpressionEditor = this.getExpressionEditorComponent();
        var variables = this._getVariables();
        return createVNode(1, "div", "context-menu-container ref-input-editor input-edit", [createVNode(1, "div", "dms-form-control", createComponentVNode(2, ContentEditable, {
          "className": "dms-input-label",
          "value": label || '',
          "placeholder": this.translate('Input'),
          "singleLine": true,
          "onInput": this.handleLabelChange
        }), 2), createVNode(1, "div", "dms-form-control", [createVNode(1, "label", "dms-label", this.translate('Expression'), 0), createComponentVNode(2, ExpressionEditor, {
          "placeholder": this.translate('Enter expression'),
          "className": ['ref-text', 'dms-input'].join(' '),
          "onInput": this.handleValue,
          "value": text || '',
          "variables": variables
        })], 4)], 4, {
          "onKeyDown": this.handleKeyDown
        });
      }
    }]);
    return InputEditor;
  }(Component);
  function noopTranslate(str) {
    return str;
  }

  var _excluded$3 = ["label"];
  function ownKeys$5(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$5(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {
        _defineProperty$m(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _objectWithoutProperties$3(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$3(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _defineProperty$m(obj, key, value) {
    key = _toPropertyKey$l(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$l(arg) {
    var key = _toPrimitive$l(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$l(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var InputCellContextMenu = /*#__PURE__*/function (_Component) {
    _inherits$1(InputCellContextMenu, _Component);
    var _super = _createSuper(InputCellContextMenu);
    function InputCellContextMenu(props, context) {
      var _this;
      _classCallCheck(this, InputCellContextMenu);
      _this = _super.call(this, props, context);
      _defineProperty$m(_assertThisInitialized(_this), "persistChanges", function () {
        var input = _this.props.context.input;
        var unsaved = _this.state.unsaved;
        if (!unsaved) {
          return;
        }
        var label = unsaved.label,
          inputExpressionProperties = _objectWithoutProperties$3(unsaved, _excluded$3);
        var changes = {};
        if ('label' in unsaved) {
          changes.label = label;
        }
        if (hasKeys(inputExpressionProperties)) {
          changes.inputExpression = inputExpressionProperties;
        }
        _this.modeling.updateProperties(input, changes);
        _this.setState({
          unsaved: false
        });
      });
      _defineProperty$m(_assertThisInitialized(_this), "handleChange", function (changes) {
        _this.setState({
          unsaved: _objectSpread$5(_objectSpread$5({}, _this.state.unsaved), changes)
        }, _this.persistChanges);
      });
      _this.state = {};
      inject(_assertThisInitialized(_this));
      _this.persistChanges = _this.debounceInput(_this.persistChanges);
      return _this;
    }
    _createClass(InputCellContextMenu, [{
      key: "getValue",
      value: function getValue(attr) {
        var input = this.props.context.input;
        var unsaved = this.state.unsaved;
        var target = input;

        // input variable stored in parent
        if (attr === 'text') {
          target = target.inputExpression;
        }
        return unsaved && attr in unsaved ? unsaved[attr] : target.get(attr);
      }
    }, {
      key: "render",
      value: function render() {
        return createComponentVNode(2, InputEditor, {
          "label": this.getValue('label'),
          "text": this.getValue('text'),
          "element": this.props.context.input,
          "onChange": this.handleChange
        });
      }
    }]);
    return InputCellContextMenu;
  }(Component);
  InputCellContextMenu.$inject = ['debounceInput', 'modeling', 'injector'];

  // helpers //////////////////////

  function hasKeys(obj) {
    return Object.keys(obj).length;
  }

  var InputCellProvider = /*#__PURE__*/_createClass(function InputCellProvider(components, contextMenu, eventBus, renderer) {
    _classCallCheck(this, InputCellProvider);
    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;
      if (cellType === 'input-header') {
        return InputCell;
      }
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType === 'input-edit') {
        return InputCellContextMenu;
      }
    });
    eventBus.on('input.edit', function (_ref2) {
      var event = _ref2.event,
        input = _ref2.input;
      var target = event.target;
      var node = closest(target, 'th', true);
      var _node$getBoundingClie = node.getBoundingClientRect(),
        left = _node$getBoundingClie.left,
        top = _node$getBoundingClie.top;
      contextMenu.open({
        x: left,
        y: top,
        align: 'bottom-right'
      }, {
        contextMenuType: 'input-edit',
        input: input
      });
    });
  });
  InputCellProvider.$inject = ['components', 'contextMenu', 'eventBus', 'renderer'];

  function _defineProperty$l(obj, key, value) {
    key = _toPropertyKey$k(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$k(arg) {
    var key = _toPrimitive$k(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$k(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var InputSelect = /*#__PURE__*/function (_Component) {
    _inherits$1(InputSelect, _Component);
    var _super = _createSuper(InputSelect);
    function InputSelect(props, context) {
      var _this;
      _classCallCheck(this, InputSelect);
      _this = _super.call(this, props, context);
      _defineProperty$l(_assertThisInitialized(_this), "onChange", function (value) {
        _this.setState({
          value: value
        });
        var onChange = _this.props.onChange;
        if (typeof onChange !== 'function') {
          return;
        }
        onChange(value);
      });
      _defineProperty$l(_assertThisInitialized(_this), "onInputClick", function (event) {
        event.preventDefault();
        event.stopPropagation();
        _this.setOptionsVisible(!_this.state.optionsVisible);
        _this.focusInput();
      });
      _defineProperty$l(_assertThisInitialized(_this), "onInput", function (event) {
        var value = event.target.value;
        _this.onChange(value);
      });
      _defineProperty$l(_assertThisInitialized(_this), "onOptionClick", function (value, event) {
        event.preventDefault();
        event.stopPropagation();
        _this.setOptionsVisible(false);
        _this.onChange(value);
        _this.focusInput();
      });
      _defineProperty$l(_assertThisInitialized(_this), "onFocusChanged", function (evt) {
        _this.checkClose(evt.target);
      });
      _defineProperty$l(_assertThisInitialized(_this), "onGlobalClick", function (evt) {
        _this.checkClose(evt.target);
      });
      _defineProperty$l(_assertThisInitialized(_this), "onKeyDown", function (evt) {
        var optionsVisible = _this.state.optionsVisible;
        var code = evt.which;

        // DOWN or UP
        if (code === 40 || code === 38) {
          evt.stopPropagation();
          evt.preventDefault();
          if (!optionsVisible) {
            _this.setOptionsVisible(true);
          } else {
            _this.select(code === 40 ? 1 : -1);
          }
        }
        if (optionsVisible) {
          // ENTER
          // ESC
          if (code === 13 || code === 27) {
            evt.stopPropagation();
            evt.preventDefault();
            _this.setOptionsVisible(false);
          }
        }
      });
      _defineProperty$l(_assertThisInitialized(_this), "onKeyboard", function (keycode) {
        var optionsVisible = _this.state.optionsVisible;
        if (!optionsVisible) {
          return;
        }

        // close on ESC
        if (keycode === 27) {
          _this.setOptionsVisible(false);
          return true;
        }
      });
      inject(_assertThisInitialized(_this));
      var _value = props.value;
      _this.state = {
        value: _value,
        optionsVisible: false
      };
      _this._portalEl = null;
      return _this;
    }
    _createClass(InputSelect, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        document.addEventListener('mousedown', this.onGlobalClick);
        document.addEventListener('focusin', this.onFocusChanged);
        this.keyboard.addListener(this.onKeyboard);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        document.removeEventListener('focusin', this.onFocusChanged);
        document.removeEventListener('mousedown', this.onGlobalClick);
        this.keyboard.removeListener(this.onKeyboard);
        this.removePortalEl();
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(props) {
        var value = props.value;
        this.setState({
          value: value
        });
      }
    }, {
      key: "componentWillUpdate",
      value: function componentWillUpdate(nextProps, nextState) {
        var optionsVisible = nextState.optionsVisible;
        if (optionsVisible) {
          if (!this._portalEl) {
            this.addPortalEl();
          }
        } else {
          if (this._portalEl) {
            this.removePortalEl();
          }
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var optionsVisible = this.state.optionsVisible;
        if (!optionsVisible || !this.inputNode) {
          return;
        }
        var optionsBounds = this.getOptionsBounds();
        assign$4(this._portalEl.style, optionsBounds);
      }
    }, {
      key: "getOptionsBounds",
      value: function getOptionsBounds() {
        var container = this.renderer.getContainer();
        var _container$getBoundin = container.getBoundingClientRect(),
          containerTop = _container$getBoundin.top,
          containerLeft = _container$getBoundin.left,
          containerBottom = _container$getBoundin.bottom;
        var _this$inputNode$getBo = this.inputNode.getBoundingClientRect(),
          inputTop = _this$inputNode$getBo.top,
          inputLeft = _this$inputNode$getBo.left,
          width = _this$inputNode$getBo.width,
          height = _this$inputNode$getBo.height,
          inputBottom = _this$inputNode$getBo.bottom;
        var top = inputTop + height - containerTop + container.scrollTop;
        var left = inputLeft - containerLeft + container.scrollLeft;
        var bounds = {
          top: "".concat(top, "px"),
          left: "".concat(left, "px"),
          width: "".concat(width, "px"),
          'max-height': "calc(100% - ".concat(top, "px)")
        };

        // open the options upwards when not even one option (=input height) fits
        if (containerBottom - inputBottom < height) {
          var bottom = containerBottom - inputTop;
          bounds.bottom = "".concat(bottom, "px");
          bounds['max-height'] = "calc(100% - ".concat(bottom, ")");
          delete bounds.top;
        }
        return bounds;
      }
    }, {
      key: "addPortalEl",
      value: function addPortalEl() {
        this._portalEl = domify$1('<div class="dms-select-options"></div>');
        var container = this.renderer.getContainer();
        container.appendChild(this._portalEl);

        // suppress mousedown event propagation to handle click events inside the component
        this._portalEl.addEventListener('mousedown', stopPropagation);
      }
    }, {
      key: "removePortalEl",
      value: function removePortalEl() {
        if (this._portalEl) {
          this._portalEl.removeEventListener('mousedown', stopPropagation);
          remove$4(this._portalEl);
          this._portalEl = null;
        }
      }
      /**
       * Focus input node
       */
    }, {
      key: "focusInput",
      value: function focusInput() {
        var node = this.inputNode;
        node.focus();

        // move cursor to end of input
        if ('selectionStart' in node) {
          node.selectionStart = 100000;
        }
      }
    }, {
      key: "checkClose",
      value: function checkClose(focusTarget) {
        if (this._portalEl && !this._portalEl.contains(focusTarget) && !this.parentNode.contains(focusTarget)) {
          this.setOptionsVisible(false);
        }
      }
    }, {
      key: "select",
      value: function select(direction) {
        var options = this.props.options;
        var value = this.state.value;
        if (!options) {
          return;
        }
        var option = options.filter(function (o) {
          return o.value === value;
        })[0];
        var idx = option ? options.indexOf(option) : -1;
        var nextIdx = idx === -1 ? direction === 1 ? 0 : options.length - 1 : (idx + direction) % options.length;
        var nextOption = options[nextIdx < 0 ? options.length + nextIdx : nextIdx];
        this.onChange(nextOption.value);
      }
    }, {
      key: "setOptionsVisible",
      value: function setOptionsVisible(optionsVisible) {
        this.setState({
          optionsVisible: optionsVisible
        });
      }
    }, {
      key: "renderOptions",
      value: function renderOptions(options, activeOption) {
        var _this2 = this;
        return createVNode(1, "div", "options", options.map(function (option) {
          return createVNode(1, "div", ['option', activeOption === option ? 'active' : ''].join(' '), option.label, 0, {
            "data-value": option.value,
            "onClick": function onClick(e) {
              return _this2.onOptionClick(option.value, e);
            }
          });
        }), 0);
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;
        var _this$props = this.props,
          className = _this$props.className,
          options = _this$props.options,
          noInput = _this$props.noInput,
          title = _this$props.title;
        var _this$state = this.state,
          optionsVisible = _this$state.optionsVisible,
          value = _this$state.value;
        var option = options ? options.filter(function (o) {
          return o.value === value;
        })[0] : false;
        var label = option ? option.label : value;
        return createVNode(1, "div", [className || '', 'dms-input-select'].join(' '), [noInput ? createVNode(1, "div", "dms-input", label, 0, {
          "tabindex": "0",
          "onKeyDown": this.onKeyDown
        }, null, function (node) {
          return _this3.inputNode = node;
        }) : createVNode(64, "input", "dms-input", null, 1, {
          "onInput": this.onInput,
          "onKeyDown": this.onKeyDown,
          "spellcheck": "false",
          "type": "text",
          "value": value
        }, null, function (node) {
          return _this3.inputNode = node;
        }), createVNode(1, "span", ['dms-input-select-icon', optionsVisible ? 'dmn-icon-up' : 'dmn-icon-down'].join(' ')), optionsVisible && createPortal(this.renderOptions(options, option), this._portalEl)], 0, {
          "title": title,
          "onClick": this.onInputClick
        }, null, function (node) {
          return _this3.parentNode = node;
        });
      }
    }]);
    return InputSelect;
  }(Component);
  InputSelect.$inject = ['keyboard', 'renderer'];

  // helper ////
  function stopPropagation(event) {
    event.stopPropagation();
  }

  function _defineProperty$k(obj, key, value) {
    key = _toPropertyKey$j(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$j(arg) {
    var key = _toPrimitive$j(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$j(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var TypeRefCellContextMenu = /*#__PURE__*/function (_Component) {
    _inherits$1(TypeRefCellContextMenu, _Component);
    var _super = _createSuper(TypeRefCellContextMenu);
    function TypeRefCellContextMenu(props, context) {
      var _this;
      _classCallCheck(this, TypeRefCellContextMenu);
      _this = _super.call(this, props);
      _defineProperty$k(_assertThisInitialized(_this), "onTypeChange", function (value) {
        var element = _this.getElement();
        var actualElement = is$1(element, 'dmn:LiteralExpression') ? element.$parent : element;
        var newProperties;
        if (isInput$1(actualElement)) {
          newProperties = {
            inputExpression: {
              typeRef: value
            }
          };
        } else if (isOutput(actualElement)) {
          newProperties = {
            typeRef: value
          };
        }
        _this._modeling.updateProperties(actualElement, newProperties);
      });
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      _this._dataTypes = context.injector.get('dataTypes');
      return _this;
    }
    _createClass(TypeRefCellContextMenu, [{
      key: "getElement",
      value: function getElement() {
        return this.props.context.input || this.props.context.output;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var element = this.getElement();
        var typeRef = (is$1(element, 'dmn:InputClause') ? element.inputExpression : element).typeRef;
        var typeRefOptions = this._dataTypes.getAll().map(function (t) {
          return {
            label: _this2._translate(t),
            value: t
          };
        });
        return createVNode(1, "div", "type-ref-edit context-menu-container", createVNode(1, "div", "dms-form-control", [createVNode(1, "label", "dms-label", [this._translate('Type'), createTextVNode(":")], 0), createComponentVNode(2, InputSelect, {
          "className": "type-ref-edit-select",
          "onChange": this.onTypeChange,
          "options": typeRefOptions,
          "value": typeRef
        })], 4), 2);
      }
    }]);
    return TypeRefCellContextMenu;
  }(Component);

  var LOW_PRIORITY$5 = 750;
  var TypeRef = /*#__PURE__*/_createClass(function TypeRef(components) {
    _classCallCheck(this, TypeRef);
    components.onGetComponent('context-menu', LOW_PRIORITY$5, function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var contextMenuType = context.contextMenuType;
      if (contextMenuType === 'input-edit' || contextMenuType === 'output-edit') {
        return TypeRefCellContextMenu;
      }
    });
  });
  TypeRef.$inject = ['components'];

  var TypeRefEditing = {
    __depends__: [contextMenuModule, DataTypesModule],
    __init__: ['typeRefEditingProvider'],
    typeRefEditingProvider: ['type', TypeRef]
  };

  /**
   * Makes sure allowed values are removed if type is set to
   * something other than string.
   */
  var AllowedValuesUpdateBehavior = /*#__PURE__*/function (_CommandInterceptor) {
    _inherits$1(AllowedValuesUpdateBehavior, _CommandInterceptor);
    var _super = _createSuper(AllowedValuesUpdateBehavior);
    function AllowedValuesUpdateBehavior(eventBus, modeling) {
      var _this;
      _classCallCheck(this, AllowedValuesUpdateBehavior);
      _this = _super.call(this, eventBus);
      _this.postExecuted('element.updateProperties', function (event) {
        var _event$context = event.context,
          element = _event$context.element,
          properties = _event$context.properties;
        var actualProperties = isInput$1(element) ? properties.inputExpression : properties;
        if (actualProperties && actualProperties.typeRef && actualProperties.typeRef !== 'string') {
          var target = is$1(element, 'dmn:LiteralExpression') ? element.$parent : element;

          // delete allowed values
          modeling.editAllowedValues(target, null);
        }
      });
      return _this;
    }
    return _createClass(AllowedValuesUpdateBehavior);
  }(CommandInterceptor);
  AllowedValuesUpdateBehavior.$inject = ['eventBus', 'modeling'];

  function _defineProperty$j(obj, key, value) {
    key = _toPropertyKey$i(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$i(arg) {
    var key = _toPrimitive$i(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$i(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var RADIO = 'radio';
  var REMOVE_BTN_CLS = 'remove dmn-icon-clear';

  /**
   * Shows a list of grouped items that can be checked
   * (checkboxes or radio buttons), removed.
   *
   * Example list of items:
   *
   * [
   *   { value: 'foo', isChecked: true, isRemovable: false, group: 'foo' },
   *   { value: 'bar', isChecked: false, isRemovable: true, group: 'bar' },
   *   { value: 'baz', isCheckable: false, group: 'baz' }
   * ]
   */
  var List = /*#__PURE__*/function (_Component) {
    _inherits$1(List, _Component);
    var _super = _createSuper(List);
    function List(props, context) {
      var _this;
      _classCallCheck(this, List);
      _this = _super.call(this, props, context);
      _defineProperty$j(_assertThisInitialized(_this), "getRemoveClickHandler", function (item) {
        return function (e) {
          e.stopPropagation();
          _this.removeItem(item);
        };
      });
      _defineProperty$j(_assertThisInitialized(_this), "getToggleClickHandler", function (item) {
        return function (e) {
          e.stopPropagation();
          _this.toggleItem(item);
        };
      });
      _defineProperty$j(_assertThisInitialized(_this), "removeItem", function (item) {
        var onChange = _this.props.onChange;

        // remove item
        var newItems = _this.state.items.filter(function (i) {
          return i !== item;
        });
        _this.setState({
          items: newItems
        });
        onChange && onChange(newItems);
      });
      _defineProperty$j(_assertThisInitialized(_this), "toggleItem", function (item) {
        var _this$props = _this.props,
          onChange = _this$props.onChange,
          type = _this$props.type;

        // toggle item
        var newItems = _this.state.items.map(function (i) {
          if (i === item) {
            i.isChecked = !i.isChecked;
          } else {
            if (type === RADIO) {
              i.isChecked = false;
            }
          }
          return i;
        });
        _this.setState({
          items: newItems
        });
        onChange && onChange(newItems);
      });
      var items = props.items;
      _this.state = {
        items: items
      };
      return _this;
    }
    _createClass(List, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(props) {
        var items = props.items;
        this.setState({
          items: items
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$props2 = this.props,
          className = _this$props2.className,
          items = _this$props2.items,
          type = _this$props2.type,
          labelComponent = _this$props2.labelComponent;
        var classes = ['dms-list-component'];
        if (className) {
          classes.push(className);
        }

        // group items by group title
        var groupedItems = groupBy(items, 'group');
        var asPairs = toPairs(groupedItems);
        return createVNode(1, "div", classes.join(' '), asPairs.map(function (pair) {
          var groupTitle = pair[0],
            groupItems = pair[1];
          return createVNode(1, "div", "group", [labelComponent && labelComponent(groupTitle) || createVNode(1, "h4", "dms-heading", groupTitle, 0), createVNode(1, "ul", "items no-wrap", groupItems.map(function (item) {
            return createVNode(1, "li", "item", [type && createVNode(64, "input", "item-toggle", null, 1, {
              "type": type,
              "checked": item.isChecked,
              "onClick": _this2.getToggleClickHandler(item)
            }), createTextVNode("\xA0"), item.value, item.isRemovable && createVNode(1, "span", REMOVE_BTN_CLS, null, 1, {
              "title": "Remove item",
              "onClick": _this2.getRemoveClickHandler(item)
            })], 0);
          }), 0)], 0);
        }), 0);
      }
    }]);
    return List;
  }(Component); // helpers ////////////
  function toPairs(object) {
    var entrys = [];
    for (var key in object) {
      entrys.push([key, object[key]]);
    }
    return entrys;
  }

  /**
   * Input with optional validation.
   */
  var ValidatedInput = /*#__PURE__*/function (_Component) {
    _inherits$1(ValidatedInput, _Component);
    var _super = _createSuper(ValidatedInput);
    function ValidatedInput(props, context) {
      var _this;
      _classCallCheck(this, ValidatedInput);
      _this = _super.call(this, props, context);
      var validate = props.validate,
        value = props.value;
      var validationWarning = validate ? validate(value || '') : undefined;
      _this.state = {
        validationWarning: validationWarning,
        value: value
      };
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
      _this.onKeyUp = _this.onKeyUp.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(ValidatedInput, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(props) {
        var validate = props.validate,
          value = props.value;
        var validationWarning = validate ? validate(value || '') : undefined;
        this.setState({
          validationWarning: validationWarning,
          value: value
        });
      }
    }, {
      key: "onInput",
      value: function onInput(value) {
        var _this$props = this.props,
          onInput = _this$props.onInput,
          validate = _this$props.validate;
        var validationWarning = validate ? validate(value) : undefined;
        this.setState({
          validationWarning: validationWarning,
          value: value
        });
        if (typeof onInput !== 'function') {
          return;
        }
        onInput && onInput({
          isValid: !validationWarning,
          value: value
        });
      }
    }, {
      key: "onKeyDown",
      value: function onKeyDown(event) {
        var target = event.target,
          value = target.value;
        var _this$props2 = this.props,
          onKeyDown = _this$props2.onKeyDown,
          validate = _this$props2.validate;
        var validationWarning = validate ? validate(value) : undefined;
        if (typeof onKeyDown !== 'function') {
          return;
        }
        onKeyDown({
          isValid: !validationWarning,
          value: value,
          event: event
        });
      }
    }, {
      key: "onKeyUp",
      value: function onKeyUp(event) {
        var target = event.target,
          value = target.value;
        var _this$props3 = this.props,
          onKeyUp = _this$props3.onKeyUp,
          validate = _this$props3.validate;
        var validationWarning = validate ? validate(value) : undefined;
        if (typeof onKeyUp !== 'function') {
          return;
        }
        onKeyUp({
          isValid: !validationWarning,
          value: value,
          event: event
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props4 = this.props,
          placeholder = _this$props4.placeholder,
          type = _this$props4.type,
          className = _this$props4.className;
        var _this$state = this.state,
          validationWarning = _this$state.validationWarning,
          value = _this$state.value;
        var parentClasses = ['dms-validated-input', className].join(' ');
        var inputClasses = [];
        if (validationWarning) {
          inputClasses.push('invalid');
        }
        return createVNode(1, "div", parentClasses, [createComponentVNode(2, Input, {
          "className": inputClasses,
          "onInput": this.onInput,
          "onKeyDown": this.onKeyDown,
          "onKeyUp": this.onKeyUp,
          "placeholder": placeholder || '',
          "type": type,
          "value": value || ''
        }), validationWarning && createVNode(1, "p", "dms-hint dms-validation-warning", validationWarning, 0)], 0);
      }
    }]);
    return ValidatedInput;
  }(Component);

  function parseString$6(string) {
    // empty string or no string at all
    if (!string || isEmptyString$4(string.trim())) {
      return {
        values: []
      };
    }

    // disjunction
    var values = string.split(',');
    var result = {
      values: []
    };
    var openString = '';
    values.forEach(function (value) {
      openString += value;
      if (/^"[^"]*"$/.test(openString.trim())) {
        result.values.push(openString.trim());
        openString = '';
      } else {
        openString += ',';
      }
    });
    if (!openString) {
      return result;
    }
  }
  function isEmptyString$4(string) {
    return string === '';
  }
  function getValuesArray(values) {
    return values.map(function (value) {
      return value.value;
    });
  }

  function _defineProperty$i(obj, key, value) {
    key = _toPropertyKey$h(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$h(arg) {
    var key = _toPrimitive$h(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$h(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var AllowedValuesEditing$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(AllowedValuesEditing, _Component);
    var _super = _createSuper(AllowedValuesEditing);
    function AllowedValuesEditing(props, context) {
      var _this;
      _classCallCheck(this, AllowedValuesEditing);
      _this = _super.call(this, props, context);
      _defineProperty$i(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$i(_assertThisInitialized(_this), "setPredefinedValues", function (values) {
        // inputClause or outputClause
        var target = _this.getAllowedValuesTarget();
        _this.setState({
          values: values
        });
        _this._modeling.editAllowedValues(target, values && getValuesArray(values));
      });
      _defineProperty$i(_assertThisInitialized(_this), "onListChange", function (values) {
        _this.setPredefinedValues(values);
      });
      _defineProperty$i(_assertThisInitialized(_this), "onInput", function (_ref) {
        _ref.isValid;
          var value = _ref.value;
        _this.setState({
          inputValue: value
        });
      });
      _defineProperty$i(_assertThisInitialized(_this), "onKeyDown", function (_ref2) {
        var isValid = _ref2.isValid,
          event = _ref2.event;
        if (!isEnter$1(event.keyCode)) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        if (isValid) {
          var _this$state = _this.state,
            inputValue = _this$state.inputValue,
            values = _this$state.values;
          var parsedString = parseString$6(inputValue);
          _this.onListChange((values || []).concat(parsedString.values.map(function (value) {
            return {
              value: value,
              isCheckable: false,
              isRemovable: true,
              group: _this._translate('Predefined values')
            };
          })));
          _this.setState({
            inputValue: ''
          });
        }
      });
      _defineProperty$i(_assertThisInitialized(_this), "handleRemovePredifinedValuesClick", function (e) {
        e.stopPropagation();
        _this.removePredefinedValues();
      });
      _defineProperty$i(_assertThisInitialized(_this), "removePredefinedValues", function () {
        _this.setPredefinedValues(null);
      });
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      _this._changeSupport = context.changeSupport;
      var _target = _this.getAllowedValuesTarget();
      var _parsedString = parseString$6(_target.inputValues && _target.inputValues.text || _target.outputValues && _target.outputValues.text || '');
      if (_parsedString) {
        _this.state = {
          values: _parsedString.values.map(function (value) {
            return {
              value: value,
              isCheckable: false,
              isRemovable: true,
              group: _this._translate('Predefined values')
            };
          }),
          inputValue: ''
        };
      } else {
        _this.state = {
          values: null,
          inputValue: ''
        };
      }
      return _this;
    }
    _createClass(AllowedValuesEditing, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var target = this.getAllowedValuesTarget();
        this._changeSupport.onElementsChanged(target.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var target = this.getAllowedValuesTarget();
        this._changeSupport.offElementsChanged(target.id, this.onElementsChanged);
      }
    }, {
      key: "getAllowedValuesTarget",
      value: function getAllowedValuesTarget() {
        var element = this.getElement();
        if (is$1(element, 'dmn:LiteralExpression')) {
          return element.$parent;
        } else {
          return element;
        }
      }
    }, {
      key: "getElement",
      value: function getElement() {
        return this.props.context.output || this.props.context.input.inputExpression;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var element = this.getElement();
        var _this$state2 = this.state,
          inputValue = _this$state2.inputValue,
          values = _this$state2.values;
        return element.typeRef === 'string' ? createVNode(1, "div", "context-menu-container allowed-values-edit", createVNode(1, "div", "dms-form-control", [!isNull$1(values) && values.length > 0 && createComponentVNode(2, List, {
          "labelComponent": Label,
          "items": values,
          "onChange": this.onListChange
        }), !isNull$1(values) && !values.length && createVNode(1, "div", null, [createVNode(1, "label", "dms-label", this._translate('Predefined values'), 0), createVNode(1, "span", "placeholder", this._translate('No values'), 0)], 4), !isNull$1(values) && createVNode(1, "p", "dms-hint", createVNode(1, "button", "del-values", this._translate('Clear predefined values'), 0, {
          "type": "button",
          "onClick": this.handleRemovePredifinedValuesClick
        }), 2), createVNode(1, "label", "dms-label", this._translate('Add predefined values'), 0), createComponentVNode(2, ValidatedInput, {
          "onInput": this.onInput,
          "onKeyDown": this.onKeyDown,
          "placeholder": this._translate('"value", "value", ...'),
          "type": "text",
          "validate": function validate(value) {
            if (!parseString$6(value)) {
              return _this2._translate('Strings must be in double quotes');
            }
          },
          "value": inputValue
        })], 0), 2) : null;
      }
    }]);
    return AllowedValuesEditing;
  }(Component);
  function Label(label) {
    return createVNode(1, "label", "dms-label", label, 0);
  }

  // helpers //////////////////////

  function isEnter$1(keyCode) {
    return keyCode === 13;
  }
  function isNull$1(value) {
    return value === null;
  }

  var LOW_PRIORITY$4 = 500;
  var InputOutputValues = /*#__PURE__*/_createClass(function InputOutputValues(components) {
    _classCallCheck(this, InputOutputValues);
    components.onGetComponent('context-menu', LOW_PRIORITY$4, function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var contextMenuType = context.contextMenuType;
      if (contextMenuType === 'input-edit' || contextMenuType === 'output-edit') {
        return AllowedValuesEditing$1;
      }
    });
  });
  InputOutputValues.$inject = ['components'];

  var AllowedValuesEditing = {
    __init__: ['allowedValuesUpdateBehavior', 'allowedValuesEditingProvider'],
    allowedValuesUpdateBehavior: ['type', AllowedValuesUpdateBehavior],
    allowedValuesEditingProvider: ['type', InputOutputValues]
  };

  function _defineProperty$h(obj, key, value) {
    key = _toPropertyKey$g(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$g(arg) {
    var key = _toPrimitive$g(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$g(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var AddInput = /*#__PURE__*/function (_Component) {
    _inherits$1(AddInput, _Component);
    var _super = _createSuper(AddInput);
    function AddInput(props, context) {
      var _this;
      _classCallCheck(this, AddInput);
      _this = _super.call(this, props, context);
      _defineProperty$h(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$h(_assertThisInitialized(_this), "handleClick", function (e) {
        e.stopPropagation();
        _this.add();
      });
      _defineProperty$h(_assertThisInitialized(_this), "add", function () {
        _this._eventBus.fire('addInput');
      });
      _this._sheet = context.injector.get('sheet');
      _this._eventBus = context.injector.get('eventBus');
      _this._changeSupport = context.changeSupport;
      _this._translate = context.injector.get('translate');
      return _this;
    }
    _createClass(AddInput, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var root = this.getRoot();
        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var root = this.getRoot();
        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this._sheet.getRoot();
      }
    }, {
      key: "render",
      value: function render() {
        return createVNode(1, "div", "add-input actionable", createVNode(1, "span", "dmn-icon-plus action-icon"), 2, {
          "onClick": this.handleClick,
          "title": this._translate('Add input')
        });
      }
    }]);
    return AddInput;
  }(Component);

  function _defineProperty$g(obj, key, value) {
    key = _toPropertyKey$f(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$f(arg) {
    var key = _toPrimitive$f(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$f(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var AddOutput = /*#__PURE__*/function (_Component) {
    _inherits$1(AddOutput, _Component);
    var _super = _createSuper(AddOutput);
    function AddOutput(props, context) {
      var _this;
      _classCallCheck(this, AddOutput);
      _this = _super.call(this, props, context);
      _defineProperty$g(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$g(_assertThisInitialized(_this), "handleClick", function (e) {
        e.stopPropagation();
        _this.add();
      });
      _defineProperty$g(_assertThisInitialized(_this), "add", function () {
        _this._eventBus.fire('addOutput');
      });
      _this._sheet = context.injector.get('sheet');
      _this._eventBus = context.injector.get('eventBus');
      _this._changeSupport = context.changeSupport;
      _this._translate = context.injector.get('translate');
      return _this;
    }
    _createClass(AddOutput, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var root = this.getRoot();
        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var root = this.getRoot();
        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this._sheet.getRoot();
      }
    }, {
      key: "render",
      value: function render() {
        return createVNode(1, "div", "add-output actionable", createVNode(1, "span", "dmn-icon-plus action-icon"), 2, {
          "onClick": this.handleClick,
          "title": this._translate('Add output')
        });
      }
    }]);
    return AddOutput;
  }(Component);

  function AddInputOutputProvider(components, editorActions, eventBus) {
    components.onGetComponent('cell-inner', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var cellType = context.cellType,
        index = context.index,
        inputsLength = context.inputsLength,
        outputsLength = context.outputsLength;
      if (cellType === 'input-cell' && index === inputsLength - 1) {
        return AddInput;
      }
      if (cellType === 'output-cell' && index === outputsLength - 1) {
        return AddOutput;
      }
    });
    eventBus.on('addInput', function () {
      editorActions.trigger('addInput');
    });
    eventBus.on('addOutput', function () {
      editorActions.trigger('addOutput');
    });
  }
  AddInputOutputProvider.$inject = ['components', 'editorActions', 'eventBus'];

  var AddInputOutput = {
    __depends__: [decisionTableEditorActionsModule],
    __init__: ['addInputOutputProvider'],
    addInputOutputProvider: ['type', AddInputOutputProvider]
  };

  function _defineProperty$f(obj, key, value) {
    key = _toPropertyKey$e(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$e(arg) {
    var key = _toPrimitive$e(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$e(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * A keyboard abstraction that may be activated and
   * deactivated by users at will, consuming key events
   * and triggering diagram actions.
   *
   * The implementation fires the following key events that allow
   * other components to hook into key handling:
   *
   *  - keyboard.bind
   *  - keyboard.unbind
   *  - keyboard.init
   *  - keyboard.destroy
   *
   * All events contain the fields (node, listeners).
   *
   * A default binding for the keyboard may be specified via the
   * `keyboard.bindTo` configuration option.
   *
   * @param {Config} config
   * @param {EventBus} eventBus
   * @param {EditorActions} editorActions
   * @param {CellSelection} cellSelection
   */
  var Keyboard$1 = /*#__PURE__*/function () {
    function Keyboard(config, eventBus, editorActions, cellSelection) {
      var _this = this;
      _classCallCheck(this, Keyboard);
      _defineProperty$f(this, "_init", function () {
        _this._registerDefaultBindings();
        _this._fire('init');
      });
      _defineProperty$f(this, "_destroy", function () {
        _this._fire('destroy');
        _this.unbind();
        _this._listeners = null;
      });
      _defineProperty$f(this, "_keyHandler", function (event) {
        var i,
          l,
          listeners = _this._listeners,
          code = event.keyCode || event.charCode || -1;
        for (i = 0; l = listeners[i]; i++) {
          if (l(code, event)) {
            event.preventDefault();
            event.stopPropagation();
            return;
          }
        }
      });
      _defineProperty$f(this, "unbind", function () {
        var node = _this._node;
        if (node) {
          _this._fire('unbind');

          // unbind key events
          event.unbind(node, 'keydown', _this._keyHandler);
        }
        _this._node = null;
      });
      this._config = config || {};
      this._editorActions = editorActions;
      this._eventBus = eventBus;
      this._cellSelection = cellSelection;
      this._listeners = [];
      eventBus.on('table.destroy', this._destroy);
      eventBus.on('table.init', this._init);
      eventBus.on('attach', function () {
        if (_this._config.bindTo) {
          _this.bind(config.bindTo);
        }
      });
      eventBus.on('detach', this.unbind);
    }
    _createClass(Keyboard, [{
      key: "bind",
      value: function bind(node) {
        // make sure that the keyboard is only bound once to the DOM
        this.unbind();
        this._node = node;

        // bind key events
        event.bind(node, 'keydown', this._keyHandler);
        this._fire('bind');
      }
    }, {
      key: "getBinding",
      value: function getBinding() {
        return this._node;
      }
    }, {
      key: "_fire",
      value: function _fire(event) {
        this._eventBus.fire('keyboard.' + event, {
          node: this._node,
          listeners: this._listeners
        });
      }
    }, {
      key: "_registerDefaultBindings",
      value: function _registerDefaultBindings() {
        var listeners = this._listeners;
        var editorActions = this._editorActions;
        var cellSelection = this._cellSelection;

        // init default listeners

        // undo
        // (CTRL|CMD) + Z
        function undo(key, modifiers) {
          if (isCmd$3(modifiers) && !isShift$1(modifiers) && key === 90) {
            editorActions.trigger('undo');
            return true;
          }
        }

        // redo
        // CTRL + Y
        // CMD + SHIFT + Z
        function redo(key, modifiers) {
          if (isCmd$3(modifiers) && (key === 89 || key === 90 && isShift$1(modifiers))) {
            editorActions.trigger('redo');
            return true;
          }
        }
        listeners.push(undo);
        listeners.push(redo);
        function selectCellAbove(key, event) {
          if (key !== 13 || isCmd$3(event) || !isShift$1(event)) {
            return;
          }
          if (!findSelectableAncestor(event.target)) {
            return;
          }
          editorActions.trigger('selectCellAbove');
          return true;
        }
        listeners.push(selectCellAbove);
        function selectCellBelow(key, event) {
          if (key !== 13 || isCmd$3(event) || isShift$1(event)) {
            return;
          }
          if (!findSelectableAncestor(event.target)) {
            return;
          }
          var changed = editorActions.trigger('selectCellBelow');
          var selectedCell = cellSelection.getCellSelection();

          // add new rule if no next rule
          if (!changed && selectedCell && !isDecisionNameCell(selectedCell)) {
            var rule = editorActions.trigger('addRule');
            editorActions.trigger('selectCellBelow');
            return rule;
          }
          return true;
        }
        listeners.push(selectCellBelow);
      }

      /**
       * Add a listener function that is notified with (key, modifiers) whenever
       * the keyboard is bound and the user presses a key.
       *
       * @param {Function} listenerFn
       */
    }, {
      key: "addListener",
      value: function addListener(listenerFn) {
        this._listeners.unshift(listenerFn);
      }
    }, {
      key: "removeListener",
      value: function removeListener(listenerFn) {
        this._listeners = this._listeners.filter(function (l) {
          return l !== listenerFn;
        });
      }
    }]);
    return Keyboard;
  }();
  Keyboard$1.$inject = ['config.keyboard', 'eventBus', 'editorActions', 'cellSelection'];

  // helper /////
  function isDecisionNameCell(cell) {
    return cell === '__decisionProperties_name';
  }

  var keyboardModule = {
    __depends__: [decisionTableEditorActionsModule],
    __init__: ['keyboard'],
    keyboard: ['type', Keyboard$1]
  };

  var decisionTableHeadEditorModule = {
    __depends__: [AddInputOutput, AllowedValuesEditing, contextMenuModule, DebounceInput, ExpressionLanguagesModule, keyboardModule, TypeRefEditing],
    __init__: ['inputEditingProvider', 'outputEditingProvider'],
    inputEditingProvider: ['type', InputCellProvider],
    outputEditingProvider: ['type', OutputEditingProvider]
  };

  function _defineProperty$e(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var TARGET_SELECTOR = ".dmn-decision-table-container td,\n   .dmn-decision-table-container th";
  var DragAndDrop$2 = /*#__PURE__*/function () {
    function DragAndDrop(eventBus, renderer, modeling, sheet) {
      var _this = this;
      _classCallCheck(this, DragAndDrop);
      _defineProperty$e(this, "handleDragOver", function (event) {
        // we're taking over (!)
        stopEvent(event);
        var targetEl = event.target;
        var cellEl = closest(targetEl, TARGET_SELECTOR, true);
        var allowed = !!cellEl;
        var hoverEl = _this._dragContext.hoverEl; // drag leave

        if (hoverEl && hoverEl !== cellEl) {
          _this._emit('dragAndDrop.dragLeave', event); // unset target element

          _this._dragContext.targetEl = null; // unset hover element

          _this._dragContext.hoverEl = null;
        }
        if (cellEl) {
          // drag enter
          if (cellEl !== hoverEl) {
            // new hover element
            _this._dragContext.hoverEl = cellEl;
            allowed = _this._emit('dragAndDrop.dragEnter', event);
            if (allowed !== false) {
              // new targetEl
              _this._dragContext.targetEl = cellEl;
            }
          } // drag over

          allowed = _this._emit('dragAndDrop.dragOver', event);
        }
        event.dataTransfer.dropEffect = allowed !== false ? 'move' : 'none';
      });
      _defineProperty$e(this, "handleDrop", function (event) {
        // prevent default drop action
        // QUIRK: Firefox will redirect if not prevented
        stopEvent(event);
        var target = _this._emit('dragAndDrop.drop', event);
        if (target) {
          var draggedElement = _this._dragContext.draggedElement;
          if (draggedElement instanceof Row) {
            var _this$_sheet$getRoot = _this._sheet.getRoot(),
              rows = _this$_sheet$getRoot.rows;
            var index = rows.indexOf(target);
            _this._modeling.moveRow(draggedElement, index);
          } else if (draggedElement instanceof Col) {
            var _this$_sheet$getRoot2 = _this._sheet.getRoot(),
              cols = _this$_sheet$getRoot2.cols;
            var _index = cols.indexOf(target);
            _this._modeling.moveCol(draggedElement, _index);
          }
        } // manually call to drag end needed, as we prevent the default
        // browser behavior / drag end handling via
        // event.preventDefault();

        _this.handleDragEnd(event);
      });
      _defineProperty$e(this, "handleDragEnd", function (event) {
        // prevent default drop action
        stopEvent(event);
        _this._unbindListeners();
        _this._emit('dragAndDrop.dragEnd', event);
        _this._dragContext = null;
      });
      this._eventBus = eventBus;
      this._renderer = renderer;
      this._modeling = modeling;
      this._sheet = sheet;
      this._dragContext = null;
      eventBus.on('table.destroy', function () {
        _this._unbindListeners();
      });
    }
    _createClass(DragAndDrop, [{
      key: "_bindListeners",
      value: function _bindListeners() {
        event.bind(document, 'dragover', this.handleDragOver);
        event.bind(document, 'drop', this.handleDrop);
        event.bind(document, 'dragend', this.handleDragEnd);
      }
    }, {
      key: "_unbindListeners",
      value: function _unbindListeners() {
        event.unbind(document, 'dragover', this.handleDragOver);
        event.unbind(document, 'drop', this.handleDrop);
        event.unbind(document, 'dragend', this.handleDragEnd);
      }
    }, {
      key: "_emit",
      value: function _emit(eventName, originalEvent) {
        return this._eventBus.fire(eventName, {
          dragContext: this._dragContext,
          originalEvent: originalEvent
        });
      }
    }, {
      key: "startDrag",
      value: function startDrag(element, event) {
        stopEvent(event, true);
        event.dataTransfer.effectAllowed = 'move'; // QUIRK: Firefox won't fire events unless data was set

        if (event.dataTransfer.setData) {
          event.dataTransfer.setData('text', '__DUMMY');
        }
        this._dragContext = {
          draggedElement: element
        };
        this._bindListeners();
        this._emit('dragAndDrop.dragStart', event);
      }
    }]);
    return DragAndDrop;
  }();
  DragAndDrop$2.$inject = ['eventBus', 'renderer', 'modeling', 'sheet']; // helpers /////////////////

  function stopEvent(event, preventDefault) {
    event.stopPropagation();
    if (preventDefault !== true) {
      event.preventDefault();
    }
  }

  var DragAndDrop$1 = {
    __init__: ['dragAndDrop'],
    dragAndDrop: ['type', DragAndDrop$2]
  };

  function _defineProperty$d(obj, key, value) {
    key = _toPropertyKey$d(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$d(arg) {
    var key = _toPrimitive$d(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$d(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var TOP = 'top',
    RIGHT = 'right',
    BOTTOM = 'bottom',
    LEFT = 'left';
  var DragAndDrop = /*#__PURE__*/function () {
    function DragAndDrop(components, elementRegistry, eventBus, dragAndDrop, renderer, rules, sheet, translate) {
      var _this = this;
      _classCallCheck(this, DragAndDrop);
      _defineProperty$d(this, "_cleanup", function () {
        var container = _this._renderer.getContainer();
        removeHighlight(container);
        removeFadeOut(container);
        if (_this._dragImage) {
          remove$4(_this._dragImage);
          _this._dragImage = null;
        }
      });
      this._elementRegistry = elementRegistry;
      this._dragAndDrop = dragAndDrop;
      this._renderer = renderer;
      this._rules = rules;
      this._sheet = sheet;
      this._translate = translate;

      // provide drag handle for drag and drop
      components.onGetComponent('cell-inner', function (_ref) {
        var cellType = _ref.cellType,
          col = _ref.col,
          row = _ref.row;
        if (cellType === 'rule-index') {
          return function () {
            return createVNode(1, "span", "dmn-icon-drag vertical", createTextVNode("\xA0"), 2, {
              "draggable": "true",
              "onDragStart": function onDragStart(e) {
                return _this.startDrag(row, e);
              },
              "title": _this._translate('Move rule')
            });
          };
        } else if (cellType === 'input-cell' || cellType === 'output-cell') {
          var title = "Move ".concat(isInput$1(col) ? 'Input' : 'Output');
          return function () {
            return createVNode(1, "span", "dmn-icon-drag horizontal", null, 1, {
              "draggable": "true",
              "onDragStart": function onDragStart(e) {
                return _this.startDrag(col, e);
              },
              "title": title
            });
          };
        }
      });

      // validate allowed rules
      eventBus.on('dragAndDrop.dragEnter', function (event) {
        var dragContext = event.dragContext;
        var draggedElement = dragContext.draggedElement,
          hoverEl = dragContext.hoverEl;

        // can always drag rows
        if (draggedElement instanceof Row) {
          return true;
        }
        if (draggedElement instanceof Col) {
          var dropIndex = getTargetColIndex(hoverEl, _this._elementRegistry, _this._sheet);

          // cannot drop as we cannot compute the drop index
          if (dropIndex === -1) {
            return false;
          }
          var allowed = _this._rules.allowed('col.move', {
            col: draggedElement,
            index: dropIndex
          });
          return allowed;
        }
        return false;
      });

      // clear previous UI
      eventBus.on('dragAndDrop.dragLeave', function (event) {
        var dragContext = event.dragContext;
        var targetEl = dragContext.targetEl;
        if (!targetEl) {
          return;
        }
        var container = _this._renderer.getContainer();
        removeHighlight(container);
      });

      // update UI
      eventBus.on('dragAndDrop.dragOver', function (event) {
        var dragContext = event.dragContext,
          originalEvent = event.originalEvent;
        var draggedElement = dragContext.draggedElement,
          lastPosition = dragContext.lastPosition,
          targetEl = dragContext.targetEl;
        var container = _this._renderer.getContainer();
        if (!targetEl) {
          return false;
        }
        var newPosition;
        if (draggedElement instanceof Row) {
          newPosition = getVerticalPosition(originalEvent, targetEl);
        }
        if (draggedElement instanceof Col) {
          newPosition = getHorizontalPosition(originalEvent, targetEl);
        }

        // nothing to do
        if (lastPosition === newPosition) {
          return true;
        }

        // remove old highlight
        removeHighlight(container);
        if (draggedElement instanceof Row) {
          if (newPosition === TOP) {
            // drop above
            highlightRow(targetEl, container, 'top');
          } else {
            // drop below
            highlightRow(targetEl, container, 'bottom');
          }
        }
        if (draggedElement instanceof Col) {
          if (newPosition === LEFT) {
            // drop left
            highlightCol(targetEl, container, 'left');
          } else {
            // drop right
            highlightCol(targetEl, container, 'right');
          }
        }

        // remember position
        dragContext.lastPosition = newPosition;

        // allowed
        return true;
      });

      // perform drop operation
      eventBus.on('dragAndDrop.drop', function (event) {
        var dragContext = event.dragContext,
          originalEvent = event.originalEvent;
        var draggedElement = dragContext.draggedElement,
          targetEl = dragContext.targetEl;
        if (!targetEl) {
          return false;
        }
        if (draggedElement instanceof Row) {
          var verticalPosition = getVerticalPosition(originalEvent, targetEl);
          var rowId = targetEl.dataset.rowId,
            row = _this._elementRegistry.get(rowId);
          if (!row || row === draggedElement) {
            return;
          }
          var targetRow = getTargetRow(draggedElement, row, verticalPosition, _this._sheet.getRoot().rows);
          if (targetRow === draggedElement) {
            return;
          }
          return targetRow;
        }
        if (draggedElement instanceof Col) {
          var horizontalPosition = getHorizontalPosition(originalEvent, targetEl);

          // no need to check rules; we verified on
          // dragEnter that dropping is O.K.
          var colId = targetEl.dataset.colId,
            col = _this._elementRegistry.get(colId);
          if (!col || col === draggedElement) {
            return;
          }
          var targetCol = getTargetCol(draggedElement, col, horizontalPosition, _this._sheet.getRoot().cols);
          if (targetCol === draggedElement) {
            return;
          }
          return targetCol;
        }
      });
      eventBus.on('dragAndDrop.dragEnd', this._cleanup);
    }
    _createClass(DragAndDrop, [{
      key: "startDrag",
      value: function startDrag(element, event) {
        var container = this._renderer.getContainer();
        this._dragImage = domify$1("<span style=\"\n          visibility: hidden;\n          position: fixed;\n          top: -10000px\n      \"></span>");

        // needs to be present in DOM
        document.body.appendChild(this._dragImage);

        // QUIRK: not supported by Edge and Internet Explorer
        if (event.dataTransfer.setDragImage) {
          event.dataTransfer.setDragImage(this._dragImage, 0, 0);
        }
        if (element instanceof Row) {
          fadeOutRow(element, container);
        } else if (element instanceof Col) {
          fadeOutCol(element, container);
        }
        this._dragAndDrop.startDrag(element, event);
      }
    }]);
    return DragAndDrop;
  }();
  DragAndDrop.$inject = ['components', 'elementRegistry', 'eventBus', 'dragAndDrop', 'renderer', 'rules', 'sheet', 'translate'];

  // helpers //////////

  function getTargetColIndex(cellEl, elementRegistry, sheet) {
    var targetCol = elementRegistry.get(cellEl.dataset.colId);
    if (!targetCol) {
      return -1;
    }
    var _sheet$getRoot = sheet.getRoot(),
      cols = _sheet$getRoot.cols;
    return cols.indexOf(targetCol);
  }
  function highlightRow(dragOverCell, container, position) {
    var rowId = dragOverCell.dataset.rowId;
    if (!rowId) {
      return;
    }
    var cells = all("[data-row-id=".concat(rowId, "]"), container);
    forEach$3(cells, function (cell) {
      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes$1(cell).add('dragover');
        classes$1(cell).add(position);
      }
    });
  }
  function highlightCol(dragOverCell, container, position) {
    var colId = dragOverCell.dataset.colId;
    if (!colId) {
      return;
    }
    var cells = all("[data-col-id=".concat(colId, "]"), container);
    forEach$3(cells, function (cell) {
      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes$1(cell).add('dragover');
        classes$1(cell).add(position);
      }
    });
  }
  function removeHighlight(container) {
    var cells = all('.dragover', container);
    forEach$3(cells, function (cell) {
      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes$1(cell).remove('dragover');
        classes$1(cell).remove('top');
        classes$1(cell).remove('right');
        classes$1(cell).remove('bottom');
        classes$1(cell).remove('left');
      }
    });
  }
  function fadeOutRow(row, container) {
    var cells = all("[data-row-id=".concat(row.id, "]"), container);
    forEach$3(cells, function (cell) {
      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes$1(cell).add('dragged');
      }
    });
  }
  function fadeOutCol(col, container) {
    var cells = all("[data-col-id=".concat(col.id, "]"), container);
    forEach$3(cells, function (cell) {
      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes$1(cell).add('dragged');
      }
    });
  }
  function removeFadeOut(container) {
    var cells = all('.dragged', container);
    forEach$3(cells, function (cell) {
      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes$1(cell).remove('dragged');
      }
    });
  }
  function getHorizontalPosition(event, dragOverElement) {
    var bounds = dragOverElement.getBoundingClientRect();
    return event.clientX < bounds.left + bounds.width / 2 ? LEFT : RIGHT;
  }
  function getVerticalPosition(event, dragOverElement) {
    var bounds = dragOverElement.getBoundingClientRect();
    return event.clientY < bounds.top + bounds.height / 2 ? TOP : BOTTOM;
  }
  function getTargetRow(draggedRow, targetRow, verticalPosition, rows) {
    if (rows.indexOf(draggedRow) > rows.indexOf(targetRow)) {
      targetRow = getRowBelow(targetRow, rows);
    }
    if (verticalPosition === TOP) {
      // return row above or row
      return getRowAbove(targetRow, rows);
    } else {
      // return row
      return targetRow;
    }
  }
  function getTargetCol(draggedCol, targetCol, horizontalPosition, cols) {
    if (cols.indexOf(draggedCol) > cols.indexOf(targetCol)) {
      targetCol = getColRight(targetCol, cols);
    }
    if (horizontalPosition === LEFT) {
      // return col left or col
      return getColLeft(targetCol, cols);
    } else {
      // return col
      return targetCol;
    }
  }
  function getRowAbove(row, rows) {
    var index = rows.indexOf(row);
    return rows[Math.max(0, index - 1)];
  }
  function getRowBelow(row, rows) {
    var index = rows.indexOf(row);
    return rows[Math.min(rows.length - 1, index + 1)];
  }
  function getColLeft(col, cols) {
    var index = cols.indexOf(col);
    if (isOutput(col)) {
      var firstOutput = cols.filter(function (col) {
        return isOutput(col);
      })[0];
      var firstOutputIndex = cols.indexOf(firstOutput);
      return cols[Math.max(firstOutputIndex, index - 1)];
    }
    return cols[Math.max(0, index - 1)];
  }
  function getColRight(col, cols) {
    var index = cols.indexOf(col);
    if (isInput$1(col)) {
      var inputs = cols.filter(function (col) {
        return isInput$1(col);
      });
      var lastInput = inputs[inputs.length - 1];
      var lastInputIndex = cols.indexOf(lastInput);
      return cols[Math.min(lastInputIndex, index + 1)];
    }
    return cols[Math.min(cols.length - 1, index + 1)];
  }

  // QUIRK: PhantomJS requires check if actual DOM node
  function isNode(node) {
    return node && (node.nodeType === 1 || node.nodeType == 11);
  }

  var dragAndDropModule = {
    __depends__: [DragAndDrop$1, Rules],
    __init__: ['dmnDragAndDrop'],
    dmnDragAndDrop: ['type', DragAndDrop]
  };

  function _defineProperty$c(obj, key, value) {
    key = _toPropertyKey$c(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$c(arg) {
    var key = _toPrimitive$c(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$c(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var DescriptionEditor = /*#__PURE__*/function (_Component) {
    _inherits$1(DescriptionEditor, _Component);
    var _super = _createSuper(DescriptionEditor);
    function DescriptionEditor(props, context) {
      var _this;
      _classCallCheck(this, DescriptionEditor);
      _this = _super.call(this, props, context);
      _defineProperty$c(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$c(_assertThisInitialized(_this), "changeDescription", function (value) {
        _this._modeling.updateProperties(_this._element, {
          description: value
        });
      });
      _this._elementRegistry = context.injector.get('elementRegistry');
      _this._modeling = context.injector.get('modeling');
      _this._changeSupport = _this.context.changeSupport;
      var id = _this.props.context.id;
      _this._element = _this._elementRegistry.get(id);
      return _this;
    }
    _createClass(DescriptionEditor, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        if (this._element) {
          this._changeSupport.onElementsChanged(this._element.id, this.onElementsChanged);
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var autoFocus = this.props.context.autoFocus;
        if (autoFocus && this.node) {
          var editor = getEditor(this.node);
          editor.focus();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._element) {
          this._changeSupport.offElementsChanged(this._element.id, this.onElementsChanged);
          var businessObject = this._element.businessObject;
          var description = businessObject.description;

          // if empty description remove description
          if (isString$4(description) && !description.length) {
            this.changeDescription(null);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        if (!this._element) {
          return;
        }
        var businessObject = this._element.businessObject;
        var description = businessObject.description;
        if (!isString$4(description)) {
          return;
        }
        return createVNode(1, "div", "context-menu-container description-editor", createComponentVNode(2, Editor$3, {
          "className": "dms-input",
          "onChange": this.changeDescription,
          "value": description
        }), 2, null, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);
    return DescriptionEditor;
  }(Component);
  var Editor$3 = /*#__PURE__*/function (_EditableComponent) {
    _inherits$1(Editor, _EditableComponent);
    var _super2 = _createSuper(Editor);
    function Editor() {
      _classCallCheck(this, Editor);
      return _super2.apply(this, arguments);
    }
    _createClass(Editor, [{
      key: "render",
      value: function render() {
        return createVNode(1, "div", this.getClassName(), this.getEditor(), 0);
      }
    }]);
    return Editor;
  }(EditableComponent); // helpers //////////
  function getEditor(container) {
    return query('.content-editable', container);
  }

  function _defineProperty$b(obj, key, value) {
    key = _toPropertyKey$b(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$b(arg) {
    var key = _toPrimitive$b(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$b(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var LOW_PRIORITY$3 = 500;
  var LOWER_PRIORITY = 750;
  var OFFSET_X = 26;
  var Description = /*#__PURE__*/_createClass(function Description(components, contextMenu, elementRegistry, eventBus, modeling, renderer, translate) {
    var _this2 = this;
    _classCallCheck(this, Description);
    var _this = this;
    _defineProperty$b(this, "addDescription", function (cell) {
      _this2._modeling.updateProperties(cell, {
        description: ''
      });
      var container = _this2._renderer.getContainer();
      var node = getNodeById(cell.id, container);
      var bounds = node.getBoundingClientRect();
      var position = getPosition(container, bounds);
      _this2._contextMenu.open(position, {
        contextMenuType: 'cell-description',
        id: cell.id,
        autoFocus: true,
        offset: {
          x: 4,
          y: 4
        }
      });
    });
    _defineProperty$b(this, "removeDescription", function (cell) {
      _this2._modeling.updateProperties(cell, {
        description: null
      });
      _this2._contextMenu.close();
    });
    this._contextMenu = contextMenu;
    this._modeling = modeling;
    this._renderer = renderer;
    this._translate = translate;
    eventBus.on('cell.click', LOWER_PRIORITY, function (event) {
      if (event.defaultPrevented) {
        return;
      }
      var target = event.target,
        id = event.id;
      var element = elementRegistry.get(id);
      if (!isAny(element, ['dmn:UnaryTests', 'dmn:LiteralExpression'])) {
        return;
      }
      var description = getDescription(element);
      if (!description) {
        // prevent focus
        event.preventDefault();
      }
      var container = renderer.getContainer(),
        bounds = target.getBoundingClientRect();
      var position = getPosition(container, bounds);
      contextMenu.open(position, {
        contextMenuType: 'cell-description',
        autoFocus: false,
        id: id,
        offset: {
          x: 4,
          y: 4
        }
      });
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'cell-description') {
        var element = elementRegistry.get(context.id);
        var description = getDescription(element);
        if (isString$4(description)) {
          return DescriptionEditor;
        }
      }
    });
    components.onGetComponent('context-menu-cell-additional', LOW_PRIORITY$3, function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'context-menu') {
        var id = context.id;
        if (!id) {
          return;
        }
        var element = elementRegistry.get(id);

        // element might not be in element registry (e.g. cut)
        if (!element) {
          return;
        }
        var businessObject = element.businessObject;
        var description = businessObject.description;
        var existingDescription = isString$4(description);
        var className = existingDescription ? 'remove-description' : 'add-description';
        var onClick = existingDescription ? function () {
          return _this.removeDescription(element);
        } : function () {
          return _this.addDescription(element);
        };
        return createVNode(1, "div", "context-menu-group-entry ".concat(className), isString$4(description) ? _this._translate('Remove cell description') : _this._translate('Add cell description'), 0, {
          "onClick": onClick
        });
      }
    });
  });
  Description.$inject = ['components', 'contextMenu', 'elementRegistry', 'eventBus', 'modeling', 'renderer', 'translate'];

  // helpers //////////

  function getPosition(container, bounds) {
    var top = bounds.top,
      left = bounds.left,
      width = bounds.width,
      height = bounds.height;
    return {
      x: left + container.parentNode.scrollLeft - OFFSET_X,
      y: top + container.parentNode.scrollTop,
      width: width + 2 * OFFSET_X,
      height: height
    };
  }
  function getDescription(element) {
    return element && element.businessObject && element.businessObject.description;
  }

  var descriptionModule = {
    __depends__: [contextMenuModule, interactionEventsModule],
    __init__: ['description'],
    description: ['type', Description]
  };

  var ExpressionLanguage$1 = /*#__PURE__*/function () {
    function ExpressionLanguage(components, elementRegistry, modeling, expressionLanguages, translate, contextMenu) {
      _classCallCheck(this, ExpressionLanguage);
      var _this = this;
      this._modeling = modeling;
      this._translate = translate;
      this._expressionLanguages = expressionLanguages;
      components.onGetComponent('context-menu-cell-additional', function () {
        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (context.contextMenuType && context.contextMenuType === 'context-menu') {
          var event = context.event,
            id = context.id;
          if (!id) {
            return;
          }
          var element = elementRegistry.get(id);

          // element might not be in element registry (e.g. cut)
          if (!element) {
            return;
          }
          if (!_this._shouldDisplayContextMenuEntry(element)) {
            return;
          }
          var openMenu = function openMenu(clickEvent) {
            contextMenu.open({
              x: (event || clickEvent).pageX,
              y: (event || clickEvent).pageY
            }, {
              contextMenuType: 'expression-language',
              id: id
            });
          };
          return createVNode(1, "div", "context-menu-group-entry", _this._translate('Change cell expression language'), 0, {
            "onClick": openMenu
          });
        }
      });
      components.onGetComponent('context-menu', function () {
        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (context.contextMenuType && context.contextMenuType === 'expression-language') {
          var id = context.id;
          if (!id) {
            return;
          }
          var element = elementRegistry.get(id);

          // element might not be in element registry (e.g. cut)
          if (!element) {
            return;
          }
          var expressionLanguage = _this._getElementExpressionLanguage(element);
          var options = expressionLanguages.getAll();
          var className = 'context-menu-group-entry ' + 'context-menu-entry-set-expression-language';
          return function () {
            return createVNode(1, "div", "context-menu-flex", createVNode(1, "div", "context-menu-group", createVNode(1, "div", className, [createVNode(1, "div", null, _this._translate('Expression language'), 0), createComponentVNode(2, InputSelect, {
              "className": "expression-language",
              "onChange": function onChange(value) {
                return _this.onChange(element, value);
              },
              "options": options,
              "value": expressionLanguage
            })], 4), 2), 2);
          };
        }
      });
      components.onGetComponent('context-menu', function () {
        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (context.contextMenuType === 'input-edit') {
          return function () {
            var inputExpression = context.input.inputExpression;
            if (!_this._shouldDisplayContextMenuEntry(inputExpression)) {
              return;
            }
            var expressionLanguage = _this._getElementExpressionLanguage(inputExpression);
            var options = expressionLanguages.getAll();
            return createVNode(1, "div", "context-menu-container ref-language", createVNode(1, "div", "dms-form-control", [createVNode(1, "label", "dms-label", _this._translate('Expression language'), 0), createComponentVNode(2, InputSelect, {
              "className": "ref-language",
              "value": expressionLanguage || '',
              "onChange": function onChange(value) {
                return _this.onChange(inputExpression, value);
              },
              "options": options
            })], 4), 2);
          };
        }
      });
    }
    _createClass(ExpressionLanguage, [{
      key: "onChange",
      value: function onChange(element, expressionLanguage) {
        this._modeling.editExpressionLanguage(element, expressionLanguage);
      }
    }, {
      key: "_shouldDisplayContextMenuEntry",
      value: function _shouldDisplayContextMenuEntry(element) {
        var expressionLanguages = this._expressionLanguages.getAll();
        if (expressionLanguages.length > 1) {
          return true;
        }
        var expressionLanguage = this._getElementExpressionLanguage(element);
        return expressionLanguage !== this._getDefaultElementExpressionLanguage(element);
      }
    }, {
      key: "_getElementExpressionLanguage",
      value: function _getElementExpressionLanguage(element) {
        return getBusinessObject(element).expressionLanguage || this._getDefaultElementExpressionLanguage(element);
      }
    }, {
      key: "_getDefaultElementExpressionLanguage",
      value: function _getDefaultElementExpressionLanguage(element) {
        return this._expressionLanguages.getDefault(isInput$1(element.col) ? 'inputCell' : 'outputCell').value;
      }
    }]);
    return ExpressionLanguage;
  }();
  ExpressionLanguage$1.$inject = ['components', 'elementRegistry', 'modeling', 'expressionLanguages', 'translate', 'contextMenu'];

  var expressionLanguageModule = {
    __depends__: [ExpressionLanguagesModule],
    __init__: ['expressionLanguage'],
    expressionLanguage: ['type', ExpressionLanguage$1]
  };

  function _defineProperty$a(obj, key, value) {
    key = _toPropertyKey$a(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$a(arg) {
    var key = _toPrimitive$a(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$a(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var DecisionTablePropertiesComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionTablePropertiesComponent, _Component);
    var _super = _createSuper(DecisionTablePropertiesComponent);
    function DecisionTablePropertiesComponent(props, context) {
      var _this;
      _classCallCheck(this, DecisionTablePropertiesComponent);
      _this = _super.call(this, props, context);
      _defineProperty$a(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$a(_assertThisInitialized(_this), "setDecisionTableName", function (name) {
        _this.modeling.editDecisionTableName(name);
      });
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(DecisionTablePropertiesComponent, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.setupChangeListeners({
          bind: this.getBusinessObject().id
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.setupChangeListeners({
          unbind: this.getBusinessObject().id
        });
      }
    }, {
      key: "setupChangeListeners",
      value: function setupChangeListeners(_ref) {
        var bind = _ref.bind,
          unbind = _ref.unbind;
        if (typeof unbind === 'string') {
          this.changeSupport.offElementsChanged(unbind, this.onElementsChanged);
        }
        if (typeof bind === 'string') {
          this.changeSupport.onElementsChanged(bind, this.onElementsChanged);
        }
      }
    }, {
      key: "getBusinessObject",
      value: function getBusinessObject() {
        return this.sheet.getRoot().businessObject.$parent;
      }
    }, {
      key: "render",
      value: function render() {
        var bo = this.getBusinessObject();
        var name = bo.name;
        var HitPolicy = this.components.getComponent('hit-policy') || NullComponent;
        return createVNode(1, "div", "decision-table-properties", [createComponentVNode(2, DecisionTableName, {
          "className": "decision-table-name",
          "value": name,
          "ctrlForNewline": true,
          "onBlur": resetScroll$1,
          "onChange": this.setDecisionTableName,
          "elementId": '__decisionProperties_name',
          "coords": '0:__decisionProperties'
        }), createVNode(1, "div", "decision-table-header-separator"), createComponentVNode(2, HitPolicy)], 4);
      }
    }]);
    return DecisionTablePropertiesComponent;
  }(Component);
  DecisionTablePropertiesComponent.$inject = ['sheet', 'modeling', 'changeSupport', 'components'];
  var DecisionTableName = /*#__PURE__*/function (_EditableComponent) {
    _inherits$1(DecisionTableName, _EditableComponent);
    var _super2 = _createSuper(DecisionTableName);
    function DecisionTableName(props, context) {
      var _this2;
      _classCallCheck(this, DecisionTableName);
      _this2 = _super2.call(this, props, context);
      _this2._translate = context.injector.get('translate');
      mixin(_assertThisInitialized(_this2), SelectionAware$1);
      return _this2;
    }
    _createClass(DecisionTableName, [{
      key: "render",
      value: function render() {
        var name = this.props.value;
        var className = classNames(this.getSelectionClasses(), this.getClassName());
        return createVNode(1, "div", className, this.getEditor(), 0, {
          "data-element-id": this.props.elementId,
          "data-coords": this.props.coords,
          "title": this._translate('Decision name: ') + name
        });
      }
    }]);
    return DecisionTableName;
  }(EditableComponent);
  function NullComponent() {
    return null;
  }
  function resetScroll$1(event) {
    event.target.scroll(0, 0);
  }

  var LOW_PRIORITY$2 = 500;
  var DecisionTableProperties = /*#__PURE__*/_createClass(function DecisionTableProperties(components) {
    _classCallCheck(this, DecisionTableProperties);
    components.onGetComponent('table.before', LOW_PRIORITY$2, function () {
      return DecisionTablePropertiesComponent;
    });
  });
  DecisionTableProperties.$inject = ['components'];

  var tablePropertiesEditorModule = {
    __depends__: [DebounceInput],
    __init__: ['decisionTableProperties'],
    decisionTableProperties: ['type', DecisionTableProperties]
  };

  function ownKeys$4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {
        _defineProperty$9(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$9(obj, key, value) {
    key = _toPropertyKey$9(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$9(arg) {
    var key = _toPrimitive$9(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$9(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var EditableHitPolicy = /*#__PURE__*/function (_Component) {
    _inherits$1(EditableHitPolicy, _Component);
    var _super = _createSuper(EditableHitPolicy);
    function EditableHitPolicy(props, context) {
      var _this;
      _classCallCheck(this, EditableHitPolicy);
      _this = _super.call(this, props, context);
      _defineProperty$9(_assertThisInitialized(_this), "onChange", function (_ref) {
        var aggregation = _ref.aggregation,
          hitPolicy = _ref.hitPolicy;
        _this.modeling.editHitPolicy(hitPolicy, aggregation);
      });
      _defineProperty$9(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _this._translate = context.injector.get('translate');
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(EditableHitPolicy, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.changeSupport.onElementsChanged(this.getRoot().id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.changeSupport.offElementsChanged(this.getRoot().id, this.onElementsChanged);
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this.sheet.getRoot();
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var root = this.getRoot(),
          businessObject = root.businessObject;
        var aggregation = businessObject.aggregation,
          hitPolicy = businessObject.hitPolicy;
        var hitPolicyEntry = find$2(HIT_POLICIES, function (entry) {
          return isEqualHitPolicy(entry.value, {
            aggregation: aggregation,
            hitPolicy: hitPolicy
          });
        });
        return createVNode(1, "div", "hit-policy", [createVNode(1, "label", "dms-label", this._translate('Hit policy:'), 0), createComponentVNode(2, InputSelect, {
          "className": "hit-policy-edit-policy-select",
          "onChange": this.onChange,
          "options": HIT_POLICIES.map(function (entry) {
            return _objectSpread$4(_objectSpread$4({}, entry), {}, {
              label: _this2._translate(entry.label)
            });
          }),
          "value": hitPolicyEntry.value,
          "data-hit-policy": "true",
          "noInput": true
        })], 4, {
          "title": this._translate(hitPolicyEntry.explanation)
        });
      }
    }]);
    return EditableHitPolicy;
  }(Component);
  EditableHitPolicy.$inject = ['changeSupport', 'sheet', 'modeling'];

  // helpers //////////////////////
  function isEqualHitPolicy(a, b) {
    return a.hitPolicy === b.hitPolicy && a.aggregation === b.aggregation;
  }

  function HitPolicyEditingProvider(components) {
    components.onGetComponent('hit-policy', function () {
      return EditableHitPolicy;
    });
  }
  HitPolicyEditingProvider.$inject = ['components'];

  var hitPolicyEditorModule = {
    __depends__: [contextMenuModule],
    __init__: ['hitPolicyProvider'],
    hitPolicyProvider: ['type', HitPolicyEditingProvider]
  };

  /**
   * A handler responsible for updating the underlying DMN
   * once changes on the table happen.
   */
  var DmnUpdater = /*#__PURE__*/function (_CommandInterceptor) {
    _inherits$1(DmnUpdater, _CommandInterceptor);
    var _super = _createSuper(DmnUpdater);
    function DmnUpdater(eventBus, sheet) {
      var _this;
      _classCallCheck(this, DmnUpdater);
      _this = _super.call(this, eventBus);
      _this.executed(['row.add', 'row.remove', 'col.add', 'col.remove'], ifDmn(function (e) {
        var context = e.context;
        var element = context.row || context.col;
        _this.updateRoot(element, context.oldRoot);
      }));
      _this.reverted(['row.add', 'row.remove', 'col.add', 'col.remove'], ifDmn(function (e) {
        var context = e.context;
        var element = context.row || context.col;
        _this.updateRoot(element, context.newRoot);
      }));
      return _this;
    }
    _createClass(DmnUpdater, [{
      key: "updateRoot",
      value: function updateRoot(element, oldRoot) {
        var _this2 = this;
        var newRoot = element.root;
        var businessObject = element.businessObject;
        if (is$1(element, 'dmn:DecisionRule')) {
          // we're removing
          if (oldRoot) {
            var oldTable = oldRoot.businessObject;
            var oldRules = oldTable.get('rule');
            var oldIdx = oldRules.indexOf(businessObject);

            // unwire Row <-> Table
            oldRules.splice(oldIdx, 1);
            businessObject.$parent = null;
          }

          // we're adding
          if (newRoot) {
            var newTable = newRoot.businessObject;
            var newIdx = newRoot.rows.indexOf(element);

            // wire Row <-> Table
            newTable.get('rule').splice(newIdx, 0, businessObject);
            businessObject.$parent = newTable;
            element.cells.forEach(function (cell, idx) {
              // wire Cell <-> Row
              _this2.wireCell(cell, element, idx);
            });
          }
        }
        if (is$1(element, 'dmn:InputClause') || is$1(element, 'dmn:OutputClause')) {
          var collection, collectionIdx;

          // we're removing
          if (oldRoot) {
            var _oldTable = oldRoot.businessObject;
            var inputs = _oldTable.get('input');
            var outputs = _oldTable.get('output');
            if (is$1(element, 'dmn:InputClause')) {
              collection = inputs;
              collectionIdx = inputs.indexOf(businessObject);
            }
            if (is$1(element, 'dmn:OutputClause')) {
              collection = outputs;
              collectionIdx = outputs.indexOf(businessObject);
            }
            if (collectionIdx === -1) {
              throw new Error('inconsistent model: clause not in table');
            }

            // unwire Col <-> Table
            collection.splice(collectionIdx, 1);
            businessObject.$parent = null;
            element.cells.forEach(function (cel, rowIdx) {
              // unwire Cell <-> Row
              _this2.unwireCell(cel, oldRoot.rows[rowIdx]);
            });
          }
          if (newRoot) {
            var _newTable = newRoot.businessObject;
            var _inputs = _newTable.get('input');
            var _outputs = _newTable.get('output');
            var colIdx = newRoot.cols.indexOf(element);
            var _collectionIdx, _collection;
            if (is$1(element, 'dmn:InputClause')) {
              _collection = _inputs;
              _collectionIdx = colIdx;
            }
            if (is$1(element, 'dmn:OutputClause')) {
              _collection = _outputs;
              _collectionIdx = colIdx - _inputs.length;
            }

            // wire Col <-> Table
            _collection.splice(_collectionIdx, 0, businessObject);
            businessObject.$parent = _newTable;
            element.cells.forEach(function (cell, rowIdx) {
              // wire Cell <-> Row
              _this2.wireCell(cell, newRoot.rows[rowIdx], colIdx);
            });
          }
        }
      }
    }, {
      key: "unwireCell",
      value: function unwireCell(cell, oldRow) {
        var cellBo = cell.businessObject;
        var oldRowBo = oldRow.businessObject;
        var inputEntries = oldRowBo.get('inputEntry');
        var outputEntries = oldRowBo.get('outputEntry');
        var collection, collectionIdx;

        // remove from inputEntries
        if (is$1(cell, 'dmn:UnaryTests')) {
          collection = inputEntries;
        }

        // remove from outputEntries
        if (is$1(cell, 'dmn:LiteralExpression')) {
          collection = outputEntries;
        }
        collectionIdx = collection.indexOf(cellBo);
        if (collectionIdx === -1) {
          throw new Error('cell not in row');
        }

        // unwire Cell <-> Row relationship
        collection.splice(collectionIdx, 1);
        cellBo.$parent = null;
      }
    }, {
      key: "wireCell",
      value: function wireCell(cell, row, colIdx) {
        var cellBo = cell.businessObject;
        var rowBo = row.businessObject;
        var inputEntries = rowBo.get('inputEntry');
        var outputEntries = rowBo.get('outputEntry');
        var collection, collectionIdx;

        // ensure we handle already wired cells
        if (cellBo.$parent === rowBo) {
          return;
        }

        // add to inputEntries
        if (is$1(cell, 'dmn:UnaryTests')) {
          collection = inputEntries;
          collectionIdx = colIdx;
        }

        // add to outputEntries
        if (is$1(cell, 'dmn:LiteralExpression')) {
          collection = outputEntries;
          collectionIdx = colIdx - inputEntries.length;
        }

        // wire Cell <-> Row relationship
        collection.splice(collectionIdx, 0, cellBo);
        cellBo.$parent = rowBo;
      }
    }]);
    return DmnUpdater;
  }(CommandInterceptor);
  DmnUpdater.$inject = ['eventBus', 'sheet'];

  // helpers //////////////////////

  /**
   * Make sure the event listener is only called
   * if the touched element is a DMN element.
   *
   * @param  {Function} fn
   * @return {Function} guarded function
   */
  function ifDmn(fn) {
    return function (event) {
      var context = event.context,
        element = context.row || context.col;
      if (is$1(element, 'dmn:DMNElement')) {
        fn(event);
      }
    };
  }

  var DmnFactory = /*#__PURE__*/function () {
    function DmnFactory(moddle) {
      _classCallCheck(this, DmnFactory);
      this._model = moddle;
    }
    _createClass(DmnFactory, [{
      key: "create",
      value: function create(type) {
        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var element = this._model.create(type, attrs || {});
        if (is$1(element, 'dmn:InputClause')) {
          if (attrs.inputExpression) {
            element.inputExpression = attrs.inputExpression;
          } else {
            element.inputExpression = this.create('dmn:LiteralExpression', {
              typeRef: 'string'
            });
            element.inputExpression.$parent = element;
          }
        }
        if (is$1(element, 'dmn:OutputClause')) {
          element.typeRef = attrs.typeRef || 'string';
        }
        if (is$1(element, 'dmn:UnaryTests') || is$1(element, 'dmn:LiteralExpression')) {
          element.text = attrs.text || '';
        }
        this._ensureId(element);
        return element;
      }
    }, {
      key: "_needsId",
      value: function _needsId(element) {
        return is$1(element, 'dmn:DMNElement');
      }
    }, {
      key: "_ensureId",
      value: function _ensureId(element) {
        // generate semantic ids for elements
        // dmn:UnaryTests -> UnaryTests_ID
        var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';
        if (!element.id && this._needsId(element)) {
          element.id = this._model.ids.nextPrefixed(prefix, element);
        }
      }
    }]);
    return DmnFactory;
  }();
  DmnFactory.$inject = ['moddle'];

  var _excluded$2 = ["businessObject", "type"];
  function ownKeys$3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
        _defineProperty$8(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$8(obj, key, value) {
    key = _toPropertyKey$8(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$8(arg) {
    var key = _toPrimitive$8(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$8(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _objectWithoutProperties$2(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$2(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  var ElementFactory = /*#__PURE__*/function (_BaseElementFactory) {
    _inherits$1(ElementFactory, _BaseElementFactory);
    var _super = _createSuper(ElementFactory);
    function ElementFactory(dmnFactory) {
      var _this;
      _classCallCheck(this, ElementFactory);
      _this = _super.call(this);
      _this._dmnFactory = dmnFactory;
      return _this;
    }
    _createClass(ElementFactory, [{
      key: "create",
      value: function create(tType, attrs) {
        var dmnFactory = this._dmnFactory;
        var businessObject = attrs.businessObject,
          type = attrs.type,
          additionalAttrs = _objectWithoutProperties$2(attrs, _excluded$2);
        if (!businessObject) {
          if (!type) {
            if (tType === 'root') {
              type = 'dmn:DecisionTable';
            } else if (tType === 'cell') {
              var col = additionalAttrs.col;
              if (is$1(col, 'dmn:OutputClause')) {
                type = 'dmn:LiteralExpression';
              }
              if (is$1(col, 'dmn:InputClause')) {
                type = 'dmn:UnaryTests';
              }
            }
            if (!type) {
              throw new Error('cannot guess <type>');
            }
          }
          businessObject = dmnFactory.create(type);
        }
        return _get(_getPrototypeOf(ElementFactory.prototype), "create", this).call(this, tType, _objectSpread$3({
          businessObject: businessObject,
          id: businessObject.id
        }, additionalAttrs));
      }
    }]);
    return ElementFactory;
  }(ElementFactory$1);
  ElementFactory.$inject = ['dmnFactory'];

  /**
   * A handler that implements row addition.
   */
  var AddRowHandler = /*#__PURE__*/function () {
    function AddRowHandler(sheet, elementFactory) {
      _classCallCheck(this, AddRowHandler);
      this._sheet = sheet;
      this._elementFactory = elementFactory;
    }
    /**
     * <do>
     */
    _createClass(AddRowHandler, [{
      key: "execute",
      value: function execute(context) {
        var sheet = this._sheet,
          elementFactory = this._elementFactory,
          root = sheet.getRoot();
        var row = context.row,
          index = context.index;
        if (typeof index === 'undefined') {
          index = context.index = root.rows.length;
        }
        context.newRoot = root;
        if (!row.cells.length) {
          root.cols.forEach(function (col, idx) {
            var cell = elementFactory.create('cell', {
              row: row,
              col: col
            });
            row.cells[idx] = cell;
          });
        }
        sheet.addRow(row, index);
        return sheet.getRoot();
      }
      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var row = context.row;
        var sheet = this._sheet;
        sheet.removeRow(row);
        return sheet.getRoot();
      }
    }]);
    return AddRowHandler;
  }();
  AddRowHandler.$inject = ['sheet', 'elementFactory'];

  /**
   * A handler that implements row deletion.
   */
  var RemoveRowHandler = /*#__PURE__*/function () {
    function RemoveRowHandler(sheet) {
      _classCallCheck(this, RemoveRowHandler);
      this._sheet = sheet;
    }
    /**
     * <do>
     */
    _createClass(RemoveRowHandler, [{
      key: "execute",
      value: function execute(context) {
        var sheet = this._sheet,
          root = sheet.getRoot();
        var row = context.row; // retrieve and remember previous row position

        var oldIndex = context.oldIndex = root.rows.indexOf(row);
        context.oldRoot = row.root;
        if (oldIndex === -1) {
          throw new Error("row#".concat(row.id, " not in sheet"));
        }
        sheet.removeRow(row);
        return sheet.getRoot();
      }
      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var row = context.row,
          oldIndex = context.oldIndex;
        var sheet = this._sheet;
        sheet.addRow(row, oldIndex);
        return sheet.getRoot();
      }
    }]);
    return RemoveRowHandler;
  }();
  RemoveRowHandler.$inject = ['sheet'];

  /**
   * A handler that implements row movement.
   */
  var MoveRowHandler = /*#__PURE__*/function () {
    function MoveRowHandler(modeling) {
      _classCallCheck(this, MoveRowHandler);
      this._modeling = modeling;
    }
    /**
     * <preexecute>
     */
    _createClass(MoveRowHandler, [{
      key: "preExecute",
      value: function preExecute(context) {
        var row = context.row;
        this._modeling.removeRow(row);
      }
      /**
       * <postexecute>
       */
    }, {
      key: "postExecute",
      value: function postExecute(context) {
        var row = context.row,
          index = context.index;
        this._modeling.addRow(row, index);
      }
    }]);
    return MoveRowHandler;
  }();
  MoveRowHandler.$inject = ['modeling'];

  /**
   * A handler that implements column addition.
   */
  var AddColHandler = /*#__PURE__*/function () {
    function AddColHandler(sheet, elementFactory) {
      _classCallCheck(this, AddColHandler);
      this._sheet = sheet;
      this._elementFactory = elementFactory;
    }
    /**
     * <do>
     */
    _createClass(AddColHandler, [{
      key: "execute",
      value: function execute(context) {
        var sheet = this._sheet,
          elementFactory = this._elementFactory,
          root = sheet.getRoot();
        var col = context.col,
          index = context.index;
        if (typeof index === 'undefined') {
          index = context.index = root.cols.length;
        }
        context.newRoot = root;
        if (!col.cells.length) {
          root.rows.forEach(function (row, idx) {
            var cell = elementFactory.create('cell', {
              row: row,
              col: col
            });
            col.cells[idx] = cell;
          });
        }
        sheet.addCol(col, index);
        return sheet.getRoot();
      }
      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var col = context.col;
        var sheet = this._sheet;
        sheet.removeCol(col);
        return sheet.getRoot();
      }
    }]);
    return AddColHandler;
  }();
  AddColHandler.$inject = ['sheet', 'elementFactory'];

  /**
   * A handler that implements column deletion.
   */
  var RemoveColHandler = /*#__PURE__*/function () {
    function RemoveColHandler(sheet, elementFactory) {
      _classCallCheck(this, RemoveColHandler);
      this._sheet = sheet;
      this._elementFactory = elementFactory;
    }
    /**
     * <do>
     */
    _createClass(RemoveColHandler, [{
      key: "execute",
      value: function execute(context) {
        var sheet = this._sheet;
        var col = context.col;
        var root = context.oldRoot = col.root; // retrieve and remember previous col position

        var oldIndex = context.oldIndex = root.cols.indexOf(col);
        if (oldIndex === -1) {
          throw new Error("col#".concat(col.id, " not in sheet"));
        }
        sheet.removeCol(col);
        return sheet.getRoot();
      }
      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var col = context.col,
          oldIndex = context.oldIndex;
        var sheet = this._sheet;
        sheet.addCol(col, oldIndex);
        return sheet.getRoot();
      }
    }]);
    return RemoveColHandler;
  }();
  RemoveColHandler.$inject = ['sheet', 'elementFactory'];

  /**
   * A handler that implements col movement.
   */
  var MoveColHandler = /*#__PURE__*/function () {
    function MoveColHandler(modeling) {
      _classCallCheck(this, MoveColHandler);
      this._modeling = modeling;
    }
    /**
     * <preexecute>
     */
    _createClass(MoveColHandler, [{
      key: "preExecute",
      value: function preExecute(context) {
        var col = context.col;
        this._modeling.removeCol(col);
      }
      /**
       * <postexecute>
       */
    }, {
      key: "postExecute",
      value: function postExecute(context) {
        var col = context.col,
          index = context.index;
        this._modeling.addCol(col, index);
      }
    }]);
    return MoveColHandler;
  }();
  MoveColHandler.$inject = ['modeling'];

  /**
   * A handler that implements cell editing.
   *
   * Per default, this handler does nothing.
   * Interested parties may hook into the edit commands
   * `preExecute` or `postExecute` phases to carry out
   * the actual editing.
   */
  var EditCellHandler = /*#__PURE__*/function () {
    function EditCellHandler() {
      _classCallCheck(this, EditCellHandler);
    }
    _createClass(EditCellHandler, [{
      key: "execute",
      value:
      /**
       * <do>
       */
      function execute(context) {
        var cell = context.cell;
        return cell;
      }
      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var cell = context.cell;
        return cell;
      }
    }]);
    return EditCellHandler;
  }();

  /**
   * The basic modeling entry point.
   *
   * @param {EventBus} eventBus
   * @param {ElementFactory} elementFactory
   * @param {CommandStack} commandStack
   */
  var Modeling$2 = /*#__PURE__*/function () {
    function Modeling(eventBus, elementFactory, commandStack) {
      var _this = this;
      _classCallCheck(this, Modeling);
      this._eventBus = eventBus;
      this._elementFactory = elementFactory;
      this._commandStack = commandStack;
      eventBus.on('table.init', function () {
        // register modeling handlers
        registerHandlers$1(_this.getHandlers(), commandStack);
      });
    }
    _createClass(Modeling, [{
      key: "getHandlers",
      value: function getHandlers() {
        return Modeling._getHandlers();
      }
    }, {
      key: "_create",
      value: function _create(type, attrs) {
        if (attrs instanceof Base) {
          return attrs;
        } else {
          return this._elementFactory.create(type, attrs);
        }
      } // public API
    }, {
      key: "addRow",
      value: function addRow(attrs, index) {
        var row = this._create('row', attrs);
        var context = {
          row: row,
          index: index
        };
        this._commandStack.execute('row.add', context);
        return row;
      }
    }, {
      key: "removeRow",
      value: function removeRow(row) {
        this._commandStack.execute('row.remove', {
          row: row
        });
      }
    }, {
      key: "moveRow",
      value: function moveRow(row, index) {
        var context = {
          row: row,
          index: index
        };
        this._commandStack.execute('row.move', context);
      }
    }, {
      key: "addCol",
      value: function addCol(attrs, index) {
        var col = this._create('col', attrs);
        var context = {
          col: col,
          index: index
        };
        this._commandStack.execute('col.add', context);
        return col;
      }
    }, {
      key: "removeCol",
      value: function removeCol(col) {
        this._commandStack.execute('col.remove', {
          col: col
        });
      }
    }, {
      key: "moveCol",
      value: function moveCol(col, index) {
        var context = {
          col: col,
          index: index
        };
        this._commandStack.execute('col.move', context);
      }
    }, {
      key: "editCell",
      value: function editCell(cell, changedAttrs) {
        var context = _objectSpread2({
          cell: cell
        }, changedAttrs);
        this._commandStack.execute('cell.edit', context);
      }
    }], [{
      key: "_getHandlers",
      value: function _getHandlers() {
        return {
          'row.add': AddRowHandler,
          'row.remove': RemoveRowHandler,
          'row.move': MoveRowHandler,
          'col.add': AddColHandler,
          'col.remove': RemoveColHandler,
          'col.move': MoveColHandler,
          'cell.edit': EditCellHandler
        };
      }
    }]);
    return Modeling;
  }();
  Modeling$2.$inject = ['eventBus', 'elementFactory', 'commandStack']; // helpers /////////////

  /**
   * Register handlers with the command stack
   *
   * @param {Object} handlers { id -> Handler } map
   * @param {CommandStack} commandStack
   */

  function registerHandlers$1(handlers, commandStack) {
    forEach$3(handlers, function (handler, id) {
      commandStack.registerHandler(id, handler);
    });
  }

  /**
   * A handler that implements adding/removing allowed values.
   */
  var UpdateAllowedValuesHandler = /*#__PURE__*/function () {
    function UpdateAllowedValuesHandler(dmnFactory, moddle, modeling) {
      _classCallCheck(this, UpdateAllowedValuesHandler);
      this._dmnFactory = dmnFactory;
      this._moddle = moddle;
      this._modeling = modeling;
    }

    /**
     * <do>
     */
    _createClass(UpdateAllowedValuesHandler, [{
      key: "execute",
      value: function execute(context) {
        var element = context.element,
          allowedValues = context.allowedValues;
        var isInput = is$1(element, 'dmn:InputClause');
        if (isInput) {
          if (element.inputValues) {
            context.oldAllowedValues = element.inputValues.text;
          } else {
            if (!isNull(allowedValues)) {
              element.inputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }
          }
          if (isNull(allowedValues)) {
            if (element.inputValues) {
              delete element.inputValues;
            }
          } else {
            element.inputValues.text = allowedValues.join(',');
          }
        } else {
          if (element.outputValues && element) {
            context.oldAllowedValues = element.outputValues.text;
          } else {
            if (!isNull(allowedValues)) {
              element.outputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }
          }
          if (isNull(allowedValues)) {
            if (element.outputValues) {
              delete element.outputValues;
            }
          } else {
            element.outputValues.text = allowedValues.join(',');
          }
        }
        return element;
      }

      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var element = context.element,
          oldAllowedValues = context.oldAllowedValues;
        var isInput = is$1(element, 'dmn:InputClause');
        if (isInput) {
          if (oldAllowedValues) {
            if (!element.inputValues) {
              element.inputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }
            element.inputValues.text = oldAllowedValues;
          } else {
            delete element.inputValues;
          }
        } else {
          if (oldAllowedValues) {
            if (!element.outputValues) {
              element.outputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }
            element.outputValues.text = oldAllowedValues;
          } else {
            delete element.outputValues;
          }
        }
        return element;
      }
    }]);
    return UpdateAllowedValuesHandler;
  }();
  UpdateAllowedValuesHandler.$inject = ['dmnFactory', 'moddle', 'modeling'];

  // helpers //////////////////////

  function isNull(value) {
    return value === null;
  }

  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
        _defineProperty$7(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$7(obj, key, value) {
    key = _toPropertyKey$7(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$7(arg) {
    var key = _toPrimitive$7(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$7(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ID = 'id';

  /**
   * A generic handler that implements property editing.
   */
  var EditPropertiesHandler = /*#__PURE__*/function () {
    function EditPropertiesHandler(elementRegistry, moddle) {
      _classCallCheck(this, EditPropertiesHandler);
      this._elementRegistry = elementRegistry;
      this._moddle = moddle;
    }

    /**
     * <do>
     */
    _createClass(EditPropertiesHandler, [{
      key: "execute",
      value: function execute(context) {
        var element = context.element,
          properties = context.properties;
        var bo = getBusinessObject(element);
        var _this$updatePropertie = this.updateProperties(bo, properties),
          changed = _this$updatePropertie.changed,
          oldProperties = _this$updatePropertie.oldProperties;
        context.oldProperties = oldProperties;
        return [].concat(_toConsumableArray(changed), [element]);
      }

      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var element = context.element,
          oldProperties = context.oldProperties;
        var bo = getBusinessObject(element);
        var _this$updatePropertie2 = this.updateProperties(bo, oldProperties),
          changed = _this$updatePropertie2.changed;
        return [].concat(_toConsumableArray(changed), [element]);
      }

      /**
       * Update properties of the given business object
       * and return { changed, oldProperties }.
       */
    }, {
      key: "updateProperties",
      value: function updateProperties(bo, newProps) {
        var _this = this;
        var ids = this._moddle.ids;

        // Reduce over all new properties and return
        //
        // {
        //  changed,
        //  oldProperties
        // }
        return reduce(newProps, function (result, value, key) {
          var propertyValue = bo.get(key);

          // handle nested update
          if (isContainer(value)) {
            if (!isContainer(propertyValue)) {
              throw new Error("non-existing property <".concat(key, ">: cannot update values"));
            }
            var _this$updatePropertie3 = _this.updateProperties(propertyValue, value),
              changed = _this$updatePropertie3.changed,
              oldProperties = _this$updatePropertie3.oldProperties;
            return {
              changed: [].concat(_toConsumableArray(result.changed), _toConsumableArray(changed), [propertyValue]),
              oldProperties: _objectSpread$2(_objectSpread$2({}, result.oldProperties), {}, _defineProperty$M({}, key, oldProperties))
            };
          }

          // handle ID change
          if (key === ID && isIdChange(bo, value)) {
            ids.unclaim(bo[ID]);
            _this._elementRegistry.updateId(bo, value);
            ids.claim(value, bo);
          }

          // handle plain update
          bo.set(key, value);
          return {
            changed: result.changed,
            oldProperties: _objectSpread$2(_objectSpread$2({}, result.oldProperties), {}, _defineProperty$M({}, key, propertyValue))
          };
        }, {
          changed: [],
          oldProperties: {}
        });
      }
    }]);
    return EditPropertiesHandler;
  }();
  EditPropertiesHandler.$inject = ['elementRegistry', 'moddle'];

  // helpers //////////////////////

  function isIdChange(element, newId) {
    return element[ID] !== newId;
  }
  function isContainer(o) {
    return isDefined(o) && isObject$2(o);
  }

  var IdClaimHandler = /*#__PURE__*/function () {
    function IdClaimHandler(moddle) {
      _classCallCheck(this, IdClaimHandler);
      this._moddle = moddle;
    }

    /**
     * <do>
     */
    _createClass(IdClaimHandler, [{
      key: "execute",
      value: function execute(context) {
        var ids = this._moddle.ids,
          id = context.id,
          element = context.element,
          claiming = context.claiming;
        if (claiming) {
          ids.claim(id, element);
        } else {
          ids.unclaim(id);
        }
      }

      /**
       * <undo>
       */
    }, {
      key: "revert",
      value: function revert(context) {
        var ids = this._moddle.ids,
          id = context.id,
          element = context.element,
          claiming = context.claiming;
        if (claiming) {
          ids.unclaim(id);
        } else {
          ids.claim(id, element);
        }
      }
    }]);
    return IdClaimHandler;
  }();
  IdClaimHandler.$inject = ['moddle'];

  var Modeling$1 = /*#__PURE__*/function (_BaseModeling) {
    _inherits$1(Modeling, _BaseModeling);
    var _super = _createSuper(Modeling);
    function Modeling(eventBus, elementFactory, commandStack, sheet) {
      var _this;
      _classCallCheck(this, Modeling);
      _this = _super.call(this, eventBus, elementFactory, commandStack);
      _this._eventBus = eventBus;
      _this._elementFactory = elementFactory;
      _this._commandStack = commandStack;
      _this._sheet = sheet;
      return _this;
    }
    _createClass(Modeling, [{
      key: "getHandlers",
      value: function getHandlers() {
        return Modeling._getHandlers();
      }
    }, {
      key: "editDecisionTableName",
      value: function editDecisionTableName(name) {
        var root = this._sheet.getRoot(),
          businessObject = root.businessObject,
          parentBusinessObject = businessObject.$parent;
        var context = {
          element: parentBusinessObject,
          properties: {
            name: name
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editDecisionTableId",
      value: function editDecisionTableId(id) {
        var root = this._sheet.getRoot(),
          businessObject = root.businessObject,
          parentBusinessObject = businessObject.$parent;
        var context = {
          element: parentBusinessObject,
          properties: {
            id: id
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editHitPolicy",
      value: function editHitPolicy(hitPolicy, aggregation) {
        var root = this._sheet.getRoot(),
          businessObject = root.businessObject;
        var context = {
          element: businessObject,
          properties: {
            hitPolicy: hitPolicy,
            aggregation: aggregation
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "updateProperties",
      value: function updateProperties(el, props) {
        var context = {
          element: el,
          properties: props
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editInputExpression",
      value: function editInputExpression(inputExpression, props) {
        var context = {
          element: inputExpression,
          properties: props
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editOutputName",
      value: function editOutputName(output, name) {
        var context = {
          element: output,
          properties: {
            name: name
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editInputExpressionTypeRef",
      value: function editInputExpressionTypeRef(inputExpression, typeRef) {
        var context = {
          element: inputExpression,
          properties: {
            typeRef: typeRef
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editOutputTypeRef",
      value: function editOutputTypeRef(output, typeRef) {
        var context = {
          element: output,
          properties: {
            typeRef: typeRef
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editCell",
      value: function editCell(cell, text) {
        var context = {
          element: cell,
          properties: {
            text: text
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editAnnotation",
      value: function editAnnotation(rule, description) {
        var context = {
          element: rule,
          properties: {
            description: description
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editAllowedValues",
      value: function editAllowedValues(element, allowedValues) {
        var context = {
          element: element,
          allowedValues: allowedValues
        };
        this._commandStack.execute('editAllowedValues', context);
      }
    }, {
      key: "editExpressionLanguage",
      value: function editExpressionLanguage(element, expressionLanguage) {
        var context = {
          element: element,
          properties: {
            expressionLanguage: expressionLanguage
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "claimId",
      value: function claimId(id, moddleElement) {
        var context = {
          id: id,
          element: moddleElement,
          claiming: true
        };
        this._commandStack.execute('id.updateClaim', context);
      }
    }, {
      key: "unclaimId",
      value: function unclaimId(id, moddleElement) {
        var context = {
          id: id,
          element: moddleElement
        };
        this._commandStack.execute('id.updateClaim', context);
      }
    }], [{
      key: "_getHandlers",
      value: function _getHandlers() {
        return assign$4({}, _get(_getPrototypeOf(Modeling), "_getHandlers", this).call(this), {
          'editAllowedValues': UpdateAllowedValuesHandler,
          'element.updateProperties': EditPropertiesHandler,
          'id.updateClaim': IdClaimHandler
        });
      }
    }]);
    return Modeling;
  }(Modeling$2);
  Modeling$1.$inject = ['eventBus', 'elementFactory', 'commandStack', 'sheet'];

  var IdClaimBehavior = /*#__PURE__*/function (_CommandInterceptor) {
    _inherits$1(IdClaimBehavior, _CommandInterceptor);
    var _super = _createSuper(IdClaimBehavior);
    function IdClaimBehavior(eventBus, moddle, modeling) {
      var _this;
      _classCallCheck(this, IdClaimBehavior);
      _this = _super.call(this, eventBus);
      _this._ids = moddle.ids;
      _this._modeling = modeling;
      _this.preExecute(['row.add', 'col.add'], function (event) {
        var context = event.context,
          element = context.row || context.col;
        _this.claimId(element.businessObject);
        if (element.cells) {
          element.cells.forEach(function (cell) {
            return _this.claimId(cell.businessObject);
          });
        }
      });
      return _this;
    }
    _createClass(IdClaimBehavior, [{
      key: "claimId",
      value: function claimId(businessObject) {
        var _this2 = this;
        if (businessObject.id && !this._ids.assigned(businessObject.id)) {
          this._modeling.claimId(businessObject.id, businessObject);
        }
        businessObject.$descriptor.properties.forEach(function (property) {
          var value = businessObject[property.name];

          // not set
          if (!value) {
            return;
          }

          // array of moddle elements
          if (isArray$6(value)) {
            value.forEach(function (v) {
              return _this2.claimId(v);
            });
          }

          // moddle element
          if (value.$type) {
            _this2.claimId(value);
          }
        });
      }
    }]);
    return IdClaimBehavior;
  }(CommandInterceptor);
  IdClaimBehavior.$inject = ['eventBus', 'moddle', 'modeling'];

  var IdUnclaimBehavior = /*#__PURE__*/function (_CommandInterceptor) {
    _inherits$1(IdUnclaimBehavior, _CommandInterceptor);
    var _super = _createSuper(IdUnclaimBehavior);
    function IdUnclaimBehavior(eventBus, modeling) {
      var _this;
      _classCallCheck(this, IdUnclaimBehavior);
      _this = _super.call(this, eventBus);
      _this._modeling = modeling;
      _this.preExecute(['row.remove', 'col.remove'], function (event) {
        var context = event.context,
          element = context.row || context.col;
        _this.unclaimId(element.businessObject);
        if (element.cells) {
          element.cells.forEach(function (cell) {
            return _this.unclaimId(cell.businessObject);
          });
        }
      });
      return _this;
    }
    _createClass(IdUnclaimBehavior, [{
      key: "unclaimId",
      value: function unclaimId(businessObject) {
        var _this2 = this;
        if (businessObject.id) {
          this._modeling.unclaimId(businessObject.id, businessObject);
        }
        businessObject.$descriptor.properties.forEach(function (property) {
          var value = businessObject[property.name];

          // not set
          if (!value) {
            return;
          }

          // array of moddle elements
          if (isArray$6(value)) {
            value.forEach(function (v) {
              return _this2.unclaimId(v);
            });
          }

          // moddle element
          if (value.$type) {
            _this2.unclaimId(value);
          }
        });
      }
    }]);
    return IdUnclaimBehavior;
  }(CommandInterceptor);
  IdUnclaimBehavior.$inject = ['eventBus', 'modeling'];

  var Behavior = {
    __init__: ['idClaimBehavior', 'idUnclaimBehavior'],
    idClaimBehavior: ['type', IdClaimBehavior],
    idUnclaimBehavior: ['type', IdUnclaimBehavior]
  };

  var modelingModule = {
    __init__: ['dmnUpdater', 'idChangeBehavior', 'modeling'],
    __depends__: [Behavior, CommandStack],
    dmnUpdater: ['type', DmnUpdater],
    dmnFactory: ['type', DmnFactory],
    elementFactory: ['type', ElementFactory],
    idChangeBehavior: ['type', IdChangeBehavior],
    modeling: ['type', Modeling$1]
  };

  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
        _defineProperty$6(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$6(obj, key, value) {
    key = _toPropertyKey$6(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$6(arg) {
    var key = _toPrimitive$6(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$6(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var DecisionRulesCellEditorComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionRulesCellEditorComponent, _Component);
    var _super = _createSuper(DecisionRulesCellEditorComponent);
    function DecisionRulesCellEditorComponent(props, context) {
      var _this;
      _classCallCheck(this, DecisionRulesCellEditorComponent);
      _this = _super.call(this, props, context);
      _this.changeCellValue = _this.changeCellValue.bind(_assertThisInitialized(_this));
      _this.onElementsChanged = _this.onElementsChanged.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(DecisionRulesCellEditorComponent, [{
      key: "onElementsChanged",
      value: function onElementsChanged() {
        this.forceUpdate();
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        var injector = this.context.injector;
        var cell = this.props.cell;
        var changeSupport = this._changeSupport = this.context.changeSupport;
        this._modeling = injector.get('modeling');
        changeSupport.onElementsChanged(cell.id, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var cell = this.props.cell;
        this._changeSupport.offElementsChanged(cell.id, this.onElementsChanged);
      }
    }, {
      key: "changeCellValue",
      value: function changeCellValue(value) {
        var cell = this.props.cell;
        this._modeling.editCell(cell.businessObject, value);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          cell = _this$props.cell,
          rowIndex = _this$props.rowIndex,
          row = _this$props.row,
          col = _this$props.col,
          colIndex = _this$props.colIndex;
        var isUnaryTest = is$1(cell, 'dmn:UnaryTests');
        var businessObject = cell.businessObject;
        return createComponentVNode(2, HeaderCell, {
          "className": isUnaryTest ? 'input-cell' : 'output-cell',
          "elementId": cell.id,
          "coords": "".concat(rowIndex, ":").concat(colIndex),
          "data-row-id": row.id,
          "data-col-id": col.id,
          children: createComponentVNode(2, TableCellEditor, {
            "placeholder": isUnaryTest ? '-' : '',
            "onChange": this.changeCellValue,
            "value": businessObject.text,
            "businessObject": businessObject
          })
        });
      }
    }]);
    return DecisionRulesCellEditorComponent;
  }(Component);
  var FeelEditor$1 = /*#__PURE__*/function (_Component2) {
    _inherits$1(FeelEditor, _Component2);
    var _super2 = _createSuper(FeelEditor);
    function FeelEditor(props, context) {
      var _this2;
      _classCallCheck(this, FeelEditor);
      _this2 = _super2.call(this, props, context);
      _this2.state = {
        focussed: false
      };
      _this2.onFocus = _this2.onFocus.bind(_assertThisInitialized(_this2));
      _this2.onBlur = _this2.onBlur.bind(_assertThisInitialized(_this2));
      return _this2;
    }
    _createClass(FeelEditor, [{
      key: "onFocus",
      value: function onFocus() {
        this.setState({
          focussed: true
        });
      }
    }, {
      key: "onBlur",
      value: function onBlur() {
        this.setState({
          focussed: false
        });
      }
    }, {
      key: "render",
      value: function render() {
        var focussed = this.state.focussed;
        var className = "feel-editor".concat(focussed ? ' focussed' : '');

        // TODO(@barmac): display only a single editor;
        // required to workaround "replaceChild" error
        return createVNode(1, "div", className, [focussed && normalizeProps(createComponentVNode(2, LiteralExpression, _objectSpread$1(_objectSpread$1({}, this.props), {}, {
          "autoFocus": true,
          "onBlur": this.onBlur
        }))), normalizeProps(createComponentVNode(2, ContentEditable, _objectSpread$1(_objectSpread$1({}, this.props), {}, {
          "onInput": function onInput() {},
          "onFocus": this.onFocus
        })))], 0, {
          "onClick": this.onFocus
        });
      }
    }]);
    return FeelEditor;
  }(Component);
  var TableCellEditor = /*#__PURE__*/function (_Component3) {
    _inherits$1(TableCellEditor, _Component3);
    var _super3 = _createSuper(TableCellEditor);
    function TableCellEditor(props, context) {
      var _this3;
      _classCallCheck(this, TableCellEditor);
      _this3 = _super3.call(this, props, context);
      _this3._expressionLanguages = context.injector.get('expressionLanguages');
      _this3._translate = context.injector.get('translate');
      _this3._variableResolver = context.injector.get('variableResolver', false);
      return _this3;
    }
    _createClass(TableCellEditor, [{
      key: "isDefaultExpressionLanguage",
      value: function isDefaultExpressionLanguage(businessObject) {
        var expressionLanguage = businessObject.expressionLanguage;
        var defaultExpressionLanguage = this.getDefaultExpressionLanguage(businessObject).value;
        return !expressionLanguage || expressionLanguage === defaultExpressionLanguage;
      }
    }, {
      key: "getDescription",
      value: function getDescription(businessObject) {
        return businessObject.description;
      }
    }, {
      key: "getExpressionLanguageLabel",
      value: function getExpressionLanguageLabel(businessObject) {
        var expressionLanguage = businessObject.expressionLanguage;
        var defaultExpressionLanguage = this.getDefaultExpressionLanguage(businessObject);
        return this._expressionLanguages.getLabel(expressionLanguage) || defaultExpressionLanguage.label;
      }
    }, {
      key: "isScript",
      value: function isScript(businessObject) {
        var defaultExpressionLanguage = this.getDefaultExpressionLanguage(businessObject);
        var isInputCell = is$1(businessObject, 'dmn:UnaryTests');
        if (!isInputCell) {
          return false;
        }
        if (businessObject.text.indexOf('\n') !== -1) {
          return true;
        }
        return businessObject.expressionLanguage && businessObject.expressionLanguage !== defaultExpressionLanguage;
      }
    }, {
      key: "getDefaultExpressionLanguage",
      value: function getDefaultExpressionLanguage(businessObject) {
        var elementType = is$1(businessObject, 'dmn:UnaryTests') ? 'inputCell' : 'outputCell';
        return this._expressionLanguages.getDefault(elementType);
      }
    }, {
      key: "getEditor",
      value: function getEditor() {
        return this.isFEEL() ? FeelEditor$1 : ContentEditable;
      }
    }, {
      key: "isFEEL",
      value: function isFEEL() {
        return this.getExpressionLanguage() === 'feel';
      }
    }, {
      key: "getExpressionLanguage",
      value: function getExpressionLanguage() {
        var businessObject = this.props.businessObject;
        return businessObject.expressionLanguage || this.getDefaultExpressionLanguage(businessObject).value;
      }
    }, {
      key: "_getVariables",
      value: function _getVariables() {
        var businessObject = this.props.businessObject;
        return this._variableResolver && this._variableResolver.getVariables(businessObject);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
          businessObject = _this$props2.businessObject,
          placeholder = _this$props2.placeholder,
          value = _this$props2.value,
          onChange = _this$props2.onChange;
        var description = this.getDescription(businessObject);
        var isDefaultExpressionLanguage = this.isDefaultExpressionLanguage(businessObject);
        var expressionLanguageLabel = this.getExpressionLanguageLabel(businessObject);
        var isScript = this.isScript(businessObject);
        var Editor = this.getEditor();
        var variables = this._getVariables();
        return createVNode(1, "div", "cell-editor", [isString$4(description) && createVNode(1, "div", "description-indicator"), createComponentVNode(2, Editor, {
          "className": isScript ? 'script-editor' : '',
          "ctrlForNewline": true,
          "onInput": onChange,
          "value": value,
          "placeholder": placeholder,
          "variables": variables
        }), !isDefaultExpressionLanguage && createVNode(1, "span", "dms-badge dmn-expression-language", [createVNode(1, "span", "dms-badge-icon dmn-icon-file-code"), createVNode(1, "span", "dms-badge-label", expressionLanguageLabel, 0)], 4, {
          "title": this._translate('Expression language: {expressionLanguageLabel}', {
            expressionLanguageLabel: expressionLanguageLabel
          })
        })], 0);
      }
    }]);
    return TableCellEditor;
  }(Component);

  var HIGH_PRIORITY$2 = 1500;
  var RulesEditor = /*#__PURE__*/_createClass(function RulesEditor(components) {
    _classCallCheck(this, RulesEditor);
    components.onGetComponent('cell', HIGH_PRIORITY$2, function (_ref) {
      var cellType = _ref.cellType;
      if (cellType === 'rule') {
        return DecisionRulesCellEditorComponent;
      }
    });
  });
  RulesEditor.$inject = ['components'];

  var decisionRulesEditorModule = {
    __depends__: [DebounceInput, Rules$2],
    __init__: ['decisionRulesEditor'],
    decisionRulesEditor: ['type', RulesEditor]
  };

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty$5(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$5(obj, key, value) {
    key = _toPropertyKey$5(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$5(arg) {
    var key = _toPrimitive$5(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$5(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var OFFSET = 4;
  var SimpleModeButtonComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(SimpleModeButtonComponent, _Component);
    var _super = _createSuper(SimpleModeButtonComponent);
    function SimpleModeButtonComponent(props, context) {
      var _this;
      _classCallCheck(this, SimpleModeButtonComponent);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this.state = {
        top: 0,
        left: 0,
        isVisible: false,
        isDisabled: false,
        selection: null
      };
      inject(_assertThisInitialized(_this));
      var debounceInput = _this.debounceInput;
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      _this.handleSelectionChanged = _this.handleSelectionChanged.bind(_assertThisInitialized(_this));
      _this.hideAndShowDebounced = _this.hideAndShowDebounced.bind(_assertThisInitialized(_this));
      _this.showDebounced = debounceInput(_this.showDebounced.bind(_assertThisInitialized(_this)));
      _this.updatePosition = _this.updatePosition.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(SimpleModeButtonComponent, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var eventBus = this.eventBus;
        eventBus.on('cellSelection.changed', this.handleSelectionChanged);
        eventBus.on('commandStack.changed', this.updatePosition);
        eventBus.on('sheet.scroll', this.hideAndShowDebounced);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var eventBus = this.eventBus;
        eventBus.off('cellSelection.changed', this.handleSelectionChanged);
        eventBus.off('commandStack.changed', this.updatePosition);
        eventBus.off('sheet.scroll', this.hideAndShowDebounced);
      }
    }, {
      key: "hideAndShowDebounced",
      value: function hideAndShowDebounced() {
        if (this.state.isVisible) {
          this.hide();
          this.showDebounced();
        }
      }
    }, {
      key: "showDebounced",
      value: function showDebounced() {
        this.show();
      }
    }, {
      key: "hide",
      value: function hide() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.setState(_objectSpread(_objectSpread({}, state), {}, {
          isVisible: false
        }));
      }
    }, {
      key: "show",
      value: function show() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.setState(_objectSpread(_objectSpread({}, state), {}, {
          isVisible: true
        }));
        this.updatePosition();
      }
    }, {
      key: "handleSelectionChanged",
      value: function handleSelectionChanged(_ref) {
        var elementId = _ref.elementId;
        var elementRegistry = this.elementRegistry,
          expressionLanguages = this.expressionLanguages,
          simpleMode = this.simpleMode;
        var selection = elementRegistry.get(elementId);
        if (!selection || !simpleMode.canSimpleEdit(selection)) {
          this.hide({
            isDisabled: false,
            selection: null
          });
          return;
        }
        var expressionLanguage = getExpressionLanguage(selection);
        var isDisabled = !isDefaultExpressionLanguage(selection, expressionLanguage, expressionLanguages);
        this.show({
          isDisabled: isDisabled,
          selection: selection
        });
      }

      // position button always on opposite site of context menu
    }, {
      key: "updatePosition",
      value: function updatePosition() {
        var selection = this.state.selection;
        var node = this.node;
        if (!selection || !node) {
          return;
        }
        var renderer = this.renderer;
        var container = renderer.getContainer(),
          containerBounds = container.getBoundingClientRect();
        var cellNode = getNodeById(selection.id, container);
        var cellBounds = cellNode.getBoundingClientRect();
        var nodeBounds = this.node.getBoundingClientRect();
        var _getTableContainerScr = getTableContainerScroll(node),
          scrollLeft = _getTableContainerScr.scrollLeft,
          scrollTop = _getTableContainerScr.scrollTop;
        var nodePosition = {};
        if (cellBounds.left + cellBounds.width / 2 > containerBounds.width / 2) {
          // left
          nodePosition.left = -containerBounds.left + cellBounds.left - nodeBounds.width + OFFSET + scrollLeft + 'px';
          node.classList.remove('right');
          node.classList.add('left');
        } else {
          // right
          nodePosition.left = -containerBounds.left + cellBounds.left + cellBounds.width - OFFSET + scrollLeft + 'px';
          node.classList.remove('left');
          node.classList.add('right');
        }
        if (cellBounds.top + cellBounds.height / 2 > containerBounds.height / 2) {
          // bottom
          nodePosition.top = -containerBounds.top + cellBounds.top - nodeBounds.height + OFFSET + scrollTop + 'px';
          node.classList.remove('top');
          node.classList.add('bottom');
        } else {
          // top
          nodePosition.top = -containerBounds.top + cellBounds.top - OFFSET + scrollTop + 'px';
          node.classList.remove('bottom');
          node.classList.add('top');
        }
        assign$4(this.node.style, nodePosition);
      }
    }, {
      key: "onClick",
      value: function onClick() {
        var eventBus = this.eventBus;
        var isDisabled = this.state.isDisabled;
        if (isDisabled) {
          return;
        }
        var selection = this.selection;
        var element = selection.get();
        if (!element) {
          return;
        }
        eventBus.fire('simpleMode.open', {
          element: element,
          node: getNodeById(element.id, this._container)
        });
        this.hide();
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$state = this.state,
          isDisabled = _this$state.isDisabled,
          isVisible = _this$state.isVisible,
          top = _this$state.top,
          left = _this$state.left;
        var classes = ['simple-mode-button', 'no-deselect'];
        if (isDisabled) {
          classes.push('disabled');
        }
        return isVisible ? createVNode(1, "div", classes.join(' '), createVNode(1, "span", "dmn-icon-edit"), 2, {
          "onClick": this.onClick,
          "style": {
            top: top,
            left: left
          },
          "title": isDisabled ? this._translate('Editing not supported for set expression language') : this._translate('Edit')
        }, null, function (node) {
          return _this2.node = node;
        }) : null;
      }
    }]);
    return SimpleModeButtonComponent;
  }(Component);
  SimpleModeButtonComponent.$inject = ['debounceInput', 'elementRegistry', 'eventBus', 'expressionLanguages', 'renderer', 'selection', 'simpleMode'];

  // helpers //////////////////////

  /**
   * Return set expression language if found.
   *
   * @param {Cell} cell - Cell.
   */
  function getExpressionLanguage(cell) {
    return cell.businessObject.expressionLanguage;
  }
  function isDefaultExpressionLanguage(cell, expressionLanguage, expressionLanguages) {
    return !expressionLanguage || expressionLanguage === getDefaultExpressionLanguage(cell, expressionLanguages);
  }
  function getDefaultExpressionLanguage(cell, expressionLanguages) {
    if (isInput$1(cell.col)) {
      return expressionLanguages.getDefault('inputCell').value;
    } else if (isOutput(cell.col)) {
      return expressionLanguages.getDefault('outputCell').value;
    }
  }
  function getTableContainerScroll(node) {
    var tableContainer = closest(node, '.tjs-table-container');
    if (!tableContainer) {
      return {
        scrollTop: 0,
        scrollLeft: 0
      };
    }
    var scrollLeft = tableContainer.scrollLeft,
      scrollTop = tableContainer.scrollTop;
    return {
      scrollTop: scrollTop,
      scrollLeft: scrollLeft
    };
  }

  var SimpleMode = /*#__PURE__*/function () {
    function SimpleMode(components, contextMenu, elementRegistry, eventBus, renderer) {
      _classCallCheck(this, SimpleMode);
      this._providers = [];
      components.onGetComponent('table.before', function () {
        return SimpleModeButtonComponent;
      });
      eventBus.on('simpleMode.open', function (_ref) {
        var element = _ref.element,
          node = _ref.node;
        var _node$getBoundingClie = node.getBoundingClientRect(),
          left = _node$getBoundingClie.left,
          top = _node$getBoundingClie.top,
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;
        var container = renderer.getContainer();
        contextMenu.open({
          x: left + container.parentNode.scrollLeft,
          y: top + container.parentNode.scrollTop,
          width: width,
          height: height
        }, {
          contextMenuType: 'simple-mode-edit',
          element: element,
          offset: {
            x: 4,
            y: 4
          }
        });
      });
      eventBus.on('cell.click', function (e) {
        var event = e.event,
          node = e.node,
          id = e.id;
        if (isCmd$1(event)) {
          var element = elementRegistry.get(id);
          if (element) {
            eventBus.fire('simpleMode.open', {
              node: node,
              element: element
            });
          }

          // prevent focus
          e.preventDefault();
        }
      });
    }
    _createClass(SimpleMode, [{
      key: "registerProvider",
      value: function registerProvider(provider) {
        this._providers.push(provider);
      }
    }, {
      key: "canSimpleEdit",
      value: function canSimpleEdit(element) {
        return this._providers.reduce(function (canSimpleEdit, provider) {
          return canSimpleEdit || provider(element);
        }, false);
      }
    }]);
    return SimpleMode;
  }();
  SimpleMode.$inject = ['components', 'contextMenu', 'elementRegistry', 'eventBus', 'renderer'];

  // helpers //////////

  function isCmd$1(event) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (event.altKey) {
      return false;
    }
    return event.ctrlKey || event.metaKey;
  }

  var simpleModeModule = {
    __depends__: [contextMenuModule, cellSelectionModule, ExpressionLanguagesModule],
    __init__: ['simpleMode'],
    simpleMode: ['type', SimpleMode]
  };

  function parseString$5(string) {
    if (!string || isEmptyString$3(string)) {
      return 'none';
    } else if (string.trim() === 'true') {
      return 'true';
    } else if (string.trim() === 'false') {
      return 'false';
    }
  }
  function isEmptyString$3(string) {
    return string === '';
  }

  var TRUE = 'true',
    FALSE = 'false',
    NONE = 'none';
  var BooleanEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(BooleanEdit, _Component);
    var _super = _createSuper(BooleanEdit);
    function BooleanEdit(props, context) {
      var _this;
      _classCallCheck(this, BooleanEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString$5(element.businessObject.text);
      _this.state = {
        value: parsedString || NONE
      };
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onChange = _this.onChange.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(BooleanEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onChange",
      value: function onChange(value) {
        var element = this.props.context.element;
        this.editCell(element.businessObject, value === NONE ? '' : value);
        this.setState({
          value: value
        });
      }
    }, {
      key: "render",
      value: function render() {
        var value = this.state.value;
        var options = [{
          label: '-',
          value: NONE
        }, {
          label: this._translate('Yes'),
          value: TRUE
        }, {
          label: this._translate('No'),
          value: FALSE
        }];
        return createVNode(1, "div", "simple-boolean-edit context-menu-container", [createVNode(1, "h3", "dms-heading", this._translate('Edit boolean'), 0), createVNode(1, "h4", "dms-heading", this._translate('Set value'), 0), createComponentVNode(2, InputSelect, {
          "noInput": true,
          "className": "dms-block",
          "onChange": this.onChange,
          "options": options,
          "value": value
        })], 4);
      }
    }]);
    return BooleanEdit;
  }(Component);

  var SimpleBooleanEdit = /*#__PURE__*/_createClass(function SimpleBooleanEdit(components, simpleMode) {
    _classCallCheck(this, SimpleBooleanEdit);
    simpleMode.registerProvider(function (element) {
      return (isInput$1(element.col) || isOutput(element.col)) && getTypeRef$8(element) === 'boolean';
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {
        if (!context.element) {
          return;
        }
        var typeRef = getTypeRef$8(context.element);
        if (typeRef === 'boolean') {
          return BooleanEdit;
        }
      }
    });
  });
  SimpleBooleanEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$8(element) {
    if (isInput$1(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }

  var simpleBooleanEditModule = {
    __depends__: [keyboardModule, simpleModeModule],
    __init__: ['simpleBooleanEdit'],
    simpleBooleanEdit: ['type', SimpleBooleanEdit]
  };

  var ISO_DATE_REGEX$1 = /^\d{4}(?:-\d\d){2}$/;

  // eslint-disable-next-line
  var BETWEEN_DATE_REGEX$1 = /^\[date\("([^"]*)"\)..date\("([^"]*)"\)\]$/;

  // eslint-disable-next-line
  var BEFORE_AFTER_DATE_REGEX$1 = /^(<|>)\s*date\("([^"]*)"\)$/;
  var EXACT_DATE_REGEX$1 = /^date\("([^"]*)"\)$/;
  var EXACT$5 = 'exact',
    BEFORE$5 = 'before',
    AFTER$5 = 'after',
    BETWEEN$5 = 'between';
  function validateISOString$2(string) {
    if (!ISO_DATE_REGEX$1.test(string.trim())) {
      return 'Date must match pattern yyyy-MM-dd';
    }
  }
  function getDateString$1(type, dates) {
    if (type === EXACT$5) {
      return "date(\"".concat(dates[0], "\")");
    } else if (type === BEFORE$5) {
      return "< date(\"".concat(dates[0], "\")");
    } else if (type === AFTER$5) {
      return "> date(\"".concat(dates[0], "\")");
    } else if (type === BETWEEN$5) {
      return "[date(\"".concat(dates[0], "\")..date(\"").concat(dates[1], "\")]");
    }
  }
  function getSampleDate$1() {
    var date = new Date();
    date.setUTCHours(0, 0, 0, 0);
    return date.toISOString().slice(0, 10);
  }
  function parseString$4(string) {
    // emtpy
    if (!string || string.trim() === '') {
      return {
        type: 'exact',
        date: ''
      };
    }

    // between
    var matches = string.match(BETWEEN_DATE_REGEX$1);
    if (matches) {
      return {
        type: 'between',
        dates: [matches[1], matches[2]]
      };
    }

    // before or after
    matches = string.match(BEFORE_AFTER_DATE_REGEX$1);
    if (matches) {
      return {
        type: matches[1] === '<' ? 'before' : 'after',
        date: matches[2]
      };
    }

    // exact
    matches = string.match(EXACT_DATE_REGEX$1);
    if (matches) {
      return {
        type: 'exact',
        date: matches[1]
      };
    }
  }

  var EXACT$4 = 'exact',
    BEFORE$4 = 'before',
    AFTER$4 = 'after',
    BETWEEN$4 = 'between';
  var InputDateEdit$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(InputDateEdit, _Component);
    var _super = _createSuper(InputDateEdit);
    function InputDateEdit(props, context) {
      var _this;
      _classCallCheck(this, InputDateEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString$4(element.businessObject.text);
      if (parsedString) {
        var dates;
        if (parsedString.date) {
          dates = [parsedString.date, ''];
        } else if (parsedString.dates) {
          dates = parsedString.dates;
        } else {
          dates = ['', ''];
        }
        _this.state = {
          type: parsedString.type,
          dates: dates
        };
      } else {
        _this.state = {
          type: EXACT$4,
          dates: ['', '']
        };
      }
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onTypeChange = _this.onTypeChange.bind(_assertThisInitialized(_this));
      _this.onSetStartDateTodayClick = _this.onSetStartDateTodayClick.bind(_assertThisInitialized(_this));
      _this.onSetEndDateTodayClick = _this.onSetEndDateTodayClick.bind(_assertThisInitialized(_this));
      _this.onStartDateInput = _this.onStartDateInput.bind(_assertThisInitialized(_this));
      _this.onEndDateInput = _this.onEndDateInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(InputDateEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onTypeChange",
      value: function onTypeChange(value) {
        var element = this.props.context.element;
        var dates = this.state.dates;
        this.setState({
          type: value
        });
        if (parseString$4(getDateString$1(value, dates))) {
          this.editCell(element.businessObject, getDateString$1(value, dates));
        }
      }
    }, {
      key: "onSetStartDateTodayClick",
      value: function onSetStartDateTodayClick() {
        var element = this.props.context.element;
        var _this$state = this.state,
          dates = _this$state.dates,
          type = _this$state.type;
        var date = getSampleDate$1();
        this.setState({
          dates: [date, dates[1]]
        });
        if (parseString$4(getDateString$1(type, [date, dates[1]]))) {
          this.editCell(element.businessObject, getDateString$1(type, [date, dates[1]]));
        }
      }
    }, {
      key: "onSetEndDateTodayClick",
      value: function onSetEndDateTodayClick() {
        var element = this.props.context.element;
        var _this$state2 = this.state,
          dates = _this$state2.dates,
          type = _this$state2.type;
        var date = getSampleDate$1();
        this.setState({
          dates: [dates[0], date]
        });
        if (parseString$4(getDateString$1(type, [dates[0], date]))) {
          this.editCell(element.businessObject, getDateString$1(type, [dates[0], date]));
        }
      }
    }, {
      key: "onStartDateInput",
      value: function onStartDateInput(_ref) {
        var value = _ref.value;
        var element = this.props.context.element;
        var _this$state3 = this.state,
          dates = _this$state3.dates,
          type = _this$state3.type;
        this.setState({
          dates: [value, dates[1]]
        });
        this.debouncedEditCell(element.businessObject, getDateString$1(type, [value, dates[1]]));
      }
    }, {
      key: "onEndDateInput",
      value: function onEndDateInput(_ref2) {
        var value = _ref2.value;
        var element = this.props.context.element;
        var _this$state4 = this.state,
          dates = _this$state4.dates,
          type = _this$state4.type;
        this.setState({
          dates: [dates[0], value]
        });
        this.debouncedEditCell(element.businessObject, getDateString$1(type, [dates[0], value]));
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$state5 = this.state,
          dates = _this$state5.dates,
          type = _this$state5.type;
        var options = [{
          label: this._translate('Exactly'),
          value: EXACT$4
        }, {
          label: this._translate('Before'),
          value: BEFORE$4
        }, {
          label: this._translate('After'),
          value: AFTER$4
        }, {
          label: this._translate('Between'),
          value: BETWEEN$4
        }];
        return createVNode(1, "div", "context-menu-container simple-date-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit date'), 0), createVNode(1, "div", "dms-fill-row", createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onTypeChange,
          "options": options,
          "value": type
        }), 2), createVNode(1, "h4", "dms-heading", type === BETWEEN$4 ? this._translate('Edit start date') : this._translate('Set date'), 0), createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "className": "start-date-input dms-block",
          "onInput": this.onStartDateInput,
          "placeholder": this._translate('e.g. { sample }', {
            sample: getSampleDate$1()
          }),
          "validate": function validate(string) {
            return validateISOString$2(string) && _this2._translate(validateISOString$2(string));
          },
          "value": dates[0]
        }), createVNode(1, "p", "dms-hint", [createVNode(1, "button", "use-today", this._translate('Use today'), 0, {
          "type": "button",
          "onClick": this.onSetStartDateTodayClick
        }), createTextVNode(".")], 4)], 4), type === BETWEEN$4 && createVNode(1, "h4", "dms-heading", this._translate('Edit end date'), 0), type === BETWEEN$4 && createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "className": "end-date-input dms-block",
          "onInput": this.onEndDateInput,
          "placeholder": this._translate('e.g. { sample }', {
            sample: getSampleDate$1()
          }),
          "validate": function validate(string) {
            return validateISOString$2(string) && _this2._translate(validateISOString$2(string));
          },
          "value": dates[1]
        }), createVNode(1, "p", "dms-hint", [createVNode(1, "button", "use-today", this._translate('Use today'), 0, {
          "type": "button",
          "onClick": this.onSetEndDateTodayClick
        }), createTextVNode(".")], 4)], 4)], 0);
      }
    }]);
    return InputDateEdit;
  }(Component);

  var OutputDateEdit$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputDateEdit, _Component);
    var _super = _createSuper(OutputDateEdit);
    function OutputDateEdit(props, context) {
      var _this;
      _classCallCheck(this, OutputDateEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString$4(element.businessObject.text);
      _this.state = {
        date: parsedString ? parsedString.date : ''
      };
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(OutputDateEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onClick",
      value: function onClick() {
        var element = this.props.context.element;
        var date = getSampleDate$1();
        this.setState({
          date: date
        });
        this.editCell(element.businessObject, "date(\"".concat(date, "\")"));
      }
    }, {
      key: "onInput",
      value: function onInput(_ref) {
        var value = _ref.value;
        var element = this.props.context.element;
        this.setState({
          date: value
        });
        this.debouncedEditCell(element.businessObject, "date(\"".concat(value, "\")"));
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var date = this.state.date;
        return createVNode(1, "div", "context-menu-container simple-date-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit date'), 0), createVNode(1, "h4", "dms-heading", this._translate('Set date'), 0), createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "onInput": this.onInput,
          "placeholder": this._translate('e.g. { example } ', {
            example: getSampleDate$1()
          }),
          "validate": function validate(string) {
            return validateISOString$2(string) && _this2._translate(validateISOString$2(string));
          },
          "value": date,
          "className": "dms-block"
        }), createVNode(1, "p", "dms-hint", createVNode(1, "button", "use-today", this._translate('Use today'), 0, {
          "type": "button",
          "onClick": this.onClick
        }), 2)], 4)], 4);
      }
    }]);
    return OutputDateEdit;
  }(Component);

  var SimpleDateEdit$2 = /*#__PURE__*/_createClass(function SimpleDateEdit(components, simpleMode) {
    _classCallCheck(this, SimpleDateEdit);
    simpleMode.registerProvider(function (element) {
      var typeRef = getTypeRef$7(element);
      return (isInput$1(element.col) || isOutput(element.col)) && isDate(typeRef);
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {
        if (!context.element) {
          return;
        }
        var typeRef = getTypeRef$7(context.element);
        if (isDate(typeRef)) {
          if (isInput$1(context.element.col)) {
            return InputDateEdit$1;
          } else if (isOutput(context.element.col)) {
            return OutputDateEdit$1;
          }
        }
      }
    });
  });
  SimpleDateEdit$2.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$7(element) {
    if (isInput$1(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }
  function isDate(typeRef) {
    return typeRef === 'date';
  }

  var simpleDateEditModule = {
    __depends__: [keyboardModule, simpleModeModule],
    __init__: ['simpleDateEdit'],
    simpleDateEdit: ['type', SimpleDateEdit$2]
  };

  var ISO_DATE_REGEX = /^\d{4}(?:-\d\d){2}T(?:\d\d:){2}\d\d(?:Z|(?:[@+-][^")]+))?$/;

  // eslint-disable-next-line
  var BETWEEN_DATE_REGEX = /^\[date and time\("([^"]*)"\)..date and time\("([^"]*)"\)\]$/;

  // eslint-disable-next-line
  var BEFORE_AFTER_DATE_REGEX = /^(<|>)\s*date and time\("([^"]*)"\)$/;

  // eslint-disable-next-line
  var EXACT_DATE_REGEX = /^date and time\("([^"]*)"\)$/;
  var EXACT$3 = 'exact',
    BEFORE$3 = 'before',
    AFTER$3 = 'after',
    BETWEEN$3 = 'between';
  function validateISOString$1(string) {
    if (!ISO_DATE_REGEX.test(string.trim())) {
      return 'Date and time must match pattern yyyy-MM-ddTHH:mm:ss[time zone]';
    }
  }
  function getDateString(type, dates) {
    if (type === EXACT$3) {
      return "date and time(\"".concat(dates[0], "\")");
    } else if (type === BEFORE$3) {
      return "< date and time(\"".concat(dates[0], "\")");
    } else if (type === AFTER$3) {
      return "> date and time(\"".concat(dates[0], "\")");
    } else if (type === BETWEEN$3) {
      return "[date and time(\"".concat(dates[0], "\")..date and time(\"").concat(dates[1], "\")]");
    }
  }
  function getSampleDate() {
    var date = new Date();
    date.setUTCHours(0, 0, 0, 0);
    return date.toISOString().replace('.000Z', 'Z');
  }
  function parseString$3(string) {
    // emtpy
    if (!string || string.trim() === '') {
      return {
        type: 'exact',
        date: ''
      };
    }

    // between
    var matches = string.match(BETWEEN_DATE_REGEX);
    if (matches) {
      return {
        type: 'between',
        dates: [matches[1], matches[2]]
      };
    }

    // before or after
    matches = string.match(BEFORE_AFTER_DATE_REGEX);
    if (matches) {
      return {
        type: matches[1] === '<' ? 'before' : 'after',
        date: matches[2]
      };
    }

    // exact
    matches = string.match(EXACT_DATE_REGEX);
    if (matches) {
      return {
        type: 'exact',
        date: matches[1]
      };
    }
  }

  var EXACT$2 = 'exact',
    BEFORE$2 = 'before',
    AFTER$2 = 'after',
    BETWEEN$2 = 'between';
  var InputDateEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(InputDateEdit, _Component);
    var _super = _createSuper(InputDateEdit);
    function InputDateEdit(props, context) {
      var _this;
      _classCallCheck(this, InputDateEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString$3(element.businessObject.text);
      if (parsedString) {
        var dates;
        if (parsedString.date) {
          dates = [parsedString.date, ''];
        } else if (parsedString.dates) {
          dates = parsedString.dates;
        } else {
          dates = ['', ''];
        }
        _this.state = {
          type: parsedString.type,
          dates: dates
        };
      } else {
        _this.state = {
          type: EXACT$2,
          dates: ['', '']
        };
      }
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onTypeChange = _this.onTypeChange.bind(_assertThisInitialized(_this));
      _this.onSetStartDateTodayClick = _this.onSetStartDateTodayClick.bind(_assertThisInitialized(_this));
      _this.onSetEndDateTodayClick = _this.onSetEndDateTodayClick.bind(_assertThisInitialized(_this));
      _this.onStartDateInput = _this.onStartDateInput.bind(_assertThisInitialized(_this));
      _this.onEndDateInput = _this.onEndDateInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(InputDateEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onTypeChange",
      value: function onTypeChange(value) {
        var element = this.props.context.element;
        var dates = this.state.dates;
        this.setState({
          type: value
        });
        if (parseString$3(getDateString(value, dates))) {
          this.editCell(element.businessObject, getDateString(value, dates));
        }
      }
    }, {
      key: "onSetStartDateTodayClick",
      value: function onSetStartDateTodayClick() {
        var element = this.props.context.element;
        var _this$state = this.state,
          dates = _this$state.dates,
          type = _this$state.type;
        var date = getSampleDate();
        this.setState({
          dates: [date, dates[1]]
        });
        if (parseString$3(getDateString(type, [date, dates[1]]))) {
          this.editCell(element.businessObject, getDateString(type, [date, dates[1]]));
        }
      }
    }, {
      key: "onSetEndDateTodayClick",
      value: function onSetEndDateTodayClick() {
        var element = this.props.context.element;
        var _this$state2 = this.state,
          dates = _this$state2.dates,
          type = _this$state2.type;
        var date = getSampleDate();
        this.setState({
          dates: [dates[0], date]
        });
        if (parseString$3(getDateString(type, [dates[0], date]))) {
          this.editCell(element.businessObject, getDateString(type, [dates[0], date]));
        }
      }
    }, {
      key: "onStartDateInput",
      value: function onStartDateInput(_ref) {
        var value = _ref.value;
        var element = this.props.context.element;
        var _this$state3 = this.state,
          dates = _this$state3.dates,
          type = _this$state3.type;
        this.setState({
          dates: [value, dates[1]]
        });
        this.debouncedEditCell(element.businessObject, getDateString(type, [value, dates[1]]));
      }
    }, {
      key: "onEndDateInput",
      value: function onEndDateInput(_ref2) {
        var value = _ref2.value;
        var element = this.props.context.element;
        var _this$state4 = this.state,
          dates = _this$state4.dates,
          type = _this$state4.type;
        this.setState({
          dates: [dates[0], value]
        });
        this.debouncedEditCell(element.businessObject, getDateString(type, [dates[0], value]));
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$state5 = this.state,
          dates = _this$state5.dates,
          type = _this$state5.type;
        var options = [{
          label: this._translate('Exactly'),
          value: EXACT$2
        }, {
          label: this._translate('Before'),
          value: BEFORE$2
        }, {
          label: this._translate('After'),
          value: AFTER$2
        }, {
          label: this._translate('Between'),
          value: BETWEEN$2
        }];
        return createVNode(1, "div", "context-menu-container simple-date-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit date and time'), 0), createVNode(1, "div", "dms-fill-row", createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onTypeChange,
          "options": options,
          "value": type
        }), 2), createVNode(1, "h4", "dms-heading", type === BETWEEN$2 ? this._translate('Edit start date') : this._translate('Set date'), 0), createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "className": "start-date-input dms-block",
          "onInput": this.onStartDateInput,
          "placeholder": this._translate('e.g. { sample }', {
            sample: getSampleDate()
          }),
          "validate": function validate(string) {
            return validateISOString$1(string) && _this2._translate(validateISOString$1(string));
          },
          "value": dates[0]
        }), createVNode(1, "p", "dms-hint", createVNode(1, "button", "use-today", this._translate('Use today'), 0, {
          "type": "button",
          "onClick": this.onSetStartDateTodayClick
        }), 2)], 4), type === BETWEEN$2 && createVNode(1, "h4", "dms-heading", this._translate('Edit end date'), 0), type === BETWEEN$2 && createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "className": "end-date-input dms-block",
          "onInput": this.onEndDateInput,
          "placeholder": this._translate('e.g. { sample }', {
            sample: getSampleDate()
          }),
          "validate": function validate(string) {
            return validateISOString$1(string) && _this2._translate(validateISOString$1(string));
          },
          "value": dates[1]
        }), createVNode(1, "p", "dms-hint", createVNode(1, "button", "use-today", this._translate('Use today'), 0, {
          "type": "button",
          "onClick": this.onSetEndDateTodayClick
        }), 2)], 4)], 0);
      }
    }]);
    return InputDateEdit;
  }(Component);

  var OutputDateEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputDateEdit, _Component);
    var _super = _createSuper(OutputDateEdit);
    function OutputDateEdit(props, context) {
      var _this;
      _classCallCheck(this, OutputDateEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString$3(element.businessObject.text);
      _this.state = {
        date: parsedString ? parsedString.date : ''
      };
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(OutputDateEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onClick",
      value: function onClick() {
        var element = this.props.context.element;
        var date = getSampleDate();
        this.setState({
          date: date
        });
        this.editCell(element.businessObject, "date and time(\"".concat(date, "\")"));
      }
    }, {
      key: "onInput",
      value: function onInput(_ref) {
        var value = _ref.value;
        var element = this.props.context.element;
        this.setState({
          date: value
        });
        this.debouncedEditCell(element.businessObject, "date and time(\"".concat(value, "\")"));
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var date = this.state.date;
        return createVNode(1, "div", "context-menu-container simple-date-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit date and time'), 0), createVNode(1, "h4", "dms-heading", this._translate('Set date and time'), 0), createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "onInput": this.onInput,
          "placeholder": this._translate('e.g. { sample }', {
            sample: getSampleDate()
          }),
          "validate": function validate(string) {
            return validateISOString$1(string) && _this2._translate(validateISOString$1(string));
          },
          "value": date,
          "className": "dms-block"
        }), createVNode(1, "p", "dms-hint", createVNode(1, "button", "use-today", this._translate('Use today'), 0, {
          "type": "button",
          "onClick": this.onClick
        }), 2)], 4)], 4);
      }
    }]);
    return OutputDateEdit;
  }(Component);

  var SimpleDateEdit$1 = /*#__PURE__*/_createClass(function SimpleDateEdit(components, simpleMode) {
    _classCallCheck(this, SimpleDateEdit);
    simpleMode.registerProvider(function (element) {
      var typeRef = getTypeRef$6(element);
      return (isInput$1(element.col) || isOutput(element.col)) && isDateTime(typeRef);
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {
        if (!context.element) {
          return;
        }
        var typeRef = getTypeRef$6(context.element);
        if (isDateTime(typeRef)) {
          if (isInput$1(context.element.col)) {
            return InputDateEdit;
          } else if (isOutput(context.element.col)) {
            return OutputDateEdit;
          }
        }
      }
    });
  });
  SimpleDateEdit$1.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$6(element) {
    if (isInput$1(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }
  function isDateTime(typeRef) {
    return typeRef === 'dateTime';
  }

  var simpleDateTimeEditModule = {
    __depends__: [keyboardModule, simpleModeModule],
    __init__: ['simpleDateTimeEdit'],
    simpleDateTimeEdit: ['type', SimpleDateEdit$1]
  };

  function _wrapRegExp() {
    _wrapRegExp = function _wrapRegExp(re, groups) {
      return new BabelRegExp(re, void 0, groups);
    };
    var _super = RegExp.prototype,
      _groups = new WeakMap();
    function BabelRegExp(re, flags, groups) {
      var _this = new RegExp(re, flags);
      return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
    }
    function buildGroups(result, re) {
      var g = _groups.get(re);
      return Object.keys(g).reduce(function (groups, name) {
        var i = g[name];
        if ("number" == typeof i) groups[name] = result[i];else {
          for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++;
          groups[name] = result[i[k]];
        }
        return groups;
      }, Object.create(null));
    }
    return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
      var result = _super.exec.call(this, str);
      if (result) {
        result.groups = buildGroups(result, this);
        var indices = result.indices;
        indices && (indices.groups = buildGroups(indices, this));
      }
      return result;
    }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
      if ("string" == typeof substitution) {
        var groups = _groups.get(this);
        return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
          var group = groups[name];
          return "$" + (Array.isArray(group) ? group.join("$") : group);
        }));
      }
      if ("function" == typeof substitution) {
        var _this = this;
        return _super[Symbol.replace].call(this, str, function () {
          var args = arguments;
          return "object" != _typeof(args[args.length - 1]) && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
        });
      }
      return _super[Symbol.replace].call(this, str, substitution);
    }, _wrapRegExp.apply(this, arguments);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  var operators$1 = {
    equals: '=',
    less: '<',
    lessEquals: '<=',
    greater: '>',
    greaterEquals: '>='
  };
  function getOperatorName$1(string) {
    return keys(operators$1).filter(function (key) {
      return string === operators$1[key];
    })[0];
  }
  function parseDuration(text) {
    if (!text || isEmptyString$2(text.trim())) {
      return {
        type: 'comparison',
        values: []
      };
    }
    var parsedComparison = parseComparison(text);
    if (parsedComparison) {
      return parsedComparison;
    }
    var parsedRange = parseRange(text);
    if (parsedRange) {
      return parsedRange;
    }
  }
  function isEmptyString$2(string) {
    return string === '';
  }
  function getComparisonString$1(comparisonOperator, comparisonValue) {
    if (comparisonOperator === 'equals') {
      return "duration(\"".concat(comparisonValue, "\")");
    } else {
      return "".concat(operators$1[comparisonOperator], " duration(\"").concat(comparisonValue, "\")");
    }
  }
  function getRangeString$1(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
    var rangeStartChar = rangeStartType === 'exclude' ? ']' : '[',
      rangeEndChar = rangeEndType === 'exclude' ? '[' : ']';
    return "".concat(rangeStartChar, "duration(\"").concat(rangeStartValue, "\")") + "..duration(\"".concat(rangeEndValue, "\")").concat(rangeEndChar);
  }
  function validateDuration(type, value) {
    if (type === 'yearMonthDuration') {
      return validateYearMonthDuration(value);
    } else if (type === 'dayTimeDuration') {
      return validateDayTimeDuration(value);
    }
  }
  function validateYearMonthDuration(value) {
    return /^P(\d+Y\d+M|\d+Y|\d+M)$/.test(value);
  }
  function validateDayTimeDuration(value) {
    return /^P(\d+DT\d+H|\d+D|T\d+H)$/.test(value);
  }
  function withoutDurationCall(text) {
    var result = /^duration\("([^"]*)"\)$/.exec(text);
    return result && result[1];
  }
  function parseComparison(text) {
    var exactValue = withoutDurationCall(text);
    if (exactValue) {
      return {
        type: 'comparison',
        operator: 'equals',
        values: [exactValue]
      };
    }
    var _match = match( /*#__PURE__*/_wrapRegExp(/^(=|(:?<|>)=?)\s*duration\("([^"]*)"\)$/, {
        operator: 1,
        value: 3
      }), text),
      operator = _match.operator,
      value = _match.value;
    if (operator && value) {
      return {
        type: 'comparison',
        values: [value],
        operator: getOperatorName$1(operator)
      };
    }
  }
  function parseRange(text) {
    var _match2 = match( /*#__PURE__*/_wrapRegExp(/^([[\]])duration\("([^"]*)"\)\.\.duration\("([^"]*)"\)([[\]])$/, {
        start: 1,
        firstValue: 2,
        secondValue: 3,
        end: 4
      }), text),
      start = _match2.start,
      end = _match2.end,
      firstValue = _match2.firstValue,
      secondValue = _match2.secondValue;
    if (start && end) {
      return {
        type: 'range',
        values: [firstValue, secondValue],
        start: start === ']' ? 'exclude' : 'include',
        end: end === '[' ? 'exclude' : 'include'
      };
    }
  }
  function match(regex, input) {
    var _ref = regex.exec(input) || {
        groups: {}
      },
      groups = _ref.groups;
    return groups;
  }

  var ERROR_MESSAGE = {
    yearMonthDuration: 'Must match PnYnM',
    dayTimeDuration: 'Must match PnDTnH'
  };
  var DurationInput = /*#__PURE__*/function (_Component) {
    _inherits$1(DurationInput, _Component);
    var _super = _createSuper(DurationInput);
    function DurationInput(props, context) {
      var _this;
      _classCallCheck(this, DurationInput);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._type = props.type;
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      _this.validate = _this.validate.bind(_assertThisInitialized(_this));
      _this.state = {
        value: props.value
      };
      return _this;
    }
    _createClass(DurationInput, [{
      key: "onInput",
      value: function onInput(_ref) {
        var value = _ref.value;
        this.setState({
          value: value
        });
        this.props.onInput(value);
      }
    }, {
      key: "validate",
      value: function validate(value) {
        if (!validateDuration(this._type, value)) {
          return this._translate(ERROR_MESSAGE[this._type]);
        }
      }
    }, {
      key: "_getPlaceholder",
      value: function _getPlaceholder() {
        if (this._type === 'yearMonthDuration') {
          return this._translate('e.g. { sample }', {
            sample: 'P1Y2M'
          });
        } else if (this._type === 'dayTimeDuration') {
          this._translate('e.g. { sample }', {
            sample: 'P1DT2H'
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        return createComponentVNode(2, ValidatedInput, {
          "type": "text",
          "onInput": this.onInput,
          "placeholder": this._getPlaceholder(),
          "validate": this.validate,
          "value": this.state.value,
          "className": this.props.className
        });
      }
    }]);
    return DurationInput;
  }(Component);

  var COMPARISON$1 = 'comparison',
    RANGE$1 = 'range';

  // adapted from InputNumberEdit
  var InputDurationEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(InputDurationEdit, _Component);
    var _super = _createSuper(InputDurationEdit);
    function InputDurationEdit(props, context) {
      var _this;
      _classCallCheck(this, InputDurationEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      _this._type = getTypeRef$5(element);
      var parsedString = parseDuration(element.businessObject.text, _this._type);
      if (parsedString) {
        _this.state = {
          type: parsedString.type,
          comparisonOperator: parsedString.operator || 'equals',
          startValue: parsedString.values[0] || '',
          endValue: parsedString.values[1] || '',
          rangeStartType: parsedString.start || 'include',
          rangeEndType: parsedString.end || 'include'
        };
      } else {
        _this.state = {
          type: COMPARISON$1,
          comparisonOperator: 'equals',
          startValue: '',
          endValue: '',
          rangeStartType: 'include',
          rangeEndType: 'include'
        };
      }
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onComparisonOperatorChange = _this.onComparisonOperatorChange.bind(_assertThisInitialized(_this));
      _this.onComparisonValueChange = _this.onComparisonValueChange.bind(_assertThisInitialized(_this));
      _this.onTypeChange = _this.onTypeChange.bind(_assertThisInitialized(_this));
      _this.onRangeStartTypeChange = _this.onRangeStartTypeChange.bind(_assertThisInitialized(_this));
      _this.onRangeStartValueChange = _this.onRangeStartValueChange.bind(_assertThisInitialized(_this));
      _this.onRangeEndTypeChange = _this.onRangeEndTypeChange.bind(_assertThisInitialized(_this));
      _this.onRangeEndValueChange = _this.onRangeEndValueChange.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(InputDurationEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onTypeChange",
      value: function onTypeChange(value) {
        var element = this.props.context.element;
        var _this$state = this.state,
          comparisonOperator = _this$state.comparisonOperator,
          startValue = _this$state.startValue,
          endValue = _this$state.endValue,
          rangeStartType = _this$state.rangeStartType,
          rangeEndType = _this$state.rangeEndType;
        if (value === COMPARISON$1) {
          this.editCell(element.businessObject, getComparisonString$1(comparisonOperator, startValue));
        } else {
          this.editCell(element.businessObject, getRangeString$1(startValue, endValue, rangeStartType, rangeEndType));
        }
        this.setState({
          type: value
        });
      }
    }, {
      key: "onComparisonOperatorChange",
      value: function onComparisonOperatorChange(value) {
        var element = this.props.context.element;
        var _this$state2 = this.state,
          type = _this$state2.type,
          startValue = _this$state2.startValue;
        if (type === COMPARISON$1) {
          this.editCell(element.businessObject, getComparisonString$1(value, startValue));
          this.setState({
            comparisonOperator: value
          });
        }
      }
    }, {
      key: "onComparisonValueChange",
      value: function onComparisonValueChange(comparisonValue) {
        var element = this.props.context.element;
        var _this$state3 = this.state,
          type = _this$state3.type,
          comparisonOperator = _this$state3.comparisonOperator;
        if (type === COMPARISON$1) {
          this.debouncedEditCell(element.businessObject, getComparisonString$1(comparisonOperator, comparisonValue));
          this.setState({
            startValue: comparisonValue
          });
        }
      }
    }, {
      key: "onRangeStartTypeChange",
      value: function onRangeStartTypeChange(value) {
        var element = this.props.context.element;
        var _this$state4 = this.state,
          type = _this$state4.type,
          startValue = _this$state4.startValue,
          endValue = _this$state4.endValue,
          rangeEndType = _this$state4.rangeEndType;
        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString$1(startValue, endValue, value, rangeEndType));
          this.setState({
            rangeStartType: value
          });
        }
      }
    }, {
      key: "onRangeStartValueChange",
      value: function onRangeStartValueChange(value) {
        var element = this.props.context.element;
        var _this$state5 = this.state,
          type = _this$state5.type,
          endValue = _this$state5.endValue,
          rangeStartType = _this$state5.rangeStartType,
          rangeEndType = _this$state5.rangeEndType;
        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString$1(value, endValue, rangeStartType, rangeEndType));
          this.setState({
            startValue: value
          });
        }
      }
    }, {
      key: "onRangeEndTypeChange",
      value: function onRangeEndTypeChange(value) {
        var element = this.props.context.element;
        var _this$state6 = this.state,
          type = _this$state6.type,
          startValue = _this$state6.startValue,
          endValue = _this$state6.endValue,
          rangeStartType = _this$state6.rangeStartType;
        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString$1(startValue, endValue, rangeStartType, value));
          this.setState({
            rangeEndType: value
          });
        }
      }
    }, {
      key: "onRangeEndValueChange",
      value: function onRangeEndValueChange(value) {
        var element = this.props.context.element;
        var _this$state7 = this.state,
          type = _this$state7.type,
          startValue = _this$state7.startValue,
          rangeStartType = _this$state7.rangeStartType,
          rangeEndType = _this$state7.rangeEndType;
        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString$1(startValue, value, rangeStartType, rangeEndType));
          this.setState({
            endValue: value
          });
        }
      }
    }, {
      key: "renderComparison",
      value: function renderComparison(comparisonOperator, comparisonValue) {
        var comparisonOperatorOptions = [{
          label: this._translate('Equals'),
          value: 'equals'
        }, {
          label: this._translate('Less'),
          value: 'less'
        }, {
          label: this._translate('Less or equals'),
          value: 'lessEquals'
        }, {
          label: this._translate('Greater'),
          value: 'greater'
        }, {
          label: this._translate('Greater or equals'),
          value: 'greaterEquals'
        }];
        return createVNode(1, "div", "comparison", [createVNode(1, "h4", "dms-heading", createTextVNode("Value"), 2), createVNode(1, "div", "dms-fill-row dms-input-duration-edit-row", [createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onComparisonOperatorChange,
          "options": comparisonOperatorOptions,
          "value": comparisonOperator
        }), createTextVNode("\xA0"), createComponentVNode(2, DurationInput, {
          "type": this._type,
          "className": "comparison-duration-input",
          "onInput": this.onComparisonValueChange,
          "value": comparisonValue
        })], 4)], 4);
      }
    }, {
      key: "renderRange",
      value: function renderRange(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
        var rangeTypeOptions = [{
          label: this._translate('Include'),
          value: 'include'
        }, {
          label: this._translate('Exclude'),
          value: 'exclude'
        }];
        return createVNode(1, "div", "range", [createVNode(1, "h4", "dms-heading", this._translate('Start value'), 0), createVNode(1, "div", "dms-fill-row dms-input-duration-edit-row", [createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onRangeStartTypeChange,
          "options": rangeTypeOptions,
          "value": rangeStartType
        }), createTextVNode("\xA0"), createComponentVNode(2, DurationInput, {
          "type": this._type,
          "className": "range-start-duration-input",
          "onInput": this.onRangeStartValueChange,
          "value": rangeStartValue
        })], 4), createVNode(1, "h4", "dms-heading", this._translate('End value'), 0), createVNode(1, "div", "dms-fill-row dms-input-duration-edit-row", [createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onRangeEndTypeChange,
          "options": rangeTypeOptions,
          "value": rangeEndType
        }), createTextVNode("\xA0"), createComponentVNode(2, DurationInput, {
          "type": this._type,
          "className": "range-end-duration-input",
          "onInput": this.onRangeEndValueChange,
          "value": rangeEndValue
        })], 4)], 4);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state8 = this.state,
          type = _this$state8.type,
          comparisonOperator = _this$state8.comparisonOperator,
          startValue = _this$state8.startValue,
          endValue = _this$state8.endValue,
          rangeStartType = _this$state8.rangeStartType,
          rangeEndType = _this$state8.rangeEndType;
        var typeOptions = [{
          label: this._translate('Comparison'),
          value: COMPARISON$1
        }, {
          label: this._translate('Range'),
          value: RANGE$1
        }];
        return createVNode(1, "div", "context-menu-container simple-duration-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit duration'), 0), createVNode(1, "div", "dms-fill-row", createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onTypeChange,
          "options": typeOptions,
          "value": type
        }), 2), type === COMPARISON$1 && this.renderComparison(comparisonOperator, startValue), type === RANGE$1 && this.renderRange(startValue, endValue, rangeStartType, rangeEndType)], 0);
      }
    }]);
    return InputDurationEdit;
  }(Component);
  function getTypeRef$5(element) {
    return element.col.businessObject.inputExpression.typeRef;
  }

  var OutputDurationEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputDurationEdit, _Component);
    var _super = _createSuper(OutputDurationEdit);
    function OutputDurationEdit(props, context) {
      var _this;
      _classCallCheck(this, OutputDurationEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      _this._type = getTypeRef$4(element);
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(OutputDurationEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onInput",
      value: function onInput(value) {
        var element = this.props.context.element;
        this.debouncedEditCell(element.businessObject, "duration(\"".concat(value, "\")"));
      }
    }, {
      key: "render",
      value: function render() {
        var value = withoutDurationCall(this.props.context.element.businessObject.text, this._type);
        return createVNode(1, "div", "context-menu-container simple-duration-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit duration'), 0), createVNode(1, "h4", "dms-heading", this._translate('Set duration'), 0), createComponentVNode(2, DurationInput, {
          "onInput": this.onInput,
          "value": value,
          "type": this._type,
          "className": "dms-block"
        })], 4);
      }
    }]);
    return OutputDurationEdit;
  }(Component);
  function getTypeRef$4(element) {
    return element.col.businessObject.typeRef;
  }

  var SimpleDurationEdit = /*#__PURE__*/_createClass(function SimpleDurationEdit(components, simpleMode) {
    _classCallCheck(this, SimpleDurationEdit);
    simpleMode.registerProvider(function (element) {
      var typeRef = getTypeRef$3(element);
      return (isInput$1(element.col) || isOutput(element.col)) && isDuration(typeRef);
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {
        if (!context.element) {
          return;
        }
        var typeRef = getTypeRef$3(context.element);
        if (isDuration(typeRef)) {
          if (isInput$1(context.element.col)) {
            return InputDurationEdit;
          } else if (isOutput(context.element.col)) {
            return OutputDurationEdit;
          }
        }
      }
    });
  });
  SimpleDurationEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$3(element) {
    if (isInput$1(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }
  var durations = ['yearMonthDuration', 'dayTimeDuration'];
  function isDuration(typeRef) {
    return durations.includes(typeRef);
  }

  var simpleDurationEditModule = {
    __depends__: [keyboardModule, simpleModeModule],
    __init__: ['simpleDurationEdit'],
    simpleDurationEdit: ['type', SimpleDurationEdit]
  };

  // eslint-disable-next-line
  var COMPARISON_REGULAR_EXPRESSION = /^(-?(?:[0-9]|\.[0-9])+)$|^((?:<|>|=){0,2})\s*(-?(?:[0-9]|\.[0-9])+)$/;

  // eslint-disable-next-line
  var RANGE_REGULAR_EXPRESSION = /^(\[|\]){1}(-?(?:[0-9]|\.[0-9])+){1,}\.\.(-?(?:[0-9]|\.[0-9])+){1,}(\[|\]){1}$/;
  var operators = {
    equals: '=',
    less: '<',
    lessEquals: '<=',
    greater: '>',
    greaterEquals: '>='
  };
  function getOperatorName(string) {
    return keys(operators).filter(function (key) {
      return string === operators[key];
    })[0];
  }
  function parseString$2(string) {
    if (!string || isEmptyString$1(string.trim())) {
      return {
        type: 'comparison'
      };
    }
    var comparisonMatches = string.match(COMPARISON_REGULAR_EXPRESSION),
      rangeMatches = string.match(RANGE_REGULAR_EXPRESSION);
    if (comparisonMatches) {
      if (isNumber$1(comparisonMatches)) {
        return {
          type: 'comparison',
          value: parseFloat(comparisonMatches[1]),
          operator: 'equals'
        };
      } else if (isComparison(comparisonMatches)) {
        return {
          type: 'comparison',
          value: parseFloat(comparisonMatches[3]),
          operator: getOperatorName(comparisonMatches[2])
        };
      }
    } else if (rangeMatches) {
      return {
        type: 'range',
        values: [rangeMatches[2], rangeMatches[3]].map(function (value) {
          return parseFloat(value);
        }),
        start: rangeMatches[1] === ']' ? 'exclude' : 'include',
        end: rangeMatches[4] === '[' ? 'exclude' : 'include'
      };
    }
  }
  function isEmptyString$1(string) {
    return string === '';
  }
  function isNumber$1(matches) {
    return matches[0] && matches[1] && !matches[2] && !matches[3];
  }
  function isComparison(matches) {
    return matches[0] && !matches[1] && matches[2] && matches[3];
  }
  function getComparisonString(comparisonOperator, comparisonValue) {
    if (comparisonOperator === 'equals') {
      return "".concat(comparisonValue);
    } else {
      return "".concat(operators[comparisonOperator], " ").concat(comparisonValue);
    }
  }
  function getRangeString(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
    var rangeStartChar = rangeStartType === 'exclude' ? ']' : '[',
      rangeEndChar = rangeEndType === 'exclude' ? '[' : ']';
    return "".concat(rangeStartChar).concat(rangeStartValue, "..").concat(rangeEndValue).concat(rangeEndChar);
  }

  var COMPARISON = 'comparison',
    RANGE = 'range';
  var InputNumberEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(InputNumberEdit, _Component);
    var _super = _createSuper(InputNumberEdit);
    function InputNumberEdit(props, context) {
      var _this;
      _classCallCheck(this, InputNumberEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString$2(element.businessObject.text);
      if (parsedString) {
        _this.state = {
          type: parsedString.type,
          comparisonOperator: parsedString.operator || 'equals',
          comparisonValue: parsedString.value || 0,
          rangeStartValue: parsedString.values ? parsedString.values[0] : 0,
          rangeEndValue: parsedString.values ? parsedString.values[1] : 0,
          rangeStartType: parsedString.start || 'include',
          rangeEndType: parsedString.end || 'include'
        };
      } else {
        _this.state = {
          type: COMPARISON,
          comparisonOperator: 'equals',
          comparisonValue: 0,
          rangeStartValue: 0,
          rangeEndValue: 0,
          rangeStartType: 'include',
          rangeEndType: 'include'
        };
      }
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onComparisonOperatorChange = _this.onComparisonOperatorChange.bind(_assertThisInitialized(_this));
      _this.onComparisonValueChange = _this.onComparisonValueChange.bind(_assertThisInitialized(_this));
      _this.onTypeChange = _this.onTypeChange.bind(_assertThisInitialized(_this));
      _this.onRangeStartTypeChange = _this.onRangeStartTypeChange.bind(_assertThisInitialized(_this));
      _this.onRangeStartValueChange = _this.onRangeStartValueChange.bind(_assertThisInitialized(_this));
      _this.onRangeEndTypeChange = _this.onRangeEndTypeChange.bind(_assertThisInitialized(_this));
      _this.onRangeEndValueChange = _this.onRangeEndValueChange.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(InputNumberEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onTypeChange",
      value: function onTypeChange(value) {
        var element = this.props.context.element;
        var _this$state = this.state,
          comparisonOperator = _this$state.comparisonOperator,
          comparisonValue = _this$state.comparisonValue,
          rangeStartValue = _this$state.rangeStartValue,
          rangeEndValue = _this$state.rangeEndValue,
          rangeStartType = _this$state.rangeStartType,
          rangeEndType = _this$state.rangeEndType;
        if (value === COMPARISON) {
          this.editCell(element.businessObject, getComparisonString(comparisonOperator, comparisonValue));
        } else {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType));
        }
        this.setState({
          type: value
        });
      }
    }, {
      key: "onComparisonOperatorChange",
      value: function onComparisonOperatorChange(value) {
        var element = this.props.context.element;
        var _this$state2 = this.state,
          type = _this$state2.type,
          comparisonValue = _this$state2.comparisonValue;
        if (type === COMPARISON) {
          this.editCell(element.businessObject, getComparisonString(value, comparisonValue));
          this.setState({
            comparisonOperator: value
          });
        }
      }
    }, {
      key: "onComparisonValueChange",
      value: function onComparisonValueChange(comparisonValue) {
        var element = this.props.context.element;
        var _this$state3 = this.state,
          type = _this$state3.type,
          comparisonOperator = _this$state3.comparisonOperator;
        if (type === COMPARISON) {
          this.debouncedEditCell(element.businessObject, getComparisonString(comparisonOperator, comparisonValue));
          this.setState({
            comparisonValue: comparisonValue
          });
        }
      }
    }, {
      key: "onRangeStartTypeChange",
      value: function onRangeStartTypeChange(value) {
        var element = this.props.context.element;
        var _this$state4 = this.state,
          type = _this$state4.type,
          rangeStartValue = _this$state4.rangeStartValue,
          rangeEndValue = _this$state4.rangeEndValue,
          rangeEndType = _this$state4.rangeEndType;
        if (type === RANGE) {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, rangeEndValue, value, rangeEndType));
          this.setState({
            rangeStartType: value
          });
        }
      }
    }, {
      key: "onRangeStartValueChange",
      value: function onRangeStartValueChange(value) {
        var element = this.props.context.element;
        var _this$state5 = this.state,
          type = _this$state5.type,
          rangeEndValue = _this$state5.rangeEndValue,
          rangeStartType = _this$state5.rangeStartType,
          rangeEndType = _this$state5.rangeEndType;
        if (type === RANGE) {
          this.editCell(element.businessObject, getRangeString(value, rangeEndValue, rangeStartType, rangeEndType));
          this.setState({
            rangeStartValue: value
          });
        }
      }
    }, {
      key: "onRangeEndTypeChange",
      value: function onRangeEndTypeChange(value) {
        var element = this.props.context.element;
        var _this$state6 = this.state,
          type = _this$state6.type,
          rangeStartValue = _this$state6.rangeStartValue,
          rangeEndValue = _this$state6.rangeEndValue,
          rangeStartType = _this$state6.rangeStartType;
        if (type === RANGE) {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, rangeEndValue, rangeStartType, value));
          this.setState({
            rangeEndType: value
          });
        }
      }
    }, {
      key: "onRangeEndValueChange",
      value: function onRangeEndValueChange(value) {
        var element = this.props.context.element;
        var _this$state7 = this.state,
          type = _this$state7.type,
          rangeStartValue = _this$state7.rangeStartValue,
          rangeStartType = _this$state7.rangeStartType,
          rangeEndType = _this$state7.rangeEndType;
        if (type === RANGE) {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, value, rangeStartType, rangeEndType));
          this.setState({
            rangeEndValue: value
          });
        }
      }
    }, {
      key: "renderComparison",
      value: function renderComparison(comparisonOperator, comparisonValue) {
        var comparisonOperatorOptions = [{
          label: this._translate('Equals'),
          value: 'equals'
        }, {
          label: this._translate('Less'),
          value: 'less'
        }, {
          label: this._translate('Less or equals'),
          value: 'lessEquals'
        }, {
          label: this._translate('Greater'),
          value: 'greater'
        }, {
          label: this._translate('Greater or equals'),
          value: 'greaterEquals'
        }];
        return createVNode(1, "div", "comparison", [createVNode(1, "h4", "dms-heading", this._translate('Value'), 0), createVNode(1, "div", "dms-fill-row", [createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onComparisonOperatorChange,
          "options": comparisonOperatorOptions,
          "value": comparisonOperator
        }), createTextVNode("\xA0"), createComponentVNode(2, Input, {
          "className": "comparison-number-input",
          "onInput": this.onComparisonValueChange,
          "type": "number",
          "value": comparisonValue
        })], 4)], 4);
      }
    }, {
      key: "renderRange",
      value: function renderRange(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
        var rangeTypeOptions = [{
          label: this._translate('Include'),
          value: 'include'
        }, {
          label: this._translate('Exclude'),
          value: 'exclude'
        }];
        return createVNode(1, "div", "range", [createVNode(1, "h4", "dms-heading", this._translate('Start value'), 0), createVNode(1, "div", "dms-fill-row", [createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onRangeStartTypeChange,
          "options": rangeTypeOptions,
          "value": rangeStartType
        }), createTextVNode("\xA0"), createComponentVNode(2, Input, {
          "className": "range-start-number-input",
          "onInput": this.onRangeStartValueChange,
          "type": "number",
          "value": rangeStartValue
        })], 4), createVNode(1, "h4", "dms-heading", this._translate('End value'), 0), createVNode(1, "div", "dms-fill-row", [createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onRangeEndTypeChange,
          "options": rangeTypeOptions,
          "value": rangeEndType
        }), createTextVNode("\xA0"), createComponentVNode(2, Input, {
          "className": "range-end-number-input",
          "onInput": this.onRangeEndValueChange,
          "type": "number",
          "value": rangeEndValue
        })], 4)], 4);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state8 = this.state,
          type = _this$state8.type,
          comparisonOperator = _this$state8.comparisonOperator,
          comparisonValue = _this$state8.comparisonValue,
          rangeStartValue = _this$state8.rangeStartValue,
          rangeEndValue = _this$state8.rangeEndValue,
          rangeStartType = _this$state8.rangeStartType,
          rangeEndType = _this$state8.rangeEndType;
        var typeOptions = [{
          label: this._translate('Comparison'),
          value: COMPARISON
        }, {
          label: this._translate('Range'),
          value: RANGE
        }];
        return createVNode(1, "div", "context-menu-container simple-number-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit number'), 0), createVNode(1, "div", "dms-fill-row", createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onTypeChange,
          "options": typeOptions,
          "value": type
        }), 2), type === COMPARISON && this.renderComparison(comparisonOperator, comparisonValue), type === RANGE && this.renderRange(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType)], 0);
      }
    }]);
    return InputNumberEdit;
  }(Component);

  var OutputNumberEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputNumberEdit, _Component);
    var _super = _createSuper(OutputNumberEdit);
    function OutputNumberEdit(props, context) {
      var _this;
      _classCallCheck(this, OutputNumberEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString$2(element.businessObject.text);
      if (parsedString) {
        _this.state = {
          value: parsedString.value
        };
      } else {
        _this.state = {
          value: ''
        };
      }
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(OutputNumberEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onInput",
      value: function onInput(value) {
        var element = this.props.context.element;
        this.debouncedEditCell(element.businessObject, value);
        this.setState({
          value: value
        });
      }
    }, {
      key: "render",
      value: function render() {
        var value = this.state.value;
        return createVNode(1, "div", "context-menu-container simple-number-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit number'), 0), createVNode(1, "h4", "dms-heading", this._translate('Set value'), 0), createComponentVNode(2, Input, {
          "onInput": this.onInput,
          "type": "number",
          "value": value
        })], 4);
      }
    }]);
    return OutputNumberEdit;
  }(Component);

  var SimpleNumberEdit = /*#__PURE__*/_createClass(function SimpleNumberEdit(components, simpleMode) {
    _classCallCheck(this, SimpleNumberEdit);
    simpleMode.registerProvider(function (element) {
      var typeRef = getTypeRef$2(element);
      return (isInput$1(element.col) || isOutput(element.col)) && isNumber(typeRef);
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {
        if (!context.element) {
          return;
        }
        var typeRef = getTypeRef$2(context.element);
        if (isNumber(typeRef)) {
          if (isInput$1(context.element.col)) {
            return InputNumberEdit;
          } else if (isOutput(context.element.col)) {
            return OutputNumberEdit;
          }
        }
      }
    });
  });
  SimpleNumberEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$2(element) {
    if (isInput$1(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }
  var numberTypes = ['number', 'integer', 'long', 'double'];
  function isNumber(typeRef) {
    return numberTypes.includes(typeRef);
  }

  var simpleNumberEditModule = {
    __depends__: [keyboardModule, simpleModeModule],
    __init__: ['simpleNumberEdit'],
    simpleNumberEdit: ['type', SimpleNumberEdit]
  };

  /**
   * Parse input/output entry string to unary tests and type of unary tests.
   *
   * Example:
   *
   * not("foo", "bar")
   *
   * returns
   *
   * {
   *   type: 'negation',
   *   values: [ "foo", "bar, baz" ]
   * }
   *
   * @param {string} string - Input/Output entry as string e.g. "foo", "bar".
   */
  function parseString$1(string) {
    // empty string or no string at all
    if (!string || isEmptyString(string.trim())) {
      return {
        type: 'disjunction',
        values: []
      };
    }

    // disjunction
    var values = string.split(',');
    var result = {
      type: 'disjunction',
      values: []
    };
    var openString = '';
    values.forEach(function (value) {
      openString += value;
      if (/^"[^"]*"$/.test(openString.trim())) {
        result.values.push(openString.trim());
        openString = '';
      } else {
        openString += ',';
      }
    });
    if (!openString) {
      return result;
    }

    // negation
    result.type = 'negation';
    result.values = [];
    openString = '';
    var matches = string.match(/^\s*not\((.*)\)\s*$/);
    if (matches) {
      values = matches[1].split(',');
      values.forEach(function (value) {
        openString += value;
        if (/^"[^"]*"$/.test(openString.trim())) {
          result.values.push(openString.trim());
          openString = '';
        } else {
          openString += ',';
        }
      });
      if (!openString) {
        return result;
      }
    }
  }

  // TODO(philippfromme): seperate when refactoring component
  function getInputOrOutputValues(inputOrOutput) {
    var inputOrOutputValues = isInput$1(inputOrOutput) ? inputOrOutput.inputValues : inputOrOutput.outputValues;
    if (!inputOrOutputValues || isEmptyString(inputOrOutputValues.text)) {
      return [];
    } else {
      return inputOrOutputValues.text.split(',').map(function (value) {
        return value.trim();
      });
    }
  }
  function isEmptyString(string) {
    return string === '';
  }

  var DISJUNCTION = 'disjunction',
    NEGATION = 'negation';
  var INPUT_VALUES_LABEL = 'Predefined values',
    OUTPUT_VALUES_LABEL = 'Predefined values',
    INPUT_ENTRY_VALUES_LABEL = 'Custom values';
  var SimpleStringEditContextMenuComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(SimpleStringEditContextMenuComponent, _Component);
    var _super = _createSuper(SimpleStringEditContextMenuComponent);
    function SimpleStringEditContextMenuComponent(props, context) {
      var _this;
      _classCallCheck(this, SimpleStringEditContextMenuComponent);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var parsedString = parseString$1(props.context.element.businessObject.text);

      // could not parse
      if (!parsedString) {
        parsedString = {
          values: [],
          type: DISJUNCTION
        };
      }
      var inputOrOutputValues = getInputOrOutputValues(props.context.element.col.businessObject);
      var filteredValues = parsedString.values.filter(function (value) {
        return !includes(inputOrOutputValues, value);
      });
      var isInputClause = isInput$1(props.context.element.col);
      var items = inputOrOutputValues.map(function (value) {
        return {
          value: value,
          isChecked: includes(parsedString.values, value),
          isRemovable: false,
          group: isInputClause ? _this._translate(INPUT_VALUES_LABEL) : _this._translate(OUTPUT_VALUES_LABEL)
        };
      });
      if (isInputClause) {
        items = items.concat(filteredValues.map(function (value) {
          return {
            value: value,
            isChecked: true,
            isRemovable: true,
            group: _this._translate(INPUT_ENTRY_VALUES_LABEL)
          };
        }));
      }
      var inputValue = '';
      if (!isInputClause && parsedString.values.length && !includes(inputOrOutputValues, parsedString.values[0])) {
        inputValue = parsedString.values[0];
      }
      _this.state = {
        items: items,
        unaryTestsType: parsedString.type,
        inputValue: inputValue,
        isOutputValueInputChecked: inputValue !== ''
      };
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.addUnaryTestsListItem = _this.addUnaryTestsListItem.bind(_assertThisInitialized(_this));
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
      _this.onOutputValueInputClick = _this.onOutputValueInputClick.bind(_assertThisInitialized(_this));
      _this.onUnaryTestsListChanged = _this.onUnaryTestsListChanged.bind(_assertThisInitialized(_this));
      _this.onUnaryTestsTypeChange = _this.onUnaryTestsTypeChange.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(SimpleStringEditContextMenuComponent, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }

      /**
       * Change type of unary tests.
       */
    }, {
      key: "onUnaryTestsTypeChange",
      value: function onUnaryTestsTypeChange(value) {
        var items = this.state.items;
        var values = getValues(items);
        var element = this.props.context.element;
        if (value === DISJUNCTION) {
          this.editCell(element.businessObject, values.join(','));
          this.setState({
            unaryTestsType: DISJUNCTION
          });
        } else {
          this.editCell(element.businessObject, "not(".concat(values.join(','), ")"));
          this.setState({
            unaryTestsType: NEGATION
          });
        }
      }

      /**
       * Change list of unary tests.
       */
    }, {
      key: "onUnaryTestsListChanged",
      value: function onUnaryTestsListChanged(items) {
        // get checked items
        var values = getValues(items);
        var element = this.props.context.element;
        var unaryTestsType = this.state.unaryTestsType;
        if (unaryTestsType === DISJUNCTION) {
          this.editCell(element.businessObject, values.join(','));
        } else {
          this.editCell(element.businessObject, "not(".concat(values.join(','), ")"));
        }
        this.setState({
          items: items,
          isOutputValueInputChecked: false
        });
      }

      /**
       * Set output value to input value.
       */
    }, {
      key: "onOutputValueInputClick",
      value: function onOutputValueInputClick() {
        var element = this.props.context.element;
        var _this$state = this.state,
          inputValue = _this$state.inputValue,
          items = _this$state.items;
        var parsedString = parseString$1(inputValue);
        if (!parsedString || parsedString.values.length > 1) {
          return;
        }
        this.editCell(element.businessObject, "".concat(parsedString.values.join('')));

        // uncheck all other values
        this.setState({
          items: items.map(function (item) {
            item.isChecked = false;
            return item;
          }),
          isOutputValueInputChecked: true
        });
      }

      /**
       * Set output value if valid.
       */
    }, {
      key: "onInput",
      value: function onInput(_ref) {
        var isValid = _ref.isValid,
          value = _ref.value;
        var isOutputValueInputChecked = this.state.isOutputValueInputChecked;
        this.setState({
          inputValue: value
        });
        var element = this.props.context.element;
        if (!isInput$1(element) && isValid && isOutputValueInputChecked) {
          this.debouncedEditCell(element.businessObject, value);
        }
      }

      /**
       * Add new value on ENTER.
       */
    }, {
      key: "onKeyDown",
      value: function onKeyDown(_ref2) {
        var isValid = _ref2.isValid,
          event = _ref2.event;
        if (!isEnter(event.keyCode)) {
          return;
        }
        var element = this.props.context.element;
        var isInputClause = isInput$1(element.col);

        // stop ENTER propagation (and ContextMenu close)
        if (isInputClause || !isValid) {
          event.stopPropagation();
          event.preventDefault();
        }
        if (isValid) {
          if (isInputClause) {
            this.addUnaryTestsListItem();
          } else {
            this.onOutputValueInputClick();
          }
        }
      }

      /**
       * Add unary tests to list.
       */
    }, {
      key: "addUnaryTestsListItem",
      value: function addUnaryTestsListItem() {
        var _this2 = this;
        var _this$state2 = this.state,
          inputValue = _this$state2.inputValue,
          items = _this$state2.items,
          unaryTestsType = _this$state2.unaryTestsType;
        var parsedInput = parseString$1(inputValue);
        if (!parsedInput) {
          return;
        }
        var element = this.props.context.element;
        var values = getValues(items);
        var newValues = [].concat(values, parsedInput.values);
        if (unaryTestsType === DISJUNCTION) {
          this.editCell(element.businessObject, newValues.join(','));
        } else {
          this.editCell(element.businessObject, "not(".concat(newValues.join(','), ")"));
        }
        var newItems = items.concat(parsedInput.values.map(function (value) {
          return {
            value: value,
            isChecked: true,
            isRemovable: true,
            group: _this2._translate('Custom values')
          };
        }));
        this.setState({
          items: newItems,
          inputValue: ''
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;
        var element = this.props.context.element;
        var _this$state3 = this.state,
          inputValue = _this$state3.inputValue,
          isOutputValueInputChecked = _this$state3.isOutputValueInputChecked,
          items = _this$state3.items,
          unaryTestsType = _this$state3.unaryTestsType;
        var options = [{
          label: this._translate('Match one'),
          value: DISJUNCTION
        }, {
          label: this._translate('Match none'),
          value: NEGATION
        }];
        var isInputClause = isInput$1(element.col);
        var isNegation = unaryTestsType === NEGATION;
        var showRadio = !isInputClause && items.length > 0;
        return createVNode(1, "div", "simple-string-edit context-menu-container", [createVNode(1, "h3", "dms-heading", this._translate('Edit string'), 0), isInputClause && createVNode(1, "p", null, createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onUnaryTestsTypeChange,
          "options": options,
          "value": isNegation ? NEGATION : DISJUNCTION
        }, null, function (node) {
          return _this3.selectNode = node;
        }), 2), createComponentVNode(2, List, {
          "onChange": this.onUnaryTestsListChanged,
          "items": items,
          "type": isInputClause ? 'checkbox' : 'radio'
        }), isInputClause ? createVNode(1, "h4", "dms-heading", this._translate('Add values'), 0) : createVNode(1, "h4", "dms-heading", this._translate('Set value'), 0), createVNode(1, "div", "dms-fill-row", [showRadio && createVNode(64, "input", "cursor-pointer", null, 1, {
          "checked": isOutputValueInputChecked,
          "onClick": this.onOutputValueInputClick,
          "type": "radio",
          "style": {
            marginRight: '8px'
          }
        }), createComponentVNode(2, ValidatedInput, {
          "className": "dms-block",
          "onKeyDown": this.onKeyDown,
          "onInput": this.onInput,
          "placeholder": isInputClause ? this._translate('"value", "value", ...') : this._translate('"value"'),
          "type": "text",
          "validate": function validate(value) {
            if (!parseString$1(value)) {
              return _this3._translate('Strings must be in double quotes');
            }
          },
          "value": inputValue
        })], 0)], 0);
      }
    }]);
    return SimpleStringEditContextMenuComponent;
  }(Component); // helpers //////////////////////
  function isEnter(keyCode) {
    return keyCode === 13;
  }

  /**
   * Get array of actual values from array of items.
   *
   * @param {Array} items - Array of items.
   */
  function getValues(items) {
    return items.filter(function (item) {
      return item.isChecked;
    }).map(function (item) {
      return item.value;
    });
  }
  function includes(array, value) {
    return array.indexOf(value) !== -1;
  }

  var SimpleStringEdit = /*#__PURE__*/_createClass(function SimpleStringEdit(components, simpleMode) {
    _classCallCheck(this, SimpleStringEdit);
    simpleMode.registerProvider(function (element) {
      return (isInput$1(element.col) || isOutput(element.col)) && getTypeRef$1(element) === 'string';
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {
        if (!context.element) {
          return;
        }
        var typeRef = getTypeRef$1(context.element);
        if (typeRef === 'string') {
          return SimpleStringEditContextMenuComponent;
        }
      }
    });
  });
  SimpleStringEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$1(element) {
    if (isInput$1(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }

  var simpleStringEditModule = {
    __depends__: [keyboardModule, simpleModeModule],
    __init__: ['simpleStringEdit'],
    simpleStringEdit: ['type', SimpleStringEdit]
  };

  var ISO_TIME_REGEX = /^(?:\d\d:){2}\d\d(?:Z|(?:[@+-][^")]+))?$/;
  var BETWEEN_TIME_REGEX = /^\[time\("([^"]*)"\)..time\("([^"]*)"\)\]$/;
  var BEFORE_AFTER_TIME_REGEX = /^(<|>)\s*time\("([^"]*)"\)$/;
  var EXACT_TIME_REGEX = /^time\("([^"]*)"\)$/;
  var EXACT$1 = 'exact',
    BEFORE$1 = 'before',
    AFTER$1 = 'after',
    BETWEEN$1 = 'between';
  function validateISOString(string) {
    if (!ISO_TIME_REGEX.test(string.trim())) {
      return 'Time must match pattern hh:mm:ss[time zone]';
    }
  }
  function getTimeString(type, times) {
    if (type === EXACT$1) {
      return "time(\"".concat(times[0], "\")");
    } else if (type === BEFORE$1) {
      return "< time(\"".concat(times[0], "\")");
    } else if (type === AFTER$1) {
      return "> time(\"".concat(times[0], "\")");
    } else if (type === BETWEEN$1) {
      return "[time(\"".concat(times[0], "\")..time(\"").concat(times[1], "\")]");
    }
  }
  function getSampleTime() {
    var time = new Date();
    return time.toISOString().slice(11, -5) + 'Z';
  }
  function parseString(string) {
    // emtpy
    if (!string || string.trim() === '') {
      return {
        type: 'exact',
        time: ''
      };
    }

    // between
    var matches = string.match(BETWEEN_TIME_REGEX);
    if (matches) {
      return {
        type: 'between',
        times: [matches[1], matches[2]]
      };
    }

    // before or after
    matches = string.match(BEFORE_AFTER_TIME_REGEX);
    if (matches) {
      return {
        type: matches[1] === '<' ? 'before' : 'after',
        time: matches[2]
      };
    }

    // exact
    matches = string.match(EXACT_TIME_REGEX);
    if (matches) {
      return {
        type: 'exact',
        time: matches[1]
      };
    }
  }

  var EXACT = 'exact',
    BEFORE = 'before',
    AFTER = 'after',
    BETWEEN = 'between';
  var InputTimeEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(InputTimeEdit, _Component);
    var _super = _createSuper(InputTimeEdit);
    function InputTimeEdit(props, context) {
      var _this;
      _classCallCheck(this, InputTimeEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString(element.businessObject.text);
      if (parsedString) {
        var times;
        if (parsedString.time) {
          times = [parsedString.time, ''];
        } else if (parsedString.times) {
          times = parsedString.times;
        } else {
          times = ['', ''];
        }
        _this.state = {
          type: parsedString.type,
          times: times
        };
      } else {
        _this.state = {
          type: EXACT,
          times: ['', '']
        };
      }
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onTypeChange = _this.onTypeChange.bind(_assertThisInitialized(_this));
      _this.onSetStartTimeNowClick = _this.onSetStartTimeNowClick.bind(_assertThisInitialized(_this));
      _this.onSetEndTimeNowClick = _this.onSetEndTimeNowClick.bind(_assertThisInitialized(_this));
      _this.onStartTimeInput = _this.onStartTimeInput.bind(_assertThisInitialized(_this));
      _this.onEndTimeInput = _this.onEndTimeInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(InputTimeEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onTypeChange",
      value: function onTypeChange(value) {
        var element = this.props.context.element;
        var times = this.state.times;
        this.setState({
          type: value
        });
        if (parseString(getTimeString(value, times))) {
          this.editCell(element.businessObject, getTimeString(value, times));
        }
      }
    }, {
      key: "onSetStartTimeNowClick",
      value: function onSetStartTimeNowClick() {
        var element = this.props.context.element;
        var _this$state = this.state,
          times = _this$state.times,
          type = _this$state.type;
        var time = getSampleTime();
        this.setState({
          times: [time, times[1]]
        });
        if (parseString(getTimeString(type, [time, times[1]]))) {
          this.editCell(element.businessObject, getTimeString(type, [time, times[1]]));
        }
      }
    }, {
      key: "onSetEndTimeNowClick",
      value: function onSetEndTimeNowClick() {
        var element = this.props.context.element;
        var _this$state2 = this.state,
          times = _this$state2.times,
          type = _this$state2.type;
        var time = getSampleTime();
        this.setState({
          times: [times[0], time]
        });
        if (parseString(getTimeString(type, [times[0], time]))) {
          this.editCell(element.businessObject, getTimeString(type, [times[0], time]));
        }
      }
    }, {
      key: "onStartTimeInput",
      value: function onStartTimeInput(_ref) {
        var value = _ref.value;
        var element = this.props.context.element;
        var _this$state3 = this.state,
          times = _this$state3.times,
          type = _this$state3.type;
        this.setState({
          times: [value, times[1]]
        });
        this.debouncedEditCell(element.businessObject, getTimeString(type, [value, times[1]]));
      }
    }, {
      key: "onEndTimeInput",
      value: function onEndTimeInput(_ref2) {
        var value = _ref2.value;
        var element = this.props.context.element;
        var _this$state4 = this.state,
          times = _this$state4.times,
          type = _this$state4.type;
        this.setState({
          times: [times[0], value]
        });
        this.debouncedEditCell(element.businessObject, getTimeString(type, [times[0], value]));
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$state5 = this.state,
          times = _this$state5.times,
          type = _this$state5.type;
        var options = [{
          label: this._translate('Exactly'),
          value: EXACT
        }, {
          label: this._translate('Before'),
          value: BEFORE
        }, {
          label: this._translate('After'),
          value: AFTER
        }, {
          label: this._translate('Between'),
          value: BETWEEN
        }];
        return createVNode(1, "div", "context-menu-container simple-time-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit time'), 0), createVNode(1, "div", "dms-fill-row", createComponentVNode(2, InputSelect, {
          "noInput": true,
          "onChange": this.onTypeChange,
          "options": options,
          "value": type
        }), 2), createVNode(1, "h4", "dms-heading", type === BETWEEN ? this._translate('Edit start time') : this._translate('Set time'), 0), createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "className": "start-time-input dms-block",
          "onInput": this.onStartTimeInput,
          "placeholder": this._translate('e.g. { example } ', {
            example: getSampleDate$1()
          }),
          "validate": function validate(string) {
            return validateISOString(string) && _this2._translate(validateISOString(string));
          },
          "value": times[0]
        }), createVNode(1, "p", "dms-hint", [createVNode(1, "button", "use-now", this._translate('Use now'), 0, {
          "type": "button",
          "onClick": this.onSetStartTimeNowClick
        }), createTextVNode(".")], 4)], 4), type === BETWEEN && createVNode(1, "h4", "dms-heading", this._translate('Edit end time'), 0), type === BETWEEN && createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "className": "end-time-input dms-block",
          "onInput": this.onEndTimeInput,
          "placeholder": this._translate('e.g. { example } ', {
            example: getSampleDate$1()
          }),
          "validate": function validate(string) {
            return validateISOString(string) && _this2._translate(validateISOString(string));
          },
          "value": times[1]
        }), createVNode(1, "p", "dms-hint", [createVNode(1, "button", "use-now", this._translate('Use now'), 0, {
          "type": "button",
          "onClick": this.onSetEndTimeNowClick
        }), createTextVNode(".")], 4)], 4)], 0);
      }
    }]);
    return InputTimeEdit;
  }(Component);

  var OutputTimeEdit = /*#__PURE__*/function (_Component) {
    _inherits$1(OutputTimeEdit, _Component);
    var _super = _createSuper(OutputTimeEdit);
    function OutputTimeEdit(props, context) {
      var _this;
      _classCallCheck(this, OutputTimeEdit);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._modeling = context.injector.get('modeling');
      var element = _this.props.context.element;
      var parsedString = parseString(element.businessObject.text);
      _this.state = {
        date: parsedString ? parsedString.date : ''
      };
      var debounceInput = context.injector.get('debounceInput');
      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_assertThisInitialized(_this)));
      _this.editCell = _this.editCell.bind(_assertThisInitialized(_this));
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(OutputTimeEdit, [{
      key: "editCell",
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: "onClick",
      value: function onClick() {
        var element = this.props.context.element;
        var date = getSampleTime();
        this.setState({
          date: date
        });
        this.editCell(element.businessObject, "time(\"".concat(date, "\")"));
      }
    }, {
      key: "onInput",
      value: function onInput(_ref) {
        var value = _ref.value;
        var element = this.props.context.element;
        this.setState({
          date: value
        });
        this.debouncedEditCell(element.businessObject, "time(\"".concat(value, "\")"));
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var date = this.state.date;
        return createVNode(1, "div", "context-menu-container simple-time-edit", [createVNode(1, "h3", "dms-heading", this._translate('Edit date'), 0), createVNode(1, "h4", "dms-heading", this._translate('Set date'), 0), createVNode(1, "div", null, [createComponentVNode(2, ValidatedInput, {
          "onInput": this.onInput,
          "placeholder": this._translate('e.g. { example } ', {
            example: getSampleDate$1()
          }),
          "validate": function validate(string) {
            return validateISOString(string) && _this2._translate(validateISOString(string));
          },
          "value": date,
          "className": "dms-block"
        }), createVNode(1, "p", "dms-hint", [createVNode(1, "button", "use-now", this._translate('Use now'), 0, {
          "type": "button",
          "onClick": this.onClick
        }), createTextVNode(".")], 4)], 4)], 4);
      }
    }]);
    return OutputTimeEdit;
  }(Component);

  var SimpleDateEdit = /*#__PURE__*/_createClass(function SimpleDateEdit(components, simpleMode) {
    _classCallCheck(this, SimpleDateEdit);
    simpleMode.registerProvider(function (element) {
      var typeRef = getTypeRef(element);
      return (isInput$1(element.col) || isOutput(element.col)) && isTime(typeRef);
    });
    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {
        if (!context.element) {
          return;
        }
        var typeRef = getTypeRef(context.element);
        if (isTime(typeRef)) {
          if (isInput$1(context.element.col)) {
            return InputTimeEdit;
          } else if (isOutput(context.element.col)) {
            return OutputTimeEdit;
          }
        }
      }
    });
  });
  SimpleDateEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef(element) {
    if (isInput$1(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }
  function isTime(typeRef) {
    return typeRef === 'time';
  }

  var simpleTimeEditModule = {
    __depends__: [keyboardModule, simpleModeModule],
    __init__: ['simpleTimeEdit'],
    simpleTimeEdit: ['type', SimpleDateEdit]
  };

  function _defineProperty$4(obj, key, value) {
    key = _toPropertyKey$4(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$4(arg) {
    var key = _toPrimitive$4(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$4(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ResizeColumn = /*#__PURE__*/function (_Component) {
    _inherits$1(ResizeColumn, _Component);
    var _super = _createSuper(ResizeColumn);
    function ResizeColumn(props, context) {
      var _this;
      _classCallCheck(this, ResizeColumn);
      _this = _super.call(this, props, context);
      _defineProperty$4(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$4(_assertThisInitialized(_this), "handleMouseDown", function (event) {
        var cell = closest(event.target, 'th', false);
        startResize({
          node: cell,
          event: event,
          minWidth: _this.props.minWidth || 150,
          onEnd: _this.saveWidth
        });
      });
      _defineProperty$4(_assertThisInitialized(_this), "saveWidth", function (newWidth) {
        var col = _this.props.col;
        var update = {};
        if (is$1(col, 'dmn:DecisionTable')) {
          update.annotationsWidth = newWidth;
        } else {
          update.width = newWidth;
        }
        _this.modeling.updateProperties(col, update);
      });
      inject(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(ResizeColumn, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var root = this.getRoot();
        this.changeSupport.onElementsChanged(root, this.onElementsChanged);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var root = this.getRoot();
        this.changeSupport.offElementsChanged(root, this.onElementsChanged);
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this.sheet.getRoot();
      }
    }, {
      key: "isLastInputOrOutput",
      value: function isLastInputOrOutput() {
        var col = this.props.col,
          root = this.getRoot(),
          bo = getBusinessObject(root);
        if (is$1(col, 'dmn:InputClause')) {
          var inputs = bo.get('input');
          return inputs.indexOf(col) === inputs.length - 1;
        } else if (is$1(col, 'dmn:OutputClause')) {
          var outputs = bo.get('output');
          return outputs.indexOf(col) === outputs.length - 1;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var style = this.isLastInputOrOutput() ? {
          right: '-7px',
          width: '27px'
        } : null;
        return createVNode(1, "div", "resize-column-handle", null, 1, {
          "onMouseDown": this.handleMouseDown,
          "title": this.translate('Resize'),
          "style": style
        });
      }
    }]);
    return ResizeColumn;
  }(Component);
  ResizeColumn.$inject = ['sheet', 'changeSupport', 'translate', 'modeling'];

  // helper
  function startResize(_ref) {
    var node = _ref.node,
      event = _ref.event,
      minWidth = _ref.minWidth,
      _ref$onEnd = _ref.onEnd,
      onEnd = _ref$onEnd === void 0 ? noop : _ref$onEnd;
    event.preventDefault();
    var initialWidth = node.getBoundingClientRect().width;
    var initialX = event.clientX;
    var currentUpdate;
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    function handleMouseMove(event) {
      event.preventDefault();
      var currentWidth = getResizedWidth(event.clientX);
      if (currentUpdate) {
        cancelAnimationFrame(currentUpdate);
      }
      currentUpdate = requestAnimationFrame(function () {
        node.style.width = currentWidth + 'px';
      });
    }
    function handleMouseUp(event) {
      event.preventDefault();
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      var currentWidth = getResizedWidth(event.clientX);
      onEnd(currentWidth);
    }
    function getResizedWidth(currentX) {
      var delta = currentX - initialX;
      return Math.max(initialWidth + delta, minWidth);
    }
  }
  function noop() {}

  function ColumnResizeProvider(components) {
    components.onGetComponent('cell-inner', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var cellType = context.cellType;
      if (cellType === 'input-cell' || cellType === 'output-cell' || cellType === 'annotations') {
        return ResizeColumn;
      }
    });
  }
  ColumnResizeProvider.$inject = ['components'];

  var columnResizeModule = {
    __init__: ['columnResizeProvider'],
    columnResizeProvider: ['type', ColumnResizeProvider]
  };

  var Editor$2 = /*#__PURE__*/function (_Viewer) {
    _inherits$1(Editor, _Viewer);
    var _super = _createSuper(Editor);
    function Editor() {
      _classCallCheck(this, Editor);
      return _super.apply(this, arguments);
    }
    _createClass(Editor, [{
      key: "getModules",
      value: function getModules() {
        return [].concat(_toConsumableArray(Viewer$2._getModules()), _toConsumableArray(Editor._getModules()));
      }
    }], [{
      key: "_getModules",
      value: function _getModules() {
        return [addRuleModule, annotationsEditorModule, cellSelectionModule, contextMenuModule, copyCutPasteModule, copyCutPasteKeybindingsModule, createInputsModule, DataTypesModule, decisionTableContextMenu, decisionTableEditorActionsModule, decisionTableHeadEditorModule, columnResizeModule, dragAndDropModule, descriptionModule, expressionLanguageModule, ExpressionLanguagesModule, keyboardModule, tablePropertiesEditorModule, editorActionsModule, hitPolicyEditorModule, interactionEventsModule, modelingModule, decisionRulesEditorModule, selectionModule, simpleModeModule, simpleBooleanEditModule, simpleDateEditModule, simpleDateTimeEditModule, simpleDurationEditModule, simpleNumberEditModule, simpleStringEditModule, simpleTimeEditModule, DmnVariableResolverModule];
      }
    }]);
    return Editor;
  }(Viewer$2);

  var ChangeSupport = /*#__PURE__*/function () {
    function ChangeSupport(eventBus) {
      var _this = this;
      _classCallCheck(this, ChangeSupport);
      this._listeners = {};
      eventBus.on('elements.changed', function (_ref) {
        var elements = _ref.elements;
        _this.elementsChanged(elements);
      });
      eventBus.on('element.updateId', function (_ref2) {
        var element = _ref2.element,
          newId = _ref2.newId;
        _this.updateId(element.id, newId);
      });
    }
    _createClass(ChangeSupport, [{
      key: "elementsChanged",
      value: function elementsChanged(elements) {
        var invoked = {};
        var elementsLength = elements.length;
        for (var i = 0; i < elementsLength; i++) {
          var id = elements[i].id;
          if (invoked[id]) {
            return;
          }
          invoked[id] = true;
          var listenersLength = this._listeners[id] && this._listeners[id].length;
          if (listenersLength) {
            for (var j = 0; j < listenersLength; j++) {
              // listeners might remove themselves before they get called
              this._listeners[id][j] && this._listeners[id][j]();
            }
          }
        }
      }
    }, {
      key: "onElementsChanged",
      value: function onElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          this._listeners[id] = [];
        }

        // avoid push for better performance
        this._listeners[id][this._listeners[id].length] = listener;
      }
    }, {
      key: "offElementsChanged",
      value: function offElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          return;
        }
        if (listener) {
          var idx = this._listeners[id].indexOf(listener);
          if (idx !== -1) {
            this._listeners[id].splice(idx, 1);
          }
        } else {
          this._listeners[id].length = 0;
        }
      }
    }, {
      key: "updateId",
      value: function updateId(oldId, newId) {
        if (this._listeners[oldId]) {
          this._listeners[newId] = this._listeners[oldId];
          delete this._listeners[oldId];
        }
      }
    }]);
    return ChangeSupport;
  }();
  ChangeSupport.$inject = ['eventBus'];

  var DEFAULT_PRIORITY = 1000;
  var Components = /*#__PURE__*/function () {
    function Components() {
      _classCallCheck(this, Components);
      this._listeners = {};
    }
    _createClass(Components, [{
      key: "getComponent",
      value: function getComponent(type, context) {
        var listeners = this._listeners[type];
        if (!listeners) {
          return;
        }
        var component;
        for (var i = 0; i < listeners.length; i++) {
          component = listeners[i].callback(context);
          if (component) {
            break;
          }
        }
        return component;
      }
    }, {
      key: "getComponents",
      value: function getComponents(type, context) {
        var listeners = this._listeners[type];
        if (!listeners) {
          return;
        }
        var components = [];
        for (var i = 0; i < listeners.length; i++) {
          var component = listeners[i].callback(context);
          if (component) {
            components.push(component);
          }
        }
        if (!components.length) {
          return;
        }
        return components;
      }
    }, {
      key: "onGetComponent",
      value: function onGetComponent(type, priority, callback) {
        if (isFunction$2(priority)) {
          callback = priority;
          priority = DEFAULT_PRIORITY;
        }
        if (!isNumber$3(priority)) {
          throw new Error('priority must be a number');
        }
        var listeners = this._getListeners(type);
        var existingListener, idx;
        var newListener = {
          priority: priority,
          callback: callback
        };
        for (idx = 0; existingListener = listeners[idx]; idx++) {
          if (existingListener.priority < priority) {
            // prepend newListener at before existingListener
            listeners.splice(idx, 0, newListener);
            return;
          }
        }
        listeners.push(newListener);
      }
    }, {
      key: "offGetComponent",
      value: function offGetComponent(type, callback) {
        var listeners = this._getListeners(type);
        var listener, listenerCallback, idx;
        if (callback) {
          // move through listeners from back to front
          // and remove matching listeners
          for (idx = listeners.length - 1; listener = listeners[idx]; idx--) {
            listenerCallback = listener.callback;
            if (listenerCallback === callback) {
              listeners.splice(idx, 1);
            }
          }
        } else {
          // clear listeners
          listeners.length = 0;
        }
      }
    }, {
      key: "_getListeners",
      value: function _getListeners(type) {
        var listeners = this._listeners[type];
        if (!listeners) {
          this._listeners[type] = listeners = [];
        }
        return listeners;
      }
    }]);
    return Components;
  }();

  var ViewerComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(ViewerComponent, _Component);
    var _super = _createSuper(ViewerComponent);
    function ViewerComponent(props) {
      var _this;
      _classCallCheck(this, ViewerComponent);
      _this = _super.call(this, props);
      var injector = _this._injector = props.injector;
      _this._changeSupport = injector.get('changeSupport');
      _this._components = injector.get('components');
      _this._renderer = injector.get('renderer');
      return _this;
    }
    _createClass(ViewerComponent, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          changeSupport: this._changeSupport,
          components: this._components,
          renderer: this._renderer,
          injector: this._injector
        };
      }
    }, {
      key: "render",
      value: function render() {
        var components = this._components.getComponents('viewer');
        return createVNode(1, "div", "viewer-container", components && components.map(function (Component, index) {
          return createComponentVNode(2, Component, null, index);
        }), 0);
      }
    }]);
    return ViewerComponent;
  }(Component);

  var Renderer = /*#__PURE__*/function () {
    function Renderer(changeSupport, components, config, eventBus, injector) {
      _classCallCheck(this, Renderer);
      var container = config.container;
      this._container = container;
      eventBus.on('renderer.mount', function () {
        render(createComponentVNode(2, ViewerComponent, {
          "injector": injector
        }), container);
      });
      eventBus.on('renderer.unmount', function () {
        render(null, container);
      });
    }
    _createClass(Renderer, [{
      key: "getContainer",
      value: function getContainer() {
        return this._container;
      }
    }]);
    return Renderer;
  }();
  Renderer.$inject = ['changeSupport', 'components', 'config.renderer', 'eventBus', 'injector'];

  var core = {
    __init__: ['changeSupport', 'components', 'renderer'],
    changeSupport: ['type', ChangeSupport],
    components: ['type', Components],
    eventBus: ['type', EventBus],
    renderer: ['type', Renderer]
  };

  var _excluded$1 = ["modules"];
  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$1(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  /**
   * A base for React-style viewers.
   */
  var Viewer$1 = /*#__PURE__*/function () {
    function Viewer() {
      _classCallCheck(this, Viewer);
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var injector = options.injector;
      if (!injector) {
        var _this$_init = this._init(options),
          modules = _this$_init.modules,
          config = _this$_init.config;
        injector = createInjector(config, modules);
      }
      this.get = injector.get;
      this.invoke = injector.invoke;
      this.get('eventBus').fire('viewer.init');
    }

    /**
     * Intialize and return modules and config used for creation.
     *
     * @param  {Object} options
     *
     * @return {Object} { modules=[], config }
     */
    _createClass(Viewer, [{
      key: "_init",
      value: function _init(options) {
        var modules = options.modules,
          config = _objectWithoutProperties$1(options, _excluded$1);
        return {
          modules: modules,
          config: config
        };
      }

      /**
       * Destroy. This results in removing the attachment from the container.
       */
    }, {
      key: "destroy",
      value: function destroy() {
        var eventBus = this.get('eventBus');
        eventBus.fire('viewer.destroy');
      }

      /**
       * Clear. Should be used to reset the state of any stateful services.
       */
    }, {
      key: "clear",
      value: function clear() {
        var eventBus = this.get('eventBus');
        eventBus.fire('viewer.clear');
      }
    }]);
    return Viewer;
  }(); // helpers //////////////////////
  function createInjector(config, modules) {
    var bootstrapModules = [{
      config: ['value', config]
    }, core].concat(modules || []);
    var injector = new Injector(bootstrapModules);
    injector.init();
    return injector;
  }

  /**
   * A single decision element registry.
   *
   * The sole purpose of this service is to provide the necessary API
   * to serve shared components, i.e. the UpdatePropertiesHandler.
   */
  var ElementRegistry = /*#__PURE__*/function () {
    function ElementRegistry(viewer, eventBus) {
      _classCallCheck(this, ElementRegistry);
      this._eventBus = eventBus;
      this._viewer = viewer;
    }
    _createClass(ElementRegistry, [{
      key: "getDecision",
      value: function getDecision() {
        return this._viewer.getDecision();
      }
    }, {
      key: "updateId",
      value: function updateId(element, newId) {
        var decision = this.getDecision();
        if (element !== decision) {
          throw new Error('element !== decision');
        }
        this._eventBus.fire('element.updateId', {
          element: element,
          newId: newId
        });
        element.id = newId;
      }
    }]);
    return ElementRegistry;
  }();
  ElementRegistry.$inject = ['viewer', 'eventBus'];

  var CoreModule = {
    __init__: ['elementRegistry'],
    elementRegistry: ['type', ElementRegistry]
  };

  var DecisionPropertiesComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionPropertiesComponent, _Component);
    var _super = _createSuper(DecisionPropertiesComponent);
    function DecisionPropertiesComponent(props, context) {
      var _this;
      _classCallCheck(this, DecisionPropertiesComponent);
      _this = _super.call(this, props, context);
      _this._viewer = context.injector.get('viewer');
      return _this;
    }
    _createClass(DecisionPropertiesComponent, [{
      key: "render",
      value: function render() {
        // there is only one single element
        var _this$_viewer$getDeci = this._viewer.getDecision(),
          name = _this$_viewer$getDeci.name;
        return createVNode(1, "div", "decision-properties", createVNode(1, "h3", "decision-name", name, 0), 2);
      }
    }]);
    return DecisionPropertiesComponent;
  }(Component);

  var HIGH_PRIORITY$1 = 1500;
  var DecisionProperties$1 = /*#__PURE__*/_createClass(function DecisionProperties(components) {
    _classCallCheck(this, DecisionProperties);
    components.onGetComponent('viewer', HIGH_PRIORITY$1, function () {
      return DecisionPropertiesComponent;
    });
  });
  DecisionProperties$1.$inject = ['components'];

  var DecisionPropertiesModule = {
    __init__: ['decisionProperties'],
    decisionProperties: ['type', DecisionProperties$1]
  };

  var LiteralExpressionPropertiesComponent$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(LiteralExpressionPropertiesComponent, _Component);
    var _super = _createSuper(LiteralExpressionPropertiesComponent);
    function LiteralExpressionPropertiesComponent(props, context) {
      var _this;
      _classCallCheck(this, LiteralExpressionPropertiesComponent);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._viewer = context.injector.get('viewer');
      return _this;
    }
    _createClass(LiteralExpressionPropertiesComponent, [{
      key: "render",
      value: function render() {
        var _this$_viewer$getDeci = this._viewer.getDecision(),
          literalExpression = _this$_viewer$getDeci.decisionLogic,
          variable = _this$_viewer$getDeci.variable;
        return createVNode(1, "div", "literal-expression-properties", createVNode(1, "table", null, [createVNode(1, "tr", null, [createVNode(1, "td", null, this._translate('Variable name:'), 0), createVNode(1, "td", null, createVNode(1, "span", null, variable.name || '-', 0), 2)], 4), createVNode(1, "tr", null, [createVNode(1, "td", null, this._translate('Variable type:'), 0), createVNode(1, "td", null, createVNode(1, "span", null, this._translate(variable.typeRef || '') || '-', 0), 2)], 4), createVNode(1, "tr", null, [createVNode(1, "td", null, this._translate('Expression language:'), 0), createVNode(1, "td", null, createVNode(1, "span", null, literalExpression.expressionLanguage || '-', 0), 2)], 4)], 4), 2);
      }
    }]);
    return LiteralExpressionPropertiesComponent;
  }(Component);

  var LOW_PRIORITY$1 = 500;
  var DecisionProperties = /*#__PURE__*/_createClass(function DecisionProperties(components) {
    _classCallCheck(this, DecisionProperties);
    components.onGetComponent('viewer', LOW_PRIORITY$1, function () {
      return LiteralExpressionPropertiesComponent$1;
    });
  });
  DecisionProperties.$inject = ['components'];

  var LiteralExpressionPropertiesModule = {
    __depends__: [],
    __init__: ['literalExpressionProperties'],
    literalExpressionProperties: ['type', DecisionProperties]
  };

  function _defineProperty$3(obj, key, value) {
    key = _toPropertyKey$3(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$3(arg) {
    var key = _toPrimitive$3(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$3(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var PoweredByLogoComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(PoweredByLogoComponent, _Component);
    var _super = _createSuper(PoweredByLogoComponent);
    function PoweredByLogoComponent(props, context) {
      var _this;
      _classCallCheck(this, PoweredByLogoComponent);
      _this = _super.call(this, props, context);
      _defineProperty$3(_assertThisInitialized(_this), "onClick", function () {
        _this._eventBus.fire('poweredBy.show');
      });
      var injector = context.injector;
      _this._eventBus = injector.get('eventBus');
      return _this;
    }
    _createClass(PoweredByLogoComponent, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        return createVNode(1, "div", "powered-by", createVNode(1, "div", "powered-by__logo", createComponentVNode(2, Logo), 2), 2, {
          "onClick": this.onClick,
          "title": "Powered by bpmn.io"
        }, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);
    return PoweredByLogoComponent;
  }(Component);

  var PoweredByOverlayComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(PoweredByOverlayComponent, _Component);
    var _super = _createSuper(PoweredByOverlayComponent);
    function PoweredByOverlayComponent(props) {
      var _this;
      _classCallCheck(this, PoweredByOverlayComponent);
      _this = _super.call(this, props);
      _this.state = {
        show: false
      };
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      _this.onShow = _this.onShow.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(PoweredByOverlayComponent, [{
      key: "onClick",
      value: function onClick() {
        this.setState({
          show: false
        });
      }
    }, {
      key: "onShow",
      value: function onShow() {
        this.setState({
          show: true
        });
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        var eventBus = this._eventBus = this.context.injector.get('eventBus');
        eventBus.on('poweredBy.show', this.onShow);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._eventBus.off('poweredBy.show', this.onShow);
      }
    }, {
      key: "render",
      value: function render() {
        var show = this.state.show;
        return show && createVNode(1, "div", "powered-by-overlay", createVNode(1, "div", "powered-by-overlay-content", [createVNode(1, "a", "logo", createComponentVNode(2, Logo), 2, {
          "href": "https://bpmn.io",
          "target": "_blank",
          "rel": "noopener"
        }), createVNode(1, "span", null, [createTextVNode("Web-based tooling for BPMN, DMN and CMMN diagrams powered by "), createVNode(1, "a", null, createTextVNode("bpmn.io"), 2, {
          "href": "http://bpmn.io",
          "target": "_blank"
        }), createTextVNode(".")], 4)], 4, {
          "onClick": function onClick(e) {
            return e.stopPropagation();
          }
        }), 2, {
          "onClick": this.onClick
        });
      }
    }]);
    return PoweredByOverlayComponent;
  }(Component);

  var HIGHER_PRIORITY = 2000;
  var PoweredBy = /*#__PURE__*/_createClass(function PoweredBy(components, eventBus) {
    _classCallCheck(this, PoweredBy);
    components.onGetComponent('viewer', HIGHER_PRIORITY, function () {
      return PoweredByLogoComponent;
    });
    components.onGetComponent('viewer', function () {
      return PoweredByOverlayComponent;
    });
  });
  PoweredBy.$inject = ['components', 'eventBus'];

  var PoweredByModule = {
    __init__: ['poweredBy'],
    poweredBy: ['type', PoweredBy]
  };

  var TextareaComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(TextareaComponent, _Component);
    var _super = _createSuper(TextareaComponent);
    function TextareaComponent(props, context) {
      var _this;
      _classCallCheck(this, TextareaComponent);
      _this = _super.call(this, props, context);
      _this._viewer = context.injector.get('viewer');
      return _this;
    }
    _createClass(TextareaComponent, [{
      key: "render",
      value: function render() {
        var text = this._viewer.getDecision().decisionLogic.text;
        return createVNode(1, "div", "textarea", createVNode(1, "div", "content", text, 0), 2);
      }
    }]);
    return TextareaComponent;
  }(Component);

  var Textarea$1 = /*#__PURE__*/_createClass(function Textarea(components) {
    _classCallCheck(this, Textarea);
    components.onGetComponent('viewer', function () {
      return TextareaComponent;
    });
  });
  Textarea$1.$inject = ['components'];

  var TextareaModule = {
    __init__: ['textarea'],
    textarea: ['type', Textarea$1]
  };

  function _defineProperty$2(obj, key, value) {
    key = _toPropertyKey$2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$2(arg) {
    var key = _toPrimitive$2(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$2(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ViewDrdComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(ViewDrdComponent, _Component);
    var _super = _createSuper(ViewDrdComponent);
    function ViewDrdComponent(props, context) {
      var _this;
      _classCallCheck(this, ViewDrdComponent);
      _this = _super.call(this, props, context);
      _defineProperty$2(_assertThisInitialized(_this), "onClick", function () {
        _this._eventBus.fire('showDrd');
      });
      var injector = context.injector;
      _this._translate = injector.get('translate');
      _this._eventBus = injector.get('eventBus');
      return _this;
    }
    _createClass(ViewDrdComponent, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        return createVNode(1, "div", "view-drd", createVNode(1, "button", "view-drd-button", this._translate('View DRD'), 0, {
          "type": "button",
          "onClick": this.onClick
        }), 2, null, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);
    return ViewDrdComponent;
  }(Component);
  ViewDrdComponent.$inject = ['translate'];

  var VERY_HIGH_PRIORITY = 2000;
  var ViewDrd = /*#__PURE__*/function () {
    function ViewDrd(components, viewer, eventBus, injector) {
      var _this = this;
      _classCallCheck(this, ViewDrd);
      this._injector = injector;
      this._viewer = viewer;
      components.onGetComponent('viewer', VERY_HIGH_PRIORITY, function () {
        if (_this.canViewDrd()) {
          return ViewDrdComponent;
        }
      });
      eventBus.on('showDrd', function () {
        var parent = injector.get('_parent', false);

        // there is only one single element
        var definitions = _this.getDefinitions();

        // open definitions
        var view = parent.getView(definitions);
        parent.open(view);
      });
    }
    _createClass(ViewDrd, [{
      key: "canViewDrd",
      value: function canViewDrd() {
        var parent = this._injector.get('_parent', false);
        if (!parent) {
          return;
        }

        // there is only one single element
        var definitions = this.getDefinitions();
        return !!parent.getView(definitions);
      }
    }, {
      key: "getDefinitions",
      value: function getDefinitions() {
        return _getDefinitions(this._viewer.getDecision());
      }
    }]);
    return ViewDrd;
  }();
  ViewDrd.$inject = ['components', 'viewer', 'eventBus', 'injector'];

  // helpers //////////////////////

  function _getDefinitions(decision) {
    var definitions = decision.$parent;
    return definitions;
  }

  var ViewDrdModule = {
    __init__: ['viewDrd'],
    viewDrd: ['type', ViewDrd]
  };

  var _excluded = ["modules", "additionalModules"];
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  /**
   * @typedef {import('dmn-js-shared/lib/base/View).OpenResult} OpenResult
   */

  /**
   * @typedef {import('dmn-js-shared/lib/base/View).OpenError} OpenError
   */
  var Viewer = /*#__PURE__*/function (_BaseViewer) {
    _inherits$1(Viewer, _BaseViewer);
    var _super = _createSuper(Viewer);
    function Viewer() {
      var _this;
      _classCallCheck(this, Viewer);
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var container = Viewer._createContainer();
      _this = _super.call(this, assign$4(options, {
        renderer: {
          container: container
        }
      }));
      _this._container = container;
      return _this;
    }

    /**
     * Open diagram element.
     *
     * @param  {ModdleElement} decision
     * @returns {Promise} Resolves with {OpenResult} when successful
     * or rejects with {OpenError}
     */
    _createClass(Viewer, [{
      key: "open",
      value: function open(decision) {
        var self = this;
        return new Promise(function (resolve, reject) {
          var err;

          // use try/catch to not swallow synchronous exceptions
          // that may be raised during model parsing
          try {
            if (self._decision) {
              // clear existing literal expression
              self.clear();

              // unmount first
              self.get('eventBus').fire('renderer.unmount');
            }

            // update literal expression
            self._decision = decision;

            // let others know about import
            self.get('eventBus').fire('import', decision);
            self.get('eventBus').fire('renderer.mount');
          } catch (e) {
            err = e;
          }

          // handle synchronously thrown exception
          if (err) {
            err.warnings = err.warnings || [];
            reject(err);
          } else {
            resolve({
              warnings: []
            });
          }
        });
      }

      /**
       * Initialize the literal expression, returning { modules: [], config }.
       *
       * @param  {Object} options
       *
       * @return {Object} init config
       */
    }, {
      key: "_init",
      value: function _init(options) {
        var modules = options.modules,
          additionalModules = options.additionalModules,
          config = _objectWithoutProperties(options, _excluded);
        var baseModules = modules || this.getModules();
        var extraModules = additionalModules || [];
        var staticModules = [{
          viewer: ['value', this]
        }];
        var allModules = [].concat(_toConsumableArray(baseModules), _toConsumableArray(extraModules), staticModules);
        return {
          modules: allModules,
          config: config
        };
      }

      /**
       * Register an event listener
       *
       * Remove a previously added listener via {@link #off(event, callback)}.
       *
       * @param {string} event
       * @param {number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */
    }, {
      key: "on",
      value: function on(event, priority, callback, target) {
        return this.get('eventBus').on(event, priority, callback, target);
      }

      /**
       * De-register an event listener
       *
       * @param {string} event
       * @param {Function} callback
       */
    }, {
      key: "off",
      value: function off(event, callback) {
        this.get('eventBus').off(event, callback);
      }

      /**
       * Emit an event on the underlying {@link EventBus}
       *
       * @param  {string} type
       * @param  {Object} event
       *
       * @return {Object} event processing result (if any)
       */
    }, {
      key: "_emit",
      value: function _emit(type, event) {
        return this.get('eventBus').fire(type, event);
      }

      /**
       * Returns the currently displayed decision.
       *
       * @return {ModdleElement}
       */
    }, {
      key: "getDecision",
      value: function getDecision() {
        return this._decision;
      }

      /**
       * Attach viewer to given parent node.
       *
       * @param  {Element} parentNode
       */
    }, {
      key: "attachTo",
      value: function attachTo(parentNode) {
        if (!parentNode) {
          throw new Error('parentNode required');
        }

        // ensure we detach from the
        // previous, old parent
        this.detach();
        parentNode.appendChild(this._container);
        this._emit('attach', {});
      }

      /**
       * Detach viewer from parent node, if attached.
       */
    }, {
      key: "detach",
      value: function detach() {
        var container = this._container,
          parentNode = container.parentNode;
        if (!parentNode) {
          return;
        }
        this._emit('detach', {});
        remove$4(container);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(Viewer.prototype), "destroy", this).call(this);
        this.detach();
      }
    }, {
      key: "getModules",
      value: function getModules() {
        return Viewer._getModules();
      }
    }], [{
      key: "_getModules",
      value: function _getModules() {
        return [CoreModule, TranslateModule, DecisionPropertiesModule, LiteralExpressionPropertiesModule, PoweredByModule, TextareaModule, ViewDrdModule];
      }
    }, {
      key: "_createContainer",
      value: function _createContainer() {
        return domify$1('<div class="dmn-literal-expression-container"></div>');
      }
    }]);
    return Viewer;
  }(Viewer$1);

  function _defineProperty$1(obj, key, value) {
    key = _toPropertyKey$1(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey$1(arg) {
    var key = _toPrimitive$1(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive$1(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var DecisionPropertiesEditorComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(DecisionPropertiesEditorComponent, _Component);
    var _super = _createSuper(DecisionPropertiesEditorComponent);
    function DecisionPropertiesEditorComponent(props, context) {
      var _this;
      _classCallCheck(this, DecisionPropertiesEditorComponent);
      _this = _super.call(this, props, context);
      _defineProperty$1(_assertThisInitialized(_this), "onElementsChanged", function () {
        _this.forceUpdate();
      });
      _defineProperty$1(_assertThisInitialized(_this), "setDecisionName", function (name) {
        _this._modeling.editDecisionName(name);
      });
      _this._viewer = context.injector.get('viewer');
      _this._modeling = context.injector.get('modeling');
      _this.setupChangeListeners({
        bind: _this.getDecision().id
      });
      return _this;
    }
    _createClass(DecisionPropertiesEditorComponent, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.setupChangeListeners({
          unbind: this.getDecision().id
        });
      }
    }, {
      key: "getDecision",
      value: function getDecision() {
        return this._viewer.getDecision();
      }
    }, {
      key: "setupChangeListeners",
      value: function setupChangeListeners(_ref) {
        var bind = _ref.bind,
          unbind = _ref.unbind;
        var changeSupport = this.context.changeSupport;
        if (typeof unbind === 'string') {
          changeSupport.offElementsChanged(unbind, this.onElementsChanged);
        }
        if (typeof bind === 'string') {
          changeSupport.onElementsChanged(bind, this.onElementsChanged);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$getDecision = this.getDecision(),
          name = _this$getDecision.name;
        return createVNode(1, "header", "decision-properties", createComponentVNode(2, DecisionName, {
          "className": "decision-name editor",
          "value": name,
          "onBlur": resetScroll,
          "onChange": this.setDecisionName
        }), 2);
      }
    }]);
    return DecisionPropertiesEditorComponent;
  }(Component);
  var DecisionName = /*#__PURE__*/function (_EditableComponent) {
    _inherits$1(DecisionName, _EditableComponent);
    var _super2 = _createSuper(DecisionName);
    function DecisionName() {
      _classCallCheck(this, DecisionName);
      return _super2.apply(this, arguments);
    }
    _createClass(DecisionName, [{
      key: "render",
      value: function render() {
        return createVNode(1, "h3", this.getClassName(), this.getEditor(), 0);
      }
    }]);
    return DecisionName;
  }(EditableComponent);
  function resetScroll(event) {
    event.target.scroll(0, 0);
  }

  var HIGH_PRIORITY = 1500;
  var DecisionPropertiesEditor = /*#__PURE__*/_createClass(function DecisionPropertiesEditor(components) {
    _classCallCheck(this, DecisionPropertiesEditor);
    components.onGetComponent('viewer', HIGH_PRIORITY, function () {
      return DecisionPropertiesEditorComponent;
    });
  });
  DecisionPropertiesEditor.$inject = ['components'];

  var DecisionPropertiesEditorModule = {
    __depends__: [DebounceInput],
    __init__: ['decisionProperties'],
    decisionProperties: ['type', DecisionPropertiesEditor]
  };

  var NOT_REGISTERED_ERROR = 'is not a registered action',
    IS_REGISTERED_ERROR = 'is already registered';

  /**
   * An interface that provides access to modeling actions by decoupling
   * the one who requests the action to be triggered and the trigger itself.
   *
   * It's possible to add new actions by registering them with registerAction and likewise
   * unregister existing ones with unregisterAction.
   *
   */
  var EditorActions$1 = /*#__PURE__*/function () {
    function EditorActions(commandStack, eventBus) {
      _classCallCheck(this, EditorActions);
      this._actions = {
        undo: function undo() {
          commandStack.undo();
        },
        redo: function redo() {
          commandStack.redo();
        }
      };
    }

    /**
     * Triggers a registered action
     *
     * @param  {string} action
     * @param  {Object} opts
     *
     * @return {Unknown} Returns what the registered listener returns
     */
    _createClass(EditorActions, [{
      key: "trigger",
      value: function trigger(action, opts) {
        if (!this._actions[action]) {
          throw error(action, NOT_REGISTERED_ERROR);
        }
        return this._actions[action](opts);
      }

      /**
       * Registers a collections of actions.
       * The key of the object will be the name of the action.
       *
       * @param  {Object} actions
       */
    }, {
      key: "register",
      value: function register(actions, listener) {
        var _this = this;
        if (typeof actions === 'string') {
          return this._registerAction(actions, listener);
        }
        forEach$3(actions, function (listener, action) {
          _this._registerAction(action, listener);
        });
      }

      /**
       * Registers a listener to an action key
       *
       * @param  {string} action
       * @param  {Function} listener
       */
    }, {
      key: "_registerAction",
      value: function _registerAction(action, listener) {
        if (this.isRegistered(action)) {
          throw error(action, IS_REGISTERED_ERROR);
        }
        this._actions[action] = listener;
      }

      /**
       * Unregister an existing action
       *
       * @param {string} action
       */
    }, {
      key: "unregister",
      value: function unregister(action) {
        if (!this.isRegistered(action)) {
          throw error(action, NOT_REGISTERED_ERROR);
        }
        this._actions[action] = undefined;
      }

      /**
       * Checks wether the given action is registered
       *
       * @param {string} action
       *
       * @return {boolean}
       */
    }, {
      key: "isRegistered",
      value: function isRegistered(action) {
        return !!this._actions[action];
      }
    }]);
    return EditorActions;
  }();
  EditorActions$1.$inject = ['commandStack', 'eventBus'];

  // helpers /////////////

  function error(action, message) {
    return new Error(action + ' ' + message);
  }

  var EditorActions = {
    __init__: ['editorActions'],
    editorActions: ['type', EditorActions$1]
  };

  function isCmd(modifiers) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (modifiers.altKey) {
      return false;
    }
    return modifiers.ctrlKey || modifiers.metaKey;
  }
  function isShift(modifiers) {
    return modifiers.shiftKey;
  }

  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * A keyboard abstraction that may be activated and
   * deactivated by users at will, consuming key events
   * and triggering diagram actions.
   *
   * The implementation fires the following key events that allow
   * other components to hook into key handling:
   *
   *  - keyboard.bind
   *  - keyboard.unbind
   *  - keyboard.init
   *  - keyboard.destroy
   *
   * All events contain the fields (node, listeners).
   *
   * A default binding for the keyboard may be specified via the
   * `keyboard.bindTo` configuration option.
   *
   * @param {Config} config
   * @param {EventBus} eventBus
   * @param {EditorActions} editorActions
   */
  var Keyboard = /*#__PURE__*/function () {
    function Keyboard(config, eventBus, editorActions) {
      var _this = this;
      _classCallCheck(this, Keyboard);
      _defineProperty(this, "_init", function () {
        _this._registerDefaultBindings();
        _this._fire('init');
      });
      _defineProperty(this, "_destroy", function () {
        _this._fire('destroy');
        _this.unbind();
        _this._listeners = null;
      });
      _defineProperty(this, "_keyHandler", function (event) {
        var i,
          l,
          listeners = _this._listeners,
          code = event.keyCode || event.charCode || -1;
        for (i = 0; l = listeners[i]; i++) {
          if (l(code, event)) {
            event.preventDefault();
            event.stopPropagation();
            return;
          }
        }
      });
      _defineProperty(this, "unbind", function () {
        var node = _this._node;
        if (node) {
          _this._fire('unbind');

          // unbind key events
          event.unbind(node, 'keydown', _this._keyHandler, true);
        }
        _this._node = null;
      });
      this._config = config || {};
      this._eventBus = eventBus;
      this._editorActions = editorActions;
      this._listeners = [];
      eventBus.on('viewer.destroy', this._destroy);
      eventBus.on('viewer.init', this._init);
      eventBus.on('attach', function () {
        if (_this._config.bindTo) {
          _this.bind(config.bindTo);
        }
      });
      eventBus.on('detach', this.unbind);
    }
    _createClass(Keyboard, [{
      key: "bind",
      value: function bind(node) {
        // make sure that the keyboard is only bound once to the DOM
        this.unbind();
        this._node = node;

        // bind key events
        event.bind(node, 'keydown', this._keyHandler, true);
        this._fire('bind');
      }
    }, {
      key: "getBinding",
      value: function getBinding() {
        return this._node;
      }
    }, {
      key: "_fire",
      value: function _fire(event) {
        this._eventBus.fire('keyboard.' + event, {
          node: this._node,
          listeners: this._listeners
        });
      }
    }, {
      key: "_registerDefaultBindings",
      value: function _registerDefaultBindings() {
        var listeners = this._listeners;
        var editorActions = this._editorActions;

        // init default listeners

        // undo
        // (CTRL|CMD) + Z
        function undo(key, modifiers) {
          if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {
            editorActions.trigger('undo');
            return true;
          }
        }

        // redo
        // CTRL + Y
        // CMD + SHIFT + Z
        function redo(key, modifiers) {
          if (isCmd(modifiers) && (key === 89 || key === 90 && isShift(modifiers))) {
            editorActions.trigger('redo');
            return true;
          }
        }
        listeners.push(undo);
        listeners.push(redo);
      }

      /**
       * Add a listener function that is notified with (key, modifiers) whenever
       * the keyboard is bound and the user presses a key.
       *
       * @param {Function} listenerFn
       */
    }, {
      key: "addListener",
      value: function addListener(listenerFn) {
        this._listeners.unshift(listenerFn);
      }
    }, {
      key: "removeListener",
      value: function removeListener(listenerFn) {
        this._listeners = this._listeners.filter(function (l) {
          return l !== listenerFn;
        });
      }
    }]);
    return Keyboard;
  }();
  Keyboard.$inject = ['config.keyboard', 'eventBus', 'editorActions'];

  var KeyboardModule = {
    __depends__: [EditorActions],
    __init__: ['keyboard'],
    keyboard: ['type', Keyboard]
  };

  var LiteralExpressionPropertiesComponent = /*#__PURE__*/function (_Component) {
    _inherits$1(LiteralExpressionPropertiesComponent, _Component);
    var _super = _createSuper(LiteralExpressionPropertiesComponent);
    function LiteralExpressionPropertiesComponent(props, context) {
      var _this;
      _classCallCheck(this, LiteralExpressionPropertiesComponent);
      _this = _super.call(this, props, context);
      _this._translate = context.injector.get('translate');
      _this._viewer = context.injector.get('viewer');
      _this._modeling = context.injector.get('modeling');
      _this._dataTypes = context.injector.get('dataTypes');
      var decision = _this._viewer.getDecision();
      _this.state = {
        name: decision.variable.name,
        typeRef: decision.variable.typeRef
      };
      _this.setVariableName = _this.setVariableName.bind(_assertThisInitialized(_this));
      _this.setVariableType = _this.setVariableType.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(LiteralExpressionPropertiesComponent, [{
      key: "setVariableName",
      value: function setVariableName(name) {
        this._modeling.editVariableName(name);
        this.setState({
          name: name
        });
      }
    }, {
      key: "setVariableType",
      value: function setVariableType(typeRef) {
        if (typeRef === '') {
          this._modeling.editVariableType(undefined);
          this.setState({
            typeRef: undefined
          });
        } else {
          this._modeling.editVariableType(typeRef);
          this.setState({
            typeRef: typeRef
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$state = this.state,
          name = _this$state.name,
          typeRef = _this$state.typeRef;
        var typeRefOptions = this._dataTypes.getAll().map(function (t) {
          return {
            label: _this2._translate(t),
            value: t
          };
        });
        return createVNode(1, "div", "literal-expression-properties", createVNode(1, "table", null, [createVNode(1, "tr", null, [createVNode(1, "td", null, this._translate('Variable name:'), 0), createVNode(1, "td", null, createComponentVNode(2, Input, {
          "className": "variable-name-input",
          "onInput": this.setVariableName,
          "placeholder": this._translate('name'),
          "value": name || ''
        }), 2)], 4), createVNode(1, "tr", null, [createVNode(1, "td", null, this._translate('Variable type:'), 0), createVNode(1, "td", null, createVNode(1, "div", "dms-fill-row", createComponentVNode(2, InputSelect, {
          "onChange": this.setVariableType,
          "options": typeRefOptions,
          "value": typeRef,
          "className": "variable-type-select dms-block"
        }), 2), 2)], 4), createComponentVNode(2, ExpressionLanguage)], 4), 2);
      }
    }]);
    return LiteralExpressionPropertiesComponent;
  }(Component);
  var ExpressionLanguage = /*#__PURE__*/function (_Component2) {
    _inherits$1(ExpressionLanguage, _Component2);
    var _super2 = _createSuper(ExpressionLanguage);
    function ExpressionLanguage(props, context) {
      var _this3;
      _classCallCheck(this, ExpressionLanguage);
      _this3 = _super2.call(this, props, context);
      _this3._translate = context.injector.get('translate');
      _this3._viewer = context.injector.get('viewer');
      _this3._modeling = context.injector.get('modeling');
      _this3._expressionLanguages = context.injector.get('expressionLanguages');
      _this3.setExpressionLanguage = _this3.setExpressionLanguage.bind(_assertThisInitialized(_this3));
      return _this3;
    }
    _createClass(ExpressionLanguage, [{
      key: "setExpressionLanguage",
      value: function setExpressionLanguage(expressionLanguage) {
        if (expressionLanguage === '') {
          this._modeling.editExpressionLanguage(undefined);
        } else {
          this._modeling.editExpressionLanguage(expressionLanguage);
        }
      }
    }, {
      key: "_getExpressionLanguage",
      value: function _getExpressionLanguage() {
        var decision = this._viewer.getDecision();
        var literalExpression = decision.decisionLogic;
        return literalExpression && literalExpression.expressionLanguage ? literalExpression.expressionLanguage.toLowerCase() : this._getDefaultExpressionLanguage();
      }
    }, {
      key: "_getDefaultExpressionLanguage",
      value: function _getDefaultExpressionLanguage() {
        return this._expressionLanguages.getDefault().value;
      }
    }, {
      key: "_shouldRender",
      value: function _shouldRender() {
        var expressionLanguages = this._expressionLanguages.getAll();
        if (expressionLanguages.length > 1) {
          return true;
        }
        var expressionLanguage = this._getExpressionLanguage();
        return expressionLanguage !== this._getDefaultExpressionLanguage();
      }
    }, {
      key: "render",
      value: function render() {
        if (!this._shouldRender()) {
          return null;
        }
        var expressionLanguage = this._getExpressionLanguage();
        var languageOptions = this._expressionLanguages.getAll();
        return createVNode(1, "tr", null, [createVNode(1, "td", null, this._translate('Expression language:'), 0), createVNode(1, "td", null, createVNode(1, "div", "dms-fill-row", createComponentVNode(2, InputSelect, {
          "onChange": this.setExpressionLanguage,
          "options": languageOptions,
          "value": expressionLanguage,
          "className": "expression-language-select dms-block"
        }), 2), 2)], 4);
      }
    }]);
    return ExpressionLanguage;
  }(Component);

  var LOW_PRIORITY = 500;
  var LiteralExpressionPropertiesEditor = /*#__PURE__*/_createClass(function LiteralExpressionPropertiesEditor(components) {
    _classCallCheck(this, LiteralExpressionPropertiesEditor);
    components.onGetComponent('viewer', LOW_PRIORITY, function () {
      return LiteralExpressionPropertiesComponent;
    });
  });
  LiteralExpressionPropertiesEditor.$inject = ['components'];

  var LiteralExpressionPropertiesEditorModule = {
    __depends__: [DebounceInput, KeyboardModule, ExpressionLanguagesModule, DataTypes],
    __init__: ['literalExpressionProperties'],
    literalExpressionProperties: ['type', LiteralExpressionPropertiesEditor]
  };

  var Modeling = /*#__PURE__*/function () {
    function Modeling(commandStack, viewer, eventBus) {
      var _this = this;
      _classCallCheck(this, Modeling);
      this._commandStack = commandStack;
      this._viewer = viewer;
      this._eventBus = eventBus;
      eventBus.on('viewer.init', function () {
        // register modeling handlers
        registerHandlers(_this.getHandlers(), commandStack);
      });
    }
    _createClass(Modeling, [{
      key: "getHandlers",
      value: function getHandlers() {
        return Modeling._getHandlers();
      }
    }, {
      key: "getDecision",
      value: function getDecision() {
        return this._viewer.getDecision();
      }
    }, {
      key: "editDecisionName",
      value: function editDecisionName(name) {
        var decision = this.getDecision();
        var context = {
          element: decision,
          properties: {
            name: name
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editDecisionId",
      value: function editDecisionId(id) {
        var decision = this.getDecision();
        var context = {
          element: decision,
          properties: {
            id: id
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editLiteralExpressionText",
      value: function editLiteralExpressionText(text) {
        var decision = this.getDecision(),
          literalExpression = decision.decisionLogic;
        var context = {
          element: literalExpression,
          properties: {
            text: text
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editExpressionLanguage",
      value: function editExpressionLanguage(expressionLanguage) {
        var decision = this.getDecision(),
          literalExpression = decision.decisionLogic;
        var context = {
          element: literalExpression,
          properties: {
            expressionLanguage: expressionLanguage
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editVariableName",
      value: function editVariableName(name) {
        var decision = this.getDecision(),
          variable = decision.variable;
        var context = {
          element: variable,
          properties: {
            name: name
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }, {
      key: "editVariableType",
      value: function editVariableType(typeRef) {
        var decision = this.getDecision(),
          variable = decision.variable;
        var context = {
          element: variable,
          properties: {
            typeRef: typeRef
          }
        };
        this._commandStack.execute('element.updateProperties', context);
      }
    }], [{
      key: "_getHandlers",
      value: function _getHandlers() {
        return {
          'element.updateProperties': EditPropertiesHandler
        };
      }
    }]);
    return Modeling;
  }();
  Modeling.$inject = ['commandStack', 'viewer', 'eventBus'];

  // helpers //////////////////////

  /**
   * Register handlers with the command stack
   *
   * @param {Object} handlers { id -> Handler } map
   * @param {CommandStack} commandStack
   */
  function registerHandlers(handlers, commandStack) {
    forEach$3(handlers, function (handler, id) {
      commandStack.registerHandler(id, handler);
    });
  }

  var ModelingModule = {
    __init__: ['idChangeBehavior', 'modeling'],
    commandStack: ['type', CommandStack$1],
    idChangeBehavior: ['type', IdChangeBehavior],
    modeling: ['type', Modeling]
  };

  var TextareaEditorComponent$1 = /*#__PURE__*/function (_Component) {
    _inherits$1(TextareaEditorComponent, _Component);
    var _super = _createSuper(TextareaEditorComponent);
    function TextareaEditorComponent(props, context) {
      var _this;
      _classCallCheck(this, TextareaEditorComponent);
      _this = _super.call(this, props, context);
      _this._modeling = context.injector.get('modeling');
      _this._viewer = context.injector.get('viewer');
      _this._expressionLanguages = context.injector.get('expressionLanguages');
      _this._variableResolver = context.injector.get('variableResolver', false);
      _this.editLiteralExpressionText = _this.editLiteralExpressionText.bind(_assertThisInitialized(_this));
      _this.onElementsChanged = _this.onElementsChanged.bind(_assertThisInitialized(_this));

      // there is only one single element
      var _this$getLiteralExpre = _this.getLiteralExpression(),
        id = _this$getLiteralExpre.id;
      context.changeSupport.onElementsChanged(id, _this.onElementsChanged);
      return _this;
    }
    _createClass(TextareaEditorComponent, [{
      key: "getLiteralExpression",
      value: function getLiteralExpression() {
        return this._viewer.getDecision().decisionLogic;
      }
    }, {
      key: "onElementsChanged",
      value: function onElementsChanged() {
        this.forceUpdate();
      }
    }, {
      key: "editLiteralExpressionText",
      value: function editLiteralExpressionText(text) {
        this._modeling.editLiteralExpressionText(text);
      }
    }, {
      key: "getEditor",
      value: function getEditor() {
        return this.isFeel() ? FeelEditor : Editor$1;
      }
    }, {
      key: "isFeel",
      value: function isFeel() {
        return this.getExpressionLanguage() === 'feel';
      }
    }, {
      key: "getExpressionLanguage",
      value: function getExpressionLanguage() {
        var businessObject = this.getLiteralExpression();
        return businessObject.expressionLanguage || this._expressionLanguages.getDefault().value;
      }
    }, {
      key: "_getVariables",
      value: function _getVariables() {
        var businessObject = this.getLiteralExpression();
        return this._variableResolver && this._variableResolver.getVariables(businessObject);
      }
    }, {
      key: "render",
      value: function render() {
        // there is only one single element
        var _this$getLiteralExpre2 = this.getLiteralExpression(),
          text = _this$getLiteralExpre2.text;
        var Editor = this.getEditor();
        var variables = this._getVariables();
        return createComponentVNode(2, Editor, {
          "className": "textarea editor",
          "value": text,
          "onChange": this.editLiteralExpressionText,
          "variables": variables
        });
      }
    }]);
    return TextareaEditorComponent;
  }(Component);
  var FeelEditor = /*#__PURE__*/function (_Component2) {
    _inherits$1(FeelEditor, _Component2);
    var _super2 = _createSuper(FeelEditor);
    function FeelEditor() {
      _classCallCheck(this, FeelEditor);
      return _super2.apply(this, arguments);
    }
    _createClass(FeelEditor, [{
      key: "render",
      value: function render() {
        return createComponentVNode(2, LiteralExpression, {
          "className": this.props.className,
          "value": this.props.value,
          "onInput": this.props.onChange,
          "variables": this.props.variables
        });
      }
    }]);
    return FeelEditor;
  }(Component);
  var Editor$1 = /*#__PURE__*/function (_EditableComponent) {
    _inherits$1(Editor, _EditableComponent);
    var _super3 = _createSuper(Editor);
    function Editor() {
      _classCallCheck(this, Editor);
      return _super3.apply(this, arguments);
    }
    _createClass(Editor, [{
      key: "render",
      value: function render() {
        return createVNode(1, "div", this.getClassName(), this.getEditor(), 0);
      }
    }]);
    return Editor;
  }(EditableComponent);

  var Textarea = /*#__PURE__*/_createClass(function Textarea(components) {
    _classCallCheck(this, Textarea);
    components.onGetComponent('viewer', function () {
      return TextareaEditorComponent$1;
    });
  });
  Textarea.$inject = ['components'];

  var TextareaEditorComponent = {
    __depends__: [DebounceInput],
    __init__: ['textarea'],
    textarea: ['type', Textarea]
  };

  var Editor = /*#__PURE__*/function (_Viewer) {
    _inherits$1(Editor, _Viewer);
    var _super = _createSuper(Editor);
    function Editor() {
      _classCallCheck(this, Editor);
      return _super.apply(this, arguments);
    }
    _createClass(Editor, [{
      key: "getModules",
      value: function getModules() {
        return [].concat(_toConsumableArray(Viewer._getModules()), _toConsumableArray(Editor._getModules()));
      }
    }], [{
      key: "_getModules",
      value: function _getModules() {
        return [DecisionPropertiesEditorModule, KeyboardModule, LiteralExpressionPropertiesEditorModule, ModelingModule, ExpressionLanguagesModule, DataTypesModule, TextareaEditorComponent, DmnVariableResolverModule];
      }
    }]);
    return Editor;
  }(Viewer);

  /**
   * The dmn editor.
   */
  var Modeler = /*#__PURE__*/function (_EditingManager) {
    _inherits$1(Modeler, _EditingManager);
    var _super = _createSuper(Modeler);
    function Modeler() {
      _classCallCheck(this, Modeler);
      return _super.apply(this, arguments);
    }
    _createClass(Modeler, [{
      key: "_getViewProviders",
      value: function _getViewProviders() {
        return [{
          id: 'drd',
          constructor: Modeler$1,
          opens: 'dmn:Definitions'
        }, {
          id: 'decisionTable',
          constructor: Editor$2,
          opens: function opens(element) {
            return is$1(element, 'dmn:Decision') && is$1(element.decisionLogic, 'dmn:DecisionTable');
          }
        }, {
          id: 'literalExpression',
          constructor: Editor,
          opens: function opens(element) {
            return is$1(element, 'dmn:Decision') && is$1(element.decisionLogic, 'dmn:LiteralExpression');
          }
        }];
      }
    }, {
      key: "_getInitialView",
      value: function _getInitialView(views) {
        var _get2;
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        var initialView = (_get2 = _get(_getPrototypeOf(Modeler.prototype), "_getInitialView", this)).call.apply(_get2, [this, views].concat(rest));
        if (!initialView) {
          return;
        }
        var element = initialView.element;

        // if initial view is definitions without DI, try to open another view
        if (is$1(element, 'dmn:Definitions') && !containsDi(element)) {
          initialView = find$2(views, function (view) {
            return !is$1(view.element, 'dmn:Definitions');
          }) || initialView;
        }
        return initialView;
      }
    }]);
    return Modeler;
  }(EditingManager);

  return Modeler;

}));
