import { createVNode, createComponentVNode, normalizeProps } from "inferno";
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { Component } from 'inferno';
import { isString } from 'min-dash';
import { is } from 'dmn-js-shared/lib/util/ModelUtil';
import ContentEditable from 'dmn-js-shared/lib/components/ContentEditable';
import LiteralExpression from 'dmn-js-shared/lib/components/LiteralExpression';
import { Cell } from 'table-js/lib/components';
export default class DecisionRulesCellEditorComponent extends Component {
  constructor(props, context) {
    super(props, context);
    this.changeCellValue = this.changeCellValue.bind(this);
    this.onElementsChanged = this.onElementsChanged.bind(this);
  }
  onElementsChanged() {
    this.forceUpdate();
  }
  componentWillMount() {
    const injector = this.context.injector;
    const cell = this.props.cell;
    const changeSupport = this._changeSupport = this.context.changeSupport;
    this._modeling = injector.get('modeling');
    changeSupport.onElementsChanged(cell.id, this.onElementsChanged);
  }
  componentWillUnmount() {
    const cell = this.props.cell;
    this._changeSupport.offElementsChanged(cell.id, this.onElementsChanged);
  }
  changeCellValue(value) {
    const cell = this.props.cell;
    this._modeling.editCell(cell.businessObject, value);
  }
  render() {
    const _this$props = this.props,
      cell = _this$props.cell,
      rowIndex = _this$props.rowIndex,
      row = _this$props.row,
      col = _this$props.col,
      colIndex = _this$props.colIndex;
    const isUnaryTest = is(cell, 'dmn:UnaryTests');
    const businessObject = cell.businessObject;
    return createComponentVNode(2, Cell, {
      "className": isUnaryTest ? 'input-cell' : 'output-cell',
      "elementId": cell.id,
      "coords": "".concat(rowIndex, ":").concat(colIndex),
      "data-row-id": row.id,
      "data-col-id": col.id,
      children: createComponentVNode(2, TableCellEditor, {
        "placeholder": isUnaryTest ? '-' : '',
        "onChange": this.changeCellValue,
        "value": businessObject.text,
        "businessObject": businessObject
      })
    });
  }
}
class FeelEditor extends Component {
  constructor(props, context) {
    super(props, context);
    this.state = {
      focussed: false
    };
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
  }
  onFocus() {
    this.setState({
      focussed: true
    });
  }
  onBlur() {
    this.setState({
      focussed: false
    });
  }
  render() {
    const focussed = this.state.focussed;
    const className = "feel-editor".concat(focussed ? ' focussed' : '');

    // TODO(@barmac): display only a single editor;
    // required to workaround "replaceChild" error
    return createVNode(1, "div", className, [focussed && normalizeProps(createComponentVNode(2, LiteralExpression, _objectSpread(_objectSpread({}, this.props), {}, {
      "autoFocus": true,
      "onBlur": this.onBlur
    }))), normalizeProps(createComponentVNode(2, ContentEditable, _objectSpread(_objectSpread({}, this.props), {}, {
      "onInput": () => {},
      "onFocus": this.onFocus
    })))], 0, {
      "onClick": this.onFocus
    });
  }
}
class TableCellEditor extends Component {
  constructor(props, context) {
    super(props, context);
    this._expressionLanguages = context.injector.get('expressionLanguages');
    this._translate = context.injector.get('translate');
    this._variableResolver = context.injector.get('variableResolver', false);
  }
  isDefaultExpressionLanguage(businessObject) {
    const expressionLanguage = businessObject.expressionLanguage;
    const defaultExpressionLanguage = this.getDefaultExpressionLanguage(businessObject).value;
    return !expressionLanguage || expressionLanguage === defaultExpressionLanguage;
  }
  getDescription(businessObject) {
    return businessObject.description;
  }
  getExpressionLanguageLabel(businessObject) {
    const expressionLanguage = businessObject.expressionLanguage;
    const defaultExpressionLanguage = this.getDefaultExpressionLanguage(businessObject);
    return this._expressionLanguages.getLabel(expressionLanguage) || defaultExpressionLanguage.label;
  }
  isScript(businessObject) {
    const defaultExpressionLanguage = this.getDefaultExpressionLanguage(businessObject);
    const isInputCell = is(businessObject, 'dmn:UnaryTests');
    if (!isInputCell) {
      return false;
    }
    if (businessObject.text.indexOf('\n') !== -1) {
      return true;
    }
    return businessObject.expressionLanguage && businessObject.expressionLanguage !== defaultExpressionLanguage;
  }
  getDefaultExpressionLanguage(businessObject) {
    const elementType = is(businessObject, 'dmn:UnaryTests') ? 'inputCell' : 'outputCell';
    return this._expressionLanguages.getDefault(elementType);
  }
  getEditor() {
    return this.isFEEL() ? FeelEditor : ContentEditable;
  }
  isFEEL() {
    return this.getExpressionLanguage() === 'feel';
  }
  getExpressionLanguage() {
    const businessObject = this.props.businessObject;
    return businessObject.expressionLanguage || this.getDefaultExpressionLanguage(businessObject).value;
  }
  _getVariables() {
    const businessObject = this.props.businessObject;
    return this._variableResolver && this._variableResolver.getVariables(businessObject);
  }
  render() {
    const _this$props2 = this.props,
      businessObject = _this$props2.businessObject,
      placeholder = _this$props2.placeholder,
      value = _this$props2.value,
      onChange = _this$props2.onChange;
    const description = this.getDescription(businessObject);
    const isDefaultExpressionLanguage = this.isDefaultExpressionLanguage(businessObject);
    const expressionLanguageLabel = this.getExpressionLanguageLabel(businessObject);
    const isScript = this.isScript(businessObject);
    const Editor = this.getEditor();
    const variables = this._getVariables();
    return createVNode(1, "div", "cell-editor", [isString(description) && createVNode(1, "div", "description-indicator"), createComponentVNode(2, Editor, {
      "className": isScript ? 'script-editor' : '',
      "ctrlForNewline": true,
      "onInput": onChange,
      "value": value,
      "placeholder": placeholder,
      "variables": variables
    }), !isDefaultExpressionLanguage && createVNode(1, "span", "dms-badge dmn-expression-language", [createVNode(1, "span", "dms-badge-icon dmn-icon-file-code"), createVNode(1, "span", "dms-badge-label", expressionLanguageLabel, 0)], 4, {
      "title": this._translate('Expression language: {expressionLanguageLabel}', {
        expressionLanguageLabel
      })
    })], 0);
  }
}
//# sourceMappingURL=DecisionRulesCellEditorComponent.js.map